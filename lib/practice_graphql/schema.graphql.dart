class Input$AbortQueuedMigrationsInput {
  factory Input$AbortQueuedMigrationsInput({
    String? clientMutationId,
    required String ownerId,
  }) =>
      Input$AbortQueuedMigrationsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
      });

  Input$AbortQueuedMigrationsInput._(this._$data);

  factory Input$AbortQueuedMigrationsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    return Input$AbortQueuedMigrationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    return result$data;
  }

  CopyWith$Input$AbortQueuedMigrationsInput<Input$AbortQueuedMigrationsInput>
      get copyWith => CopyWith$Input$AbortQueuedMigrationsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AbortQueuedMigrationsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
    ]);
  }
}

abstract class CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  factory CopyWith$Input$AbortQueuedMigrationsInput(
    Input$AbortQueuedMigrationsInput instance,
    TRes Function(Input$AbortQueuedMigrationsInput) then,
  ) = _CopyWithImpl$Input$AbortQueuedMigrationsInput;

  factory CopyWith$Input$AbortQueuedMigrationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AbortQueuedMigrationsInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$AbortQueuedMigrationsInput<TRes>
    implements CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  _CopyWithImpl$Input$AbortQueuedMigrationsInput(
    this._instance,
    this._then,
  );

  final Input$AbortQueuedMigrationsInput _instance;

  final TRes Function(Input$AbortQueuedMigrationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$AbortQueuedMigrationsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
      }));
}

class _CopyWithStubImpl$Input$AbortQueuedMigrationsInput<TRes>
    implements CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  _CopyWithStubImpl$Input$AbortQueuedMigrationsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
  }) =>
      _res;
}

class Input$AbortRepositoryMigrationInput {
  factory Input$AbortRepositoryMigrationInput({
    String? clientMutationId,
    required String migrationId,
  }) =>
      Input$AbortRepositoryMigrationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'migrationId': migrationId,
      });

  Input$AbortRepositoryMigrationInput._(this._$data);

  factory Input$AbortRepositoryMigrationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$migrationId = data['migrationId'];
    result$data['migrationId'] = (l$migrationId as String);
    return Input$AbortRepositoryMigrationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get migrationId => (_$data['migrationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$migrationId = migrationId;
    result$data['migrationId'] = l$migrationId;
    return result$data;
  }

  CopyWith$Input$AbortRepositoryMigrationInput<
          Input$AbortRepositoryMigrationInput>
      get copyWith => CopyWith$Input$AbortRepositoryMigrationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AbortRepositoryMigrationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$migrationId = migrationId;
    final lOther$migrationId = other.migrationId;
    if (l$migrationId != lOther$migrationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$migrationId = migrationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$migrationId,
    ]);
  }
}

abstract class CopyWith$Input$AbortRepositoryMigrationInput<TRes> {
  factory CopyWith$Input$AbortRepositoryMigrationInput(
    Input$AbortRepositoryMigrationInput instance,
    TRes Function(Input$AbortRepositoryMigrationInput) then,
  ) = _CopyWithImpl$Input$AbortRepositoryMigrationInput;

  factory CopyWith$Input$AbortRepositoryMigrationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AbortRepositoryMigrationInput;

  TRes call({
    String? clientMutationId,
    String? migrationId,
  });
}

class _CopyWithImpl$Input$AbortRepositoryMigrationInput<TRes>
    implements CopyWith$Input$AbortRepositoryMigrationInput<TRes> {
  _CopyWithImpl$Input$AbortRepositoryMigrationInput(
    this._instance,
    this._then,
  );

  final Input$AbortRepositoryMigrationInput _instance;

  final TRes Function(Input$AbortRepositoryMigrationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? migrationId = _undefined,
  }) =>
      _then(Input$AbortRepositoryMigrationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (migrationId != _undefined && migrationId != null)
          'migrationId': (migrationId as String),
      }));
}

class _CopyWithStubImpl$Input$AbortRepositoryMigrationInput<TRes>
    implements CopyWith$Input$AbortRepositoryMigrationInput<TRes> {
  _CopyWithStubImpl$Input$AbortRepositoryMigrationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? migrationId,
  }) =>
      _res;
}

class Input$AcceptEnterpriseAdministratorInvitationInput {
  factory Input$AcceptEnterpriseAdministratorInvitationInput({
    String? clientMutationId,
    required String invitationId,
  }) =>
      Input$AcceptEnterpriseAdministratorInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'invitationId': invitationId,
      });

  Input$AcceptEnterpriseAdministratorInvitationInput._(this._$data);

  factory Input$AcceptEnterpriseAdministratorInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    return Input$AcceptEnterpriseAdministratorInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get invitationId => (_$data['invitationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    return result$data;
  }

  CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<
          Input$AcceptEnterpriseAdministratorInvitationInput>
      get copyWith =>
          CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AcceptEnterpriseAdministratorInvitationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$invitationId = invitationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$invitationId,
    ]);
  }
}

abstract class CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<
    TRes> {
  factory CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput(
    Input$AcceptEnterpriseAdministratorInvitationInput instance,
    TRes Function(Input$AcceptEnterpriseAdministratorInvitationInput) then,
  ) = _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput;

  factory CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput;

  TRes call({
    String? clientMutationId,
    String? invitationId,
  });
}

class _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput<TRes>
    implements
        CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<TRes> {
  _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput(
    this._instance,
    this._then,
  );

  final Input$AcceptEnterpriseAdministratorInvitationInput _instance;

  final TRes Function(Input$AcceptEnterpriseAdministratorInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? invitationId = _undefined,
  }) =>
      _then(Input$AcceptEnterpriseAdministratorInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
      }));
}

class _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput<TRes>
    implements
        CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<TRes> {
  _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? invitationId,
  }) =>
      _res;
}

class Input$AcceptEnterpriseMemberInvitationInput {
  factory Input$AcceptEnterpriseMemberInvitationInput({
    String? clientMutationId,
    required String invitationId,
  }) =>
      Input$AcceptEnterpriseMemberInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'invitationId': invitationId,
      });

  Input$AcceptEnterpriseMemberInvitationInput._(this._$data);

  factory Input$AcceptEnterpriseMemberInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    return Input$AcceptEnterpriseMemberInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get invitationId => (_$data['invitationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    return result$data;
  }

  CopyWith$Input$AcceptEnterpriseMemberInvitationInput<
          Input$AcceptEnterpriseMemberInvitationInput>
      get copyWith => CopyWith$Input$AcceptEnterpriseMemberInvitationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AcceptEnterpriseMemberInvitationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$invitationId = invitationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$invitationId,
    ]);
  }
}

abstract class CopyWith$Input$AcceptEnterpriseMemberInvitationInput<TRes> {
  factory CopyWith$Input$AcceptEnterpriseMemberInvitationInput(
    Input$AcceptEnterpriseMemberInvitationInput instance,
    TRes Function(Input$AcceptEnterpriseMemberInvitationInput) then,
  ) = _CopyWithImpl$Input$AcceptEnterpriseMemberInvitationInput;

  factory CopyWith$Input$AcceptEnterpriseMemberInvitationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AcceptEnterpriseMemberInvitationInput;

  TRes call({
    String? clientMutationId,
    String? invitationId,
  });
}

class _CopyWithImpl$Input$AcceptEnterpriseMemberInvitationInput<TRes>
    implements CopyWith$Input$AcceptEnterpriseMemberInvitationInput<TRes> {
  _CopyWithImpl$Input$AcceptEnterpriseMemberInvitationInput(
    this._instance,
    this._then,
  );

  final Input$AcceptEnterpriseMemberInvitationInput _instance;

  final TRes Function(Input$AcceptEnterpriseMemberInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? invitationId = _undefined,
  }) =>
      _then(Input$AcceptEnterpriseMemberInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
      }));
}

class _CopyWithStubImpl$Input$AcceptEnterpriseMemberInvitationInput<TRes>
    implements CopyWith$Input$AcceptEnterpriseMemberInvitationInput<TRes> {
  _CopyWithStubImpl$Input$AcceptEnterpriseMemberInvitationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? invitationId,
  }) =>
      _res;
}

class Input$AcceptTopicSuggestionInput {
  factory Input$AcceptTopicSuggestionInput({
    String? clientMutationId,
    String? repositoryId,
    String? name,
  }) =>
      Input$AcceptTopicSuggestionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (name != null) r'name': name,
      });

  Input$AcceptTopicSuggestionInput._(this._$data);

  factory Input$AcceptTopicSuggestionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$AcceptTopicSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get repositoryId => (_$data['repositoryId'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$AcceptTopicSuggestionInput<Input$AcceptTopicSuggestionInput>
      get copyWith => CopyWith$Input$AcceptTopicSuggestionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AcceptTopicSuggestionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  factory CopyWith$Input$AcceptTopicSuggestionInput(
    Input$AcceptTopicSuggestionInput instance,
    TRes Function(Input$AcceptTopicSuggestionInput) then,
  ) = _CopyWithImpl$Input$AcceptTopicSuggestionInput;

  factory CopyWith$Input$AcceptTopicSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AcceptTopicSuggestionInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
  });
}

class _CopyWithImpl$Input$AcceptTopicSuggestionInput<TRes>
    implements CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  _CopyWithImpl$Input$AcceptTopicSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$AcceptTopicSuggestionInput _instance;

  final TRes Function(Input$AcceptTopicSuggestionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$AcceptTopicSuggestionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$AcceptTopicSuggestionInput<TRes>
    implements CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$AcceptTopicSuggestionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
  }) =>
      _res;
}

class Input$AccessUserNamespaceRepositoryInput {
  factory Input$AccessUserNamespaceRepositoryInput({
    String? clientMutationId,
    required String enterpriseId,
    required String repositoryId,
  }) =>
      Input$AccessUserNamespaceRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'repositoryId': repositoryId,
      });

  Input$AccessUserNamespaceRepositoryInput._(this._$data);

  factory Input$AccessUserNamespaceRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$AccessUserNamespaceRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$AccessUserNamespaceRepositoryInput<
          Input$AccessUserNamespaceRepositoryInput>
      get copyWith => CopyWith$Input$AccessUserNamespaceRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AccessUserNamespaceRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$AccessUserNamespaceRepositoryInput<TRes> {
  factory CopyWith$Input$AccessUserNamespaceRepositoryInput(
    Input$AccessUserNamespaceRepositoryInput instance,
    TRes Function(Input$AccessUserNamespaceRepositoryInput) then,
  ) = _CopyWithImpl$Input$AccessUserNamespaceRepositoryInput;

  factory CopyWith$Input$AccessUserNamespaceRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AccessUserNamespaceRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$AccessUserNamespaceRepositoryInput<TRes>
    implements CopyWith$Input$AccessUserNamespaceRepositoryInput<TRes> {
  _CopyWithImpl$Input$AccessUserNamespaceRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$AccessUserNamespaceRepositoryInput _instance;

  final TRes Function(Input$AccessUserNamespaceRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$AccessUserNamespaceRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$AccessUserNamespaceRepositoryInput<TRes>
    implements CopyWith$Input$AccessUserNamespaceRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$AccessUserNamespaceRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$AddAssigneesToAssignableInput {
  factory Input$AddAssigneesToAssignableInput({
    String? clientMutationId,
    required String assignableId,
    required List<String> assigneeIds,
  }) =>
      Input$AddAssigneesToAssignableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'assignableId': assignableId,
        r'assigneeIds': assigneeIds,
      });

  Input$AddAssigneesToAssignableInput._(this._$data);

  factory Input$AddAssigneesToAssignableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$assignableId = data['assignableId'];
    result$data['assignableId'] = (l$assignableId as String);
    final l$assigneeIds = data['assigneeIds'];
    result$data['assigneeIds'] =
        (l$assigneeIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$AddAssigneesToAssignableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get assignableId => (_$data['assignableId'] as String);

  List<String> get assigneeIds => (_$data['assigneeIds'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$assignableId = assignableId;
    result$data['assignableId'] = l$assignableId;
    final l$assigneeIds = assigneeIds;
    result$data['assigneeIds'] = l$assigneeIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$AddAssigneesToAssignableInput<
          Input$AddAssigneesToAssignableInput>
      get copyWith => CopyWith$Input$AddAssigneesToAssignableInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddAssigneesToAssignableInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$assignableId = assignableId;
    final lOther$assignableId = other.assignableId;
    if (l$assignableId != lOther$assignableId) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (l$assigneeIds.length != lOther$assigneeIds.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeIds.length; i++) {
      final l$assigneeIds$entry = l$assigneeIds[i];
      final lOther$assigneeIds$entry = lOther$assigneeIds[i];
      if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$assignableId = assignableId;
    final l$assigneeIds = assigneeIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$assignableId,
      Object.hashAll(l$assigneeIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  factory CopyWith$Input$AddAssigneesToAssignableInput(
    Input$AddAssigneesToAssignableInput instance,
    TRes Function(Input$AddAssigneesToAssignableInput) then,
  ) = _CopyWithImpl$Input$AddAssigneesToAssignableInput;

  factory CopyWith$Input$AddAssigneesToAssignableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAssigneesToAssignableInput;

  TRes call({
    String? clientMutationId,
    String? assignableId,
    List<String>? assigneeIds,
  });
}

class _CopyWithImpl$Input$AddAssigneesToAssignableInput<TRes>
    implements CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  _CopyWithImpl$Input$AddAssigneesToAssignableInput(
    this._instance,
    this._then,
  );

  final Input$AddAssigneesToAssignableInput _instance;

  final TRes Function(Input$AddAssigneesToAssignableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? assignableId = _undefined,
    Object? assigneeIds = _undefined,
  }) =>
      _then(Input$AddAssigneesToAssignableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (assignableId != _undefined && assignableId != null)
          'assignableId': (assignableId as String),
        if (assigneeIds != _undefined && assigneeIds != null)
          'assigneeIds': (assigneeIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$AddAssigneesToAssignableInput<TRes>
    implements CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  _CopyWithStubImpl$Input$AddAssigneesToAssignableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? assignableId,
    List<String>? assigneeIds,
  }) =>
      _res;
}

class Input$AddBlockedByInput {
  factory Input$AddBlockedByInput({
    String? clientMutationId,
    required String issueId,
    required String blockingIssueId,
  }) =>
      Input$AddBlockedByInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        r'blockingIssueId': blockingIssueId,
      });

  Input$AddBlockedByInput._(this._$data);

  factory Input$AddBlockedByInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$blockingIssueId = data['blockingIssueId'];
    result$data['blockingIssueId'] = (l$blockingIssueId as String);
    return Input$AddBlockedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  String get blockingIssueId => (_$data['blockingIssueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$blockingIssueId = blockingIssueId;
    result$data['blockingIssueId'] = l$blockingIssueId;
    return result$data;
  }

  CopyWith$Input$AddBlockedByInput<Input$AddBlockedByInput> get copyWith =>
      CopyWith$Input$AddBlockedByInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddBlockedByInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$blockingIssueId = blockingIssueId;
    final lOther$blockingIssueId = other.blockingIssueId;
    if (l$blockingIssueId != lOther$blockingIssueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$blockingIssueId = blockingIssueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      l$blockingIssueId,
    ]);
  }
}

abstract class CopyWith$Input$AddBlockedByInput<TRes> {
  factory CopyWith$Input$AddBlockedByInput(
    Input$AddBlockedByInput instance,
    TRes Function(Input$AddBlockedByInput) then,
  ) = _CopyWithImpl$Input$AddBlockedByInput;

  factory CopyWith$Input$AddBlockedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddBlockedByInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? blockingIssueId,
  });
}

class _CopyWithImpl$Input$AddBlockedByInput<TRes>
    implements CopyWith$Input$AddBlockedByInput<TRes> {
  _CopyWithImpl$Input$AddBlockedByInput(
    this._instance,
    this._then,
  );

  final Input$AddBlockedByInput _instance;

  final TRes Function(Input$AddBlockedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? blockingIssueId = _undefined,
  }) =>
      _then(Input$AddBlockedByInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (blockingIssueId != _undefined && blockingIssueId != null)
          'blockingIssueId': (blockingIssueId as String),
      }));
}

class _CopyWithStubImpl$Input$AddBlockedByInput<TRes>
    implements CopyWith$Input$AddBlockedByInput<TRes> {
  _CopyWithStubImpl$Input$AddBlockedByInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? blockingIssueId,
  }) =>
      _res;
}

class Input$AddCommentInput {
  factory Input$AddCommentInput({
    String? clientMutationId,
    required String subjectId,
    required String body,
  }) =>
      Input$AddCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
        r'body': body,
      });

  Input$AddCommentInput._(this._$data);

  factory Input$AddCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$AddCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subjectId => (_$data['subjectId'] as String);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$AddCommentInput<Input$AddCommentInput> get copyWith =>
      CopyWith$Input$AddCommentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddCommentInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$AddCommentInput<TRes> {
  factory CopyWith$Input$AddCommentInput(
    Input$AddCommentInput instance,
    TRes Function(Input$AddCommentInput) then,
  ) = _CopyWithImpl$Input$AddCommentInput;

  factory CopyWith$Input$AddCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddCommentInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
    String? body,
  });
}

class _CopyWithImpl$Input$AddCommentInput<TRes>
    implements CopyWith$Input$AddCommentInput<TRes> {
  _CopyWithImpl$Input$AddCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddCommentInput _instance;

  final TRes Function(Input$AddCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$AddCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$AddCommentInput<TRes>
    implements CopyWith$Input$AddCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
    String? body,
  }) =>
      _res;
}

class Input$AddDiscussionCommentInput {
  factory Input$AddDiscussionCommentInput({
    String? clientMutationId,
    required String discussionId,
    String? replyToId,
    required String body,
  }) =>
      Input$AddDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
        if (replyToId != null) r'replyToId': replyToId,
        r'body': body,
      });

  Input$AddDiscussionCommentInput._(this._$data);

  factory Input$AddDiscussionCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('replyToId')) {
      final l$replyToId = data['replyToId'];
      result$data['replyToId'] = (l$replyToId as String?);
    }
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$AddDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get discussionId => (_$data['discussionId'] as String);

  String? get replyToId => (_$data['replyToId'] as String?);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('replyToId')) {
      final l$replyToId = replyToId;
      result$data['replyToId'] = l$replyToId;
    }
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$AddDiscussionCommentInput<Input$AddDiscussionCommentInput>
      get copyWith => CopyWith$Input$AddDiscussionCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddDiscussionCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$replyToId = replyToId;
    final lOther$replyToId = other.replyToId;
    if (_$data.containsKey('replyToId') !=
        other._$data.containsKey('replyToId')) {
      return false;
    }
    if (l$replyToId != lOther$replyToId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$replyToId = replyToId;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
      _$data.containsKey('replyToId') ? l$replyToId : const {},
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$AddDiscussionCommentInput<TRes> {
  factory CopyWith$Input$AddDiscussionCommentInput(
    Input$AddDiscussionCommentInput instance,
    TRes Function(Input$AddDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$AddDiscussionCommentInput;

  factory CopyWith$Input$AddDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? discussionId,
    String? replyToId,
    String? body,
  });
}

class _CopyWithImpl$Input$AddDiscussionCommentInput<TRes>
    implements CopyWith$Input$AddDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$AddDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddDiscussionCommentInput _instance;

  final TRes Function(Input$AddDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? replyToId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$AddDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (replyToId != _undefined) 'replyToId': (replyToId as String?),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$AddDiscussionCommentInput<TRes>
    implements CopyWith$Input$AddDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? discussionId,
    String? replyToId,
    String? body,
  }) =>
      _res;
}

class Input$AddDiscussionPollVoteInput {
  factory Input$AddDiscussionPollVoteInput({
    String? clientMutationId,
    required String pollOptionId,
  }) =>
      Input$AddDiscussionPollVoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pollOptionId': pollOptionId,
      });

  Input$AddDiscussionPollVoteInput._(this._$data);

  factory Input$AddDiscussionPollVoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pollOptionId = data['pollOptionId'];
    result$data['pollOptionId'] = (l$pollOptionId as String);
    return Input$AddDiscussionPollVoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pollOptionId => (_$data['pollOptionId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pollOptionId = pollOptionId;
    result$data['pollOptionId'] = l$pollOptionId;
    return result$data;
  }

  CopyWith$Input$AddDiscussionPollVoteInput<Input$AddDiscussionPollVoteInput>
      get copyWith => CopyWith$Input$AddDiscussionPollVoteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddDiscussionPollVoteInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pollOptionId = pollOptionId;
    final lOther$pollOptionId = other.pollOptionId;
    if (l$pollOptionId != lOther$pollOptionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pollOptionId = pollOptionId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pollOptionId,
    ]);
  }
}

abstract class CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  factory CopyWith$Input$AddDiscussionPollVoteInput(
    Input$AddDiscussionPollVoteInput instance,
    TRes Function(Input$AddDiscussionPollVoteInput) then,
  ) = _CopyWithImpl$Input$AddDiscussionPollVoteInput;

  factory CopyWith$Input$AddDiscussionPollVoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddDiscussionPollVoteInput;

  TRes call({
    String? clientMutationId,
    String? pollOptionId,
  });
}

class _CopyWithImpl$Input$AddDiscussionPollVoteInput<TRes>
    implements CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  _CopyWithImpl$Input$AddDiscussionPollVoteInput(
    this._instance,
    this._then,
  );

  final Input$AddDiscussionPollVoteInput _instance;

  final TRes Function(Input$AddDiscussionPollVoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pollOptionId = _undefined,
  }) =>
      _then(Input$AddDiscussionPollVoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pollOptionId != _undefined && pollOptionId != null)
          'pollOptionId': (pollOptionId as String),
      }));
}

class _CopyWithStubImpl$Input$AddDiscussionPollVoteInput<TRes>
    implements CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  _CopyWithStubImpl$Input$AddDiscussionPollVoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pollOptionId,
  }) =>
      _res;
}

class Input$AddEnterpriseOrganizationMemberInput {
  factory Input$AddEnterpriseOrganizationMemberInput({
    String? clientMutationId,
    required String enterpriseId,
    required String organizationId,
    required List<String> userIds,
    Enum$OrganizationMemberRole? role,
  }) =>
      Input$AddEnterpriseOrganizationMemberInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
        r'userIds': userIds,
        if (role != null) r'role': role,
      });

  Input$AddEnterpriseOrganizationMemberInput._(this._$data);

  factory Input$AddEnterpriseOrganizationMemberInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$userIds = data['userIds'];
    result$data['userIds'] =
        (l$userIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : fromJson$Enum$OrganizationMemberRole((l$role as String));
    }
    return Input$AddEnterpriseOrganizationMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get organizationId => (_$data['organizationId'] as String);

  List<String> get userIds => (_$data['userIds'] as List<String>);

  Enum$OrganizationMemberRole? get role =>
      (_$data['role'] as Enum$OrganizationMemberRole?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$userIds = userIds;
    result$data['userIds'] = l$userIds.map((e) => e).toList();
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] =
          l$role == null ? null : toJson$Enum$OrganizationMemberRole(l$role);
    }
    return result$data;
  }

  CopyWith$Input$AddEnterpriseOrganizationMemberInput<
          Input$AddEnterpriseOrganizationMemberInput>
      get copyWith => CopyWith$Input$AddEnterpriseOrganizationMemberInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddEnterpriseOrganizationMemberInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$userIds = userIds;
    final lOther$userIds = other.userIds;
    if (l$userIds.length != lOther$userIds.length) {
      return false;
    }
    for (int i = 0; i < l$userIds.length; i++) {
      final l$userIds$entry = l$userIds[i];
      final lOther$userIds$entry = lOther$userIds[i];
      if (l$userIds$entry != lOther$userIds$entry) {
        return false;
      }
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    final l$userIds = userIds;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$organizationId,
      Object.hashAll(l$userIds.map((v) => v)),
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddEnterpriseOrganizationMemberInput<TRes> {
  factory CopyWith$Input$AddEnterpriseOrganizationMemberInput(
    Input$AddEnterpriseOrganizationMemberInput instance,
    TRes Function(Input$AddEnterpriseOrganizationMemberInput) then,
  ) = _CopyWithImpl$Input$AddEnterpriseOrganizationMemberInput;

  factory CopyWith$Input$AddEnterpriseOrganizationMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddEnterpriseOrganizationMemberInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    List<String>? userIds,
    Enum$OrganizationMemberRole? role,
  });
}

class _CopyWithImpl$Input$AddEnterpriseOrganizationMemberInput<TRes>
    implements CopyWith$Input$AddEnterpriseOrganizationMemberInput<TRes> {
  _CopyWithImpl$Input$AddEnterpriseOrganizationMemberInput(
    this._instance,
    this._then,
  );

  final Input$AddEnterpriseOrganizationMemberInput _instance;

  final TRes Function(Input$AddEnterpriseOrganizationMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
    Object? userIds = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$AddEnterpriseOrganizationMemberInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (userIds != _undefined && userIds != null)
          'userIds': (userIds as List<String>),
        if (role != _undefined) 'role': (role as Enum$OrganizationMemberRole?),
      }));
}

class _CopyWithStubImpl$Input$AddEnterpriseOrganizationMemberInput<TRes>
    implements CopyWith$Input$AddEnterpriseOrganizationMemberInput<TRes> {
  _CopyWithStubImpl$Input$AddEnterpriseOrganizationMemberInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    List<String>? userIds,
    Enum$OrganizationMemberRole? role,
  }) =>
      _res;
}

class Input$AddEnterpriseSupportEntitlementInput {
  factory Input$AddEnterpriseSupportEntitlementInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$AddEnterpriseSupportEntitlementInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$AddEnterpriseSupportEntitlementInput._(this._$data);

  factory Input$AddEnterpriseSupportEntitlementInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$AddEnterpriseSupportEntitlementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get login => (_$data['login'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$AddEnterpriseSupportEntitlementInput<
          Input$AddEnterpriseSupportEntitlementInput>
      get copyWith => CopyWith$Input$AddEnterpriseSupportEntitlementInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddEnterpriseSupportEntitlementInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  factory CopyWith$Input$AddEnterpriseSupportEntitlementInput(
    Input$AddEnterpriseSupportEntitlementInput instance,
    TRes Function(Input$AddEnterpriseSupportEntitlementInput) then,
  ) = _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput;

  factory CopyWith$Input$AddEnterpriseSupportEntitlementInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput(
    this._instance,
    this._then,
  );

  final Input$AddEnterpriseSupportEntitlementInput _instance;

  final TRes Function(Input$AddEnterpriseSupportEntitlementInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$AddEnterpriseSupportEntitlementInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$AddLabelsToLabelableInput {
  factory Input$AddLabelsToLabelableInput({
    String? clientMutationId,
    required String labelableId,
    required List<String> labelIds,
  }) =>
      Input$AddLabelsToLabelableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'labelableId': labelableId,
        r'labelIds': labelIds,
      });

  Input$AddLabelsToLabelableInput._(this._$data);

  factory Input$AddLabelsToLabelableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    final l$labelIds = data['labelIds'];
    result$data['labelIds'] =
        (l$labelIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$AddLabelsToLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get labelableId => (_$data['labelableId'] as String);

  List<String> get labelIds => (_$data['labelIds'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    final l$labelIds = labelIds;
    result$data['labelIds'] = l$labelIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$AddLabelsToLabelableInput<Input$AddLabelsToLabelableInput>
      get copyWith => CopyWith$Input$AddLabelsToLabelableInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddLabelsToLabelableInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (l$labelIds.length != lOther$labelIds.length) {
      return false;
    }
    for (int i = 0; i < l$labelIds.length; i++) {
      final l$labelIds$entry = l$labelIds[i];
      final lOther$labelIds$entry = lOther$labelIds[i];
      if (l$labelIds$entry != lOther$labelIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$labelableId = labelableId;
    final l$labelIds = labelIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$labelableId,
      Object.hashAll(l$labelIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  factory CopyWith$Input$AddLabelsToLabelableInput(
    Input$AddLabelsToLabelableInput instance,
    TRes Function(Input$AddLabelsToLabelableInput) then,
  ) = _CopyWithImpl$Input$AddLabelsToLabelableInput;

  factory CopyWith$Input$AddLabelsToLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddLabelsToLabelableInput;

  TRes call({
    String? clientMutationId,
    String? labelableId,
    List<String>? labelIds,
  });
}

class _CopyWithImpl$Input$AddLabelsToLabelableInput<TRes>
    implements CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  _CopyWithImpl$Input$AddLabelsToLabelableInput(
    this._instance,
    this._then,
  );

  final Input$AddLabelsToLabelableInput _instance;

  final TRes Function(Input$AddLabelsToLabelableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? labelableId = _undefined,
    Object? labelIds = _undefined,
  }) =>
      _then(Input$AddLabelsToLabelableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
        if (labelIds != _undefined && labelIds != null)
          'labelIds': (labelIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$AddLabelsToLabelableInput<TRes>
    implements CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  _CopyWithStubImpl$Input$AddLabelsToLabelableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? labelableId,
    List<String>? labelIds,
  }) =>
      _res;
}

class Input$AddProjectCardInput {
  factory Input$AddProjectCardInput({
    String? clientMutationId,
    required String projectColumnId,
    String? contentId,
    String? note,
  }) =>
      Input$AddProjectCardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectColumnId': projectColumnId,
        if (contentId != null) r'contentId': contentId,
        if (note != null) r'note': note,
      });

  Input$AddProjectCardInput._(this._$data);

  factory Input$AddProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectColumnId = data['projectColumnId'];
    result$data['projectColumnId'] = (l$projectColumnId as String);
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    return Input$AddProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectColumnId => (_$data['projectColumnId'] as String);

  String? get contentId => (_$data['contentId'] as String?);

  String? get note => (_$data['note'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectColumnId = projectColumnId;
    result$data['projectColumnId'] = l$projectColumnId;
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    return result$data;
  }

  CopyWith$Input$AddProjectCardInput<Input$AddProjectCardInput> get copyWith =>
      CopyWith$Input$AddProjectCardInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddProjectCardInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectColumnId = projectColumnId;
    final lOther$projectColumnId = other.projectColumnId;
    if (l$projectColumnId != lOther$projectColumnId) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectColumnId = projectColumnId;
    final l$contentId = contentId;
    final l$note = note;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectColumnId,
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('note') ? l$note : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectCardInput<TRes> {
  factory CopyWith$Input$AddProjectCardInput(
    Input$AddProjectCardInput instance,
    TRes Function(Input$AddProjectCardInput) then,
  ) = _CopyWithImpl$Input$AddProjectCardInput;

  factory CopyWith$Input$AddProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectCardInput;

  TRes call({
    String? clientMutationId,
    String? projectColumnId,
    String? contentId,
    String? note,
  });
}

class _CopyWithImpl$Input$AddProjectCardInput<TRes>
    implements CopyWith$Input$AddProjectCardInput<TRes> {
  _CopyWithImpl$Input$AddProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectCardInput _instance;

  final TRes Function(Input$AddProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectColumnId = _undefined,
    Object? contentId = _undefined,
    Object? note = _undefined,
  }) =>
      _then(Input$AddProjectCardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectColumnId != _undefined && projectColumnId != null)
          'projectColumnId': (projectColumnId as String),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (note != _undefined) 'note': (note as String?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectCardInput<TRes>
    implements CopyWith$Input$AddProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectCardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectColumnId,
    String? contentId,
    String? note,
  }) =>
      _res;
}

class Input$AddProjectColumnInput {
  factory Input$AddProjectColumnInput({
    String? clientMutationId,
    required String projectId,
    required String name,
  }) =>
      Input$AddProjectColumnInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'name': name,
      });

  Input$AddProjectColumnInput._(this._$data);

  factory Input$AddProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$AddProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get name => (_$data['name'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$AddProjectColumnInput<Input$AddProjectColumnInput>
      get copyWith => CopyWith$Input$AddProjectColumnInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddProjectColumnInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$AddProjectColumnInput<TRes> {
  factory CopyWith$Input$AddProjectColumnInput(
    Input$AddProjectColumnInput instance,
    TRes Function(Input$AddProjectColumnInput) then,
  ) = _CopyWithImpl$Input$AddProjectColumnInput;

  factory CopyWith$Input$AddProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectColumnInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? name,
  });
}

class _CopyWithImpl$Input$AddProjectColumnInput<TRes>
    implements CopyWith$Input$AddProjectColumnInput<TRes> {
  _CopyWithImpl$Input$AddProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectColumnInput _instance;

  final TRes Function(Input$AddProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$AddProjectColumnInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$AddProjectColumnInput<TRes>
    implements CopyWith$Input$AddProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectColumnInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? name,
  }) =>
      _res;
}

class Input$AddProjectV2DraftIssueInput {
  factory Input$AddProjectV2DraftIssueInput({
    String? clientMutationId,
    required String projectId,
    required String title,
    String? body,
    List<String>? assigneeIds,
  }) =>
      Input$AddProjectV2DraftIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
      });

  Input$AddProjectV2DraftIssueInput._(this._$data);

  factory Input$AddProjectV2DraftIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$AddProjectV2DraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get title => (_$data['title'] as String);

  String? get body => (_$data['body'] as String?);

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$AddProjectV2DraftIssueInput<Input$AddProjectV2DraftIssueInput>
      get copyWith => CopyWith$Input$AddProjectV2DraftIssueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddProjectV2DraftIssueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$title,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  factory CopyWith$Input$AddProjectV2DraftIssueInput(
    Input$AddProjectV2DraftIssueInput instance,
    TRes Function(Input$AddProjectV2DraftIssueInput) then,
  ) = _CopyWithImpl$Input$AddProjectV2DraftIssueInput;

  factory CopyWith$Input$AddProjectV2DraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? title,
    String? body,
    List<String>? assigneeIds,
  });
}

class _CopyWithImpl$Input$AddProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  _CopyWithImpl$Input$AddProjectV2DraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectV2DraftIssueInput _instance;

  final TRes Function(Input$AddProjectV2DraftIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
  }) =>
      _then(Input$AddProjectV2DraftIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? title,
    String? body,
    List<String>? assigneeIds,
  }) =>
      _res;
}

class Input$AddProjectV2ItemByIdInput {
  factory Input$AddProjectV2ItemByIdInput({
    String? clientMutationId,
    required String projectId,
    required String contentId,
  }) =>
      Input$AddProjectV2ItemByIdInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'contentId': contentId,
      });

  Input$AddProjectV2ItemByIdInput._(this._$data);

  factory Input$AddProjectV2ItemByIdInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$contentId = data['contentId'];
    result$data['contentId'] = (l$contentId as String);
    return Input$AddProjectV2ItemByIdInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get contentId => (_$data['contentId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$contentId = contentId;
    result$data['contentId'] = l$contentId;
    return result$data;
  }

  CopyWith$Input$AddProjectV2ItemByIdInput<Input$AddProjectV2ItemByIdInput>
      get copyWith => CopyWith$Input$AddProjectV2ItemByIdInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddProjectV2ItemByIdInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (l$contentId != lOther$contentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$contentId = contentId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$contentId,
    ]);
  }
}

abstract class CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  factory CopyWith$Input$AddProjectV2ItemByIdInput(
    Input$AddProjectV2ItemByIdInput instance,
    TRes Function(Input$AddProjectV2ItemByIdInput) then,
  ) = _CopyWithImpl$Input$AddProjectV2ItemByIdInput;

  factory CopyWith$Input$AddProjectV2ItemByIdInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? contentId,
  });
}

class _CopyWithImpl$Input$AddProjectV2ItemByIdInput<TRes>
    implements CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  _CopyWithImpl$Input$AddProjectV2ItemByIdInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectV2ItemByIdInput _instance;

  final TRes Function(Input$AddProjectV2ItemByIdInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? contentId = _undefined,
  }) =>
      _then(Input$AddProjectV2ItemByIdInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (contentId != _undefined && contentId != null)
          'contentId': (contentId as String),
      }));
}

class _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput<TRes>
    implements CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? contentId,
  }) =>
      _res;
}

class Input$AddPullRequestReviewCommentInput {
  factory Input$AddPullRequestReviewCommentInput({
    String? clientMutationId,
    String? pullRequestId,
    String? pullRequestReviewId,
    String? commitOID,
    String? body,
    String? path,
    int? position,
    String? inReplyTo,
  }) =>
      Input$AddPullRequestReviewCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        if (commitOID != null) r'commitOID': commitOID,
        if (body != null) r'body': body,
        if (path != null) r'path': path,
        if (position != null) r'position': position,
        if (inReplyTo != null) r'inReplyTo': inReplyTo,
      });

  Input$AddPullRequestReviewCommentInput._(this._$data);

  factory Input$AddPullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    if (data.containsKey('commitOID')) {
      final l$commitOID = data['commitOID'];
      result$data['commitOID'] = (l$commitOID as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as String?);
    }
    if (data.containsKey('position')) {
      final l$position = data['position'];
      result$data['position'] = (l$position as int?);
    }
    if (data.containsKey('inReplyTo')) {
      final l$inReplyTo = data['inReplyTo'];
      result$data['inReplyTo'] = (l$inReplyTo as String?);
    }
    return Input$AddPullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get pullRequestId => (_$data['pullRequestId'] as String?);

  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);

  String? get commitOID => (_$data['commitOID'] as String?);

  String? get body => (_$data['body'] as String?);

  String? get path => (_$data['path'] as String?);

  int? get position => (_$data['position'] as int?);

  String? get inReplyTo => (_$data['inReplyTo'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    if (_$data.containsKey('commitOID')) {
      final l$commitOID = commitOID;
      result$data['commitOID'] = l$commitOID;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('position')) {
      final l$position = position;
      result$data['position'] = l$position;
    }
    if (_$data.containsKey('inReplyTo')) {
      final l$inReplyTo = inReplyTo;
      result$data['inReplyTo'] = l$inReplyTo;
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewCommentInput<
          Input$AddPullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddPullRequestReviewCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$commitOID = commitOID;
    final lOther$commitOID = other.commitOID;
    if (_$data.containsKey('commitOID') !=
        other._$data.containsKey('commitOID')) {
      return false;
    }
    if (l$commitOID != lOther$commitOID) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (_$data.containsKey('position') !=
        other._$data.containsKey('position')) {
      return false;
    }
    if (l$position != lOther$position) {
      return false;
    }
    final l$inReplyTo = inReplyTo;
    final lOther$inReplyTo = other.inReplyTo;
    if (_$data.containsKey('inReplyTo') !=
        other._$data.containsKey('inReplyTo')) {
      return false;
    }
    if (l$inReplyTo != lOther$inReplyTo) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$commitOID = commitOID;
    final l$body = body;
    final l$path = path;
    final l$position = position;
    final l$inReplyTo = inReplyTo;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      _$data.containsKey('commitOID') ? l$commitOID : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('position') ? l$position : const {},
      _$data.containsKey('inReplyTo') ? l$inReplyTo : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewCommentInput(
    Input$AddPullRequestReviewCommentInput instance,
    TRes Function(Input$AddPullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewCommentInput;

  factory CopyWith$Input$AddPullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? pullRequestReviewId,
    String? commitOID,
    String? body,
    String? path,
    int? position,
    String? inReplyTo,
  });
}

class _CopyWithImpl$Input$AddPullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewCommentInput _instance;

  final TRes Function(Input$AddPullRequestReviewCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? commitOID = _undefined,
    Object? body = _undefined,
    Object? path = _undefined,
    Object? position = _undefined,
    Object? inReplyTo = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (commitOID != _undefined) 'commitOID': (commitOID as String?),
        if (body != _undefined) 'body': (body as String?),
        if (path != _undefined) 'path': (path as String?),
        if (position != _undefined) 'position': (position as int?),
        if (inReplyTo != _undefined) 'inReplyTo': (inReplyTo as String?),
      }));
}

class _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? pullRequestReviewId,
    String? commitOID,
    String? body,
    String? path,
    int? position,
    String? inReplyTo,
  }) =>
      _res;
}

class Input$AddPullRequestReviewInput {
  factory Input$AddPullRequestReviewInput({
    String? clientMutationId,
    required String pullRequestId,
    String? commitOID,
    String? body,
    Enum$PullRequestReviewEvent? event,
    List<Input$DraftPullRequestReviewComment?>? comments,
    List<Input$DraftPullRequestReviewThread?>? threads,
  }) =>
      Input$AddPullRequestReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (commitOID != null) r'commitOID': commitOID,
        if (body != null) r'body': body,
        if (event != null) r'event': event,
        if (comments != null) r'comments': comments,
        if (threads != null) r'threads': threads,
      });

  Input$AddPullRequestReviewInput._(this._$data);

  factory Input$AddPullRequestReviewInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('commitOID')) {
      final l$commitOID = data['commitOID'];
      result$data['commitOID'] = (l$commitOID as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : fromJson$Enum$PullRequestReviewEvent((l$event as String));
    }
    if (data.containsKey('comments')) {
      final l$comments = data['comments'];
      result$data['comments'] = (l$comments as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$DraftPullRequestReviewComment.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('threads')) {
      final l$threads = data['threads'];
      result$data['threads'] = (l$threads as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$DraftPullRequestReviewThread.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$AddPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String? get commitOID => (_$data['commitOID'] as String?);

  String? get body => (_$data['body'] as String?);

  Enum$PullRequestReviewEvent? get event =>
      (_$data['event'] as Enum$PullRequestReviewEvent?);

  List<Input$DraftPullRequestReviewComment?>? get comments =>
      (_$data['comments'] as List<Input$DraftPullRequestReviewComment?>?);

  List<Input$DraftPullRequestReviewThread?>? get threads =>
      (_$data['threads'] as List<Input$DraftPullRequestReviewThread?>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('commitOID')) {
      final l$commitOID = commitOID;
      result$data['commitOID'] = l$commitOID;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] =
          l$event == null ? null : toJson$Enum$PullRequestReviewEvent(l$event);
    }
    if (_$data.containsKey('comments')) {
      final l$comments = comments;
      result$data['comments'] = l$comments?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('threads')) {
      final l$threads = threads;
      result$data['threads'] = l$threads?.map((e) => e?.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewInput<Input$AddPullRequestReviewInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddPullRequestReviewInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$commitOID = commitOID;
    final lOther$commitOID = other.commitOID;
    if (_$data.containsKey('commitOID') !=
        other._$data.containsKey('commitOID')) {
      return false;
    }
    if (l$commitOID != lOther$commitOID) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$comments = comments;
    final lOther$comments = other.comments;
    if (_$data.containsKey('comments') !=
        other._$data.containsKey('comments')) {
      return false;
    }
    if (l$comments != null && lOther$comments != null) {
      if (l$comments.length != lOther$comments.length) {
        return false;
      }
      for (int i = 0; i < l$comments.length; i++) {
        final l$comments$entry = l$comments[i];
        final lOther$comments$entry = lOther$comments[i];
        if (l$comments$entry != lOther$comments$entry) {
          return false;
        }
      }
    } else if (l$comments != lOther$comments) {
      return false;
    }
    final l$threads = threads;
    final lOther$threads = other.threads;
    if (_$data.containsKey('threads') != other._$data.containsKey('threads')) {
      return false;
    }
    if (l$threads != null && lOther$threads != null) {
      if (l$threads.length != lOther$threads.length) {
        return false;
      }
      for (int i = 0; i < l$threads.length; i++) {
        final l$threads$entry = l$threads[i];
        final lOther$threads$entry = lOther$threads[i];
        if (l$threads$entry != lOther$threads$entry) {
          return false;
        }
      }
    } else if (l$threads != lOther$threads) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$commitOID = commitOID;
    final l$body = body;
    final l$event = event;
    final l$comments = comments;
    final l$threads = threads;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('commitOID') ? l$commitOID : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('event') ? l$event : const {},
      _$data.containsKey('comments')
          ? l$comments == null
              ? null
              : Object.hashAll(l$comments.map((v) => v))
          : const {},
      _$data.containsKey('threads')
          ? l$threads == null
              ? null
              : Object.hashAll(l$threads.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewInput(
    Input$AddPullRequestReviewInput instance,
    TRes Function(Input$AddPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewInput;

  factory CopyWith$Input$AddPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? commitOID,
    String? body,
    Enum$PullRequestReviewEvent? event,
    List<Input$DraftPullRequestReviewComment?>? comments,
    List<Input$DraftPullRequestReviewThread?>? threads,
  });
  TRes comments(
      Iterable<Input$DraftPullRequestReviewComment?>? Function(
              Iterable<
                  CopyWith$Input$DraftPullRequestReviewComment<
                      Input$DraftPullRequestReviewComment>?>?)
          _fn);
  TRes threads(
      Iterable<Input$DraftPullRequestReviewThread?>? Function(
              Iterable<
                  CopyWith$Input$DraftPullRequestReviewThread<
                      Input$DraftPullRequestReviewThread>?>?)
          _fn);
}

class _CopyWithImpl$Input$AddPullRequestReviewInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewInput _instance;

  final TRes Function(Input$AddPullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? commitOID = _undefined,
    Object? body = _undefined,
    Object? event = _undefined,
    Object? comments = _undefined,
    Object? threads = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (commitOID != _undefined) 'commitOID': (commitOID as String?),
        if (body != _undefined) 'body': (body as String?),
        if (event != _undefined)
          'event': (event as Enum$PullRequestReviewEvent?),
        if (comments != _undefined)
          'comments': (comments as List<Input$DraftPullRequestReviewComment?>?),
        if (threads != _undefined)
          'threads': (threads as List<Input$DraftPullRequestReviewThread?>?),
      }));

  TRes comments(
          Iterable<Input$DraftPullRequestReviewComment?>? Function(
                  Iterable<
                      CopyWith$Input$DraftPullRequestReviewComment<
                          Input$DraftPullRequestReviewComment>?>?)
              _fn) =>
      call(
          comments: _fn(_instance.comments?.map((e) => e == null
              ? null
              : CopyWith$Input$DraftPullRequestReviewComment(
                  e,
                  (i) => i,
                )))?.toList());

  TRes threads(
          Iterable<Input$DraftPullRequestReviewThread?>? Function(
                  Iterable<
                      CopyWith$Input$DraftPullRequestReviewThread<
                          Input$DraftPullRequestReviewThread>?>?)
              _fn) =>
      call(
          threads: _fn(_instance.threads?.map((e) => e == null
              ? null
              : CopyWith$Input$DraftPullRequestReviewThread(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$AddPullRequestReviewInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? commitOID,
    String? body,
    Enum$PullRequestReviewEvent? event,
    List<Input$DraftPullRequestReviewComment?>? comments,
    List<Input$DraftPullRequestReviewThread?>? threads,
  }) =>
      _res;

  comments(_fn) => _res;

  threads(_fn) => _res;
}

class Input$AddPullRequestReviewThreadInput {
  factory Input$AddPullRequestReviewThreadInput({
    String? clientMutationId,
    String? path,
    required String body,
    String? pullRequestId,
    String? pullRequestReviewId,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    Enum$PullRequestReviewThreadSubjectType? subjectType,
  }) =>
      Input$AddPullRequestReviewThreadInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (path != null) r'path': path,
        r'body': body,
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        if (line != null) r'line': line,
        if (side != null) r'side': side,
        if (startLine != null) r'startLine': startLine,
        if (startSide != null) r'startSide': startSide,
        if (subjectType != null) r'subjectType': subjectType,
      });

  Input$AddPullRequestReviewThreadInput._(this._$data);

  factory Input$AddPullRequestReviewThreadInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as String?);
    }
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    if (data.containsKey('line')) {
      final l$line = data['line'];
      result$data['line'] = (l$line as int?);
    }
    if (data.containsKey('side')) {
      final l$side = data['side'];
      result$data['side'] =
          l$side == null ? null : fromJson$Enum$DiffSide((l$side as String));
    }
    if (data.containsKey('startLine')) {
      final l$startLine = data['startLine'];
      result$data['startLine'] = (l$startLine as int?);
    }
    if (data.containsKey('startSide')) {
      final l$startSide = data['startSide'];
      result$data['startSide'] = l$startSide == null
          ? null
          : fromJson$Enum$DiffSide((l$startSide as String));
    }
    if (data.containsKey('subjectType')) {
      final l$subjectType = data['subjectType'];
      result$data['subjectType'] = l$subjectType == null
          ? null
          : fromJson$Enum$PullRequestReviewThreadSubjectType(
              (l$subjectType as String));
    }
    return Input$AddPullRequestReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get path => (_$data['path'] as String?);

  String get body => (_$data['body'] as String);

  String? get pullRequestId => (_$data['pullRequestId'] as String?);

  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);

  int? get line => (_$data['line'] as int?);

  Enum$DiffSide? get side => (_$data['side'] as Enum$DiffSide?);

  int? get startLine => (_$data['startLine'] as int?);

  Enum$DiffSide? get startSide => (_$data['startSide'] as Enum$DiffSide?);

  Enum$PullRequestReviewThreadSubjectType? get subjectType =>
      (_$data['subjectType'] as Enum$PullRequestReviewThreadSubjectType?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    if (_$data.containsKey('line')) {
      final l$line = line;
      result$data['line'] = l$line;
    }
    if (_$data.containsKey('side')) {
      final l$side = side;
      result$data['side'] =
          l$side == null ? null : toJson$Enum$DiffSide(l$side);
    }
    if (_$data.containsKey('startLine')) {
      final l$startLine = startLine;
      result$data['startLine'] = l$startLine;
    }
    if (_$data.containsKey('startSide')) {
      final l$startSide = startSide;
      result$data['startSide'] =
          l$startSide == null ? null : toJson$Enum$DiffSide(l$startSide);
    }
    if (_$data.containsKey('subjectType')) {
      final l$subjectType = subjectType;
      result$data['subjectType'] = l$subjectType == null
          ? null
          : toJson$Enum$PullRequestReviewThreadSubjectType(l$subjectType);
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewThreadInput<
          Input$AddPullRequestReviewThreadInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewThreadInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddPullRequestReviewThreadInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$line = line;
    final lOther$line = other.line;
    if (_$data.containsKey('line') != other._$data.containsKey('line')) {
      return false;
    }
    if (l$line != lOther$line) {
      return false;
    }
    final l$side = side;
    final lOther$side = other.side;
    if (_$data.containsKey('side') != other._$data.containsKey('side')) {
      return false;
    }
    if (l$side != lOther$side) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (_$data.containsKey('startLine') !=
        other._$data.containsKey('startLine')) {
      return false;
    }
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startSide = startSide;
    final lOther$startSide = other.startSide;
    if (_$data.containsKey('startSide') !=
        other._$data.containsKey('startSide')) {
      return false;
    }
    if (l$startSide != lOther$startSide) {
      return false;
    }
    final l$subjectType = subjectType;
    final lOther$subjectType = other.subjectType;
    if (_$data.containsKey('subjectType') !=
        other._$data.containsKey('subjectType')) {
      return false;
    }
    if (l$subjectType != lOther$subjectType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$path = path;
    final l$body = body;
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$line = line;
    final l$side = side;
    final l$startLine = startLine;
    final l$startSide = startSide;
    final l$subjectType = subjectType;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('path') ? l$path : const {},
      l$body,
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      _$data.containsKey('line') ? l$line : const {},
      _$data.containsKey('side') ? l$side : const {},
      _$data.containsKey('startLine') ? l$startLine : const {},
      _$data.containsKey('startSide') ? l$startSide : const {},
      _$data.containsKey('subjectType') ? l$subjectType : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewThreadInput(
    Input$AddPullRequestReviewThreadInput instance,
    TRes Function(Input$AddPullRequestReviewThreadInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewThreadInput;

  factory CopyWith$Input$AddPullRequestReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput;

  TRes call({
    String? clientMutationId,
    String? path,
    String? body,
    String? pullRequestId,
    String? pullRequestReviewId,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    Enum$PullRequestReviewThreadSubjectType? subjectType,
  });
}

class _CopyWithImpl$Input$AddPullRequestReviewThreadInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewThreadInput _instance;

  final TRes Function(Input$AddPullRequestReviewThreadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? path = _undefined,
    Object? body = _undefined,
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? line = _undefined,
    Object? side = _undefined,
    Object? startLine = _undefined,
    Object? startSide = _undefined,
    Object? subjectType = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewThreadInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (path != _undefined) 'path': (path as String?),
        if (body != _undefined && body != null) 'body': (body as String),
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (line != _undefined) 'line': (line as int?),
        if (side != _undefined) 'side': (side as Enum$DiffSide?),
        if (startLine != _undefined) 'startLine': (startLine as int?),
        if (startSide != _undefined) 'startSide': (startSide as Enum$DiffSide?),
        if (subjectType != _undefined)
          'subjectType':
              (subjectType as Enum$PullRequestReviewThreadSubjectType?),
      }));
}

class _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? path,
    String? body,
    String? pullRequestId,
    String? pullRequestReviewId,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    Enum$PullRequestReviewThreadSubjectType? subjectType,
  }) =>
      _res;
}

class Input$AddPullRequestReviewThreadReplyInput {
  factory Input$AddPullRequestReviewThreadReplyInput({
    String? clientMutationId,
    String? pullRequestReviewId,
    required String pullRequestReviewThreadId,
    required String body,
  }) =>
      Input$AddPullRequestReviewThreadReplyInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        r'pullRequestReviewThreadId': pullRequestReviewThreadId,
        r'body': body,
      });

  Input$AddPullRequestReviewThreadReplyInput._(this._$data);

  factory Input$AddPullRequestReviewThreadReplyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    final l$pullRequestReviewThreadId = data['pullRequestReviewThreadId'];
    result$data['pullRequestReviewThreadId'] =
        (l$pullRequestReviewThreadId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$AddPullRequestReviewThreadReplyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);

  String get pullRequestReviewThreadId =>
      (_$data['pullRequestReviewThreadId'] as String);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    final l$pullRequestReviewThreadId = pullRequestReviewThreadId;
    result$data['pullRequestReviewThreadId'] = l$pullRequestReviewThreadId;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewThreadReplyInput<
          Input$AddPullRequestReviewThreadReplyInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewThreadReplyInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddPullRequestReviewThreadReplyInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$pullRequestReviewThreadId = pullRequestReviewThreadId;
    final lOther$pullRequestReviewThreadId = other.pullRequestReviewThreadId;
    if (l$pullRequestReviewThreadId != lOther$pullRequestReviewThreadId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$pullRequestReviewThreadId = pullRequestReviewThreadId;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      l$pullRequestReviewThreadId,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewThreadReplyInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewThreadReplyInput(
    Input$AddPullRequestReviewThreadReplyInput instance,
    TRes Function(Input$AddPullRequestReviewThreadReplyInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewThreadReplyInput;

  factory CopyWith$Input$AddPullRequestReviewThreadReplyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewThreadReplyInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestReviewId,
    String? pullRequestReviewThreadId,
    String? body,
  });
}

class _CopyWithImpl$Input$AddPullRequestReviewThreadReplyInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadReplyInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewThreadReplyInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewThreadReplyInput _instance;

  final TRes Function(Input$AddPullRequestReviewThreadReplyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? pullRequestReviewThreadId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewThreadReplyInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (pullRequestReviewThreadId != _undefined &&
            pullRequestReviewThreadId != null)
          'pullRequestReviewThreadId': (pullRequestReviewThreadId as String),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$AddPullRequestReviewThreadReplyInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadReplyInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewThreadReplyInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestReviewId,
    String? pullRequestReviewThreadId,
    String? body,
  }) =>
      _res;
}

class Input$AddReactionInput {
  factory Input$AddReactionInput({
    String? clientMutationId,
    required String subjectId,
    required Enum$ReactionContent content,
  }) =>
      Input$AddReactionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
        r'content': content,
      });

  Input$AddReactionInput._(this._$data);

  factory Input$AddReactionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$content = data['content'];
    result$data['content'] =
        fromJson$Enum$ReactionContent((l$content as String));
    return Input$AddReactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subjectId => (_$data['subjectId'] as String);

  Enum$ReactionContent get content =>
      (_$data['content'] as Enum$ReactionContent);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$content = content;
    result$data['content'] = toJson$Enum$ReactionContent(l$content);
    return result$data;
  }

  CopyWith$Input$AddReactionInput<Input$AddReactionInput> get copyWith =>
      CopyWith$Input$AddReactionInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddReactionInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    final l$content = content;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
      l$content,
    ]);
  }
}

abstract class CopyWith$Input$AddReactionInput<TRes> {
  factory CopyWith$Input$AddReactionInput(
    Input$AddReactionInput instance,
    TRes Function(Input$AddReactionInput) then,
  ) = _CopyWithImpl$Input$AddReactionInput;

  factory CopyWith$Input$AddReactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddReactionInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
    Enum$ReactionContent? content,
  });
}

class _CopyWithImpl$Input$AddReactionInput<TRes>
    implements CopyWith$Input$AddReactionInput<TRes> {
  _CopyWithImpl$Input$AddReactionInput(
    this._instance,
    this._then,
  );

  final Input$AddReactionInput _instance;

  final TRes Function(Input$AddReactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
    Object? content = _undefined,
  }) =>
      _then(Input$AddReactionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (content != _undefined && content != null)
          'content': (content as Enum$ReactionContent),
      }));
}

class _CopyWithStubImpl$Input$AddReactionInput<TRes>
    implements CopyWith$Input$AddReactionInput<TRes> {
  _CopyWithStubImpl$Input$AddReactionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
    Enum$ReactionContent? content,
  }) =>
      _res;
}

class Input$AddStarInput {
  factory Input$AddStarInput({
    String? clientMutationId,
    required String starrableId,
  }) =>
      Input$AddStarInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'starrableId': starrableId,
      });

  Input$AddStarInput._(this._$data);

  factory Input$AddStarInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$starrableId = data['starrableId'];
    result$data['starrableId'] = (l$starrableId as String);
    return Input$AddStarInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get starrableId => (_$data['starrableId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$starrableId = starrableId;
    result$data['starrableId'] = l$starrableId;
    return result$data;
  }

  CopyWith$Input$AddStarInput<Input$AddStarInput> get copyWith =>
      CopyWith$Input$AddStarInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddStarInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$starrableId = starrableId;
    final lOther$starrableId = other.starrableId;
    if (l$starrableId != lOther$starrableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$starrableId = starrableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$starrableId,
    ]);
  }
}

abstract class CopyWith$Input$AddStarInput<TRes> {
  factory CopyWith$Input$AddStarInput(
    Input$AddStarInput instance,
    TRes Function(Input$AddStarInput) then,
  ) = _CopyWithImpl$Input$AddStarInput;

  factory CopyWith$Input$AddStarInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddStarInput;

  TRes call({
    String? clientMutationId,
    String? starrableId,
  });
}

class _CopyWithImpl$Input$AddStarInput<TRes>
    implements CopyWith$Input$AddStarInput<TRes> {
  _CopyWithImpl$Input$AddStarInput(
    this._instance,
    this._then,
  );

  final Input$AddStarInput _instance;

  final TRes Function(Input$AddStarInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? starrableId = _undefined,
  }) =>
      _then(Input$AddStarInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (starrableId != _undefined && starrableId != null)
          'starrableId': (starrableId as String),
      }));
}

class _CopyWithStubImpl$Input$AddStarInput<TRes>
    implements CopyWith$Input$AddStarInput<TRes> {
  _CopyWithStubImpl$Input$AddStarInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? starrableId,
  }) =>
      _res;
}

class Input$AddSubIssueInput {
  factory Input$AddSubIssueInput({
    String? clientMutationId,
    required String issueId,
    String? subIssueId,
    String? subIssueUrl,
    bool? replaceParent,
  }) =>
      Input$AddSubIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        if (subIssueId != null) r'subIssueId': subIssueId,
        if (subIssueUrl != null) r'subIssueUrl': subIssueUrl,
        if (replaceParent != null) r'replaceParent': replaceParent,
      });

  Input$AddSubIssueInput._(this._$data);

  factory Input$AddSubIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('subIssueId')) {
      final l$subIssueId = data['subIssueId'];
      result$data['subIssueId'] = (l$subIssueId as String?);
    }
    if (data.containsKey('subIssueUrl')) {
      final l$subIssueUrl = data['subIssueUrl'];
      result$data['subIssueUrl'] = (l$subIssueUrl as String?);
    }
    if (data.containsKey('replaceParent')) {
      final l$replaceParent = data['replaceParent'];
      result$data['replaceParent'] = (l$replaceParent as bool?);
    }
    return Input$AddSubIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  String? get subIssueId => (_$data['subIssueId'] as String?);

  String? get subIssueUrl => (_$data['subIssueUrl'] as String?);

  bool? get replaceParent => (_$data['replaceParent'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('subIssueId')) {
      final l$subIssueId = subIssueId;
      result$data['subIssueId'] = l$subIssueId;
    }
    if (_$data.containsKey('subIssueUrl')) {
      final l$subIssueUrl = subIssueUrl;
      result$data['subIssueUrl'] = l$subIssueUrl;
    }
    if (_$data.containsKey('replaceParent')) {
      final l$replaceParent = replaceParent;
      result$data['replaceParent'] = l$replaceParent;
    }
    return result$data;
  }

  CopyWith$Input$AddSubIssueInput<Input$AddSubIssueInput> get copyWith =>
      CopyWith$Input$AddSubIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddSubIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$subIssueId = subIssueId;
    final lOther$subIssueId = other.subIssueId;
    if (_$data.containsKey('subIssueId') !=
        other._$data.containsKey('subIssueId')) {
      return false;
    }
    if (l$subIssueId != lOther$subIssueId) {
      return false;
    }
    final l$subIssueUrl = subIssueUrl;
    final lOther$subIssueUrl = other.subIssueUrl;
    if (_$data.containsKey('subIssueUrl') !=
        other._$data.containsKey('subIssueUrl')) {
      return false;
    }
    if (l$subIssueUrl != lOther$subIssueUrl) {
      return false;
    }
    final l$replaceParent = replaceParent;
    final lOther$replaceParent = other.replaceParent;
    if (_$data.containsKey('replaceParent') !=
        other._$data.containsKey('replaceParent')) {
      return false;
    }
    if (l$replaceParent != lOther$replaceParent) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$subIssueId = subIssueId;
    final l$subIssueUrl = subIssueUrl;
    final l$replaceParent = replaceParent;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      _$data.containsKey('subIssueId') ? l$subIssueId : const {},
      _$data.containsKey('subIssueUrl') ? l$subIssueUrl : const {},
      _$data.containsKey('replaceParent') ? l$replaceParent : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddSubIssueInput<TRes> {
  factory CopyWith$Input$AddSubIssueInput(
    Input$AddSubIssueInput instance,
    TRes Function(Input$AddSubIssueInput) then,
  ) = _CopyWithImpl$Input$AddSubIssueInput;

  factory CopyWith$Input$AddSubIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddSubIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? subIssueId,
    String? subIssueUrl,
    bool? replaceParent,
  });
}

class _CopyWithImpl$Input$AddSubIssueInput<TRes>
    implements CopyWith$Input$AddSubIssueInput<TRes> {
  _CopyWithImpl$Input$AddSubIssueInput(
    this._instance,
    this._then,
  );

  final Input$AddSubIssueInput _instance;

  final TRes Function(Input$AddSubIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? subIssueId = _undefined,
    Object? subIssueUrl = _undefined,
    Object? replaceParent = _undefined,
  }) =>
      _then(Input$AddSubIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (subIssueId != _undefined) 'subIssueId': (subIssueId as String?),
        if (subIssueUrl != _undefined) 'subIssueUrl': (subIssueUrl as String?),
        if (replaceParent != _undefined)
          'replaceParent': (replaceParent as bool?),
      }));
}

class _CopyWithStubImpl$Input$AddSubIssueInput<TRes>
    implements CopyWith$Input$AddSubIssueInput<TRes> {
  _CopyWithStubImpl$Input$AddSubIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? subIssueId,
    String? subIssueUrl,
    bool? replaceParent,
  }) =>
      _res;
}

class Input$AddUpvoteInput {
  factory Input$AddUpvoteInput({
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$AddUpvoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$AddUpvoteInput._(this._$data);

  factory Input$AddUpvoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$AddUpvoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subjectId => (_$data['subjectId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$AddUpvoteInput<Input$AddUpvoteInput> get copyWith =>
      CopyWith$Input$AddUpvoteInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddUpvoteInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$AddUpvoteInput<TRes> {
  factory CopyWith$Input$AddUpvoteInput(
    Input$AddUpvoteInput instance,
    TRes Function(Input$AddUpvoteInput) then,
  ) = _CopyWithImpl$Input$AddUpvoteInput;

  factory CopyWith$Input$AddUpvoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddUpvoteInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$AddUpvoteInput<TRes>
    implements CopyWith$Input$AddUpvoteInput<TRes> {
  _CopyWithImpl$Input$AddUpvoteInput(
    this._instance,
    this._then,
  );

  final Input$AddUpvoteInput _instance;

  final TRes Function(Input$AddUpvoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$AddUpvoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$AddUpvoteInput<TRes>
    implements CopyWith$Input$AddUpvoteInput<TRes> {
  _CopyWithStubImpl$Input$AddUpvoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$AddVerifiableDomainInput {
  factory Input$AddVerifiableDomainInput({
    String? clientMutationId,
    required String ownerId,
    required String domain,
  }) =>
      Input$AddVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'domain': domain,
      });

  Input$AddVerifiableDomainInput._(this._$data);

  factory Input$AddVerifiableDomainInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$domain = data['domain'];
    result$data['domain'] = (l$domain as String);
    return Input$AddVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  String get domain => (_$data['domain'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$domain = domain;
    result$data['domain'] = l$domain;
    return result$data;
  }

  CopyWith$Input$AddVerifiableDomainInput<Input$AddVerifiableDomainInput>
      get copyWith => CopyWith$Input$AddVerifiableDomainInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AddVerifiableDomainInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$domain = domain;
    final lOther$domain = other.domain;
    if (l$domain != lOther$domain) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$domain = domain;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$domain,
    ]);
  }
}

abstract class CopyWith$Input$AddVerifiableDomainInput<TRes> {
  factory CopyWith$Input$AddVerifiableDomainInput(
    Input$AddVerifiableDomainInput instance,
    TRes Function(Input$AddVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$AddVerifiableDomainInput;

  factory CopyWith$Input$AddVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    String? domain,
  });
}

class _CopyWithImpl$Input$AddVerifiableDomainInput<TRes>
    implements CopyWith$Input$AddVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$AddVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$AddVerifiableDomainInput _instance;

  final TRes Function(Input$AddVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? domain = _undefined,
  }) =>
      _then(Input$AddVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (domain != _undefined && domain != null)
          'domain': (domain as String),
      }));
}

class _CopyWithStubImpl$Input$AddVerifiableDomainInput<TRes>
    implements CopyWith$Input$AddVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$AddVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    String? domain,
  }) =>
      _res;
}

class Input$ApproveDeploymentsInput {
  factory Input$ApproveDeploymentsInput({
    String? clientMutationId,
    required String workflowRunId,
    required List<String> environmentIds,
    String? comment,
  }) =>
      Input$ApproveDeploymentsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'workflowRunId': workflowRunId,
        r'environmentIds': environmentIds,
        if (comment != null) r'comment': comment,
      });

  Input$ApproveDeploymentsInput._(this._$data);

  factory Input$ApproveDeploymentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$workflowRunId = data['workflowRunId'];
    result$data['workflowRunId'] = (l$workflowRunId as String);
    final l$environmentIds = data['environmentIds'];
    result$data['environmentIds'] =
        (l$environmentIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    return Input$ApproveDeploymentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get workflowRunId => (_$data['workflowRunId'] as String);

  List<String> get environmentIds => (_$data['environmentIds'] as List<String>);

  String? get comment => (_$data['comment'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$workflowRunId = workflowRunId;
    result$data['workflowRunId'] = l$workflowRunId;
    final l$environmentIds = environmentIds;
    result$data['environmentIds'] = l$environmentIds.map((e) => e).toList();
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    return result$data;
  }

  CopyWith$Input$ApproveDeploymentsInput<Input$ApproveDeploymentsInput>
      get copyWith => CopyWith$Input$ApproveDeploymentsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ApproveDeploymentsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$workflowRunId = workflowRunId;
    final lOther$workflowRunId = other.workflowRunId;
    if (l$workflowRunId != lOther$workflowRunId) {
      return false;
    }
    final l$environmentIds = environmentIds;
    final lOther$environmentIds = other.environmentIds;
    if (l$environmentIds.length != lOther$environmentIds.length) {
      return false;
    }
    for (int i = 0; i < l$environmentIds.length; i++) {
      final l$environmentIds$entry = l$environmentIds[i];
      final lOther$environmentIds$entry = lOther$environmentIds[i];
      if (l$environmentIds$entry != lOther$environmentIds$entry) {
        return false;
      }
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$workflowRunId = workflowRunId;
    final l$environmentIds = environmentIds;
    final l$comment = comment;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$workflowRunId,
      Object.hashAll(l$environmentIds.map((v) => v)),
      _$data.containsKey('comment') ? l$comment : const {},
    ]);
  }
}

abstract class CopyWith$Input$ApproveDeploymentsInput<TRes> {
  factory CopyWith$Input$ApproveDeploymentsInput(
    Input$ApproveDeploymentsInput instance,
    TRes Function(Input$ApproveDeploymentsInput) then,
  ) = _CopyWithImpl$Input$ApproveDeploymentsInput;

  factory CopyWith$Input$ApproveDeploymentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApproveDeploymentsInput;

  TRes call({
    String? clientMutationId,
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
  });
}

class _CopyWithImpl$Input$ApproveDeploymentsInput<TRes>
    implements CopyWith$Input$ApproveDeploymentsInput<TRes> {
  _CopyWithImpl$Input$ApproveDeploymentsInput(
    this._instance,
    this._then,
  );

  final Input$ApproveDeploymentsInput _instance;

  final TRes Function(Input$ApproveDeploymentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? workflowRunId = _undefined,
    Object? environmentIds = _undefined,
    Object? comment = _undefined,
  }) =>
      _then(Input$ApproveDeploymentsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (workflowRunId != _undefined && workflowRunId != null)
          'workflowRunId': (workflowRunId as String),
        if (environmentIds != _undefined && environmentIds != null)
          'environmentIds': (environmentIds as List<String>),
        if (comment != _undefined) 'comment': (comment as String?),
      }));
}

class _CopyWithStubImpl$Input$ApproveDeploymentsInput<TRes>
    implements CopyWith$Input$ApproveDeploymentsInput<TRes> {
  _CopyWithStubImpl$Input$ApproveDeploymentsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
  }) =>
      _res;
}

class Input$ApproveVerifiableDomainInput {
  factory Input$ApproveVerifiableDomainInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$ApproveVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$ApproveVerifiableDomainInput._(this._$data);

  factory Input$ApproveVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$ApproveVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$ApproveVerifiableDomainInput<
          Input$ApproveVerifiableDomainInput>
      get copyWith => CopyWith$Input$ApproveVerifiableDomainInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ApproveVerifiableDomainInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  factory CopyWith$Input$ApproveVerifiableDomainInput(
    Input$ApproveVerifiableDomainInput instance,
    TRes Function(Input$ApproveVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$ApproveVerifiableDomainInput;

  factory CopyWith$Input$ApproveVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApproveVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$ApproveVerifiableDomainInput<TRes>
    implements CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$ApproveVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$ApproveVerifiableDomainInput _instance;

  final TRes Function(Input$ApproveVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$ApproveVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$ApproveVerifiableDomainInput<TRes>
    implements CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$ApproveVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$ArchiveProjectV2ItemInput {
  factory Input$ArchiveProjectV2ItemInput({
    String? clientMutationId,
    required String projectId,
    required String itemId,
  }) =>
      Input$ArchiveProjectV2ItemInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'itemId': itemId,
      });

  Input$ArchiveProjectV2ItemInput._(this._$data);

  factory Input$ArchiveProjectV2ItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    return Input$ArchiveProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get itemId => (_$data['itemId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    return result$data;
  }

  CopyWith$Input$ArchiveProjectV2ItemInput<Input$ArchiveProjectV2ItemInput>
      get copyWith => CopyWith$Input$ArchiveProjectV2ItemInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArchiveProjectV2ItemInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$itemId = itemId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$itemId,
    ]);
  }
}

abstract class CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  factory CopyWith$Input$ArchiveProjectV2ItemInput(
    Input$ArchiveProjectV2ItemInput instance,
    TRes Function(Input$ArchiveProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$ArchiveProjectV2ItemInput;

  factory CopyWith$Input$ArchiveProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
  });
}

class _CopyWithImpl$Input$ArchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$ArchiveProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$ArchiveProjectV2ItemInput _instance;

  final TRes Function(Input$ArchiveProjectV2ItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? itemId = _undefined,
  }) =>
      _then(Input$ArchiveProjectV2ItemInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
      }));
}

class _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
  }) =>
      _res;
}

class Input$ArchiveRepositoryInput {
  factory Input$ArchiveRepositoryInput({
    String? clientMutationId,
    required String repositoryId,
  }) =>
      Input$ArchiveRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
      });

  Input$ArchiveRepositoryInput._(this._$data);

  factory Input$ArchiveRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$ArchiveRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$ArchiveRepositoryInput<Input$ArchiveRepositoryInput>
      get copyWith => CopyWith$Input$ArchiveRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ArchiveRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$ArchiveRepositoryInput<TRes> {
  factory CopyWith$Input$ArchiveRepositoryInput(
    Input$ArchiveRepositoryInput instance,
    TRes Function(Input$ArchiveRepositoryInput) then,
  ) = _CopyWithImpl$Input$ArchiveRepositoryInput;

  factory CopyWith$Input$ArchiveRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArchiveRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$ArchiveRepositoryInput<TRes>
    implements CopyWith$Input$ArchiveRepositoryInput<TRes> {
  _CopyWithImpl$Input$ArchiveRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$ArchiveRepositoryInput _instance;

  final TRes Function(Input$ArchiveRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$ArchiveRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$ArchiveRepositoryInput<TRes>
    implements CopyWith$Input$ArchiveRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$ArchiveRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$AuditLogOrder {
  factory Input$AuditLogOrder({
    Enum$AuditLogOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$AuditLogOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$AuditLogOrder._(this._$data);

  factory Input$AuditLogOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$AuditLogOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$AuditLogOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$AuditLogOrderField? get field =>
      (_$data['field'] as Enum$AuditLogOrderField?);

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$AuditLogOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$AuditLogOrder<Input$AuditLogOrder> get copyWith =>
      CopyWith$Input$AuditLogOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$AuditLogOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$AuditLogOrder<TRes> {
  factory CopyWith$Input$AuditLogOrder(
    Input$AuditLogOrder instance,
    TRes Function(Input$AuditLogOrder) then,
  ) = _CopyWithImpl$Input$AuditLogOrder;

  factory CopyWith$Input$AuditLogOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$AuditLogOrder;

  TRes call({
    Enum$AuditLogOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$AuditLogOrder<TRes>
    implements CopyWith$Input$AuditLogOrder<TRes> {
  _CopyWithImpl$Input$AuditLogOrder(
    this._instance,
    this._then,
  );

  final Input$AuditLogOrder _instance;

  final TRes Function(Input$AuditLogOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$AuditLogOrder._({
        ..._instance._$data,
        if (field != _undefined) 'field': (field as Enum$AuditLogOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$AuditLogOrder<TRes>
    implements CopyWith$Input$AuditLogOrder<TRes> {
  _CopyWithStubImpl$Input$AuditLogOrder(this._res);

  TRes _res;

  call({
    Enum$AuditLogOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$BranchNamePatternParametersInput {
  factory Input$BranchNamePatternParametersInput({
    String? name,
    bool? negate,
    required String $operator,
    required String pattern,
  }) =>
      Input$BranchNamePatternParametersInput._({
        if (name != null) r'name': name,
        if (negate != null) r'negate': negate,
        r'operator': $operator,
        r'pattern': pattern,
      });

  Input$BranchNamePatternParametersInput._(this._$data);

  factory Input$BranchNamePatternParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('negate')) {
      final l$negate = data['negate'];
      result$data['negate'] = (l$negate as bool?);
    }
    final l$$operator = data['operator'];
    result$data['operator'] = (l$$operator as String);
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    return Input$BranchNamePatternParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  bool? get negate => (_$data['negate'] as bool?);

  String get $operator => (_$data['operator'] as String);

  String get pattern => (_$data['pattern'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('negate')) {
      final l$negate = negate;
      result$data['negate'] = l$negate;
    }
    final l$$operator = $operator;
    result$data['operator'] = l$$operator;
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    return result$data;
  }

  CopyWith$Input$BranchNamePatternParametersInput<
          Input$BranchNamePatternParametersInput>
      get copyWith => CopyWith$Input$BranchNamePatternParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$BranchNamePatternParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$negate = negate;
    final lOther$negate = other.negate;
    if (_$data.containsKey('negate') != other._$data.containsKey('negate')) {
      return false;
    }
    if (l$negate != lOther$negate) {
      return false;
    }
    final l$$operator = $operator;
    final lOther$$operator = other.$operator;
    if (l$$operator != lOther$$operator) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$negate = negate;
    final l$$operator = $operator;
    final l$pattern = pattern;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('negate') ? l$negate : const {},
      l$$operator,
      l$pattern,
    ]);
  }
}

abstract class CopyWith$Input$BranchNamePatternParametersInput<TRes> {
  factory CopyWith$Input$BranchNamePatternParametersInput(
    Input$BranchNamePatternParametersInput instance,
    TRes Function(Input$BranchNamePatternParametersInput) then,
  ) = _CopyWithImpl$Input$BranchNamePatternParametersInput;

  factory CopyWith$Input$BranchNamePatternParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$BranchNamePatternParametersInput;

  TRes call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  });
}

class _CopyWithImpl$Input$BranchNamePatternParametersInput<TRes>
    implements CopyWith$Input$BranchNamePatternParametersInput<TRes> {
  _CopyWithImpl$Input$BranchNamePatternParametersInput(
    this._instance,
    this._then,
  );

  final Input$BranchNamePatternParametersInput _instance;

  final TRes Function(Input$BranchNamePatternParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? negate = _undefined,
    Object? $operator = _undefined,
    Object? pattern = _undefined,
  }) =>
      _then(Input$BranchNamePatternParametersInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (negate != _undefined) 'negate': (negate as bool?),
        if ($operator != _undefined && $operator != null)
          'operator': ($operator as String),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
      }));
}

class _CopyWithStubImpl$Input$BranchNamePatternParametersInput<TRes>
    implements CopyWith$Input$BranchNamePatternParametersInput<TRes> {
  _CopyWithStubImpl$Input$BranchNamePatternParametersInput(this._res);

  TRes _res;

  call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  }) =>
      _res;
}

class Input$BulkSponsorship {
  factory Input$BulkSponsorship({
    String? sponsorableId,
    String? sponsorableLogin,
    required int amount,
  }) =>
      Input$BulkSponsorship._({
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        r'amount': amount,
      });

  Input$BulkSponsorship._(this._$data);

  factory Input$BulkSponsorship.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as int);
    return Input$BulkSponsorship._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get sponsorableId => (_$data['sponsorableId'] as String?);

  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);

  int get amount => (_$data['amount'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    final l$amount = amount;
    result$data['amount'] = l$amount;
    return result$data;
  }

  CopyWith$Input$BulkSponsorship<Input$BulkSponsorship> get copyWith =>
      CopyWith$Input$BulkSponsorship(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$BulkSponsorship || runtimeType != other.runtimeType) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$amount = amount;
    return Object.hashAll([
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      l$amount,
    ]);
  }
}

abstract class CopyWith$Input$BulkSponsorship<TRes> {
  factory CopyWith$Input$BulkSponsorship(
    Input$BulkSponsorship instance,
    TRes Function(Input$BulkSponsorship) then,
  ) = _CopyWithImpl$Input$BulkSponsorship;

  factory CopyWith$Input$BulkSponsorship.stub(TRes res) =
      _CopyWithStubImpl$Input$BulkSponsorship;

  TRes call({
    String? sponsorableId,
    String? sponsorableLogin,
    int? amount,
  });
}

class _CopyWithImpl$Input$BulkSponsorship<TRes>
    implements CopyWith$Input$BulkSponsorship<TRes> {
  _CopyWithImpl$Input$BulkSponsorship(
    this._instance,
    this._then,
  );

  final Input$BulkSponsorship _instance;

  final TRes Function(Input$BulkSponsorship) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? amount = _undefined,
  }) =>
      _then(Input$BulkSponsorship._({
        ..._instance._$data,
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (amount != _undefined && amount != null) 'amount': (amount as int),
      }));
}

class _CopyWithStubImpl$Input$BulkSponsorship<TRes>
    implements CopyWith$Input$BulkSponsorship<TRes> {
  _CopyWithStubImpl$Input$BulkSponsorship(this._res);

  TRes _res;

  call({
    String? sponsorableId,
    String? sponsorableLogin,
    int? amount,
  }) =>
      _res;
}

class Input$CancelEnterpriseAdminInvitationInput {
  factory Input$CancelEnterpriseAdminInvitationInput({
    String? clientMutationId,
    required String invitationId,
  }) =>
      Input$CancelEnterpriseAdminInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'invitationId': invitationId,
      });

  Input$CancelEnterpriseAdminInvitationInput._(this._$data);

  factory Input$CancelEnterpriseAdminInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    return Input$CancelEnterpriseAdminInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get invitationId => (_$data['invitationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    return result$data;
  }

  CopyWith$Input$CancelEnterpriseAdminInvitationInput<
          Input$CancelEnterpriseAdminInvitationInput>
      get copyWith => CopyWith$Input$CancelEnterpriseAdminInvitationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CancelEnterpriseAdminInvitationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$invitationId = invitationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$invitationId,
    ]);
  }
}

abstract class CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  factory CopyWith$Input$CancelEnterpriseAdminInvitationInput(
    Input$CancelEnterpriseAdminInvitationInput instance,
    TRes Function(Input$CancelEnterpriseAdminInvitationInput) then,
  ) = _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput;

  factory CopyWith$Input$CancelEnterpriseAdminInvitationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput;

  TRes call({
    String? clientMutationId,
    String? invitationId,
  });
}

class _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput(
    this._instance,
    this._then,
  );

  final Input$CancelEnterpriseAdminInvitationInput _instance;

  final TRes Function(Input$CancelEnterpriseAdminInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? invitationId = _undefined,
  }) =>
      _then(Input$CancelEnterpriseAdminInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
      }));
}

class _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? invitationId,
  }) =>
      _res;
}

class Input$CancelEnterpriseMemberInvitationInput {
  factory Input$CancelEnterpriseMemberInvitationInput({
    String? clientMutationId,
    required String invitationId,
  }) =>
      Input$CancelEnterpriseMemberInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'invitationId': invitationId,
      });

  Input$CancelEnterpriseMemberInvitationInput._(this._$data);

  factory Input$CancelEnterpriseMemberInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    return Input$CancelEnterpriseMemberInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get invitationId => (_$data['invitationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    return result$data;
  }

  CopyWith$Input$CancelEnterpriseMemberInvitationInput<
          Input$CancelEnterpriseMemberInvitationInput>
      get copyWith => CopyWith$Input$CancelEnterpriseMemberInvitationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CancelEnterpriseMemberInvitationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$invitationId = invitationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$invitationId,
    ]);
  }
}

abstract class CopyWith$Input$CancelEnterpriseMemberInvitationInput<TRes> {
  factory CopyWith$Input$CancelEnterpriseMemberInvitationInput(
    Input$CancelEnterpriseMemberInvitationInput instance,
    TRes Function(Input$CancelEnterpriseMemberInvitationInput) then,
  ) = _CopyWithImpl$Input$CancelEnterpriseMemberInvitationInput;

  factory CopyWith$Input$CancelEnterpriseMemberInvitationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelEnterpriseMemberInvitationInput;

  TRes call({
    String? clientMutationId,
    String? invitationId,
  });
}

class _CopyWithImpl$Input$CancelEnterpriseMemberInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseMemberInvitationInput<TRes> {
  _CopyWithImpl$Input$CancelEnterpriseMemberInvitationInput(
    this._instance,
    this._then,
  );

  final Input$CancelEnterpriseMemberInvitationInput _instance;

  final TRes Function(Input$CancelEnterpriseMemberInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? invitationId = _undefined,
  }) =>
      _then(Input$CancelEnterpriseMemberInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
      }));
}

class _CopyWithStubImpl$Input$CancelEnterpriseMemberInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseMemberInvitationInput<TRes> {
  _CopyWithStubImpl$Input$CancelEnterpriseMemberInvitationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? invitationId,
  }) =>
      _res;
}

class Input$CancelSponsorshipInput {
  factory Input$CancelSponsorshipInput({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  }) =>
      Input$CancelSponsorshipInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
      });

  Input$CancelSponsorshipInput._(this._$data);

  factory Input$CancelSponsorshipInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    return Input$CancelSponsorshipInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get sponsorId => (_$data['sponsorId'] as String?);

  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);

  String? get sponsorableId => (_$data['sponsorableId'] as String?);

  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    return result$data;
  }

  CopyWith$Input$CancelSponsorshipInput<Input$CancelSponsorshipInput>
      get copyWith => CopyWith$Input$CancelSponsorshipInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CancelSponsorshipInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
    ]);
  }
}

abstract class CopyWith$Input$CancelSponsorshipInput<TRes> {
  factory CopyWith$Input$CancelSponsorshipInput(
    Input$CancelSponsorshipInput instance,
    TRes Function(Input$CancelSponsorshipInput) then,
  ) = _CopyWithImpl$Input$CancelSponsorshipInput;

  factory CopyWith$Input$CancelSponsorshipInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelSponsorshipInput;

  TRes call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  });
}

class _CopyWithImpl$Input$CancelSponsorshipInput<TRes>
    implements CopyWith$Input$CancelSponsorshipInput<TRes> {
  _CopyWithImpl$Input$CancelSponsorshipInput(
    this._instance,
    this._then,
  );

  final Input$CancelSponsorshipInput _instance;

  final TRes Function(Input$CancelSponsorshipInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
  }) =>
      _then(Input$CancelSponsorshipInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
      }));
}

class _CopyWithStubImpl$Input$CancelSponsorshipInput<TRes>
    implements CopyWith$Input$CancelSponsorshipInput<TRes> {
  _CopyWithStubImpl$Input$CancelSponsorshipInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  }) =>
      _res;
}

class Input$ChangeUserStatusInput {
  factory Input$ChangeUserStatusInput({
    String? clientMutationId,
    String? emoji,
    String? message,
    String? organizationId,
    bool? limitedAvailability,
    String? expiresAt,
  }) =>
      Input$ChangeUserStatusInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (emoji != null) r'emoji': emoji,
        if (message != null) r'message': message,
        if (organizationId != null) r'organizationId': organizationId,
        if (limitedAvailability != null)
          r'limitedAvailability': limitedAvailability,
        if (expiresAt != null) r'expiresAt': expiresAt,
      });

  Input$ChangeUserStatusInput._(this._$data);

  factory Input$ChangeUserStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('emoji')) {
      final l$emoji = data['emoji'];
      result$data['emoji'] = (l$emoji as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('organizationId')) {
      final l$organizationId = data['organizationId'];
      result$data['organizationId'] = (l$organizationId as String?);
    }
    if (data.containsKey('limitedAvailability')) {
      final l$limitedAvailability = data['limitedAvailability'];
      result$data['limitedAvailability'] = (l$limitedAvailability as bool?);
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] = (l$expiresAt as String?);
    }
    return Input$ChangeUserStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get emoji => (_$data['emoji'] as String?);

  String? get message => (_$data['message'] as String?);

  String? get organizationId => (_$data['organizationId'] as String?);

  bool? get limitedAvailability => (_$data['limitedAvailability'] as bool?);

  String? get expiresAt => (_$data['expiresAt'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('emoji')) {
      final l$emoji = emoji;
      result$data['emoji'] = l$emoji;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('organizationId')) {
      final l$organizationId = organizationId;
      result$data['organizationId'] = l$organizationId;
    }
    if (_$data.containsKey('limitedAvailability')) {
      final l$limitedAvailability = limitedAvailability;
      result$data['limitedAvailability'] = l$limitedAvailability;
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] = l$expiresAt;
    }
    return result$data;
  }

  CopyWith$Input$ChangeUserStatusInput<Input$ChangeUserStatusInput>
      get copyWith => CopyWith$Input$ChangeUserStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ChangeUserStatusInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$emoji = emoji;
    final lOther$emoji = other.emoji;
    if (_$data.containsKey('emoji') != other._$data.containsKey('emoji')) {
      return false;
    }
    if (l$emoji != lOther$emoji) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (_$data.containsKey('organizationId') !=
        other._$data.containsKey('organizationId')) {
      return false;
    }
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$limitedAvailability = limitedAvailability;
    final lOther$limitedAvailability = other.limitedAvailability;
    if (_$data.containsKey('limitedAvailability') !=
        other._$data.containsKey('limitedAvailability')) {
      return false;
    }
    if (l$limitedAvailability != lOther$limitedAvailability) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$emoji = emoji;
    final l$message = message;
    final l$organizationId = organizationId;
    final l$limitedAvailability = limitedAvailability;
    final l$expiresAt = expiresAt;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('emoji') ? l$emoji : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('organizationId') ? l$organizationId : const {},
      _$data.containsKey('limitedAvailability')
          ? l$limitedAvailability
          : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeUserStatusInput<TRes> {
  factory CopyWith$Input$ChangeUserStatusInput(
    Input$ChangeUserStatusInput instance,
    TRes Function(Input$ChangeUserStatusInput) then,
  ) = _CopyWithImpl$Input$ChangeUserStatusInput;

  factory CopyWith$Input$ChangeUserStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeUserStatusInput;

  TRes call({
    String? clientMutationId,
    String? emoji,
    String? message,
    String? organizationId,
    bool? limitedAvailability,
    String? expiresAt,
  });
}

class _CopyWithImpl$Input$ChangeUserStatusInput<TRes>
    implements CopyWith$Input$ChangeUserStatusInput<TRes> {
  _CopyWithImpl$Input$ChangeUserStatusInput(
    this._instance,
    this._then,
  );

  final Input$ChangeUserStatusInput _instance;

  final TRes Function(Input$ChangeUserStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? emoji = _undefined,
    Object? message = _undefined,
    Object? organizationId = _undefined,
    Object? limitedAvailability = _undefined,
    Object? expiresAt = _undefined,
  }) =>
      _then(Input$ChangeUserStatusInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (emoji != _undefined) 'emoji': (emoji as String?),
        if (message != _undefined) 'message': (message as String?),
        if (organizationId != _undefined)
          'organizationId': (organizationId as String?),
        if (limitedAvailability != _undefined)
          'limitedAvailability': (limitedAvailability as bool?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as String?),
      }));
}

class _CopyWithStubImpl$Input$ChangeUserStatusInput<TRes>
    implements CopyWith$Input$ChangeUserStatusInput<TRes> {
  _CopyWithStubImpl$Input$ChangeUserStatusInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? emoji,
    String? message,
    String? organizationId,
    bool? limitedAvailability,
    String? expiresAt,
  }) =>
      _res;
}

class Input$CheckAnnotationData {
  factory Input$CheckAnnotationData({
    required String path,
    required Input$CheckAnnotationRange location,
    required Enum$CheckAnnotationLevel annotationLevel,
    required String message,
    String? title,
    String? rawDetails,
  }) =>
      Input$CheckAnnotationData._({
        r'path': path,
        r'location': location,
        r'annotationLevel': annotationLevel,
        r'message': message,
        if (title != null) r'title': title,
        if (rawDetails != null) r'rawDetails': rawDetails,
      });

  Input$CheckAnnotationData._(this._$data);

  factory Input$CheckAnnotationData.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$location = data['location'];
    result$data['location'] = Input$CheckAnnotationRange.fromJson(
        (l$location as Map<String, dynamic>));
    final l$annotationLevel = data['annotationLevel'];
    result$data['annotationLevel'] =
        fromJson$Enum$CheckAnnotationLevel((l$annotationLevel as String));
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('rawDetails')) {
      final l$rawDetails = data['rawDetails'];
      result$data['rawDetails'] = (l$rawDetails as String?);
    }
    return Input$CheckAnnotationData._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);

  Input$CheckAnnotationRange get location =>
      (_$data['location'] as Input$CheckAnnotationRange);

  Enum$CheckAnnotationLevel get annotationLevel =>
      (_$data['annotationLevel'] as Enum$CheckAnnotationLevel);

  String get message => (_$data['message'] as String);

  String? get title => (_$data['title'] as String?);

  String? get rawDetails => (_$data['rawDetails'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$location = location;
    result$data['location'] = l$location.toJson();
    final l$annotationLevel = annotationLevel;
    result$data['annotationLevel'] =
        toJson$Enum$CheckAnnotationLevel(l$annotationLevel);
    final l$message = message;
    result$data['message'] = l$message;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('rawDetails')) {
      final l$rawDetails = rawDetails;
      result$data['rawDetails'] = l$rawDetails;
    }
    return result$data;
  }

  CopyWith$Input$CheckAnnotationData<Input$CheckAnnotationData> get copyWith =>
      CopyWith$Input$CheckAnnotationData(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckAnnotationData ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (l$location != lOther$location) {
      return false;
    }
    final l$annotationLevel = annotationLevel;
    final lOther$annotationLevel = other.annotationLevel;
    if (l$annotationLevel != lOther$annotationLevel) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$rawDetails = rawDetails;
    final lOther$rawDetails = other.rawDetails;
    if (_$data.containsKey('rawDetails') !=
        other._$data.containsKey('rawDetails')) {
      return false;
    }
    if (l$rawDetails != lOther$rawDetails) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$location = location;
    final l$annotationLevel = annotationLevel;
    final l$message = message;
    final l$title = title;
    final l$rawDetails = rawDetails;
    return Object.hashAll([
      l$path,
      l$location,
      l$annotationLevel,
      l$message,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('rawDetails') ? l$rawDetails : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckAnnotationData<TRes> {
  factory CopyWith$Input$CheckAnnotationData(
    Input$CheckAnnotationData instance,
    TRes Function(Input$CheckAnnotationData) then,
  ) = _CopyWithImpl$Input$CheckAnnotationData;

  factory CopyWith$Input$CheckAnnotationData.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckAnnotationData;

  TRes call({
    String? path,
    Input$CheckAnnotationRange? location,
    Enum$CheckAnnotationLevel? annotationLevel,
    String? message,
    String? title,
    String? rawDetails,
  });
  CopyWith$Input$CheckAnnotationRange<TRes> get location;
}

class _CopyWithImpl$Input$CheckAnnotationData<TRes>
    implements CopyWith$Input$CheckAnnotationData<TRes> {
  _CopyWithImpl$Input$CheckAnnotationData(
    this._instance,
    this._then,
  );

  final Input$CheckAnnotationData _instance;

  final TRes Function(Input$CheckAnnotationData) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? location = _undefined,
    Object? annotationLevel = _undefined,
    Object? message = _undefined,
    Object? title = _undefined,
    Object? rawDetails = _undefined,
  }) =>
      _then(Input$CheckAnnotationData._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (location != _undefined && location != null)
          'location': (location as Input$CheckAnnotationRange),
        if (annotationLevel != _undefined && annotationLevel != null)
          'annotationLevel': (annotationLevel as Enum$CheckAnnotationLevel),
        if (message != _undefined && message != null)
          'message': (message as String),
        if (title != _undefined) 'title': (title as String?),
        if (rawDetails != _undefined) 'rawDetails': (rawDetails as String?),
      }));

  CopyWith$Input$CheckAnnotationRange<TRes> get location {
    final local$location = _instance.location;
    return CopyWith$Input$CheckAnnotationRange(
        local$location, (e) => call(location: e));
  }
}

class _CopyWithStubImpl$Input$CheckAnnotationData<TRes>
    implements CopyWith$Input$CheckAnnotationData<TRes> {
  _CopyWithStubImpl$Input$CheckAnnotationData(this._res);

  TRes _res;

  call({
    String? path,
    Input$CheckAnnotationRange? location,
    Enum$CheckAnnotationLevel? annotationLevel,
    String? message,
    String? title,
    String? rawDetails,
  }) =>
      _res;

  CopyWith$Input$CheckAnnotationRange<TRes> get location =>
      CopyWith$Input$CheckAnnotationRange.stub(_res);
}

class Input$CheckAnnotationRange {
  factory Input$CheckAnnotationRange({
    required int startLine,
    int? startColumn,
    required int endLine,
    int? endColumn,
  }) =>
      Input$CheckAnnotationRange._({
        r'startLine': startLine,
        if (startColumn != null) r'startColumn': startColumn,
        r'endLine': endLine,
        if (endColumn != null) r'endColumn': endColumn,
      });

  Input$CheckAnnotationRange._(this._$data);

  factory Input$CheckAnnotationRange.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$startLine = data['startLine'];
    result$data['startLine'] = (l$startLine as int);
    if (data.containsKey('startColumn')) {
      final l$startColumn = data['startColumn'];
      result$data['startColumn'] = (l$startColumn as int?);
    }
    final l$endLine = data['endLine'];
    result$data['endLine'] = (l$endLine as int);
    if (data.containsKey('endColumn')) {
      final l$endColumn = data['endColumn'];
      result$data['endColumn'] = (l$endColumn as int?);
    }
    return Input$CheckAnnotationRange._(result$data);
  }

  Map<String, dynamic> _$data;

  int get startLine => (_$data['startLine'] as int);

  int? get startColumn => (_$data['startColumn'] as int?);

  int get endLine => (_$data['endLine'] as int);

  int? get endColumn => (_$data['endColumn'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$startLine = startLine;
    result$data['startLine'] = l$startLine;
    if (_$data.containsKey('startColumn')) {
      final l$startColumn = startColumn;
      result$data['startColumn'] = l$startColumn;
    }
    final l$endLine = endLine;
    result$data['endLine'] = l$endLine;
    if (_$data.containsKey('endColumn')) {
      final l$endColumn = endColumn;
      result$data['endColumn'] = l$endColumn;
    }
    return result$data;
  }

  CopyWith$Input$CheckAnnotationRange<Input$CheckAnnotationRange>
      get copyWith => CopyWith$Input$CheckAnnotationRange(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckAnnotationRange ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startColumn = startColumn;
    final lOther$startColumn = other.startColumn;
    if (_$data.containsKey('startColumn') !=
        other._$data.containsKey('startColumn')) {
      return false;
    }
    if (l$startColumn != lOther$startColumn) {
      return false;
    }
    final l$endLine = endLine;
    final lOther$endLine = other.endLine;
    if (l$endLine != lOther$endLine) {
      return false;
    }
    final l$endColumn = endColumn;
    final lOther$endColumn = other.endColumn;
    if (_$data.containsKey('endColumn') !=
        other._$data.containsKey('endColumn')) {
      return false;
    }
    if (l$endColumn != lOther$endColumn) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$startLine = startLine;
    final l$startColumn = startColumn;
    final l$endLine = endLine;
    final l$endColumn = endColumn;
    return Object.hashAll([
      l$startLine,
      _$data.containsKey('startColumn') ? l$startColumn : const {},
      l$endLine,
      _$data.containsKey('endColumn') ? l$endColumn : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckAnnotationRange<TRes> {
  factory CopyWith$Input$CheckAnnotationRange(
    Input$CheckAnnotationRange instance,
    TRes Function(Input$CheckAnnotationRange) then,
  ) = _CopyWithImpl$Input$CheckAnnotationRange;

  factory CopyWith$Input$CheckAnnotationRange.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckAnnotationRange;

  TRes call({
    int? startLine,
    int? startColumn,
    int? endLine,
    int? endColumn,
  });
}

class _CopyWithImpl$Input$CheckAnnotationRange<TRes>
    implements CopyWith$Input$CheckAnnotationRange<TRes> {
  _CopyWithImpl$Input$CheckAnnotationRange(
    this._instance,
    this._then,
  );

  final Input$CheckAnnotationRange _instance;

  final TRes Function(Input$CheckAnnotationRange) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? startLine = _undefined,
    Object? startColumn = _undefined,
    Object? endLine = _undefined,
    Object? endColumn = _undefined,
  }) =>
      _then(Input$CheckAnnotationRange._({
        ..._instance._$data,
        if (startLine != _undefined && startLine != null)
          'startLine': (startLine as int),
        if (startColumn != _undefined) 'startColumn': (startColumn as int?),
        if (endLine != _undefined && endLine != null)
          'endLine': (endLine as int),
        if (endColumn != _undefined) 'endColumn': (endColumn as int?),
      }));
}

class _CopyWithStubImpl$Input$CheckAnnotationRange<TRes>
    implements CopyWith$Input$CheckAnnotationRange<TRes> {
  _CopyWithStubImpl$Input$CheckAnnotationRange(this._res);

  TRes _res;

  call({
    int? startLine,
    int? startColumn,
    int? endLine,
    int? endColumn,
  }) =>
      _res;
}

class Input$CheckRunAction {
  factory Input$CheckRunAction({
    required String label,
    required String description,
    required String identifier,
  }) =>
      Input$CheckRunAction._({
        r'label': label,
        r'description': description,
        r'identifier': identifier,
      });

  Input$CheckRunAction._(this._$data);

  factory Input$CheckRunAction.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$label = data['label'];
    result$data['label'] = (l$label as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$identifier = data['identifier'];
    result$data['identifier'] = (l$identifier as String);
    return Input$CheckRunAction._(result$data);
  }

  Map<String, dynamic> _$data;

  String get label => (_$data['label'] as String);

  String get description => (_$data['description'] as String);

  String get identifier => (_$data['identifier'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$label = label;
    result$data['label'] = l$label;
    final l$description = description;
    result$data['description'] = l$description;
    final l$identifier = identifier;
    result$data['identifier'] = l$identifier;
    return result$data;
  }

  CopyWith$Input$CheckRunAction<Input$CheckRunAction> get copyWith =>
      CopyWith$Input$CheckRunAction(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckRunAction || runtimeType != other.runtimeType) {
      return false;
    }
    final l$label = label;
    final lOther$label = other.label;
    if (l$label != lOther$label) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$identifier = identifier;
    final lOther$identifier = other.identifier;
    if (l$identifier != lOther$identifier) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$label = label;
    final l$description = description;
    final l$identifier = identifier;
    return Object.hashAll([
      l$label,
      l$description,
      l$identifier,
    ]);
  }
}

abstract class CopyWith$Input$CheckRunAction<TRes> {
  factory CopyWith$Input$CheckRunAction(
    Input$CheckRunAction instance,
    TRes Function(Input$CheckRunAction) then,
  ) = _CopyWithImpl$Input$CheckRunAction;

  factory CopyWith$Input$CheckRunAction.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunAction;

  TRes call({
    String? label,
    String? description,
    String? identifier,
  });
}

class _CopyWithImpl$Input$CheckRunAction<TRes>
    implements CopyWith$Input$CheckRunAction<TRes> {
  _CopyWithImpl$Input$CheckRunAction(
    this._instance,
    this._then,
  );

  final Input$CheckRunAction _instance;

  final TRes Function(Input$CheckRunAction) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? label = _undefined,
    Object? description = _undefined,
    Object? identifier = _undefined,
  }) =>
      _then(Input$CheckRunAction._({
        ..._instance._$data,
        if (label != _undefined && label != null) 'label': (label as String),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (identifier != _undefined && identifier != null)
          'identifier': (identifier as String),
      }));
}

class _CopyWithStubImpl$Input$CheckRunAction<TRes>
    implements CopyWith$Input$CheckRunAction<TRes> {
  _CopyWithStubImpl$Input$CheckRunAction(this._res);

  TRes _res;

  call({
    String? label,
    String? description,
    String? identifier,
  }) =>
      _res;
}

class Input$CheckRunFilter {
  factory Input$CheckRunFilter({
    Enum$CheckRunType? checkType,
    int? appId,
    String? checkName,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
    List<Enum$CheckConclusionState>? conclusions,
  }) =>
      Input$CheckRunFilter._({
        if (checkType != null) r'checkType': checkType,
        if (appId != null) r'appId': appId,
        if (checkName != null) r'checkName': checkName,
        if (status != null) r'status': status,
        if (statuses != null) r'statuses': statuses,
        if (conclusions != null) r'conclusions': conclusions,
      });

  Input$CheckRunFilter._(this._$data);

  factory Input$CheckRunFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('checkType')) {
      final l$checkType = data['checkType'];
      result$data['checkType'] = l$checkType == null
          ? null
          : fromJson$Enum$CheckRunType((l$checkType as String));
    }
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as int?);
    }
    if (data.containsKey('checkName')) {
      final l$checkName = data['checkName'];
      result$data['checkName'] = (l$checkName as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$CheckStatusState((l$status as String));
    }
    if (data.containsKey('statuses')) {
      final l$statuses = data['statuses'];
      result$data['statuses'] = (l$statuses as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckStatusState((e as String)))
          .toList();
    }
    if (data.containsKey('conclusions')) {
      final l$conclusions = data['conclusions'];
      result$data['conclusions'] = (l$conclusions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckConclusionState((e as String)))
          .toList();
    }
    return Input$CheckRunFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CheckRunType? get checkType =>
      (_$data['checkType'] as Enum$CheckRunType?);

  int? get appId => (_$data['appId'] as int?);

  String? get checkName => (_$data['checkName'] as String?);

  Enum$CheckStatusState? get status =>
      (_$data['status'] as Enum$CheckStatusState?);

  List<Enum$CheckStatusState>? get statuses =>
      (_$data['statuses'] as List<Enum$CheckStatusState>?);

  List<Enum$CheckConclusionState>? get conclusions =>
      (_$data['conclusions'] as List<Enum$CheckConclusionState>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('checkType')) {
      final l$checkType = checkType;
      result$data['checkType'] =
          l$checkType == null ? null : toJson$Enum$CheckRunType(l$checkType);
    }
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    if (_$data.containsKey('checkName')) {
      final l$checkName = checkName;
      result$data['checkName'] = l$checkName;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$CheckStatusState(l$status);
    }
    if (_$data.containsKey('statuses')) {
      final l$statuses = statuses;
      result$data['statuses'] =
          l$statuses?.map((e) => toJson$Enum$CheckStatusState(e)).toList();
    }
    if (_$data.containsKey('conclusions')) {
      final l$conclusions = conclusions;
      result$data['conclusions'] = l$conclusions
          ?.map((e) => toJson$Enum$CheckConclusionState(e))
          .toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckRunFilter<Input$CheckRunFilter> get copyWith =>
      CopyWith$Input$CheckRunFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckRunFilter || runtimeType != other.runtimeType) {
      return false;
    }
    final l$checkType = checkType;
    final lOther$checkType = other.checkType;
    if (_$data.containsKey('checkType') !=
        other._$data.containsKey('checkType')) {
      return false;
    }
    if (l$checkType != lOther$checkType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$checkName = checkName;
    final lOther$checkName = other.checkName;
    if (_$data.containsKey('checkName') !=
        other._$data.containsKey('checkName')) {
      return false;
    }
    if (l$checkName != lOther$checkName) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$statuses = statuses;
    final lOther$statuses = other.statuses;
    if (_$data.containsKey('statuses') !=
        other._$data.containsKey('statuses')) {
      return false;
    }
    if (l$statuses != null && lOther$statuses != null) {
      if (l$statuses.length != lOther$statuses.length) {
        return false;
      }
      for (int i = 0; i < l$statuses.length; i++) {
        final l$statuses$entry = l$statuses[i];
        final lOther$statuses$entry = lOther$statuses[i];
        if (l$statuses$entry != lOther$statuses$entry) {
          return false;
        }
      }
    } else if (l$statuses != lOther$statuses) {
      return false;
    }
    final l$conclusions = conclusions;
    final lOther$conclusions = other.conclusions;
    if (_$data.containsKey('conclusions') !=
        other._$data.containsKey('conclusions')) {
      return false;
    }
    if (l$conclusions != null && lOther$conclusions != null) {
      if (l$conclusions.length != lOther$conclusions.length) {
        return false;
      }
      for (int i = 0; i < l$conclusions.length; i++) {
        final l$conclusions$entry = l$conclusions[i];
        final lOther$conclusions$entry = lOther$conclusions[i];
        if (l$conclusions$entry != lOther$conclusions$entry) {
          return false;
        }
      }
    } else if (l$conclusions != lOther$conclusions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$checkType = checkType;
    final l$appId = appId;
    final l$checkName = checkName;
    final l$status = status;
    final l$statuses = statuses;
    final l$conclusions = conclusions;
    return Object.hashAll([
      _$data.containsKey('checkType') ? l$checkType : const {},
      _$data.containsKey('appId') ? l$appId : const {},
      _$data.containsKey('checkName') ? l$checkName : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('statuses')
          ? l$statuses == null
              ? null
              : Object.hashAll(l$statuses.map((v) => v))
          : const {},
      _$data.containsKey('conclusions')
          ? l$conclusions == null
              ? null
              : Object.hashAll(l$conclusions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckRunFilter<TRes> {
  factory CopyWith$Input$CheckRunFilter(
    Input$CheckRunFilter instance,
    TRes Function(Input$CheckRunFilter) then,
  ) = _CopyWithImpl$Input$CheckRunFilter;

  factory CopyWith$Input$CheckRunFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunFilter;

  TRes call({
    Enum$CheckRunType? checkType,
    int? appId,
    String? checkName,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
    List<Enum$CheckConclusionState>? conclusions,
  });
}

class _CopyWithImpl$Input$CheckRunFilter<TRes>
    implements CopyWith$Input$CheckRunFilter<TRes> {
  _CopyWithImpl$Input$CheckRunFilter(
    this._instance,
    this._then,
  );

  final Input$CheckRunFilter _instance;

  final TRes Function(Input$CheckRunFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? checkType = _undefined,
    Object? appId = _undefined,
    Object? checkName = _undefined,
    Object? status = _undefined,
    Object? statuses = _undefined,
    Object? conclusions = _undefined,
  }) =>
      _then(Input$CheckRunFilter._({
        ..._instance._$data,
        if (checkType != _undefined)
          'checkType': (checkType as Enum$CheckRunType?),
        if (appId != _undefined) 'appId': (appId as int?),
        if (checkName != _undefined) 'checkName': (checkName as String?),
        if (status != _undefined) 'status': (status as Enum$CheckStatusState?),
        if (statuses != _undefined)
          'statuses': (statuses as List<Enum$CheckStatusState>?),
        if (conclusions != _undefined)
          'conclusions': (conclusions as List<Enum$CheckConclusionState>?),
      }));
}

class _CopyWithStubImpl$Input$CheckRunFilter<TRes>
    implements CopyWith$Input$CheckRunFilter<TRes> {
  _CopyWithStubImpl$Input$CheckRunFilter(this._res);

  TRes _res;

  call({
    Enum$CheckRunType? checkType,
    int? appId,
    String? checkName,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
    List<Enum$CheckConclusionState>? conclusions,
  }) =>
      _res;
}

class Input$CheckRunOutput {
  factory Input$CheckRunOutput({
    required String title,
    required String summary,
    String? text,
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
  }) =>
      Input$CheckRunOutput._({
        r'title': title,
        r'summary': summary,
        if (text != null) r'text': text,
        if (annotations != null) r'annotations': annotations,
        if (images != null) r'images': images,
      });

  Input$CheckRunOutput._(this._$data);

  factory Input$CheckRunOutput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$summary = data['summary'];
    result$data['summary'] = (l$summary as String);
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = (l$text as String?);
    }
    if (data.containsKey('annotations')) {
      final l$annotations = data['annotations'];
      result$data['annotations'] = (l$annotations as List<dynamic>?)
          ?.map((e) =>
              Input$CheckAnnotationData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('images')) {
      final l$images = data['images'];
      result$data['images'] = (l$images as List<dynamic>?)
          ?.map((e) =>
              Input$CheckRunOutputImage.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CheckRunOutput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get title => (_$data['title'] as String);

  String get summary => (_$data['summary'] as String);

  String? get text => (_$data['text'] as String?);

  List<Input$CheckAnnotationData>? get annotations =>
      (_$data['annotations'] as List<Input$CheckAnnotationData>?);

  List<Input$CheckRunOutputImage>? get images =>
      (_$data['images'] as List<Input$CheckRunOutputImage>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$title = title;
    result$data['title'] = l$title;
    final l$summary = summary;
    result$data['summary'] = l$summary;
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text;
    }
    if (_$data.containsKey('annotations')) {
      final l$annotations = annotations;
      result$data['annotations'] =
          l$annotations?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('images')) {
      final l$images = images;
      result$data['images'] = l$images?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckRunOutput<Input$CheckRunOutput> get copyWith =>
      CopyWith$Input$CheckRunOutput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckRunOutput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$annotations = annotations;
    final lOther$annotations = other.annotations;
    if (_$data.containsKey('annotations') !=
        other._$data.containsKey('annotations')) {
      return false;
    }
    if (l$annotations != null && lOther$annotations != null) {
      if (l$annotations.length != lOther$annotations.length) {
        return false;
      }
      for (int i = 0; i < l$annotations.length; i++) {
        final l$annotations$entry = l$annotations[i];
        final lOther$annotations$entry = lOther$annotations[i];
        if (l$annotations$entry != lOther$annotations$entry) {
          return false;
        }
      }
    } else if (l$annotations != lOther$annotations) {
      return false;
    }
    final l$images = images;
    final lOther$images = other.images;
    if (_$data.containsKey('images') != other._$data.containsKey('images')) {
      return false;
    }
    if (l$images != null && lOther$images != null) {
      if (l$images.length != lOther$images.length) {
        return false;
      }
      for (int i = 0; i < l$images.length; i++) {
        final l$images$entry = l$images[i];
        final lOther$images$entry = lOther$images[i];
        if (l$images$entry != lOther$images$entry) {
          return false;
        }
      }
    } else if (l$images != lOther$images) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$title = title;
    final l$summary = summary;
    final l$text = text;
    final l$annotations = annotations;
    final l$images = images;
    return Object.hashAll([
      l$title,
      l$summary,
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('annotations')
          ? l$annotations == null
              ? null
              : Object.hashAll(l$annotations.map((v) => v))
          : const {},
      _$data.containsKey('images')
          ? l$images == null
              ? null
              : Object.hashAll(l$images.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckRunOutput<TRes> {
  factory CopyWith$Input$CheckRunOutput(
    Input$CheckRunOutput instance,
    TRes Function(Input$CheckRunOutput) then,
  ) = _CopyWithImpl$Input$CheckRunOutput;

  factory CopyWith$Input$CheckRunOutput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunOutput;

  TRes call({
    String? title,
    String? summary,
    String? text,
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
  });
  TRes annotations(
      Iterable<Input$CheckAnnotationData>? Function(
              Iterable<
                  CopyWith$Input$CheckAnnotationData<
                      Input$CheckAnnotationData>>?)
          _fn);
  TRes images(
      Iterable<Input$CheckRunOutputImage>? Function(
              Iterable<
                  CopyWith$Input$CheckRunOutputImage<
                      Input$CheckRunOutputImage>>?)
          _fn);
}

class _CopyWithImpl$Input$CheckRunOutput<TRes>
    implements CopyWith$Input$CheckRunOutput<TRes> {
  _CopyWithImpl$Input$CheckRunOutput(
    this._instance,
    this._then,
  );

  final Input$CheckRunOutput _instance;

  final TRes Function(Input$CheckRunOutput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? title = _undefined,
    Object? summary = _undefined,
    Object? text = _undefined,
    Object? annotations = _undefined,
    Object? images = _undefined,
  }) =>
      _then(Input$CheckRunOutput._({
        ..._instance._$data,
        if (title != _undefined && title != null) 'title': (title as String),
        if (summary != _undefined && summary != null)
          'summary': (summary as String),
        if (text != _undefined) 'text': (text as String?),
        if (annotations != _undefined)
          'annotations': (annotations as List<Input$CheckAnnotationData>?),
        if (images != _undefined)
          'images': (images as List<Input$CheckRunOutputImage>?),
      }));

  TRes annotations(
          Iterable<Input$CheckAnnotationData>? Function(
                  Iterable<
                      CopyWith$Input$CheckAnnotationData<
                          Input$CheckAnnotationData>>?)
              _fn) =>
      call(
          annotations: _fn(_instance.annotations
              ?.map((e) => CopyWith$Input$CheckAnnotationData(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes images(
          Iterable<Input$CheckRunOutputImage>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunOutputImage<
                          Input$CheckRunOutputImage>>?)
              _fn) =>
      call(
          images: _fn(
              _instance.images?.map((e) => CopyWith$Input$CheckRunOutputImage(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CheckRunOutput<TRes>
    implements CopyWith$Input$CheckRunOutput<TRes> {
  _CopyWithStubImpl$Input$CheckRunOutput(this._res);

  TRes _res;

  call({
    String? title,
    String? summary,
    String? text,
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
  }) =>
      _res;

  annotations(_fn) => _res;

  images(_fn) => _res;
}

class Input$CheckRunOutputImage {
  factory Input$CheckRunOutputImage({
    required String alt,
    required String imageUrl,
    String? caption,
  }) =>
      Input$CheckRunOutputImage._({
        r'alt': alt,
        r'imageUrl': imageUrl,
        if (caption != null) r'caption': caption,
      });

  Input$CheckRunOutputImage._(this._$data);

  factory Input$CheckRunOutputImage.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$alt = data['alt'];
    result$data['alt'] = (l$alt as String);
    final l$imageUrl = data['imageUrl'];
    result$data['imageUrl'] = (l$imageUrl as String);
    if (data.containsKey('caption')) {
      final l$caption = data['caption'];
      result$data['caption'] = (l$caption as String?);
    }
    return Input$CheckRunOutputImage._(result$data);
  }

  Map<String, dynamic> _$data;

  String get alt => (_$data['alt'] as String);

  String get imageUrl => (_$data['imageUrl'] as String);

  String? get caption => (_$data['caption'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$alt = alt;
    result$data['alt'] = l$alt;
    final l$imageUrl = imageUrl;
    result$data['imageUrl'] = l$imageUrl;
    if (_$data.containsKey('caption')) {
      final l$caption = caption;
      result$data['caption'] = l$caption;
    }
    return result$data;
  }

  CopyWith$Input$CheckRunOutputImage<Input$CheckRunOutputImage> get copyWith =>
      CopyWith$Input$CheckRunOutputImage(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckRunOutputImage ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$alt = alt;
    final lOther$alt = other.alt;
    if (l$alt != lOther$alt) {
      return false;
    }
    final l$imageUrl = imageUrl;
    final lOther$imageUrl = other.imageUrl;
    if (l$imageUrl != lOther$imageUrl) {
      return false;
    }
    final l$caption = caption;
    final lOther$caption = other.caption;
    if (_$data.containsKey('caption') != other._$data.containsKey('caption')) {
      return false;
    }
    if (l$caption != lOther$caption) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$alt = alt;
    final l$imageUrl = imageUrl;
    final l$caption = caption;
    return Object.hashAll([
      l$alt,
      l$imageUrl,
      _$data.containsKey('caption') ? l$caption : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckRunOutputImage<TRes> {
  factory CopyWith$Input$CheckRunOutputImage(
    Input$CheckRunOutputImage instance,
    TRes Function(Input$CheckRunOutputImage) then,
  ) = _CopyWithImpl$Input$CheckRunOutputImage;

  factory CopyWith$Input$CheckRunOutputImage.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunOutputImage;

  TRes call({
    String? alt,
    String? imageUrl,
    String? caption,
  });
}

class _CopyWithImpl$Input$CheckRunOutputImage<TRes>
    implements CopyWith$Input$CheckRunOutputImage<TRes> {
  _CopyWithImpl$Input$CheckRunOutputImage(
    this._instance,
    this._then,
  );

  final Input$CheckRunOutputImage _instance;

  final TRes Function(Input$CheckRunOutputImage) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? alt = _undefined,
    Object? imageUrl = _undefined,
    Object? caption = _undefined,
  }) =>
      _then(Input$CheckRunOutputImage._({
        ..._instance._$data,
        if (alt != _undefined && alt != null) 'alt': (alt as String),
        if (imageUrl != _undefined && imageUrl != null)
          'imageUrl': (imageUrl as String),
        if (caption != _undefined) 'caption': (caption as String?),
      }));
}

class _CopyWithStubImpl$Input$CheckRunOutputImage<TRes>
    implements CopyWith$Input$CheckRunOutputImage<TRes> {
  _CopyWithStubImpl$Input$CheckRunOutputImage(this._res);

  TRes _res;

  call({
    String? alt,
    String? imageUrl,
    String? caption,
  }) =>
      _res;
}

class Input$CheckSuiteAutoTriggerPreference {
  factory Input$CheckSuiteAutoTriggerPreference({
    required String appId,
    required bool setting,
  }) =>
      Input$CheckSuiteAutoTriggerPreference._({
        r'appId': appId,
        r'setting': setting,
      });

  Input$CheckSuiteAutoTriggerPreference._(this._$data);

  factory Input$CheckSuiteAutoTriggerPreference.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$appId = data['appId'];
    result$data['appId'] = (l$appId as String);
    final l$setting = data['setting'];
    result$data['setting'] = (l$setting as bool);
    return Input$CheckSuiteAutoTriggerPreference._(result$data);
  }

  Map<String, dynamic> _$data;

  String get appId => (_$data['appId'] as String);

  bool get setting => (_$data['setting'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$appId = appId;
    result$data['appId'] = l$appId;
    final l$setting = setting;
    result$data['setting'] = l$setting;
    return result$data;
  }

  CopyWith$Input$CheckSuiteAutoTriggerPreference<
          Input$CheckSuiteAutoTriggerPreference>
      get copyWith => CopyWith$Input$CheckSuiteAutoTriggerPreference(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckSuiteAutoTriggerPreference ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$setting = setting;
    final lOther$setting = other.setting;
    if (l$setting != lOther$setting) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$setting = setting;
    return Object.hashAll([
      l$appId,
      l$setting,
    ]);
  }
}

abstract class CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  factory CopyWith$Input$CheckSuiteAutoTriggerPreference(
    Input$CheckSuiteAutoTriggerPreference instance,
    TRes Function(Input$CheckSuiteAutoTriggerPreference) then,
  ) = _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference;

  factory CopyWith$Input$CheckSuiteAutoTriggerPreference.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference;

  TRes call({
    String? appId,
    bool? setting,
  });
}

class _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference<TRes>
    implements CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference(
    this._instance,
    this._then,
  );

  final Input$CheckSuiteAutoTriggerPreference _instance;

  final TRes Function(Input$CheckSuiteAutoTriggerPreference) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? appId = _undefined,
    Object? setting = _undefined,
  }) =>
      _then(Input$CheckSuiteAutoTriggerPreference._({
        ..._instance._$data,
        if (appId != _undefined && appId != null) 'appId': (appId as String),
        if (setting != _undefined && setting != null)
          'setting': (setting as bool),
      }));
}

class _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference<TRes>
    implements CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference(this._res);

  TRes _res;

  call({
    String? appId,
    bool? setting,
  }) =>
      _res;
}

class Input$CheckSuiteFilter {
  factory Input$CheckSuiteFilter({
    int? appId,
    String? checkName,
  }) =>
      Input$CheckSuiteFilter._({
        if (appId != null) r'appId': appId,
        if (checkName != null) r'checkName': checkName,
      });

  Input$CheckSuiteFilter._(this._$data);

  factory Input$CheckSuiteFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as int?);
    }
    if (data.containsKey('checkName')) {
      final l$checkName = data['checkName'];
      result$data['checkName'] = (l$checkName as String?);
    }
    return Input$CheckSuiteFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get appId => (_$data['appId'] as int?);

  String? get checkName => (_$data['checkName'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    if (_$data.containsKey('checkName')) {
      final l$checkName = checkName;
      result$data['checkName'] = l$checkName;
    }
    return result$data;
  }

  CopyWith$Input$CheckSuiteFilter<Input$CheckSuiteFilter> get copyWith =>
      CopyWith$Input$CheckSuiteFilter(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CheckSuiteFilter || runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$checkName = checkName;
    final lOther$checkName = other.checkName;
    if (_$data.containsKey('checkName') !=
        other._$data.containsKey('checkName')) {
      return false;
    }
    if (l$checkName != lOther$checkName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$checkName = checkName;
    return Object.hashAll([
      _$data.containsKey('appId') ? l$appId : const {},
      _$data.containsKey('checkName') ? l$checkName : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckSuiteFilter<TRes> {
  factory CopyWith$Input$CheckSuiteFilter(
    Input$CheckSuiteFilter instance,
    TRes Function(Input$CheckSuiteFilter) then,
  ) = _CopyWithImpl$Input$CheckSuiteFilter;

  factory CopyWith$Input$CheckSuiteFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckSuiteFilter;

  TRes call({
    int? appId,
    String? checkName,
  });
}

class _CopyWithImpl$Input$CheckSuiteFilter<TRes>
    implements CopyWith$Input$CheckSuiteFilter<TRes> {
  _CopyWithImpl$Input$CheckSuiteFilter(
    this._instance,
    this._then,
  );

  final Input$CheckSuiteFilter _instance;

  final TRes Function(Input$CheckSuiteFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? appId = _undefined,
    Object? checkName = _undefined,
  }) =>
      _then(Input$CheckSuiteFilter._({
        ..._instance._$data,
        if (appId != _undefined) 'appId': (appId as int?),
        if (checkName != _undefined) 'checkName': (checkName as String?),
      }));
}

class _CopyWithStubImpl$Input$CheckSuiteFilter<TRes>
    implements CopyWith$Input$CheckSuiteFilter<TRes> {
  _CopyWithStubImpl$Input$CheckSuiteFilter(this._res);

  TRes _res;

  call({
    int? appId,
    String? checkName,
  }) =>
      _res;
}

class Input$ClearLabelsFromLabelableInput {
  factory Input$ClearLabelsFromLabelableInput({
    String? clientMutationId,
    required String labelableId,
  }) =>
      Input$ClearLabelsFromLabelableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'labelableId': labelableId,
      });

  Input$ClearLabelsFromLabelableInput._(this._$data);

  factory Input$ClearLabelsFromLabelableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    return Input$ClearLabelsFromLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get labelableId => (_$data['labelableId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    return result$data;
  }

  CopyWith$Input$ClearLabelsFromLabelableInput<
          Input$ClearLabelsFromLabelableInput>
      get copyWith => CopyWith$Input$ClearLabelsFromLabelableInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ClearLabelsFromLabelableInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$labelableId = labelableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$labelableId,
    ]);
  }
}

abstract class CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  factory CopyWith$Input$ClearLabelsFromLabelableInput(
    Input$ClearLabelsFromLabelableInput instance,
    TRes Function(Input$ClearLabelsFromLabelableInput) then,
  ) = _CopyWithImpl$Input$ClearLabelsFromLabelableInput;

  factory CopyWith$Input$ClearLabelsFromLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput;

  TRes call({
    String? clientMutationId,
    String? labelableId,
  });
}

class _CopyWithImpl$Input$ClearLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  _CopyWithImpl$Input$ClearLabelsFromLabelableInput(
    this._instance,
    this._then,
  );

  final Input$ClearLabelsFromLabelableInput _instance;

  final TRes Function(Input$ClearLabelsFromLabelableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? labelableId = _undefined,
  }) =>
      _then(Input$ClearLabelsFromLabelableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
      }));
}

class _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? labelableId,
  }) =>
      _res;
}

class Input$ClearProjectV2ItemFieldValueInput {
  factory Input$ClearProjectV2ItemFieldValueInput({
    String? clientMutationId,
    required String projectId,
    required String itemId,
    required String fieldId,
  }) =>
      Input$ClearProjectV2ItemFieldValueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'itemId': itemId,
        r'fieldId': fieldId,
      });

  Input$ClearProjectV2ItemFieldValueInput._(this._$data);

  factory Input$ClearProjectV2ItemFieldValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    return Input$ClearProjectV2ItemFieldValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get itemId => (_$data['itemId'] as String);

  String get fieldId => (_$data['fieldId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    return result$data;
  }

  CopyWith$Input$ClearProjectV2ItemFieldValueInput<
          Input$ClearProjectV2ItemFieldValueInput>
      get copyWith => CopyWith$Input$ClearProjectV2ItemFieldValueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ClearProjectV2ItemFieldValueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$fieldId = fieldId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$itemId,
      l$fieldId,
    ]);
  }
}

abstract class CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  factory CopyWith$Input$ClearProjectV2ItemFieldValueInput(
    Input$ClearProjectV2ItemFieldValueInput instance,
    TRes Function(Input$ClearProjectV2ItemFieldValueInput) then,
  ) = _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput;

  factory CopyWith$Input$ClearProjectV2ItemFieldValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
    String? fieldId,
  });
}

class _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput(
    this._instance,
    this._then,
  );

  final Input$ClearProjectV2ItemFieldValueInput _instance;

  final TRes Function(Input$ClearProjectV2ItemFieldValueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? fieldId = _undefined,
  }) =>
      _then(Input$ClearProjectV2ItemFieldValueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
      }));
}

class _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
    String? fieldId,
  }) =>
      _res;
}

class Input$CloneProjectInput {
  factory Input$CloneProjectInput({
    String? clientMutationId,
    required String targetOwnerId,
    required String sourceId,
    required bool includeWorkflows,
    required String name,
    String? body,
    bool? public,
  }) =>
      Input$CloneProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'targetOwnerId': targetOwnerId,
        r'sourceId': sourceId,
        r'includeWorkflows': includeWorkflows,
        r'name': name,
        if (body != null) r'body': body,
        if (public != null) r'public': public,
      });

  Input$CloneProjectInput._(this._$data);

  factory Input$CloneProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$targetOwnerId = data['targetOwnerId'];
    result$data['targetOwnerId'] = (l$targetOwnerId as String);
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$includeWorkflows = data['includeWorkflows'];
    result$data['includeWorkflows'] = (l$includeWorkflows as bool);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    return Input$CloneProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get targetOwnerId => (_$data['targetOwnerId'] as String);

  String get sourceId => (_$data['sourceId'] as String);

  bool get includeWorkflows => (_$data['includeWorkflows'] as bool);

  String get name => (_$data['name'] as String);

  String? get body => (_$data['body'] as String?);

  bool? get public => (_$data['public'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$targetOwnerId = targetOwnerId;
    result$data['targetOwnerId'] = l$targetOwnerId;
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$includeWorkflows = includeWorkflows;
    result$data['includeWorkflows'] = l$includeWorkflows;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    return result$data;
  }

  CopyWith$Input$CloneProjectInput<Input$CloneProjectInput> get copyWith =>
      CopyWith$Input$CloneProjectInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CloneProjectInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$targetOwnerId = targetOwnerId;
    final lOther$targetOwnerId = other.targetOwnerId;
    if (l$targetOwnerId != lOther$targetOwnerId) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$includeWorkflows = includeWorkflows;
    final lOther$includeWorkflows = other.includeWorkflows;
    if (l$includeWorkflows != lOther$includeWorkflows) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$targetOwnerId = targetOwnerId;
    final l$sourceId = sourceId;
    final l$includeWorkflows = includeWorkflows;
    final l$name = name;
    final l$body = body;
    final l$public = public;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$targetOwnerId,
      l$sourceId,
      l$includeWorkflows,
      l$name,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('public') ? l$public : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloneProjectInput<TRes> {
  factory CopyWith$Input$CloneProjectInput(
    Input$CloneProjectInput instance,
    TRes Function(Input$CloneProjectInput) then,
  ) = _CopyWithImpl$Input$CloneProjectInput;

  factory CopyWith$Input$CloneProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloneProjectInput;

  TRes call({
    String? clientMutationId,
    String? targetOwnerId,
    String? sourceId,
    bool? includeWorkflows,
    String? name,
    String? body,
    bool? public,
  });
}

class _CopyWithImpl$Input$CloneProjectInput<TRes>
    implements CopyWith$Input$CloneProjectInput<TRes> {
  _CopyWithImpl$Input$CloneProjectInput(
    this._instance,
    this._then,
  );

  final Input$CloneProjectInput _instance;

  final TRes Function(Input$CloneProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? targetOwnerId = _undefined,
    Object? sourceId = _undefined,
    Object? includeWorkflows = _undefined,
    Object? name = _undefined,
    Object? body = _undefined,
    Object? public = _undefined,
  }) =>
      _then(Input$CloneProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (targetOwnerId != _undefined && targetOwnerId != null)
          'targetOwnerId': (targetOwnerId as String),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (includeWorkflows != _undefined && includeWorkflows != null)
          'includeWorkflows': (includeWorkflows as bool),
        if (name != _undefined && name != null) 'name': (name as String),
        if (body != _undefined) 'body': (body as String?),
        if (public != _undefined) 'public': (public as bool?),
      }));
}

class _CopyWithStubImpl$Input$CloneProjectInput<TRes>
    implements CopyWith$Input$CloneProjectInput<TRes> {
  _CopyWithStubImpl$Input$CloneProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? targetOwnerId,
    String? sourceId,
    bool? includeWorkflows,
    String? name,
    String? body,
    bool? public,
  }) =>
      _res;
}

class Input$CloneTemplateRepositoryInput {
  factory Input$CloneTemplateRepositoryInput({
    String? clientMutationId,
    required String repositoryId,
    required String name,
    required String ownerId,
    String? description,
    required Enum$RepositoryVisibility visibility,
    bool? includeAllBranches,
  }) =>
      Input$CloneTemplateRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'name': name,
        r'ownerId': ownerId,
        if (description != null) r'description': description,
        r'visibility': visibility,
        if (includeAllBranches != null)
          r'includeAllBranches': includeAllBranches,
      });

  Input$CloneTemplateRepositoryInput._(this._$data);

  factory Input$CloneTemplateRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$visibility = data['visibility'];
    result$data['visibility'] =
        fromJson$Enum$RepositoryVisibility((l$visibility as String));
    if (data.containsKey('includeAllBranches')) {
      final l$includeAllBranches = data['includeAllBranches'];
      result$data['includeAllBranches'] = (l$includeAllBranches as bool?);
    }
    return Input$CloneTemplateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get name => (_$data['name'] as String);

  String get ownerId => (_$data['ownerId'] as String);

  String? get description => (_$data['description'] as String?);

  Enum$RepositoryVisibility get visibility =>
      (_$data['visibility'] as Enum$RepositoryVisibility);

  bool? get includeAllBranches => (_$data['includeAllBranches'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$visibility = visibility;
    result$data['visibility'] = toJson$Enum$RepositoryVisibility(l$visibility);
    if (_$data.containsKey('includeAllBranches')) {
      final l$includeAllBranches = includeAllBranches;
      result$data['includeAllBranches'] = l$includeAllBranches;
    }
    return result$data;
  }

  CopyWith$Input$CloneTemplateRepositoryInput<
          Input$CloneTemplateRepositoryInput>
      get copyWith => CopyWith$Input$CloneTemplateRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CloneTemplateRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$visibility = visibility;
    final lOther$visibility = other.visibility;
    if (l$visibility != lOther$visibility) {
      return false;
    }
    final l$includeAllBranches = includeAllBranches;
    final lOther$includeAllBranches = other.includeAllBranches;
    if (_$data.containsKey('includeAllBranches') !=
        other._$data.containsKey('includeAllBranches')) {
      return false;
    }
    if (l$includeAllBranches != lOther$includeAllBranches) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$ownerId = ownerId;
    final l$description = description;
    final l$visibility = visibility;
    final l$includeAllBranches = includeAllBranches;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$name,
      l$ownerId,
      _$data.containsKey('description') ? l$description : const {},
      l$visibility,
      _$data.containsKey('includeAllBranches')
          ? l$includeAllBranches
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  factory CopyWith$Input$CloneTemplateRepositoryInput(
    Input$CloneTemplateRepositoryInput instance,
    TRes Function(Input$CloneTemplateRepositoryInput) then,
  ) = _CopyWithImpl$Input$CloneTemplateRepositoryInput;

  factory CopyWith$Input$CloneTemplateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloneTemplateRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? includeAllBranches,
  });
}

class _CopyWithImpl$Input$CloneTemplateRepositoryInput<TRes>
    implements CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  _CopyWithImpl$Input$CloneTemplateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$CloneTemplateRepositoryInput _instance;

  final TRes Function(Input$CloneTemplateRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? description = _undefined,
    Object? visibility = _undefined,
    Object? includeAllBranches = _undefined,
  }) =>
      _then(Input$CloneTemplateRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (description != _undefined) 'description': (description as String?),
        if (visibility != _undefined && visibility != null)
          'visibility': (visibility as Enum$RepositoryVisibility),
        if (includeAllBranches != _undefined)
          'includeAllBranches': (includeAllBranches as bool?),
      }));
}

class _CopyWithStubImpl$Input$CloneTemplateRepositoryInput<TRes>
    implements CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$CloneTemplateRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? includeAllBranches,
  }) =>
      _res;
}

class Input$CloseDiscussionInput {
  factory Input$CloseDiscussionInput({
    String? clientMutationId,
    required String discussionId,
    Enum$DiscussionCloseReason? reason,
  }) =>
      Input$CloseDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
        if (reason != null) r'reason': reason,
      });

  Input$CloseDiscussionInput._(this._$data);

  factory Input$CloseDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = l$reason == null
          ? null
          : fromJson$Enum$DiscussionCloseReason((l$reason as String));
    }
    return Input$CloseDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get discussionId => (_$data['discussionId'] as String);

  Enum$DiscussionCloseReason? get reason =>
      (_$data['reason'] as Enum$DiscussionCloseReason?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] =
          l$reason == null ? null : toJson$Enum$DiscussionCloseReason(l$reason);
    }
    return result$data;
  }

  CopyWith$Input$CloseDiscussionInput<Input$CloseDiscussionInput>
      get copyWith => CopyWith$Input$CloseDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CloseDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$reason = reason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
      _$data.containsKey('reason') ? l$reason : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloseDiscussionInput<TRes> {
  factory CopyWith$Input$CloseDiscussionInput(
    Input$CloseDiscussionInput instance,
    TRes Function(Input$CloseDiscussionInput) then,
  ) = _CopyWithImpl$Input$CloseDiscussionInput;

  factory CopyWith$Input$CloseDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloseDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? discussionId,
    Enum$DiscussionCloseReason? reason,
  });
}

class _CopyWithImpl$Input$CloseDiscussionInput<TRes>
    implements CopyWith$Input$CloseDiscussionInput<TRes> {
  _CopyWithImpl$Input$CloseDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CloseDiscussionInput _instance;

  final TRes Function(Input$CloseDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? reason = _undefined,
  }) =>
      _then(Input$CloseDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (reason != _undefined)
          'reason': (reason as Enum$DiscussionCloseReason?),
      }));
}

class _CopyWithStubImpl$Input$CloseDiscussionInput<TRes>
    implements CopyWith$Input$CloseDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CloseDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? discussionId,
    Enum$DiscussionCloseReason? reason,
  }) =>
      _res;
}

class Input$CloseIssueInput {
  factory Input$CloseIssueInput({
    String? clientMutationId,
    required String issueId,
    Enum$IssueClosedStateReason? stateReason,
    String? duplicateIssueId,
  }) =>
      Input$CloseIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        if (stateReason != null) r'stateReason': stateReason,
        if (duplicateIssueId != null) r'duplicateIssueId': duplicateIssueId,
      });

  Input$CloseIssueInput._(this._$data);

  factory Input$CloseIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('stateReason')) {
      final l$stateReason = data['stateReason'];
      result$data['stateReason'] = l$stateReason == null
          ? null
          : fromJson$Enum$IssueClosedStateReason((l$stateReason as String));
    }
    if (data.containsKey('duplicateIssueId')) {
      final l$duplicateIssueId = data['duplicateIssueId'];
      result$data['duplicateIssueId'] = (l$duplicateIssueId as String?);
    }
    return Input$CloseIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  Enum$IssueClosedStateReason? get stateReason =>
      (_$data['stateReason'] as Enum$IssueClosedStateReason?);

  String? get duplicateIssueId => (_$data['duplicateIssueId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('stateReason')) {
      final l$stateReason = stateReason;
      result$data['stateReason'] = l$stateReason == null
          ? null
          : toJson$Enum$IssueClosedStateReason(l$stateReason);
    }
    if (_$data.containsKey('duplicateIssueId')) {
      final l$duplicateIssueId = duplicateIssueId;
      result$data['duplicateIssueId'] = l$duplicateIssueId;
    }
    return result$data;
  }

  CopyWith$Input$CloseIssueInput<Input$CloseIssueInput> get copyWith =>
      CopyWith$Input$CloseIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CloseIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$stateReason = stateReason;
    final lOther$stateReason = other.stateReason;
    if (_$data.containsKey('stateReason') !=
        other._$data.containsKey('stateReason')) {
      return false;
    }
    if (l$stateReason != lOther$stateReason) {
      return false;
    }
    final l$duplicateIssueId = duplicateIssueId;
    final lOther$duplicateIssueId = other.duplicateIssueId;
    if (_$data.containsKey('duplicateIssueId') !=
        other._$data.containsKey('duplicateIssueId')) {
      return false;
    }
    if (l$duplicateIssueId != lOther$duplicateIssueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$stateReason = stateReason;
    final l$duplicateIssueId = duplicateIssueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      _$data.containsKey('stateReason') ? l$stateReason : const {},
      _$data.containsKey('duplicateIssueId') ? l$duplicateIssueId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloseIssueInput<TRes> {
  factory CopyWith$Input$CloseIssueInput(
    Input$CloseIssueInput instance,
    TRes Function(Input$CloseIssueInput) then,
  ) = _CopyWithImpl$Input$CloseIssueInput;

  factory CopyWith$Input$CloseIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloseIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    Enum$IssueClosedStateReason? stateReason,
    String? duplicateIssueId,
  });
}

class _CopyWithImpl$Input$CloseIssueInput<TRes>
    implements CopyWith$Input$CloseIssueInput<TRes> {
  _CopyWithImpl$Input$CloseIssueInput(
    this._instance,
    this._then,
  );

  final Input$CloseIssueInput _instance;

  final TRes Function(Input$CloseIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? stateReason = _undefined,
    Object? duplicateIssueId = _undefined,
  }) =>
      _then(Input$CloseIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (stateReason != _undefined)
          'stateReason': (stateReason as Enum$IssueClosedStateReason?),
        if (duplicateIssueId != _undefined)
          'duplicateIssueId': (duplicateIssueId as String?),
      }));
}

class _CopyWithStubImpl$Input$CloseIssueInput<TRes>
    implements CopyWith$Input$CloseIssueInput<TRes> {
  _CopyWithStubImpl$Input$CloseIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    Enum$IssueClosedStateReason? stateReason,
    String? duplicateIssueId,
  }) =>
      _res;
}

class Input$ClosePullRequestInput {
  factory Input$ClosePullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$ClosePullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$ClosePullRequestInput._(this._$data);

  factory Input$ClosePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$ClosePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$ClosePullRequestInput<Input$ClosePullRequestInput>
      get copyWith => CopyWith$Input$ClosePullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ClosePullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$ClosePullRequestInput<TRes> {
  factory CopyWith$Input$ClosePullRequestInput(
    Input$ClosePullRequestInput instance,
    TRes Function(Input$ClosePullRequestInput) then,
  ) = _CopyWithImpl$Input$ClosePullRequestInput;

  factory CopyWith$Input$ClosePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClosePullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$ClosePullRequestInput<TRes>
    implements CopyWith$Input$ClosePullRequestInput<TRes> {
  _CopyWithImpl$Input$ClosePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$ClosePullRequestInput _instance;

  final TRes Function(Input$ClosePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$ClosePullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$ClosePullRequestInput<TRes>
    implements CopyWith$Input$ClosePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$ClosePullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$CodeScanningParametersInput {
  factory Input$CodeScanningParametersInput(
          {required List<Input$CodeScanningToolInput> codeScanningTools}) =>
      Input$CodeScanningParametersInput._({
        r'codeScanningTools': codeScanningTools,
      });

  Input$CodeScanningParametersInput._(this._$data);

  factory Input$CodeScanningParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$codeScanningTools = data['codeScanningTools'];
    result$data['codeScanningTools'] = (l$codeScanningTools as List<dynamic>)
        .map((e) =>
            Input$CodeScanningToolInput.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$CodeScanningParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CodeScanningToolInput> get codeScanningTools =>
      (_$data['codeScanningTools'] as List<Input$CodeScanningToolInput>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$codeScanningTools = codeScanningTools;
    result$data['codeScanningTools'] =
        l$codeScanningTools.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$CodeScanningParametersInput<Input$CodeScanningParametersInput>
      get copyWith => CopyWith$Input$CodeScanningParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CodeScanningParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$codeScanningTools = codeScanningTools;
    final lOther$codeScanningTools = other.codeScanningTools;
    if (l$codeScanningTools.length != lOther$codeScanningTools.length) {
      return false;
    }
    for (int i = 0; i < l$codeScanningTools.length; i++) {
      final l$codeScanningTools$entry = l$codeScanningTools[i];
      final lOther$codeScanningTools$entry = lOther$codeScanningTools[i];
      if (l$codeScanningTools$entry != lOther$codeScanningTools$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$codeScanningTools = codeScanningTools;
    return Object.hashAll([Object.hashAll(l$codeScanningTools.map((v) => v))]);
  }
}

abstract class CopyWith$Input$CodeScanningParametersInput<TRes> {
  factory CopyWith$Input$CodeScanningParametersInput(
    Input$CodeScanningParametersInput instance,
    TRes Function(Input$CodeScanningParametersInput) then,
  ) = _CopyWithImpl$Input$CodeScanningParametersInput;

  factory CopyWith$Input$CodeScanningParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CodeScanningParametersInput;

  TRes call({List<Input$CodeScanningToolInput>? codeScanningTools});
  TRes codeScanningTools(
      Iterable<Input$CodeScanningToolInput> Function(
              Iterable<
                  CopyWith$Input$CodeScanningToolInput<
                      Input$CodeScanningToolInput>>)
          _fn);
}

class _CopyWithImpl$Input$CodeScanningParametersInput<TRes>
    implements CopyWith$Input$CodeScanningParametersInput<TRes> {
  _CopyWithImpl$Input$CodeScanningParametersInput(
    this._instance,
    this._then,
  );

  final Input$CodeScanningParametersInput _instance;

  final TRes Function(Input$CodeScanningParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? codeScanningTools = _undefined}) =>
      _then(Input$CodeScanningParametersInput._({
        ..._instance._$data,
        if (codeScanningTools != _undefined && codeScanningTools != null)
          'codeScanningTools':
              (codeScanningTools as List<Input$CodeScanningToolInput>),
      }));

  TRes codeScanningTools(
          Iterable<Input$CodeScanningToolInput> Function(
                  Iterable<
                      CopyWith$Input$CodeScanningToolInput<
                          Input$CodeScanningToolInput>>)
              _fn) =>
      call(
          codeScanningTools: _fn(_instance.codeScanningTools
              .map((e) => CopyWith$Input$CodeScanningToolInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$CodeScanningParametersInput<TRes>
    implements CopyWith$Input$CodeScanningParametersInput<TRes> {
  _CopyWithStubImpl$Input$CodeScanningParametersInput(this._res);

  TRes _res;

  call({List<Input$CodeScanningToolInput>? codeScanningTools}) => _res;

  codeScanningTools(_fn) => _res;
}

class Input$CodeScanningToolInput {
  factory Input$CodeScanningToolInput({
    required String alertsThreshold,
    required String securityAlertsThreshold,
    required String tool,
  }) =>
      Input$CodeScanningToolInput._({
        r'alertsThreshold': alertsThreshold,
        r'securityAlertsThreshold': securityAlertsThreshold,
        r'tool': tool,
      });

  Input$CodeScanningToolInput._(this._$data);

  factory Input$CodeScanningToolInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$alertsThreshold = data['alertsThreshold'];
    result$data['alertsThreshold'] = (l$alertsThreshold as String);
    final l$securityAlertsThreshold = data['securityAlertsThreshold'];
    result$data['securityAlertsThreshold'] =
        (l$securityAlertsThreshold as String);
    final l$tool = data['tool'];
    result$data['tool'] = (l$tool as String);
    return Input$CodeScanningToolInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get alertsThreshold => (_$data['alertsThreshold'] as String);

  String get securityAlertsThreshold =>
      (_$data['securityAlertsThreshold'] as String);

  String get tool => (_$data['tool'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$alertsThreshold = alertsThreshold;
    result$data['alertsThreshold'] = l$alertsThreshold;
    final l$securityAlertsThreshold = securityAlertsThreshold;
    result$data['securityAlertsThreshold'] = l$securityAlertsThreshold;
    final l$tool = tool;
    result$data['tool'] = l$tool;
    return result$data;
  }

  CopyWith$Input$CodeScanningToolInput<Input$CodeScanningToolInput>
      get copyWith => CopyWith$Input$CodeScanningToolInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CodeScanningToolInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$alertsThreshold = alertsThreshold;
    final lOther$alertsThreshold = other.alertsThreshold;
    if (l$alertsThreshold != lOther$alertsThreshold) {
      return false;
    }
    final l$securityAlertsThreshold = securityAlertsThreshold;
    final lOther$securityAlertsThreshold = other.securityAlertsThreshold;
    if (l$securityAlertsThreshold != lOther$securityAlertsThreshold) {
      return false;
    }
    final l$tool = tool;
    final lOther$tool = other.tool;
    if (l$tool != lOther$tool) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$alertsThreshold = alertsThreshold;
    final l$securityAlertsThreshold = securityAlertsThreshold;
    final l$tool = tool;
    return Object.hashAll([
      l$alertsThreshold,
      l$securityAlertsThreshold,
      l$tool,
    ]);
  }
}

abstract class CopyWith$Input$CodeScanningToolInput<TRes> {
  factory CopyWith$Input$CodeScanningToolInput(
    Input$CodeScanningToolInput instance,
    TRes Function(Input$CodeScanningToolInput) then,
  ) = _CopyWithImpl$Input$CodeScanningToolInput;

  factory CopyWith$Input$CodeScanningToolInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CodeScanningToolInput;

  TRes call({
    String? alertsThreshold,
    String? securityAlertsThreshold,
    String? tool,
  });
}

class _CopyWithImpl$Input$CodeScanningToolInput<TRes>
    implements CopyWith$Input$CodeScanningToolInput<TRes> {
  _CopyWithImpl$Input$CodeScanningToolInput(
    this._instance,
    this._then,
  );

  final Input$CodeScanningToolInput _instance;

  final TRes Function(Input$CodeScanningToolInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? alertsThreshold = _undefined,
    Object? securityAlertsThreshold = _undefined,
    Object? tool = _undefined,
  }) =>
      _then(Input$CodeScanningToolInput._({
        ..._instance._$data,
        if (alertsThreshold != _undefined && alertsThreshold != null)
          'alertsThreshold': (alertsThreshold as String),
        if (securityAlertsThreshold != _undefined &&
            securityAlertsThreshold != null)
          'securityAlertsThreshold': (securityAlertsThreshold as String),
        if (tool != _undefined && tool != null) 'tool': (tool as String),
      }));
}

class _CopyWithStubImpl$Input$CodeScanningToolInput<TRes>
    implements CopyWith$Input$CodeScanningToolInput<TRes> {
  _CopyWithStubImpl$Input$CodeScanningToolInput(this._res);

  TRes _res;

  call({
    String? alertsThreshold,
    String? securityAlertsThreshold,
    String? tool,
  }) =>
      _res;
}

class Input$CommitAuthor {
  factory Input$CommitAuthor({
    String? id,
    List<String>? emails,
  }) =>
      Input$CommitAuthor._({
        if (id != null) r'id': id,
        if (emails != null) r'emails': emails,
      });

  Input$CommitAuthor._(this._$data);

  factory Input$CommitAuthor.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('emails')) {
      final l$emails = data['emails'];
      result$data['emails'] =
          (l$emails as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$CommitAuthor._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  List<String>? get emails => (_$data['emails'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('emails')) {
      final l$emails = emails;
      result$data['emails'] = l$emails?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CommitAuthor<Input$CommitAuthor> get copyWith =>
      CopyWith$Input$CommitAuthor(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommitAuthor || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$emails = emails;
    final lOther$emails = other.emails;
    if (_$data.containsKey('emails') != other._$data.containsKey('emails')) {
      return false;
    }
    if (l$emails != null && lOther$emails != null) {
      if (l$emails.length != lOther$emails.length) {
        return false;
      }
      for (int i = 0; i < l$emails.length; i++) {
        final l$emails$entry = l$emails[i];
        final lOther$emails$entry = lOther$emails[i];
        if (l$emails$entry != lOther$emails$entry) {
          return false;
        }
      }
    } else if (l$emails != lOther$emails) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$emails = emails;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('emails')
          ? l$emails == null
              ? null
              : Object.hashAll(l$emails.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommitAuthor<TRes> {
  factory CopyWith$Input$CommitAuthor(
    Input$CommitAuthor instance,
    TRes Function(Input$CommitAuthor) then,
  ) = _CopyWithImpl$Input$CommitAuthor;

  factory CopyWith$Input$CommitAuthor.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitAuthor;

  TRes call({
    String? id,
    List<String>? emails,
  });
}

class _CopyWithImpl$Input$CommitAuthor<TRes>
    implements CopyWith$Input$CommitAuthor<TRes> {
  _CopyWithImpl$Input$CommitAuthor(
    this._instance,
    this._then,
  );

  final Input$CommitAuthor _instance;

  final TRes Function(Input$CommitAuthor) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? emails = _undefined,
  }) =>
      _then(Input$CommitAuthor._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (emails != _undefined) 'emails': (emails as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$CommitAuthor<TRes>
    implements CopyWith$Input$CommitAuthor<TRes> {
  _CopyWithStubImpl$Input$CommitAuthor(this._res);

  TRes _res;

  call({
    String? id,
    List<String>? emails,
  }) =>
      _res;
}

class Input$CommitAuthorEmailPatternParametersInput {
  factory Input$CommitAuthorEmailPatternParametersInput({
    String? name,
    bool? negate,
    required String $operator,
    required String pattern,
  }) =>
      Input$CommitAuthorEmailPatternParametersInput._({
        if (name != null) r'name': name,
        if (negate != null) r'negate': negate,
        r'operator': $operator,
        r'pattern': pattern,
      });

  Input$CommitAuthorEmailPatternParametersInput._(this._$data);

  factory Input$CommitAuthorEmailPatternParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('negate')) {
      final l$negate = data['negate'];
      result$data['negate'] = (l$negate as bool?);
    }
    final l$$operator = data['operator'];
    result$data['operator'] = (l$$operator as String);
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    return Input$CommitAuthorEmailPatternParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  bool? get negate => (_$data['negate'] as bool?);

  String get $operator => (_$data['operator'] as String);

  String get pattern => (_$data['pattern'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('negate')) {
      final l$negate = negate;
      result$data['negate'] = l$negate;
    }
    final l$$operator = $operator;
    result$data['operator'] = l$$operator;
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    return result$data;
  }

  CopyWith$Input$CommitAuthorEmailPatternParametersInput<
          Input$CommitAuthorEmailPatternParametersInput>
      get copyWith => CopyWith$Input$CommitAuthorEmailPatternParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommitAuthorEmailPatternParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$negate = negate;
    final lOther$negate = other.negate;
    if (_$data.containsKey('negate') != other._$data.containsKey('negate')) {
      return false;
    }
    if (l$negate != lOther$negate) {
      return false;
    }
    final l$$operator = $operator;
    final lOther$$operator = other.$operator;
    if (l$$operator != lOther$$operator) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$negate = negate;
    final l$$operator = $operator;
    final l$pattern = pattern;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('negate') ? l$negate : const {},
      l$$operator,
      l$pattern,
    ]);
  }
}

abstract class CopyWith$Input$CommitAuthorEmailPatternParametersInput<TRes> {
  factory CopyWith$Input$CommitAuthorEmailPatternParametersInput(
    Input$CommitAuthorEmailPatternParametersInput instance,
    TRes Function(Input$CommitAuthorEmailPatternParametersInput) then,
  ) = _CopyWithImpl$Input$CommitAuthorEmailPatternParametersInput;

  factory CopyWith$Input$CommitAuthorEmailPatternParametersInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$CommitAuthorEmailPatternParametersInput;

  TRes call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  });
}

class _CopyWithImpl$Input$CommitAuthorEmailPatternParametersInput<TRes>
    implements CopyWith$Input$CommitAuthorEmailPatternParametersInput<TRes> {
  _CopyWithImpl$Input$CommitAuthorEmailPatternParametersInput(
    this._instance,
    this._then,
  );

  final Input$CommitAuthorEmailPatternParametersInput _instance;

  final TRes Function(Input$CommitAuthorEmailPatternParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? negate = _undefined,
    Object? $operator = _undefined,
    Object? pattern = _undefined,
  }) =>
      _then(Input$CommitAuthorEmailPatternParametersInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (negate != _undefined) 'negate': (negate as bool?),
        if ($operator != _undefined && $operator != null)
          'operator': ($operator as String),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
      }));
}

class _CopyWithStubImpl$Input$CommitAuthorEmailPatternParametersInput<TRes>
    implements CopyWith$Input$CommitAuthorEmailPatternParametersInput<TRes> {
  _CopyWithStubImpl$Input$CommitAuthorEmailPatternParametersInput(this._res);

  TRes _res;

  call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  }) =>
      _res;
}

class Input$CommitContributionOrder {
  factory Input$CommitContributionOrder({
    required Enum$CommitContributionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$CommitContributionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$CommitContributionOrder._(this._$data);

  factory Input$CommitContributionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$CommitContributionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$CommitContributionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CommitContributionOrderField get field =>
      (_$data['field'] as Enum$CommitContributionOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$CommitContributionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$CommitContributionOrder<Input$CommitContributionOrder>
      get copyWith => CopyWith$Input$CommitContributionOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommitContributionOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$CommitContributionOrder<TRes> {
  factory CopyWith$Input$CommitContributionOrder(
    Input$CommitContributionOrder instance,
    TRes Function(Input$CommitContributionOrder) then,
  ) = _CopyWithImpl$Input$CommitContributionOrder;

  factory CopyWith$Input$CommitContributionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitContributionOrder;

  TRes call({
    Enum$CommitContributionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$CommitContributionOrder<TRes>
    implements CopyWith$Input$CommitContributionOrder<TRes> {
  _CopyWithImpl$Input$CommitContributionOrder(
    this._instance,
    this._then,
  );

  final Input$CommitContributionOrder _instance;

  final TRes Function(Input$CommitContributionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$CommitContributionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$CommitContributionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$CommitContributionOrder<TRes>
    implements CopyWith$Input$CommitContributionOrder<TRes> {
  _CopyWithStubImpl$Input$CommitContributionOrder(this._res);

  TRes _res;

  call({
    Enum$CommitContributionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$CommitMessage {
  factory Input$CommitMessage({
    required String headline,
    String? body,
  }) =>
      Input$CommitMessage._({
        r'headline': headline,
        if (body != null) r'body': body,
      });

  Input$CommitMessage._(this._$data);

  factory Input$CommitMessage.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$headline = data['headline'];
    result$data['headline'] = (l$headline as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$CommitMessage._(result$data);
  }

  Map<String, dynamic> _$data;

  String get headline => (_$data['headline'] as String);

  String? get body => (_$data['body'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$headline = headline;
    result$data['headline'] = l$headline;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$CommitMessage<Input$CommitMessage> get copyWith =>
      CopyWith$Input$CommitMessage(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommitMessage || runtimeType != other.runtimeType) {
      return false;
    }
    final l$headline = headline;
    final lOther$headline = other.headline;
    if (l$headline != lOther$headline) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$headline = headline;
    final l$body = body;
    return Object.hashAll([
      l$headline,
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommitMessage<TRes> {
  factory CopyWith$Input$CommitMessage(
    Input$CommitMessage instance,
    TRes Function(Input$CommitMessage) then,
  ) = _CopyWithImpl$Input$CommitMessage;

  factory CopyWith$Input$CommitMessage.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitMessage;

  TRes call({
    String? headline,
    String? body,
  });
}

class _CopyWithImpl$Input$CommitMessage<TRes>
    implements CopyWith$Input$CommitMessage<TRes> {
  _CopyWithImpl$Input$CommitMessage(
    this._instance,
    this._then,
  );

  final Input$CommitMessage _instance;

  final TRes Function(Input$CommitMessage) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? headline = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$CommitMessage._({
        ..._instance._$data,
        if (headline != _undefined && headline != null)
          'headline': (headline as String),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$CommitMessage<TRes>
    implements CopyWith$Input$CommitMessage<TRes> {
  _CopyWithStubImpl$Input$CommitMessage(this._res);

  TRes _res;

  call({
    String? headline,
    String? body,
  }) =>
      _res;
}

class Input$CommitMessagePatternParametersInput {
  factory Input$CommitMessagePatternParametersInput({
    String? name,
    bool? negate,
    required String $operator,
    required String pattern,
  }) =>
      Input$CommitMessagePatternParametersInput._({
        if (name != null) r'name': name,
        if (negate != null) r'negate': negate,
        r'operator': $operator,
        r'pattern': pattern,
      });

  Input$CommitMessagePatternParametersInput._(this._$data);

  factory Input$CommitMessagePatternParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('negate')) {
      final l$negate = data['negate'];
      result$data['negate'] = (l$negate as bool?);
    }
    final l$$operator = data['operator'];
    result$data['operator'] = (l$$operator as String);
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    return Input$CommitMessagePatternParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  bool? get negate => (_$data['negate'] as bool?);

  String get $operator => (_$data['operator'] as String);

  String get pattern => (_$data['pattern'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('negate')) {
      final l$negate = negate;
      result$data['negate'] = l$negate;
    }
    final l$$operator = $operator;
    result$data['operator'] = l$$operator;
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    return result$data;
  }

  CopyWith$Input$CommitMessagePatternParametersInput<
          Input$CommitMessagePatternParametersInput>
      get copyWith => CopyWith$Input$CommitMessagePatternParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommitMessagePatternParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$negate = negate;
    final lOther$negate = other.negate;
    if (_$data.containsKey('negate') != other._$data.containsKey('negate')) {
      return false;
    }
    if (l$negate != lOther$negate) {
      return false;
    }
    final l$$operator = $operator;
    final lOther$$operator = other.$operator;
    if (l$$operator != lOther$$operator) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$negate = negate;
    final l$$operator = $operator;
    final l$pattern = pattern;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('negate') ? l$negate : const {},
      l$$operator,
      l$pattern,
    ]);
  }
}

abstract class CopyWith$Input$CommitMessagePatternParametersInput<TRes> {
  factory CopyWith$Input$CommitMessagePatternParametersInput(
    Input$CommitMessagePatternParametersInput instance,
    TRes Function(Input$CommitMessagePatternParametersInput) then,
  ) = _CopyWithImpl$Input$CommitMessagePatternParametersInput;

  factory CopyWith$Input$CommitMessagePatternParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitMessagePatternParametersInput;

  TRes call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  });
}

class _CopyWithImpl$Input$CommitMessagePatternParametersInput<TRes>
    implements CopyWith$Input$CommitMessagePatternParametersInput<TRes> {
  _CopyWithImpl$Input$CommitMessagePatternParametersInput(
    this._instance,
    this._then,
  );

  final Input$CommitMessagePatternParametersInput _instance;

  final TRes Function(Input$CommitMessagePatternParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? negate = _undefined,
    Object? $operator = _undefined,
    Object? pattern = _undefined,
  }) =>
      _then(Input$CommitMessagePatternParametersInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (negate != _undefined) 'negate': (negate as bool?),
        if ($operator != _undefined && $operator != null)
          'operator': ($operator as String),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
      }));
}

class _CopyWithStubImpl$Input$CommitMessagePatternParametersInput<TRes>
    implements CopyWith$Input$CommitMessagePatternParametersInput<TRes> {
  _CopyWithStubImpl$Input$CommitMessagePatternParametersInput(this._res);

  TRes _res;

  call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  }) =>
      _res;
}

class Input$CommittableBranch {
  factory Input$CommittableBranch({
    String? id,
    String? repositoryNameWithOwner,
    String? branchName,
  }) =>
      Input$CommittableBranch._({
        if (id != null) r'id': id,
        if (repositoryNameWithOwner != null)
          r'repositoryNameWithOwner': repositoryNameWithOwner,
        if (branchName != null) r'branchName': branchName,
      });

  Input$CommittableBranch._(this._$data);

  factory Input$CommittableBranch.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('repositoryNameWithOwner')) {
      final l$repositoryNameWithOwner = data['repositoryNameWithOwner'];
      result$data['repositoryNameWithOwner'] =
          (l$repositoryNameWithOwner as String?);
    }
    if (data.containsKey('branchName')) {
      final l$branchName = data['branchName'];
      result$data['branchName'] = (l$branchName as String?);
    }
    return Input$CommittableBranch._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  String? get repositoryNameWithOwner =>
      (_$data['repositoryNameWithOwner'] as String?);

  String? get branchName => (_$data['branchName'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('repositoryNameWithOwner')) {
      final l$repositoryNameWithOwner = repositoryNameWithOwner;
      result$data['repositoryNameWithOwner'] = l$repositoryNameWithOwner;
    }
    if (_$data.containsKey('branchName')) {
      final l$branchName = branchName;
      result$data['branchName'] = l$branchName;
    }
    return result$data;
  }

  CopyWith$Input$CommittableBranch<Input$CommittableBranch> get copyWith =>
      CopyWith$Input$CommittableBranch(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommittableBranch || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$repositoryNameWithOwner = repositoryNameWithOwner;
    final lOther$repositoryNameWithOwner = other.repositoryNameWithOwner;
    if (_$data.containsKey('repositoryNameWithOwner') !=
        other._$data.containsKey('repositoryNameWithOwner')) {
      return false;
    }
    if (l$repositoryNameWithOwner != lOther$repositoryNameWithOwner) {
      return false;
    }
    final l$branchName = branchName;
    final lOther$branchName = other.branchName;
    if (_$data.containsKey('branchName') !=
        other._$data.containsKey('branchName')) {
      return false;
    }
    if (l$branchName != lOther$branchName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$repositoryNameWithOwner = repositoryNameWithOwner;
    final l$branchName = branchName;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('repositoryNameWithOwner')
          ? l$repositoryNameWithOwner
          : const {},
      _$data.containsKey('branchName') ? l$branchName : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommittableBranch<TRes> {
  factory CopyWith$Input$CommittableBranch(
    Input$CommittableBranch instance,
    TRes Function(Input$CommittableBranch) then,
  ) = _CopyWithImpl$Input$CommittableBranch;

  factory CopyWith$Input$CommittableBranch.stub(TRes res) =
      _CopyWithStubImpl$Input$CommittableBranch;

  TRes call({
    String? id,
    String? repositoryNameWithOwner,
    String? branchName,
  });
}

class _CopyWithImpl$Input$CommittableBranch<TRes>
    implements CopyWith$Input$CommittableBranch<TRes> {
  _CopyWithImpl$Input$CommittableBranch(
    this._instance,
    this._then,
  );

  final Input$CommittableBranch _instance;

  final TRes Function(Input$CommittableBranch) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? repositoryNameWithOwner = _undefined,
    Object? branchName = _undefined,
  }) =>
      _then(Input$CommittableBranch._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (repositoryNameWithOwner != _undefined)
          'repositoryNameWithOwner': (repositoryNameWithOwner as String?),
        if (branchName != _undefined) 'branchName': (branchName as String?),
      }));
}

class _CopyWithStubImpl$Input$CommittableBranch<TRes>
    implements CopyWith$Input$CommittableBranch<TRes> {
  _CopyWithStubImpl$Input$CommittableBranch(this._res);

  TRes _res;

  call({
    String? id,
    String? repositoryNameWithOwner,
    String? branchName,
  }) =>
      _res;
}

class Input$CommitterEmailPatternParametersInput {
  factory Input$CommitterEmailPatternParametersInput({
    String? name,
    bool? negate,
    required String $operator,
    required String pattern,
  }) =>
      Input$CommitterEmailPatternParametersInput._({
        if (name != null) r'name': name,
        if (negate != null) r'negate': negate,
        r'operator': $operator,
        r'pattern': pattern,
      });

  Input$CommitterEmailPatternParametersInput._(this._$data);

  factory Input$CommitterEmailPatternParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('negate')) {
      final l$negate = data['negate'];
      result$data['negate'] = (l$negate as bool?);
    }
    final l$$operator = data['operator'];
    result$data['operator'] = (l$$operator as String);
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    return Input$CommitterEmailPatternParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  bool? get negate => (_$data['negate'] as bool?);

  String get $operator => (_$data['operator'] as String);

  String get pattern => (_$data['pattern'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('negate')) {
      final l$negate = negate;
      result$data['negate'] = l$negate;
    }
    final l$$operator = $operator;
    result$data['operator'] = l$$operator;
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    return result$data;
  }

  CopyWith$Input$CommitterEmailPatternParametersInput<
          Input$CommitterEmailPatternParametersInput>
      get copyWith => CopyWith$Input$CommitterEmailPatternParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CommitterEmailPatternParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$negate = negate;
    final lOther$negate = other.negate;
    if (_$data.containsKey('negate') != other._$data.containsKey('negate')) {
      return false;
    }
    if (l$negate != lOther$negate) {
      return false;
    }
    final l$$operator = $operator;
    final lOther$$operator = other.$operator;
    if (l$$operator != lOther$$operator) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$negate = negate;
    final l$$operator = $operator;
    final l$pattern = pattern;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('negate') ? l$negate : const {},
      l$$operator,
      l$pattern,
    ]);
  }
}

abstract class CopyWith$Input$CommitterEmailPatternParametersInput<TRes> {
  factory CopyWith$Input$CommitterEmailPatternParametersInput(
    Input$CommitterEmailPatternParametersInput instance,
    TRes Function(Input$CommitterEmailPatternParametersInput) then,
  ) = _CopyWithImpl$Input$CommitterEmailPatternParametersInput;

  factory CopyWith$Input$CommitterEmailPatternParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitterEmailPatternParametersInput;

  TRes call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  });
}

class _CopyWithImpl$Input$CommitterEmailPatternParametersInput<TRes>
    implements CopyWith$Input$CommitterEmailPatternParametersInput<TRes> {
  _CopyWithImpl$Input$CommitterEmailPatternParametersInput(
    this._instance,
    this._then,
  );

  final Input$CommitterEmailPatternParametersInput _instance;

  final TRes Function(Input$CommitterEmailPatternParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? negate = _undefined,
    Object? $operator = _undefined,
    Object? pattern = _undefined,
  }) =>
      _then(Input$CommitterEmailPatternParametersInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (negate != _undefined) 'negate': (negate as bool?),
        if ($operator != _undefined && $operator != null)
          'operator': ($operator as String),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
      }));
}

class _CopyWithStubImpl$Input$CommitterEmailPatternParametersInput<TRes>
    implements CopyWith$Input$CommitterEmailPatternParametersInput<TRes> {
  _CopyWithStubImpl$Input$CommitterEmailPatternParametersInput(this._res);

  TRes _res;

  call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  }) =>
      _res;
}

class Input$ContributionOrder {
  factory Input$ContributionOrder({required Enum$OrderDirection direction}) =>
      Input$ContributionOrder._({
        r'direction': direction,
      });

  Input$ContributionOrder._(this._$data);

  factory Input$ContributionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ContributionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ContributionOrder<Input$ContributionOrder> get copyWith =>
      CopyWith$Input$ContributionOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ContributionOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    return Object.hashAll([l$direction]);
  }
}

abstract class CopyWith$Input$ContributionOrder<TRes> {
  factory CopyWith$Input$ContributionOrder(
    Input$ContributionOrder instance,
    TRes Function(Input$ContributionOrder) then,
  ) = _CopyWithImpl$Input$ContributionOrder;

  factory CopyWith$Input$ContributionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ContributionOrder;

  TRes call({Enum$OrderDirection? direction});
}

class _CopyWithImpl$Input$ContributionOrder<TRes>
    implements CopyWith$Input$ContributionOrder<TRes> {
  _CopyWithImpl$Input$ContributionOrder(
    this._instance,
    this._then,
  );

  final Input$ContributionOrder _instance;

  final TRes Function(Input$ContributionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? direction = _undefined}) =>
      _then(Input$ContributionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ContributionOrder<TRes>
    implements CopyWith$Input$ContributionOrder<TRes> {
  _CopyWithStubImpl$Input$ContributionOrder(this._res);

  TRes _res;

  call({Enum$OrderDirection? direction}) => _res;
}

class Input$ConvertProjectCardNoteToIssueInput {
  factory Input$ConvertProjectCardNoteToIssueInput({
    String? clientMutationId,
    required String projectCardId,
    required String repositoryId,
    String? title,
    String? body,
  }) =>
      Input$ConvertProjectCardNoteToIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectCardId': projectCardId,
        r'repositoryId': repositoryId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
      });

  Input$ConvertProjectCardNoteToIssueInput._(this._$data);

  factory Input$ConvertProjectCardNoteToIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectCardId = data['projectCardId'];
    result$data['projectCardId'] = (l$projectCardId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$ConvertProjectCardNoteToIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectCardId => (_$data['projectCardId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectCardId = projectCardId;
    result$data['projectCardId'] = l$projectCardId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$ConvertProjectCardNoteToIssueInput<
          Input$ConvertProjectCardNoteToIssueInput>
      get copyWith => CopyWith$Input$ConvertProjectCardNoteToIssueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ConvertProjectCardNoteToIssueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectCardId = projectCardId;
    final lOther$projectCardId = other.projectCardId;
    if (l$projectCardId != lOther$projectCardId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectCardId = projectCardId;
    final l$repositoryId = repositoryId;
    final l$title = title;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectCardId,
      l$repositoryId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  factory CopyWith$Input$ConvertProjectCardNoteToIssueInput(
    Input$ConvertProjectCardNoteToIssueInput instance,
    TRes Function(Input$ConvertProjectCardNoteToIssueInput) then,
  ) = _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput;

  factory CopyWith$Input$ConvertProjectCardNoteToIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput;

  TRes call({
    String? clientMutationId,
    String? projectCardId,
    String? repositoryId,
    String? title,
    String? body,
  });
}

class _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput(
    this._instance,
    this._then,
  );

  final Input$ConvertProjectCardNoteToIssueInput _instance;

  final TRes Function(Input$ConvertProjectCardNoteToIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectCardId = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$ConvertProjectCardNoteToIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectCardId != _undefined && projectCardId != null)
          'projectCardId': (projectCardId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectCardId,
    String? repositoryId,
    String? title,
    String? body,
  }) =>
      _res;
}

class Input$ConvertProjectV2DraftIssueItemToIssueInput {
  factory Input$ConvertProjectV2DraftIssueItemToIssueInput({
    String? clientMutationId,
    required String itemId,
    required String repositoryId,
  }) =>
      Input$ConvertProjectV2DraftIssueItemToIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'itemId': itemId,
        r'repositoryId': repositoryId,
      });

  Input$ConvertProjectV2DraftIssueItemToIssueInput._(this._$data);

  factory Input$ConvertProjectV2DraftIssueItemToIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$ConvertProjectV2DraftIssueItemToIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get itemId => (_$data['itemId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$ConvertProjectV2DraftIssueItemToIssueInput<
          Input$ConvertProjectV2DraftIssueItemToIssueInput>
      get copyWith => CopyWith$Input$ConvertProjectV2DraftIssueItemToIssueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ConvertProjectV2DraftIssueItemToIssueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$itemId = itemId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$itemId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$ConvertProjectV2DraftIssueItemToIssueInput<TRes> {
  factory CopyWith$Input$ConvertProjectV2DraftIssueItemToIssueInput(
    Input$ConvertProjectV2DraftIssueItemToIssueInput instance,
    TRes Function(Input$ConvertProjectV2DraftIssueItemToIssueInput) then,
  ) = _CopyWithImpl$Input$ConvertProjectV2DraftIssueItemToIssueInput;

  factory CopyWith$Input$ConvertProjectV2DraftIssueItemToIssueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ConvertProjectV2DraftIssueItemToIssueInput;

  TRes call({
    String? clientMutationId,
    String? itemId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$ConvertProjectV2DraftIssueItemToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectV2DraftIssueItemToIssueInput<TRes> {
  _CopyWithImpl$Input$ConvertProjectV2DraftIssueItemToIssueInput(
    this._instance,
    this._then,
  );

  final Input$ConvertProjectV2DraftIssueItemToIssueInput _instance;

  final TRes Function(Input$ConvertProjectV2DraftIssueItemToIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? itemId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$ConvertProjectV2DraftIssueItemToIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$ConvertProjectV2DraftIssueItemToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectV2DraftIssueItemToIssueInput<TRes> {
  _CopyWithStubImpl$Input$ConvertProjectV2DraftIssueItemToIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? itemId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$ConvertPullRequestToDraftInput {
  factory Input$ConvertPullRequestToDraftInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$ConvertPullRequestToDraftInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$ConvertPullRequestToDraftInput._(this._$data);

  factory Input$ConvertPullRequestToDraftInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$ConvertPullRequestToDraftInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$ConvertPullRequestToDraftInput<
          Input$ConvertPullRequestToDraftInput>
      get copyWith => CopyWith$Input$ConvertPullRequestToDraftInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ConvertPullRequestToDraftInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  factory CopyWith$Input$ConvertPullRequestToDraftInput(
    Input$ConvertPullRequestToDraftInput instance,
    TRes Function(Input$ConvertPullRequestToDraftInput) then,
  ) = _CopyWithImpl$Input$ConvertPullRequestToDraftInput;

  factory CopyWith$Input$ConvertPullRequestToDraftInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$ConvertPullRequestToDraftInput<TRes>
    implements CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  _CopyWithImpl$Input$ConvertPullRequestToDraftInput(
    this._instance,
    this._then,
  );

  final Input$ConvertPullRequestToDraftInput _instance;

  final TRes Function(Input$ConvertPullRequestToDraftInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$ConvertPullRequestToDraftInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput<TRes>
    implements CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$CopilotCodeReviewParametersInput {
  factory Input$CopilotCodeReviewParametersInput({
    bool? reviewDraftPullRequests,
    bool? reviewOnPush,
  }) =>
      Input$CopilotCodeReviewParametersInput._({
        if (reviewDraftPullRequests != null)
          r'reviewDraftPullRequests': reviewDraftPullRequests,
        if (reviewOnPush != null) r'reviewOnPush': reviewOnPush,
      });

  Input$CopilotCodeReviewParametersInput._(this._$data);

  factory Input$CopilotCodeReviewParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('reviewDraftPullRequests')) {
      final l$reviewDraftPullRequests = data['reviewDraftPullRequests'];
      result$data['reviewDraftPullRequests'] =
          (l$reviewDraftPullRequests as bool?);
    }
    if (data.containsKey('reviewOnPush')) {
      final l$reviewOnPush = data['reviewOnPush'];
      result$data['reviewOnPush'] = (l$reviewOnPush as bool?);
    }
    return Input$CopilotCodeReviewParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get reviewDraftPullRequests =>
      (_$data['reviewDraftPullRequests'] as bool?);

  bool? get reviewOnPush => (_$data['reviewOnPush'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('reviewDraftPullRequests')) {
      final l$reviewDraftPullRequests = reviewDraftPullRequests;
      result$data['reviewDraftPullRequests'] = l$reviewDraftPullRequests;
    }
    if (_$data.containsKey('reviewOnPush')) {
      final l$reviewOnPush = reviewOnPush;
      result$data['reviewOnPush'] = l$reviewOnPush;
    }
    return result$data;
  }

  CopyWith$Input$CopilotCodeReviewParametersInput<
          Input$CopilotCodeReviewParametersInput>
      get copyWith => CopyWith$Input$CopilotCodeReviewParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CopilotCodeReviewParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reviewDraftPullRequests = reviewDraftPullRequests;
    final lOther$reviewDraftPullRequests = other.reviewDraftPullRequests;
    if (_$data.containsKey('reviewDraftPullRequests') !=
        other._$data.containsKey('reviewDraftPullRequests')) {
      return false;
    }
    if (l$reviewDraftPullRequests != lOther$reviewDraftPullRequests) {
      return false;
    }
    final l$reviewOnPush = reviewOnPush;
    final lOther$reviewOnPush = other.reviewOnPush;
    if (_$data.containsKey('reviewOnPush') !=
        other._$data.containsKey('reviewOnPush')) {
      return false;
    }
    if (l$reviewOnPush != lOther$reviewOnPush) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reviewDraftPullRequests = reviewDraftPullRequests;
    final l$reviewOnPush = reviewOnPush;
    return Object.hashAll([
      _$data.containsKey('reviewDraftPullRequests')
          ? l$reviewDraftPullRequests
          : const {},
      _$data.containsKey('reviewOnPush') ? l$reviewOnPush : const {},
    ]);
  }
}

abstract class CopyWith$Input$CopilotCodeReviewParametersInput<TRes> {
  factory CopyWith$Input$CopilotCodeReviewParametersInput(
    Input$CopilotCodeReviewParametersInput instance,
    TRes Function(Input$CopilotCodeReviewParametersInput) then,
  ) = _CopyWithImpl$Input$CopilotCodeReviewParametersInput;

  factory CopyWith$Input$CopilotCodeReviewParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CopilotCodeReviewParametersInput;

  TRes call({
    bool? reviewDraftPullRequests,
    bool? reviewOnPush,
  });
}

class _CopyWithImpl$Input$CopilotCodeReviewParametersInput<TRes>
    implements CopyWith$Input$CopilotCodeReviewParametersInput<TRes> {
  _CopyWithImpl$Input$CopilotCodeReviewParametersInput(
    this._instance,
    this._then,
  );

  final Input$CopilotCodeReviewParametersInput _instance;

  final TRes Function(Input$CopilotCodeReviewParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reviewDraftPullRequests = _undefined,
    Object? reviewOnPush = _undefined,
  }) =>
      _then(Input$CopilotCodeReviewParametersInput._({
        ..._instance._$data,
        if (reviewDraftPullRequests != _undefined)
          'reviewDraftPullRequests': (reviewDraftPullRequests as bool?),
        if (reviewOnPush != _undefined) 'reviewOnPush': (reviewOnPush as bool?),
      }));
}

class _CopyWithStubImpl$Input$CopilotCodeReviewParametersInput<TRes>
    implements CopyWith$Input$CopilotCodeReviewParametersInput<TRes> {
  _CopyWithStubImpl$Input$CopilotCodeReviewParametersInput(this._res);

  TRes _res;

  call({
    bool? reviewDraftPullRequests,
    bool? reviewOnPush,
  }) =>
      _res;
}

class Input$CopyProjectV2Input {
  factory Input$CopyProjectV2Input({
    String? clientMutationId,
    required String projectId,
    required String ownerId,
    required String title,
    bool? includeDraftIssues,
  }) =>
      Input$CopyProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'ownerId': ownerId,
        r'title': title,
        if (includeDraftIssues != null)
          r'includeDraftIssues': includeDraftIssues,
      });

  Input$CopyProjectV2Input._(this._$data);

  factory Input$CopyProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('includeDraftIssues')) {
      final l$includeDraftIssues = data['includeDraftIssues'];
      result$data['includeDraftIssues'] = (l$includeDraftIssues as bool?);
    }
    return Input$CopyProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get ownerId => (_$data['ownerId'] as String);

  String get title => (_$data['title'] as String);

  bool? get includeDraftIssues => (_$data['includeDraftIssues'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('includeDraftIssues')) {
      final l$includeDraftIssues = includeDraftIssues;
      result$data['includeDraftIssues'] = l$includeDraftIssues;
    }
    return result$data;
  }

  CopyWith$Input$CopyProjectV2Input<Input$CopyProjectV2Input> get copyWith =>
      CopyWith$Input$CopyProjectV2Input(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CopyProjectV2Input ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$includeDraftIssues = includeDraftIssues;
    final lOther$includeDraftIssues = other.includeDraftIssues;
    if (_$data.containsKey('includeDraftIssues') !=
        other._$data.containsKey('includeDraftIssues')) {
      return false;
    }
    if (l$includeDraftIssues != lOther$includeDraftIssues) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$ownerId = ownerId;
    final l$title = title;
    final l$includeDraftIssues = includeDraftIssues;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$ownerId,
      l$title,
      _$data.containsKey('includeDraftIssues')
          ? l$includeDraftIssues
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CopyProjectV2Input<TRes> {
  factory CopyWith$Input$CopyProjectV2Input(
    Input$CopyProjectV2Input instance,
    TRes Function(Input$CopyProjectV2Input) then,
  ) = _CopyWithImpl$Input$CopyProjectV2Input;

  factory CopyWith$Input$CopyProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$CopyProjectV2Input;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? ownerId,
    String? title,
    bool? includeDraftIssues,
  });
}

class _CopyWithImpl$Input$CopyProjectV2Input<TRes>
    implements CopyWith$Input$CopyProjectV2Input<TRes> {
  _CopyWithImpl$Input$CopyProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$CopyProjectV2Input _instance;

  final TRes Function(Input$CopyProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? ownerId = _undefined,
    Object? title = _undefined,
    Object? includeDraftIssues = _undefined,
  }) =>
      _then(Input$CopyProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (includeDraftIssues != _undefined)
          'includeDraftIssues': (includeDraftIssues as bool?),
      }));
}

class _CopyWithStubImpl$Input$CopyProjectV2Input<TRes>
    implements CopyWith$Input$CopyProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$CopyProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? ownerId,
    String? title,
    bool? includeDraftIssues,
  }) =>
      _res;
}

class Input$CreateAttributionInvitationInput {
  factory Input$CreateAttributionInvitationInput({
    String? clientMutationId,
    required String ownerId,
    required String sourceId,
    required String targetId,
  }) =>
      Input$CreateAttributionInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'sourceId': sourceId,
        r'targetId': targetId,
      });

  Input$CreateAttributionInvitationInput._(this._$data);

  factory Input$CreateAttributionInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$targetId = data['targetId'];
    result$data['targetId'] = (l$targetId as String);
    return Input$CreateAttributionInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  String get sourceId => (_$data['sourceId'] as String);

  String get targetId => (_$data['targetId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$targetId = targetId;
    result$data['targetId'] = l$targetId;
    return result$data;
  }

  CopyWith$Input$CreateAttributionInvitationInput<
          Input$CreateAttributionInvitationInput>
      get copyWith => CopyWith$Input$CreateAttributionInvitationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateAttributionInvitationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (l$targetId != lOther$targetId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$sourceId = sourceId;
    final l$targetId = targetId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$sourceId,
      l$targetId,
    ]);
  }
}

abstract class CopyWith$Input$CreateAttributionInvitationInput<TRes> {
  factory CopyWith$Input$CreateAttributionInvitationInput(
    Input$CreateAttributionInvitationInput instance,
    TRes Function(Input$CreateAttributionInvitationInput) then,
  ) = _CopyWithImpl$Input$CreateAttributionInvitationInput;

  factory CopyWith$Input$CreateAttributionInvitationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateAttributionInvitationInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    String? sourceId,
    String? targetId,
  });
}

class _CopyWithImpl$Input$CreateAttributionInvitationInput<TRes>
    implements CopyWith$Input$CreateAttributionInvitationInput<TRes> {
  _CopyWithImpl$Input$CreateAttributionInvitationInput(
    this._instance,
    this._then,
  );

  final Input$CreateAttributionInvitationInput _instance;

  final TRes Function(Input$CreateAttributionInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? sourceId = _undefined,
    Object? targetId = _undefined,
  }) =>
      _then(Input$CreateAttributionInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (targetId != _undefined && targetId != null)
          'targetId': (targetId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateAttributionInvitationInput<TRes>
    implements CopyWith$Input$CreateAttributionInvitationInput<TRes> {
  _CopyWithStubImpl$Input$CreateAttributionInvitationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    String? sourceId,
    String? targetId,
  }) =>
      _res;
}

class Input$CreateBranchProtectionRuleInput {
  factory Input$CreateBranchProtectionRuleInput({
    String? clientMutationId,
    required String repositoryId,
    required String pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresDeployments,
    List<String>? requiredDeploymentEnvironments,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
  }) =>
      Input$CreateBranchProtectionRuleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'pattern': pattern,
        if (requiresApprovingReviews != null)
          r'requiresApprovingReviews': requiresApprovingReviews,
        if (requiredApprovingReviewCount != null)
          r'requiredApprovingReviewCount': requiredApprovingReviewCount,
        if (requiresCommitSignatures != null)
          r'requiresCommitSignatures': requiresCommitSignatures,
        if (requiresLinearHistory != null)
          r'requiresLinearHistory': requiresLinearHistory,
        if (blocksCreations != null) r'blocksCreations': blocksCreations,
        if (allowsForcePushes != null) r'allowsForcePushes': allowsForcePushes,
        if (allowsDeletions != null) r'allowsDeletions': allowsDeletions,
        if (isAdminEnforced != null) r'isAdminEnforced': isAdminEnforced,
        if (requiresStatusChecks != null)
          r'requiresStatusChecks': requiresStatusChecks,
        if (requiresStrictStatusChecks != null)
          r'requiresStrictStatusChecks': requiresStrictStatusChecks,
        if (requiresCodeOwnerReviews != null)
          r'requiresCodeOwnerReviews': requiresCodeOwnerReviews,
        if (dismissesStaleReviews != null)
          r'dismissesStaleReviews': dismissesStaleReviews,
        if (restrictsReviewDismissals != null)
          r'restrictsReviewDismissals': restrictsReviewDismissals,
        if (reviewDismissalActorIds != null)
          r'reviewDismissalActorIds': reviewDismissalActorIds,
        if (bypassPullRequestActorIds != null)
          r'bypassPullRequestActorIds': bypassPullRequestActorIds,
        if (bypassForcePushActorIds != null)
          r'bypassForcePushActorIds': bypassForcePushActorIds,
        if (restrictsPushes != null) r'restrictsPushes': restrictsPushes,
        if (pushActorIds != null) r'pushActorIds': pushActorIds,
        if (requiredStatusCheckContexts != null)
          r'requiredStatusCheckContexts': requiredStatusCheckContexts,
        if (requiredStatusChecks != null)
          r'requiredStatusChecks': requiredStatusChecks,
        if (requiresDeployments != null)
          r'requiresDeployments': requiresDeployments,
        if (requiredDeploymentEnvironments != null)
          r'requiredDeploymentEnvironments': requiredDeploymentEnvironments,
        if (requiresConversationResolution != null)
          r'requiresConversationResolution': requiresConversationResolution,
        if (requireLastPushApproval != null)
          r'requireLastPushApproval': requireLastPushApproval,
        if (lockBranch != null) r'lockBranch': lockBranch,
        if (lockAllowsFetchAndMerge != null)
          r'lockAllowsFetchAndMerge': lockAllowsFetchAndMerge,
      });

  Input$CreateBranchProtectionRuleInput._(this._$data);

  factory Input$CreateBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    if (data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = data['requiresApprovingReviews'];
      result$data['requiresApprovingReviews'] =
          (l$requiresApprovingReviews as bool?);
    }
    if (data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount =
          data['requiredApprovingReviewCount'];
      result$data['requiredApprovingReviewCount'] =
          (l$requiredApprovingReviewCount as int?);
    }
    if (data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = data['requiresCommitSignatures'];
      result$data['requiresCommitSignatures'] =
          (l$requiresCommitSignatures as bool?);
    }
    if (data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = data['requiresLinearHistory'];
      result$data['requiresLinearHistory'] = (l$requiresLinearHistory as bool?);
    }
    if (data.containsKey('blocksCreations')) {
      final l$blocksCreations = data['blocksCreations'];
      result$data['blocksCreations'] = (l$blocksCreations as bool?);
    }
    if (data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = data['allowsForcePushes'];
      result$data['allowsForcePushes'] = (l$allowsForcePushes as bool?);
    }
    if (data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = data['allowsDeletions'];
      result$data['allowsDeletions'] = (l$allowsDeletions as bool?);
    }
    if (data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = data['isAdminEnforced'];
      result$data['isAdminEnforced'] = (l$isAdminEnforced as bool?);
    }
    if (data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = data['requiresStatusChecks'];
      result$data['requiresStatusChecks'] = (l$requiresStatusChecks as bool?);
    }
    if (data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = data['requiresStrictStatusChecks'];
      result$data['requiresStrictStatusChecks'] =
          (l$requiresStrictStatusChecks as bool?);
    }
    if (data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = data['requiresCodeOwnerReviews'];
      result$data['requiresCodeOwnerReviews'] =
          (l$requiresCodeOwnerReviews as bool?);
    }
    if (data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = data['dismissesStaleReviews'];
      result$data['dismissesStaleReviews'] = (l$dismissesStaleReviews as bool?);
    }
    if (data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = data['restrictsReviewDismissals'];
      result$data['restrictsReviewDismissals'] =
          (l$restrictsReviewDismissals as bool?);
    }
    if (data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = data['reviewDismissalActorIds'];
      result$data['reviewDismissalActorIds'] =
          (l$reviewDismissalActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = data['bypassPullRequestActorIds'];
      result$data['bypassPullRequestActorIds'] =
          (l$bypassPullRequestActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = data['bypassForcePushActorIds'];
      result$data['bypassForcePushActorIds'] =
          (l$bypassForcePushActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = data['restrictsPushes'];
      result$data['restrictsPushes'] = (l$restrictsPushes as bool?);
    }
    if (data.containsKey('pushActorIds')) {
      final l$pushActorIds = data['pushActorIds'];
      result$data['pushActorIds'] = (l$pushActorIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = data['requiredStatusCheckContexts'];
      result$data['requiredStatusCheckContexts'] =
          (l$requiredStatusCheckContexts as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = data['requiredStatusChecks'];
      result$data['requiredStatusChecks'] =
          (l$requiredStatusChecks as List<dynamic>?)
              ?.map((e) => Input$RequiredStatusCheckInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = data['requiresDeployments'];
      result$data['requiresDeployments'] = (l$requiresDeployments as bool?);
    }
    if (data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments =
          data['requiredDeploymentEnvironments'];
      result$data['requiredDeploymentEnvironments'] =
          (l$requiredDeploymentEnvironments as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution =
          data['requiresConversationResolution'];
      result$data['requiresConversationResolution'] =
          (l$requiresConversationResolution as bool?);
    }
    if (data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = data['requireLastPushApproval'];
      result$data['requireLastPushApproval'] =
          (l$requireLastPushApproval as bool?);
    }
    if (data.containsKey('lockBranch')) {
      final l$lockBranch = data['lockBranch'];
      result$data['lockBranch'] = (l$lockBranch as bool?);
    }
    if (data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = data['lockAllowsFetchAndMerge'];
      result$data['lockAllowsFetchAndMerge'] =
          (l$lockAllowsFetchAndMerge as bool?);
    }
    return Input$CreateBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get pattern => (_$data['pattern'] as String);

  bool? get requiresApprovingReviews =>
      (_$data['requiresApprovingReviews'] as bool?);

  int? get requiredApprovingReviewCount =>
      (_$data['requiredApprovingReviewCount'] as int?);

  bool? get requiresCommitSignatures =>
      (_$data['requiresCommitSignatures'] as bool?);

  bool? get requiresLinearHistory => (_$data['requiresLinearHistory'] as bool?);

  bool? get blocksCreations => (_$data['blocksCreations'] as bool?);

  bool? get allowsForcePushes => (_$data['allowsForcePushes'] as bool?);

  bool? get allowsDeletions => (_$data['allowsDeletions'] as bool?);

  bool? get isAdminEnforced => (_$data['isAdminEnforced'] as bool?);

  bool? get requiresStatusChecks => (_$data['requiresStatusChecks'] as bool?);

  bool? get requiresStrictStatusChecks =>
      (_$data['requiresStrictStatusChecks'] as bool?);

  bool? get requiresCodeOwnerReviews =>
      (_$data['requiresCodeOwnerReviews'] as bool?);

  bool? get dismissesStaleReviews => (_$data['dismissesStaleReviews'] as bool?);

  bool? get restrictsReviewDismissals =>
      (_$data['restrictsReviewDismissals'] as bool?);

  List<String>? get reviewDismissalActorIds =>
      (_$data['reviewDismissalActorIds'] as List<String>?);

  List<String>? get bypassPullRequestActorIds =>
      (_$data['bypassPullRequestActorIds'] as List<String>?);

  List<String>? get bypassForcePushActorIds =>
      (_$data['bypassForcePushActorIds'] as List<String>?);

  bool? get restrictsPushes => (_$data['restrictsPushes'] as bool?);

  List<String>? get pushActorIds => (_$data['pushActorIds'] as List<String>?);

  List<String>? get requiredStatusCheckContexts =>
      (_$data['requiredStatusCheckContexts'] as List<String>?);

  List<Input$RequiredStatusCheckInput>? get requiredStatusChecks =>
      (_$data['requiredStatusChecks'] as List<Input$RequiredStatusCheckInput>?);

  bool? get requiresDeployments => (_$data['requiresDeployments'] as bool?);

  List<String>? get requiredDeploymentEnvironments =>
      (_$data['requiredDeploymentEnvironments'] as List<String>?);

  bool? get requiresConversationResolution =>
      (_$data['requiresConversationResolution'] as bool?);

  bool? get requireLastPushApproval =>
      (_$data['requireLastPushApproval'] as bool?);

  bool? get lockBranch => (_$data['lockBranch'] as bool?);

  bool? get lockAllowsFetchAndMerge =>
      (_$data['lockAllowsFetchAndMerge'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    if (_$data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = requiresApprovingReviews;
      result$data['requiresApprovingReviews'] = l$requiresApprovingReviews;
    }
    if (_$data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
      result$data['requiredApprovingReviewCount'] =
          l$requiredApprovingReviewCount;
    }
    if (_$data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = requiresCommitSignatures;
      result$data['requiresCommitSignatures'] = l$requiresCommitSignatures;
    }
    if (_$data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = requiresLinearHistory;
      result$data['requiresLinearHistory'] = l$requiresLinearHistory;
    }
    if (_$data.containsKey('blocksCreations')) {
      final l$blocksCreations = blocksCreations;
      result$data['blocksCreations'] = l$blocksCreations;
    }
    if (_$data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = allowsForcePushes;
      result$data['allowsForcePushes'] = l$allowsForcePushes;
    }
    if (_$data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = allowsDeletions;
      result$data['allowsDeletions'] = l$allowsDeletions;
    }
    if (_$data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = isAdminEnforced;
      result$data['isAdminEnforced'] = l$isAdminEnforced;
    }
    if (_$data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = requiresStatusChecks;
      result$data['requiresStatusChecks'] = l$requiresStatusChecks;
    }
    if (_$data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
      result$data['requiresStrictStatusChecks'] = l$requiresStrictStatusChecks;
    }
    if (_$data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
      result$data['requiresCodeOwnerReviews'] = l$requiresCodeOwnerReviews;
    }
    if (_$data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = dismissesStaleReviews;
      result$data['dismissesStaleReviews'] = l$dismissesStaleReviews;
    }
    if (_$data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = restrictsReviewDismissals;
      result$data['restrictsReviewDismissals'] = l$restrictsReviewDismissals;
    }
    if (_$data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = reviewDismissalActorIds;
      result$data['reviewDismissalActorIds'] =
          l$reviewDismissalActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
      result$data['bypassPullRequestActorIds'] =
          l$bypassPullRequestActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = bypassForcePushActorIds;
      result$data['bypassForcePushActorIds'] =
          l$bypassForcePushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = restrictsPushes;
      result$data['restrictsPushes'] = l$restrictsPushes;
    }
    if (_$data.containsKey('pushActorIds')) {
      final l$pushActorIds = pushActorIds;
      result$data['pushActorIds'] = l$pushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
      result$data['requiredStatusCheckContexts'] =
          l$requiredStatusCheckContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = requiredStatusChecks;
      result$data['requiredStatusChecks'] =
          l$requiredStatusChecks?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = requiresDeployments;
      result$data['requiresDeployments'] = l$requiresDeployments;
    }
    if (_$data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
      result$data['requiredDeploymentEnvironments'] =
          l$requiredDeploymentEnvironments?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution = requiresConversationResolution;
      result$data['requiresConversationResolution'] =
          l$requiresConversationResolution;
    }
    if (_$data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = requireLastPushApproval;
      result$data['requireLastPushApproval'] = l$requireLastPushApproval;
    }
    if (_$data.containsKey('lockBranch')) {
      final l$lockBranch = lockBranch;
      result$data['lockBranch'] = l$lockBranch;
    }
    if (_$data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
      result$data['lockAllowsFetchAndMerge'] = l$lockAllowsFetchAndMerge;
    }
    return result$data;
  }

  CopyWith$Input$CreateBranchProtectionRuleInput<
          Input$CreateBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$CreateBranchProtectionRuleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateBranchProtectionRuleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final lOther$requiresApprovingReviews = other.requiresApprovingReviews;
    if (_$data.containsKey('requiresApprovingReviews') !=
        other._$data.containsKey('requiresApprovingReviews')) {
      return false;
    }
    if (l$requiresApprovingReviews != lOther$requiresApprovingReviews) {
      return false;
    }
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final lOther$requiredApprovingReviewCount =
        other.requiredApprovingReviewCount;
    if (_$data.containsKey('requiredApprovingReviewCount') !=
        other._$data.containsKey('requiredApprovingReviewCount')) {
      return false;
    }
    if (l$requiredApprovingReviewCount != lOther$requiredApprovingReviewCount) {
      return false;
    }
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final lOther$requiresCommitSignatures = other.requiresCommitSignatures;
    if (_$data.containsKey('requiresCommitSignatures') !=
        other._$data.containsKey('requiresCommitSignatures')) {
      return false;
    }
    if (l$requiresCommitSignatures != lOther$requiresCommitSignatures) {
      return false;
    }
    final l$requiresLinearHistory = requiresLinearHistory;
    final lOther$requiresLinearHistory = other.requiresLinearHistory;
    if (_$data.containsKey('requiresLinearHistory') !=
        other._$data.containsKey('requiresLinearHistory')) {
      return false;
    }
    if (l$requiresLinearHistory != lOther$requiresLinearHistory) {
      return false;
    }
    final l$blocksCreations = blocksCreations;
    final lOther$blocksCreations = other.blocksCreations;
    if (_$data.containsKey('blocksCreations') !=
        other._$data.containsKey('blocksCreations')) {
      return false;
    }
    if (l$blocksCreations != lOther$blocksCreations) {
      return false;
    }
    final l$allowsForcePushes = allowsForcePushes;
    final lOther$allowsForcePushes = other.allowsForcePushes;
    if (_$data.containsKey('allowsForcePushes') !=
        other._$data.containsKey('allowsForcePushes')) {
      return false;
    }
    if (l$allowsForcePushes != lOther$allowsForcePushes) {
      return false;
    }
    final l$allowsDeletions = allowsDeletions;
    final lOther$allowsDeletions = other.allowsDeletions;
    if (_$data.containsKey('allowsDeletions') !=
        other._$data.containsKey('allowsDeletions')) {
      return false;
    }
    if (l$allowsDeletions != lOther$allowsDeletions) {
      return false;
    }
    final l$isAdminEnforced = isAdminEnforced;
    final lOther$isAdminEnforced = other.isAdminEnforced;
    if (_$data.containsKey('isAdminEnforced') !=
        other._$data.containsKey('isAdminEnforced')) {
      return false;
    }
    if (l$isAdminEnforced != lOther$isAdminEnforced) {
      return false;
    }
    final l$requiresStatusChecks = requiresStatusChecks;
    final lOther$requiresStatusChecks = other.requiresStatusChecks;
    if (_$data.containsKey('requiresStatusChecks') !=
        other._$data.containsKey('requiresStatusChecks')) {
      return false;
    }
    if (l$requiresStatusChecks != lOther$requiresStatusChecks) {
      return false;
    }
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final lOther$requiresStrictStatusChecks = other.requiresStrictStatusChecks;
    if (_$data.containsKey('requiresStrictStatusChecks') !=
        other._$data.containsKey('requiresStrictStatusChecks')) {
      return false;
    }
    if (l$requiresStrictStatusChecks != lOther$requiresStrictStatusChecks) {
      return false;
    }
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final lOther$requiresCodeOwnerReviews = other.requiresCodeOwnerReviews;
    if (_$data.containsKey('requiresCodeOwnerReviews') !=
        other._$data.containsKey('requiresCodeOwnerReviews')) {
      return false;
    }
    if (l$requiresCodeOwnerReviews != lOther$requiresCodeOwnerReviews) {
      return false;
    }
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final lOther$dismissesStaleReviews = other.dismissesStaleReviews;
    if (_$data.containsKey('dismissesStaleReviews') !=
        other._$data.containsKey('dismissesStaleReviews')) {
      return false;
    }
    if (l$dismissesStaleReviews != lOther$dismissesStaleReviews) {
      return false;
    }
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final lOther$restrictsReviewDismissals = other.restrictsReviewDismissals;
    if (_$data.containsKey('restrictsReviewDismissals') !=
        other._$data.containsKey('restrictsReviewDismissals')) {
      return false;
    }
    if (l$restrictsReviewDismissals != lOther$restrictsReviewDismissals) {
      return false;
    }
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final lOther$reviewDismissalActorIds = other.reviewDismissalActorIds;
    if (_$data.containsKey('reviewDismissalActorIds') !=
        other._$data.containsKey('reviewDismissalActorIds')) {
      return false;
    }
    if (l$reviewDismissalActorIds != null &&
        lOther$reviewDismissalActorIds != null) {
      if (l$reviewDismissalActorIds.length !=
          lOther$reviewDismissalActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$reviewDismissalActorIds.length; i++) {
        final l$reviewDismissalActorIds$entry = l$reviewDismissalActorIds[i];
        final lOther$reviewDismissalActorIds$entry =
            lOther$reviewDismissalActorIds[i];
        if (l$reviewDismissalActorIds$entry !=
            lOther$reviewDismissalActorIds$entry) {
          return false;
        }
      }
    } else if (l$reviewDismissalActorIds != lOther$reviewDismissalActorIds) {
      return false;
    }
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final lOther$bypassPullRequestActorIds = other.bypassPullRequestActorIds;
    if (_$data.containsKey('bypassPullRequestActorIds') !=
        other._$data.containsKey('bypassPullRequestActorIds')) {
      return false;
    }
    if (l$bypassPullRequestActorIds != null &&
        lOther$bypassPullRequestActorIds != null) {
      if (l$bypassPullRequestActorIds.length !=
          lOther$bypassPullRequestActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassPullRequestActorIds.length; i++) {
        final l$bypassPullRequestActorIds$entry =
            l$bypassPullRequestActorIds[i];
        final lOther$bypassPullRequestActorIds$entry =
            lOther$bypassPullRequestActorIds[i];
        if (l$bypassPullRequestActorIds$entry !=
            lOther$bypassPullRequestActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassPullRequestActorIds !=
        lOther$bypassPullRequestActorIds) {
      return false;
    }
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final lOther$bypassForcePushActorIds = other.bypassForcePushActorIds;
    if (_$data.containsKey('bypassForcePushActorIds') !=
        other._$data.containsKey('bypassForcePushActorIds')) {
      return false;
    }
    if (l$bypassForcePushActorIds != null &&
        lOther$bypassForcePushActorIds != null) {
      if (l$bypassForcePushActorIds.length !=
          lOther$bypassForcePushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassForcePushActorIds.length; i++) {
        final l$bypassForcePushActorIds$entry = l$bypassForcePushActorIds[i];
        final lOther$bypassForcePushActorIds$entry =
            lOther$bypassForcePushActorIds[i];
        if (l$bypassForcePushActorIds$entry !=
            lOther$bypassForcePushActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassForcePushActorIds != lOther$bypassForcePushActorIds) {
      return false;
    }
    final l$restrictsPushes = restrictsPushes;
    final lOther$restrictsPushes = other.restrictsPushes;
    if (_$data.containsKey('restrictsPushes') !=
        other._$data.containsKey('restrictsPushes')) {
      return false;
    }
    if (l$restrictsPushes != lOther$restrictsPushes) {
      return false;
    }
    final l$pushActorIds = pushActorIds;
    final lOther$pushActorIds = other.pushActorIds;
    if (_$data.containsKey('pushActorIds') !=
        other._$data.containsKey('pushActorIds')) {
      return false;
    }
    if (l$pushActorIds != null && lOther$pushActorIds != null) {
      if (l$pushActorIds.length != lOther$pushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$pushActorIds.length; i++) {
        final l$pushActorIds$entry = l$pushActorIds[i];
        final lOther$pushActorIds$entry = lOther$pushActorIds[i];
        if (l$pushActorIds$entry != lOther$pushActorIds$entry) {
          return false;
        }
      }
    } else if (l$pushActorIds != lOther$pushActorIds) {
      return false;
    }
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final lOther$requiredStatusCheckContexts =
        other.requiredStatusCheckContexts;
    if (_$data.containsKey('requiredStatusCheckContexts') !=
        other._$data.containsKey('requiredStatusCheckContexts')) {
      return false;
    }
    if (l$requiredStatusCheckContexts != null &&
        lOther$requiredStatusCheckContexts != null) {
      if (l$requiredStatusCheckContexts.length !=
          lOther$requiredStatusCheckContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusCheckContexts.length; i++) {
        final l$requiredStatusCheckContexts$entry =
            l$requiredStatusCheckContexts[i];
        final lOther$requiredStatusCheckContexts$entry =
            lOther$requiredStatusCheckContexts[i];
        if (l$requiredStatusCheckContexts$entry !=
            lOther$requiredStatusCheckContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusCheckContexts !=
        lOther$requiredStatusCheckContexts) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (_$data.containsKey('requiredStatusChecks') !=
        other._$data.containsKey('requiredStatusChecks')) {
      return false;
    }
    if (l$requiredStatusChecks != null && lOther$requiredStatusChecks != null) {
      if (l$requiredStatusChecks.length != lOther$requiredStatusChecks.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusChecks.length; i++) {
        final l$requiredStatusChecks$entry = l$requiredStatusChecks[i];
        final lOther$requiredStatusChecks$entry =
            lOther$requiredStatusChecks[i];
        if (l$requiredStatusChecks$entry != lOther$requiredStatusChecks$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusChecks != lOther$requiredStatusChecks) {
      return false;
    }
    final l$requiresDeployments = requiresDeployments;
    final lOther$requiresDeployments = other.requiresDeployments;
    if (_$data.containsKey('requiresDeployments') !=
        other._$data.containsKey('requiresDeployments')) {
      return false;
    }
    if (l$requiresDeployments != lOther$requiresDeployments) {
      return false;
    }
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final lOther$requiredDeploymentEnvironments =
        other.requiredDeploymentEnvironments;
    if (_$data.containsKey('requiredDeploymentEnvironments') !=
        other._$data.containsKey('requiredDeploymentEnvironments')) {
      return false;
    }
    if (l$requiredDeploymentEnvironments != null &&
        lOther$requiredDeploymentEnvironments != null) {
      if (l$requiredDeploymentEnvironments.length !=
          lOther$requiredDeploymentEnvironments.length) {
        return false;
      }
      for (int i = 0; i < l$requiredDeploymentEnvironments.length; i++) {
        final l$requiredDeploymentEnvironments$entry =
            l$requiredDeploymentEnvironments[i];
        final lOther$requiredDeploymentEnvironments$entry =
            lOther$requiredDeploymentEnvironments[i];
        if (l$requiredDeploymentEnvironments$entry !=
            lOther$requiredDeploymentEnvironments$entry) {
          return false;
        }
      }
    } else if (l$requiredDeploymentEnvironments !=
        lOther$requiredDeploymentEnvironments) {
      return false;
    }
    final l$requiresConversationResolution = requiresConversationResolution;
    final lOther$requiresConversationResolution =
        other.requiresConversationResolution;
    if (_$data.containsKey('requiresConversationResolution') !=
        other._$data.containsKey('requiresConversationResolution')) {
      return false;
    }
    if (l$requiresConversationResolution !=
        lOther$requiresConversationResolution) {
      return false;
    }
    final l$requireLastPushApproval = requireLastPushApproval;
    final lOther$requireLastPushApproval = other.requireLastPushApproval;
    if (_$data.containsKey('requireLastPushApproval') !=
        other._$data.containsKey('requireLastPushApproval')) {
      return false;
    }
    if (l$requireLastPushApproval != lOther$requireLastPushApproval) {
      return false;
    }
    final l$lockBranch = lockBranch;
    final lOther$lockBranch = other.lockBranch;
    if (_$data.containsKey('lockBranch') !=
        other._$data.containsKey('lockBranch')) {
      return false;
    }
    if (l$lockBranch != lOther$lockBranch) {
      return false;
    }
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final lOther$lockAllowsFetchAndMerge = other.lockAllowsFetchAndMerge;
    if (_$data.containsKey('lockAllowsFetchAndMerge') !=
        other._$data.containsKey('lockAllowsFetchAndMerge')) {
      return false;
    }
    if (l$lockAllowsFetchAndMerge != lOther$lockAllowsFetchAndMerge) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$pattern = pattern;
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final l$requiresLinearHistory = requiresLinearHistory;
    final l$blocksCreations = blocksCreations;
    final l$allowsForcePushes = allowsForcePushes;
    final l$allowsDeletions = allowsDeletions;
    final l$isAdminEnforced = isAdminEnforced;
    final l$requiresStatusChecks = requiresStatusChecks;
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final l$restrictsPushes = restrictsPushes;
    final l$pushActorIds = pushActorIds;
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$requiresDeployments = requiresDeployments;
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final l$requiresConversationResolution = requiresConversationResolution;
    final l$requireLastPushApproval = requireLastPushApproval;
    final l$lockBranch = lockBranch;
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$pattern,
      _$data.containsKey('requiresApprovingReviews')
          ? l$requiresApprovingReviews
          : const {},
      _$data.containsKey('requiredApprovingReviewCount')
          ? l$requiredApprovingReviewCount
          : const {},
      _$data.containsKey('requiresCommitSignatures')
          ? l$requiresCommitSignatures
          : const {},
      _$data.containsKey('requiresLinearHistory')
          ? l$requiresLinearHistory
          : const {},
      _$data.containsKey('blocksCreations') ? l$blocksCreations : const {},
      _$data.containsKey('allowsForcePushes') ? l$allowsForcePushes : const {},
      _$data.containsKey('allowsDeletions') ? l$allowsDeletions : const {},
      _$data.containsKey('isAdminEnforced') ? l$isAdminEnforced : const {},
      _$data.containsKey('requiresStatusChecks')
          ? l$requiresStatusChecks
          : const {},
      _$data.containsKey('requiresStrictStatusChecks')
          ? l$requiresStrictStatusChecks
          : const {},
      _$data.containsKey('requiresCodeOwnerReviews')
          ? l$requiresCodeOwnerReviews
          : const {},
      _$data.containsKey('dismissesStaleReviews')
          ? l$dismissesStaleReviews
          : const {},
      _$data.containsKey('restrictsReviewDismissals')
          ? l$restrictsReviewDismissals
          : const {},
      _$data.containsKey('reviewDismissalActorIds')
          ? l$reviewDismissalActorIds == null
              ? null
              : Object.hashAll(l$reviewDismissalActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassPullRequestActorIds')
          ? l$bypassPullRequestActorIds == null
              ? null
              : Object.hashAll(l$bypassPullRequestActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassForcePushActorIds')
          ? l$bypassForcePushActorIds == null
              ? null
              : Object.hashAll(l$bypassForcePushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('restrictsPushes') ? l$restrictsPushes : const {},
      _$data.containsKey('pushActorIds')
          ? l$pushActorIds == null
              ? null
              : Object.hashAll(l$pushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusCheckContexts')
          ? l$requiredStatusCheckContexts == null
              ? null
              : Object.hashAll(l$requiredStatusCheckContexts.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusChecks')
          ? l$requiredStatusChecks == null
              ? null
              : Object.hashAll(l$requiredStatusChecks.map((v) => v))
          : const {},
      _$data.containsKey('requiresDeployments')
          ? l$requiresDeployments
          : const {},
      _$data.containsKey('requiredDeploymentEnvironments')
          ? l$requiredDeploymentEnvironments == null
              ? null
              : Object.hashAll(l$requiredDeploymentEnvironments.map((v) => v))
          : const {},
      _$data.containsKey('requiresConversationResolution')
          ? l$requiresConversationResolution
          : const {},
      _$data.containsKey('requireLastPushApproval')
          ? l$requireLastPushApproval
          : const {},
      _$data.containsKey('lockBranch') ? l$lockBranch : const {},
      _$data.containsKey('lockAllowsFetchAndMerge')
          ? l$lockAllowsFetchAndMerge
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$CreateBranchProtectionRuleInput(
    Input$CreateBranchProtectionRuleInput instance,
    TRes Function(Input$CreateBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$CreateBranchProtectionRuleInput;

  factory CopyWith$Input$CreateBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresDeployments,
    List<String>? requiredDeploymentEnvironments,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
  });
  TRes requiredStatusChecks(
      Iterable<Input$RequiredStatusCheckInput>? Function(
              Iterable<
                  CopyWith$Input$RequiredStatusCheckInput<
                      Input$RequiredStatusCheckInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$CreateBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$CreateBranchProtectionRuleInput _instance;

  final TRes Function(Input$CreateBranchProtectionRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? pattern = _undefined,
    Object? requiresApprovingReviews = _undefined,
    Object? requiredApprovingReviewCount = _undefined,
    Object? requiresCommitSignatures = _undefined,
    Object? requiresLinearHistory = _undefined,
    Object? blocksCreations = _undefined,
    Object? allowsForcePushes = _undefined,
    Object? allowsDeletions = _undefined,
    Object? isAdminEnforced = _undefined,
    Object? requiresStatusChecks = _undefined,
    Object? requiresStrictStatusChecks = _undefined,
    Object? requiresCodeOwnerReviews = _undefined,
    Object? dismissesStaleReviews = _undefined,
    Object? restrictsReviewDismissals = _undefined,
    Object? reviewDismissalActorIds = _undefined,
    Object? bypassPullRequestActorIds = _undefined,
    Object? bypassForcePushActorIds = _undefined,
    Object? restrictsPushes = _undefined,
    Object? pushActorIds = _undefined,
    Object? requiredStatusCheckContexts = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? requiresDeployments = _undefined,
    Object? requiredDeploymentEnvironments = _undefined,
    Object? requiresConversationResolution = _undefined,
    Object? requireLastPushApproval = _undefined,
    Object? lockBranch = _undefined,
    Object? lockAllowsFetchAndMerge = _undefined,
  }) =>
      _then(Input$CreateBranchProtectionRuleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
        if (requiresApprovingReviews != _undefined)
          'requiresApprovingReviews': (requiresApprovingReviews as bool?),
        if (requiredApprovingReviewCount != _undefined)
          'requiredApprovingReviewCount':
              (requiredApprovingReviewCount as int?),
        if (requiresCommitSignatures != _undefined)
          'requiresCommitSignatures': (requiresCommitSignatures as bool?),
        if (requiresLinearHistory != _undefined)
          'requiresLinearHistory': (requiresLinearHistory as bool?),
        if (blocksCreations != _undefined)
          'blocksCreations': (blocksCreations as bool?),
        if (allowsForcePushes != _undefined)
          'allowsForcePushes': (allowsForcePushes as bool?),
        if (allowsDeletions != _undefined)
          'allowsDeletions': (allowsDeletions as bool?),
        if (isAdminEnforced != _undefined)
          'isAdminEnforced': (isAdminEnforced as bool?),
        if (requiresStatusChecks != _undefined)
          'requiresStatusChecks': (requiresStatusChecks as bool?),
        if (requiresStrictStatusChecks != _undefined)
          'requiresStrictStatusChecks': (requiresStrictStatusChecks as bool?),
        if (requiresCodeOwnerReviews != _undefined)
          'requiresCodeOwnerReviews': (requiresCodeOwnerReviews as bool?),
        if (dismissesStaleReviews != _undefined)
          'dismissesStaleReviews': (dismissesStaleReviews as bool?),
        if (restrictsReviewDismissals != _undefined)
          'restrictsReviewDismissals': (restrictsReviewDismissals as bool?),
        if (reviewDismissalActorIds != _undefined)
          'reviewDismissalActorIds': (reviewDismissalActorIds as List<String>?),
        if (bypassPullRequestActorIds != _undefined)
          'bypassPullRequestActorIds':
              (bypassPullRequestActorIds as List<String>?),
        if (bypassForcePushActorIds != _undefined)
          'bypassForcePushActorIds': (bypassForcePushActorIds as List<String>?),
        if (restrictsPushes != _undefined)
          'restrictsPushes': (restrictsPushes as bool?),
        if (pushActorIds != _undefined)
          'pushActorIds': (pushActorIds as List<String>?),
        if (requiredStatusCheckContexts != _undefined)
          'requiredStatusCheckContexts':
              (requiredStatusCheckContexts as List<String>?),
        if (requiredStatusChecks != _undefined)
          'requiredStatusChecks':
              (requiredStatusChecks as List<Input$RequiredStatusCheckInput>?),
        if (requiresDeployments != _undefined)
          'requiresDeployments': (requiresDeployments as bool?),
        if (requiredDeploymentEnvironments != _undefined)
          'requiredDeploymentEnvironments':
              (requiredDeploymentEnvironments as List<String>?),
        if (requiresConversationResolution != _undefined)
          'requiresConversationResolution':
              (requiresConversationResolution as bool?),
        if (requireLastPushApproval != _undefined)
          'requireLastPushApproval': (requireLastPushApproval as bool?),
        if (lockBranch != _undefined) 'lockBranch': (lockBranch as bool?),
        if (lockAllowsFetchAndMerge != _undefined)
          'lockAllowsFetchAndMerge': (lockAllowsFetchAndMerge as bool?),
      }));

  TRes requiredStatusChecks(
          Iterable<Input$RequiredStatusCheckInput>? Function(
                  Iterable<
                      CopyWith$Input$RequiredStatusCheckInput<
                          Input$RequiredStatusCheckInput>>?)
              _fn) =>
      call(
          requiredStatusChecks: _fn(_instance.requiredStatusChecks
              ?.map((e) => CopyWith$Input$RequiredStatusCheckInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresDeployments,
    List<String>? requiredDeploymentEnvironments,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
  }) =>
      _res;

  requiredStatusChecks(_fn) => _res;
}

class Input$CreateCheckRunInput {
  factory Input$CreateCheckRunInput({
    String? clientMutationId,
    required String repositoryId,
    required String name,
    required String headSha,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
  }) =>
      Input$CreateCheckRunInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'name': name,
        r'headSha': headSha,
        if (detailsUrl != null) r'detailsUrl': detailsUrl,
        if (externalId != null) r'externalId': externalId,
        if (status != null) r'status': status,
        if (startedAt != null) r'startedAt': startedAt,
        if (conclusion != null) r'conclusion': conclusion,
        if (completedAt != null) r'completedAt': completedAt,
        if (output != null) r'output': output,
        if (actions != null) r'actions': actions,
      });

  Input$CreateCheckRunInput._(this._$data);

  factory Input$CreateCheckRunInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    if (data.containsKey('detailsUrl')) {
      final l$detailsUrl = data['detailsUrl'];
      result$data['detailsUrl'] = (l$detailsUrl as String?);
    }
    if (data.containsKey('externalId')) {
      final l$externalId = data['externalId'];
      result$data['externalId'] = (l$externalId as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$RequestableCheckStatusState((l$status as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = (l$startedAt as String?);
    }
    if (data.containsKey('conclusion')) {
      final l$conclusion = data['conclusion'];
      result$data['conclusion'] = l$conclusion == null
          ? null
          : fromJson$Enum$CheckConclusionState((l$conclusion as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = (l$completedAt as String?);
    }
    if (data.containsKey('output')) {
      final l$output = data['output'];
      result$data['output'] = l$output == null
          ? null
          : Input$CheckRunOutput.fromJson((l$output as Map<String, dynamic>));
    }
    if (data.containsKey('actions')) {
      final l$actions = data['actions'];
      result$data['actions'] = (l$actions as List<dynamic>?)
          ?.map(
              (e) => Input$CheckRunAction.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CreateCheckRunInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get name => (_$data['name'] as String);

  String get headSha => (_$data['headSha'] as String);

  String? get detailsUrl => (_$data['detailsUrl'] as String?);

  String? get externalId => (_$data['externalId'] as String?);

  Enum$RequestableCheckStatusState? get status =>
      (_$data['status'] as Enum$RequestableCheckStatusState?);

  String? get startedAt => (_$data['startedAt'] as String?);

  Enum$CheckConclusionState? get conclusion =>
      (_$data['conclusion'] as Enum$CheckConclusionState?);

  String? get completedAt => (_$data['completedAt'] as String?);

  Input$CheckRunOutput? get output =>
      (_$data['output'] as Input$CheckRunOutput?);

  List<Input$CheckRunAction>? get actions =>
      (_$data['actions'] as List<Input$CheckRunAction>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    if (_$data.containsKey('detailsUrl')) {
      final l$detailsUrl = detailsUrl;
      result$data['detailsUrl'] = l$detailsUrl;
    }
    if (_$data.containsKey('externalId')) {
      final l$externalId = externalId;
      result$data['externalId'] = l$externalId;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$RequestableCheckStatusState(l$status);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt;
    }
    if (_$data.containsKey('conclusion')) {
      final l$conclusion = conclusion;
      result$data['conclusion'] = l$conclusion == null
          ? null
          : toJson$Enum$CheckConclusionState(l$conclusion);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt;
    }
    if (_$data.containsKey('output')) {
      final l$output = output;
      result$data['output'] = l$output?.toJson();
    }
    if (_$data.containsKey('actions')) {
      final l$actions = actions;
      result$data['actions'] = l$actions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateCheckRunInput<Input$CreateCheckRunInput> get copyWith =>
      CopyWith$Input$CreateCheckRunInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateCheckRunInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    final l$detailsUrl = detailsUrl;
    final lOther$detailsUrl = other.detailsUrl;
    if (_$data.containsKey('detailsUrl') !=
        other._$data.containsKey('detailsUrl')) {
      return false;
    }
    if (l$detailsUrl != lOther$detailsUrl) {
      return false;
    }
    final l$externalId = externalId;
    final lOther$externalId = other.externalId;
    if (_$data.containsKey('externalId') !=
        other._$data.containsKey('externalId')) {
      return false;
    }
    if (l$externalId != lOther$externalId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$conclusion = conclusion;
    final lOther$conclusion = other.conclusion;
    if (_$data.containsKey('conclusion') !=
        other._$data.containsKey('conclusion')) {
      return false;
    }
    if (l$conclusion != lOther$conclusion) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$output = output;
    final lOther$output = other.output;
    if (_$data.containsKey('output') != other._$data.containsKey('output')) {
      return false;
    }
    if (l$output != lOther$output) {
      return false;
    }
    final l$actions = actions;
    final lOther$actions = other.actions;
    if (_$data.containsKey('actions') != other._$data.containsKey('actions')) {
      return false;
    }
    if (l$actions != null && lOther$actions != null) {
      if (l$actions.length != lOther$actions.length) {
        return false;
      }
      for (int i = 0; i < l$actions.length; i++) {
        final l$actions$entry = l$actions[i];
        final lOther$actions$entry = lOther$actions[i];
        if (l$actions$entry != lOther$actions$entry) {
          return false;
        }
      }
    } else if (l$actions != lOther$actions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$headSha = headSha;
    final l$detailsUrl = detailsUrl;
    final l$externalId = externalId;
    final l$status = status;
    final l$startedAt = startedAt;
    final l$conclusion = conclusion;
    final l$completedAt = completedAt;
    final l$output = output;
    final l$actions = actions;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$name,
      l$headSha,
      _$data.containsKey('detailsUrl') ? l$detailsUrl : const {},
      _$data.containsKey('externalId') ? l$externalId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('conclusion') ? l$conclusion : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('output') ? l$output : const {},
      _$data.containsKey('actions')
          ? l$actions == null
              ? null
              : Object.hashAll(l$actions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateCheckRunInput<TRes> {
  factory CopyWith$Input$CreateCheckRunInput(
    Input$CreateCheckRunInput instance,
    TRes Function(Input$CreateCheckRunInput) then,
  ) = _CopyWithImpl$Input$CreateCheckRunInput;

  factory CopyWith$Input$CreateCheckRunInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCheckRunInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? headSha,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
  });
  CopyWith$Input$CheckRunOutput<TRes> get output;
  TRes actions(
      Iterable<Input$CheckRunAction>? Function(
              Iterable<CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateCheckRunInput<TRes>
    implements CopyWith$Input$CreateCheckRunInput<TRes> {
  _CopyWithImpl$Input$CreateCheckRunInput(
    this._instance,
    this._then,
  );

  final Input$CreateCheckRunInput _instance;

  final TRes Function(Input$CreateCheckRunInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? headSha = _undefined,
    Object? detailsUrl = _undefined,
    Object? externalId = _undefined,
    Object? status = _undefined,
    Object? startedAt = _undefined,
    Object? conclusion = _undefined,
    Object? completedAt = _undefined,
    Object? output = _undefined,
    Object? actions = _undefined,
  }) =>
      _then(Input$CreateCheckRunInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
        if (detailsUrl != _undefined) 'detailsUrl': (detailsUrl as String?),
        if (externalId != _undefined) 'externalId': (externalId as String?),
        if (status != _undefined)
          'status': (status as Enum$RequestableCheckStatusState?),
        if (startedAt != _undefined) 'startedAt': (startedAt as String?),
        if (conclusion != _undefined)
          'conclusion': (conclusion as Enum$CheckConclusionState?),
        if (completedAt != _undefined) 'completedAt': (completedAt as String?),
        if (output != _undefined) 'output': (output as Input$CheckRunOutput?),
        if (actions != _undefined)
          'actions': (actions as List<Input$CheckRunAction>?),
      }));

  CopyWith$Input$CheckRunOutput<TRes> get output {
    final local$output = _instance.output;
    return local$output == null
        ? CopyWith$Input$CheckRunOutput.stub(_then(_instance))
        : CopyWith$Input$CheckRunOutput(local$output, (e) => call(output: e));
  }

  TRes actions(
          Iterable<Input$CheckRunAction>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
              _fn) =>
      call(
          actions:
              _fn(_instance.actions?.map((e) => CopyWith$Input$CheckRunAction(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateCheckRunInput<TRes>
    implements CopyWith$Input$CreateCheckRunInput<TRes> {
  _CopyWithStubImpl$Input$CreateCheckRunInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? headSha,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
  }) =>
      _res;

  CopyWith$Input$CheckRunOutput<TRes> get output =>
      CopyWith$Input$CheckRunOutput.stub(_res);

  actions(_fn) => _res;
}

class Input$CreateCheckSuiteInput {
  factory Input$CreateCheckSuiteInput({
    String? clientMutationId,
    required String repositoryId,
    required String headSha,
  }) =>
      Input$CreateCheckSuiteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'headSha': headSha,
      });

  Input$CreateCheckSuiteInput._(this._$data);

  factory Input$CreateCheckSuiteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    return Input$CreateCheckSuiteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get headSha => (_$data['headSha'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    return result$data;
  }

  CopyWith$Input$CreateCheckSuiteInput<Input$CreateCheckSuiteInput>
      get copyWith => CopyWith$Input$CreateCheckSuiteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateCheckSuiteInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$headSha = headSha;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$headSha,
    ]);
  }
}

abstract class CopyWith$Input$CreateCheckSuiteInput<TRes> {
  factory CopyWith$Input$CreateCheckSuiteInput(
    Input$CreateCheckSuiteInput instance,
    TRes Function(Input$CreateCheckSuiteInput) then,
  ) = _CopyWithImpl$Input$CreateCheckSuiteInput;

  factory CopyWith$Input$CreateCheckSuiteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCheckSuiteInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? headSha,
  });
}

class _CopyWithImpl$Input$CreateCheckSuiteInput<TRes>
    implements CopyWith$Input$CreateCheckSuiteInput<TRes> {
  _CopyWithImpl$Input$CreateCheckSuiteInput(
    this._instance,
    this._then,
  );

  final Input$CreateCheckSuiteInput _instance;

  final TRes Function(Input$CreateCheckSuiteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? headSha = _undefined,
  }) =>
      _then(Input$CreateCheckSuiteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
      }));
}

class _CopyWithStubImpl$Input$CreateCheckSuiteInput<TRes>
    implements CopyWith$Input$CreateCheckSuiteInput<TRes> {
  _CopyWithStubImpl$Input$CreateCheckSuiteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? headSha,
  }) =>
      _res;
}

class Input$CreateCommitOnBranchInput {
  factory Input$CreateCommitOnBranchInput({
    String? clientMutationId,
    required Input$CommittableBranch branch,
    Input$FileChanges? fileChanges,
    required Input$CommitMessage message,
    required String expectedHeadOid,
  }) =>
      Input$CreateCommitOnBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'branch': branch,
        if (fileChanges != null) r'fileChanges': fileChanges,
        r'message': message,
        r'expectedHeadOid': expectedHeadOid,
      });

  Input$CreateCommitOnBranchInput._(this._$data);

  factory Input$CreateCommitOnBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$branch = data['branch'];
    result$data['branch'] =
        Input$CommittableBranch.fromJson((l$branch as Map<String, dynamic>));
    if (data.containsKey('fileChanges')) {
      final l$fileChanges = data['fileChanges'];
      result$data['fileChanges'] = l$fileChanges == null
          ? null
          : Input$FileChanges.fromJson((l$fileChanges as Map<String, dynamic>));
    }
    final l$message = data['message'];
    result$data['message'] =
        Input$CommitMessage.fromJson((l$message as Map<String, dynamic>));
    final l$expectedHeadOid = data['expectedHeadOid'];
    result$data['expectedHeadOid'] = (l$expectedHeadOid as String);
    return Input$CreateCommitOnBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  Input$CommittableBranch get branch =>
      (_$data['branch'] as Input$CommittableBranch);

  Input$FileChanges? get fileChanges =>
      (_$data['fileChanges'] as Input$FileChanges?);

  Input$CommitMessage get message => (_$data['message'] as Input$CommitMessage);

  String get expectedHeadOid => (_$data['expectedHeadOid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$branch = branch;
    result$data['branch'] = l$branch.toJson();
    if (_$data.containsKey('fileChanges')) {
      final l$fileChanges = fileChanges;
      result$data['fileChanges'] = l$fileChanges?.toJson();
    }
    final l$message = message;
    result$data['message'] = l$message.toJson();
    final l$expectedHeadOid = expectedHeadOid;
    result$data['expectedHeadOid'] = l$expectedHeadOid;
    return result$data;
  }

  CopyWith$Input$CreateCommitOnBranchInput<Input$CreateCommitOnBranchInput>
      get copyWith => CopyWith$Input$CreateCommitOnBranchInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateCommitOnBranchInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$branch = branch;
    final lOther$branch = other.branch;
    if (l$branch != lOther$branch) {
      return false;
    }
    final l$fileChanges = fileChanges;
    final lOther$fileChanges = other.fileChanges;
    if (_$data.containsKey('fileChanges') !=
        other._$data.containsKey('fileChanges')) {
      return false;
    }
    if (l$fileChanges != lOther$fileChanges) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$branch = branch;
    final l$fileChanges = fileChanges;
    final l$message = message;
    final l$expectedHeadOid = expectedHeadOid;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$branch,
      _$data.containsKey('fileChanges') ? l$fileChanges : const {},
      l$message,
      l$expectedHeadOid,
    ]);
  }
}

abstract class CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  factory CopyWith$Input$CreateCommitOnBranchInput(
    Input$CreateCommitOnBranchInput instance,
    TRes Function(Input$CreateCommitOnBranchInput) then,
  ) = _CopyWithImpl$Input$CreateCommitOnBranchInput;

  factory CopyWith$Input$CreateCommitOnBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCommitOnBranchInput;

  TRes call({
    String? clientMutationId,
    Input$CommittableBranch? branch,
    Input$FileChanges? fileChanges,
    Input$CommitMessage? message,
    String? expectedHeadOid,
  });
  CopyWith$Input$CommittableBranch<TRes> get branch;
  CopyWith$Input$FileChanges<TRes> get fileChanges;
  CopyWith$Input$CommitMessage<TRes> get message;
}

class _CopyWithImpl$Input$CreateCommitOnBranchInput<TRes>
    implements CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  _CopyWithImpl$Input$CreateCommitOnBranchInput(
    this._instance,
    this._then,
  );

  final Input$CreateCommitOnBranchInput _instance;

  final TRes Function(Input$CreateCommitOnBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? branch = _undefined,
    Object? fileChanges = _undefined,
    Object? message = _undefined,
    Object? expectedHeadOid = _undefined,
  }) =>
      _then(Input$CreateCommitOnBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (branch != _undefined && branch != null)
          'branch': (branch as Input$CommittableBranch),
        if (fileChanges != _undefined)
          'fileChanges': (fileChanges as Input$FileChanges?),
        if (message != _undefined && message != null)
          'message': (message as Input$CommitMessage),
        if (expectedHeadOid != _undefined && expectedHeadOid != null)
          'expectedHeadOid': (expectedHeadOid as String),
      }));

  CopyWith$Input$CommittableBranch<TRes> get branch {
    final local$branch = _instance.branch;
    return CopyWith$Input$CommittableBranch(
        local$branch, (e) => call(branch: e));
  }

  CopyWith$Input$FileChanges<TRes> get fileChanges {
    final local$fileChanges = _instance.fileChanges;
    return local$fileChanges == null
        ? CopyWith$Input$FileChanges.stub(_then(_instance))
        : CopyWith$Input$FileChanges(
            local$fileChanges, (e) => call(fileChanges: e));
  }

  CopyWith$Input$CommitMessage<TRes> get message {
    final local$message = _instance.message;
    return CopyWith$Input$CommitMessage(local$message, (e) => call(message: e));
  }
}

class _CopyWithStubImpl$Input$CreateCommitOnBranchInput<TRes>
    implements CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  _CopyWithStubImpl$Input$CreateCommitOnBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Input$CommittableBranch? branch,
    Input$FileChanges? fileChanges,
    Input$CommitMessage? message,
    String? expectedHeadOid,
  }) =>
      _res;

  CopyWith$Input$CommittableBranch<TRes> get branch =>
      CopyWith$Input$CommittableBranch.stub(_res);

  CopyWith$Input$FileChanges<TRes> get fileChanges =>
      CopyWith$Input$FileChanges.stub(_res);

  CopyWith$Input$CommitMessage<TRes> get message =>
      CopyWith$Input$CommitMessage.stub(_res);
}

class Input$CreateDeploymentInput {
  factory Input$CreateDeploymentInput({
    String? clientMutationId,
    required String repositoryId,
    required String refId,
    bool? autoMerge,
    List<String>? requiredContexts,
    String? description,
    String? environment,
    String? task,
    String? payload,
  }) =>
      Input$CreateDeploymentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'refId': refId,
        if (autoMerge != null) r'autoMerge': autoMerge,
        if (requiredContexts != null) r'requiredContexts': requiredContexts,
        if (description != null) r'description': description,
        if (environment != null) r'environment': environment,
        if (task != null) r'task': task,
        if (payload != null) r'payload': payload,
      });

  Input$CreateDeploymentInput._(this._$data);

  factory Input$CreateDeploymentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    if (data.containsKey('autoMerge')) {
      final l$autoMerge = data['autoMerge'];
      result$data['autoMerge'] = (l$autoMerge as bool?);
    }
    if (data.containsKey('requiredContexts')) {
      final l$requiredContexts = data['requiredContexts'];
      result$data['requiredContexts'] = (l$requiredContexts as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('environment')) {
      final l$environment = data['environment'];
      result$data['environment'] = (l$environment as String?);
    }
    if (data.containsKey('task')) {
      final l$task = data['task'];
      result$data['task'] = (l$task as String?);
    }
    if (data.containsKey('payload')) {
      final l$payload = data['payload'];
      result$data['payload'] = (l$payload as String?);
    }
    return Input$CreateDeploymentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get refId => (_$data['refId'] as String);

  bool? get autoMerge => (_$data['autoMerge'] as bool?);

  List<String>? get requiredContexts =>
      (_$data['requiredContexts'] as List<String>?);

  String? get description => (_$data['description'] as String?);

  String? get environment => (_$data['environment'] as String?);

  String? get task => (_$data['task'] as String?);

  String? get payload => (_$data['payload'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$refId = refId;
    result$data['refId'] = l$refId;
    if (_$data.containsKey('autoMerge')) {
      final l$autoMerge = autoMerge;
      result$data['autoMerge'] = l$autoMerge;
    }
    if (_$data.containsKey('requiredContexts')) {
      final l$requiredContexts = requiredContexts;
      result$data['requiredContexts'] =
          l$requiredContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('environment')) {
      final l$environment = environment;
      result$data['environment'] = l$environment;
    }
    if (_$data.containsKey('task')) {
      final l$task = task;
      result$data['task'] = l$task;
    }
    if (_$data.containsKey('payload')) {
      final l$payload = payload;
      result$data['payload'] = l$payload;
    }
    return result$data;
  }

  CopyWith$Input$CreateDeploymentInput<Input$CreateDeploymentInput>
      get copyWith => CopyWith$Input$CreateDeploymentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateDeploymentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$autoMerge = autoMerge;
    final lOther$autoMerge = other.autoMerge;
    if (_$data.containsKey('autoMerge') !=
        other._$data.containsKey('autoMerge')) {
      return false;
    }
    if (l$autoMerge != lOther$autoMerge) {
      return false;
    }
    final l$requiredContexts = requiredContexts;
    final lOther$requiredContexts = other.requiredContexts;
    if (_$data.containsKey('requiredContexts') !=
        other._$data.containsKey('requiredContexts')) {
      return false;
    }
    if (l$requiredContexts != null && lOther$requiredContexts != null) {
      if (l$requiredContexts.length != lOther$requiredContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredContexts.length; i++) {
        final l$requiredContexts$entry = l$requiredContexts[i];
        final lOther$requiredContexts$entry = lOther$requiredContexts[i];
        if (l$requiredContexts$entry != lOther$requiredContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredContexts != lOther$requiredContexts) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$environment = environment;
    final lOther$environment = other.environment;
    if (_$data.containsKey('environment') !=
        other._$data.containsKey('environment')) {
      return false;
    }
    if (l$environment != lOther$environment) {
      return false;
    }
    final l$task = task;
    final lOther$task = other.task;
    if (_$data.containsKey('task') != other._$data.containsKey('task')) {
      return false;
    }
    if (l$task != lOther$task) {
      return false;
    }
    final l$payload = payload;
    final lOther$payload = other.payload;
    if (_$data.containsKey('payload') != other._$data.containsKey('payload')) {
      return false;
    }
    if (l$payload != lOther$payload) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$refId = refId;
    final l$autoMerge = autoMerge;
    final l$requiredContexts = requiredContexts;
    final l$description = description;
    final l$environment = environment;
    final l$task = task;
    final l$payload = payload;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$refId,
      _$data.containsKey('autoMerge') ? l$autoMerge : const {},
      _$data.containsKey('requiredContexts')
          ? l$requiredContexts == null
              ? null
              : Object.hashAll(l$requiredContexts.map((v) => v))
          : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('environment') ? l$environment : const {},
      _$data.containsKey('task') ? l$task : const {},
      _$data.containsKey('payload') ? l$payload : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateDeploymentInput<TRes> {
  factory CopyWith$Input$CreateDeploymentInput(
    Input$CreateDeploymentInput instance,
    TRes Function(Input$CreateDeploymentInput) then,
  ) = _CopyWithImpl$Input$CreateDeploymentInput;

  factory CopyWith$Input$CreateDeploymentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDeploymentInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? refId,
    bool? autoMerge,
    List<String>? requiredContexts,
    String? description,
    String? environment,
    String? task,
    String? payload,
  });
}

class _CopyWithImpl$Input$CreateDeploymentInput<TRes>
    implements CopyWith$Input$CreateDeploymentInput<TRes> {
  _CopyWithImpl$Input$CreateDeploymentInput(
    this._instance,
    this._then,
  );

  final Input$CreateDeploymentInput _instance;

  final TRes Function(Input$CreateDeploymentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? refId = _undefined,
    Object? autoMerge = _undefined,
    Object? requiredContexts = _undefined,
    Object? description = _undefined,
    Object? environment = _undefined,
    Object? task = _undefined,
    Object? payload = _undefined,
  }) =>
      _then(Input$CreateDeploymentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (refId != _undefined && refId != null) 'refId': (refId as String),
        if (autoMerge != _undefined) 'autoMerge': (autoMerge as bool?),
        if (requiredContexts != _undefined)
          'requiredContexts': (requiredContexts as List<String>?),
        if (description != _undefined) 'description': (description as String?),
        if (environment != _undefined) 'environment': (environment as String?),
        if (task != _undefined) 'task': (task as String?),
        if (payload != _undefined) 'payload': (payload as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateDeploymentInput<TRes>
    implements CopyWith$Input$CreateDeploymentInput<TRes> {
  _CopyWithStubImpl$Input$CreateDeploymentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? refId,
    bool? autoMerge,
    List<String>? requiredContexts,
    String? description,
    String? environment,
    String? task,
    String? payload,
  }) =>
      _res;
}

class Input$CreateDeploymentStatusInput {
  factory Input$CreateDeploymentStatusInput({
    String? clientMutationId,
    required String deploymentId,
    required Enum$DeploymentStatusState state,
    String? description,
    String? environment,
    String? environmentUrl,
    bool? autoInactive,
    String? logUrl,
  }) =>
      Input$CreateDeploymentStatusInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'deploymentId': deploymentId,
        r'state': state,
        if (description != null) r'description': description,
        if (environment != null) r'environment': environment,
        if (environmentUrl != null) r'environmentUrl': environmentUrl,
        if (autoInactive != null) r'autoInactive': autoInactive,
        if (logUrl != null) r'logUrl': logUrl,
      });

  Input$CreateDeploymentStatusInput._(this._$data);

  factory Input$CreateDeploymentStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$deploymentId = data['deploymentId'];
    result$data['deploymentId'] = (l$deploymentId as String);
    final l$state = data['state'];
    result$data['state'] =
        fromJson$Enum$DeploymentStatusState((l$state as String));
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('environment')) {
      final l$environment = data['environment'];
      result$data['environment'] = (l$environment as String?);
    }
    if (data.containsKey('environmentUrl')) {
      final l$environmentUrl = data['environmentUrl'];
      result$data['environmentUrl'] = (l$environmentUrl as String?);
    }
    if (data.containsKey('autoInactive')) {
      final l$autoInactive = data['autoInactive'];
      result$data['autoInactive'] = (l$autoInactive as bool?);
    }
    if (data.containsKey('logUrl')) {
      final l$logUrl = data['logUrl'];
      result$data['logUrl'] = (l$logUrl as String?);
    }
    return Input$CreateDeploymentStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get deploymentId => (_$data['deploymentId'] as String);

  Enum$DeploymentStatusState get state =>
      (_$data['state'] as Enum$DeploymentStatusState);

  String? get description => (_$data['description'] as String?);

  String? get environment => (_$data['environment'] as String?);

  String? get environmentUrl => (_$data['environmentUrl'] as String?);

  bool? get autoInactive => (_$data['autoInactive'] as bool?);

  String? get logUrl => (_$data['logUrl'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$deploymentId = deploymentId;
    result$data['deploymentId'] = l$deploymentId;
    final l$state = state;
    result$data['state'] = toJson$Enum$DeploymentStatusState(l$state);
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('environment')) {
      final l$environment = environment;
      result$data['environment'] = l$environment;
    }
    if (_$data.containsKey('environmentUrl')) {
      final l$environmentUrl = environmentUrl;
      result$data['environmentUrl'] = l$environmentUrl;
    }
    if (_$data.containsKey('autoInactive')) {
      final l$autoInactive = autoInactive;
      result$data['autoInactive'] = l$autoInactive;
    }
    if (_$data.containsKey('logUrl')) {
      final l$logUrl = logUrl;
      result$data['logUrl'] = l$logUrl;
    }
    return result$data;
  }

  CopyWith$Input$CreateDeploymentStatusInput<Input$CreateDeploymentStatusInput>
      get copyWith => CopyWith$Input$CreateDeploymentStatusInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateDeploymentStatusInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$deploymentId = deploymentId;
    final lOther$deploymentId = other.deploymentId;
    if (l$deploymentId != lOther$deploymentId) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (l$state != lOther$state) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$environment = environment;
    final lOther$environment = other.environment;
    if (_$data.containsKey('environment') !=
        other._$data.containsKey('environment')) {
      return false;
    }
    if (l$environment != lOther$environment) {
      return false;
    }
    final l$environmentUrl = environmentUrl;
    final lOther$environmentUrl = other.environmentUrl;
    if (_$data.containsKey('environmentUrl') !=
        other._$data.containsKey('environmentUrl')) {
      return false;
    }
    if (l$environmentUrl != lOther$environmentUrl) {
      return false;
    }
    final l$autoInactive = autoInactive;
    final lOther$autoInactive = other.autoInactive;
    if (_$data.containsKey('autoInactive') !=
        other._$data.containsKey('autoInactive')) {
      return false;
    }
    if (l$autoInactive != lOther$autoInactive) {
      return false;
    }
    final l$logUrl = logUrl;
    final lOther$logUrl = other.logUrl;
    if (_$data.containsKey('logUrl') != other._$data.containsKey('logUrl')) {
      return false;
    }
    if (l$logUrl != lOther$logUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$deploymentId = deploymentId;
    final l$state = state;
    final l$description = description;
    final l$environment = environment;
    final l$environmentUrl = environmentUrl;
    final l$autoInactive = autoInactive;
    final l$logUrl = logUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$deploymentId,
      l$state,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('environment') ? l$environment : const {},
      _$data.containsKey('environmentUrl') ? l$environmentUrl : const {},
      _$data.containsKey('autoInactive') ? l$autoInactive : const {},
      _$data.containsKey('logUrl') ? l$logUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateDeploymentStatusInput<TRes> {
  factory CopyWith$Input$CreateDeploymentStatusInput(
    Input$CreateDeploymentStatusInput instance,
    TRes Function(Input$CreateDeploymentStatusInput) then,
  ) = _CopyWithImpl$Input$CreateDeploymentStatusInput;

  factory CopyWith$Input$CreateDeploymentStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDeploymentStatusInput;

  TRes call({
    String? clientMutationId,
    String? deploymentId,
    Enum$DeploymentStatusState? state,
    String? description,
    String? environment,
    String? environmentUrl,
    bool? autoInactive,
    String? logUrl,
  });
}

class _CopyWithImpl$Input$CreateDeploymentStatusInput<TRes>
    implements CopyWith$Input$CreateDeploymentStatusInput<TRes> {
  _CopyWithImpl$Input$CreateDeploymentStatusInput(
    this._instance,
    this._then,
  );

  final Input$CreateDeploymentStatusInput _instance;

  final TRes Function(Input$CreateDeploymentStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? deploymentId = _undefined,
    Object? state = _undefined,
    Object? description = _undefined,
    Object? environment = _undefined,
    Object? environmentUrl = _undefined,
    Object? autoInactive = _undefined,
    Object? logUrl = _undefined,
  }) =>
      _then(Input$CreateDeploymentStatusInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (deploymentId != _undefined && deploymentId != null)
          'deploymentId': (deploymentId as String),
        if (state != _undefined && state != null)
          'state': (state as Enum$DeploymentStatusState),
        if (description != _undefined) 'description': (description as String?),
        if (environment != _undefined) 'environment': (environment as String?),
        if (environmentUrl != _undefined)
          'environmentUrl': (environmentUrl as String?),
        if (autoInactive != _undefined) 'autoInactive': (autoInactive as bool?),
        if (logUrl != _undefined) 'logUrl': (logUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateDeploymentStatusInput<TRes>
    implements CopyWith$Input$CreateDeploymentStatusInput<TRes> {
  _CopyWithStubImpl$Input$CreateDeploymentStatusInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? deploymentId,
    Enum$DeploymentStatusState? state,
    String? description,
    String? environment,
    String? environmentUrl,
    bool? autoInactive,
    String? logUrl,
  }) =>
      _res;
}

class Input$CreateDiscussionInput {
  factory Input$CreateDiscussionInput({
    String? clientMutationId,
    required String repositoryId,
    required String title,
    required String body,
    required String categoryId,
  }) =>
      Input$CreateDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'title': title,
        r'body': body,
        r'categoryId': categoryId,
      });

  Input$CreateDiscussionInput._(this._$data);

  factory Input$CreateDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    final l$categoryId = data['categoryId'];
    result$data['categoryId'] = (l$categoryId as String);
    return Input$CreateDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get title => (_$data['title'] as String);

  String get body => (_$data['body'] as String);

  String get categoryId => (_$data['categoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$title = title;
    result$data['title'] = l$title;
    final l$body = body;
    result$data['body'] = l$body;
    final l$categoryId = categoryId;
    result$data['categoryId'] = l$categoryId;
    return result$data;
  }

  CopyWith$Input$CreateDiscussionInput<Input$CreateDiscussionInput>
      get copyWith => CopyWith$Input$CreateDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$categoryId = categoryId;
    final lOther$categoryId = other.categoryId;
    if (l$categoryId != lOther$categoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$title = title;
    final l$body = body;
    final l$categoryId = categoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$title,
      l$body,
      l$categoryId,
    ]);
  }
}

abstract class CopyWith$Input$CreateDiscussionInput<TRes> {
  factory CopyWith$Input$CreateDiscussionInput(
    Input$CreateDiscussionInput instance,
    TRes Function(Input$CreateDiscussionInput) then,
  ) = _CopyWithImpl$Input$CreateDiscussionInput;

  factory CopyWith$Input$CreateDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? title,
    String? body,
    String? categoryId,
  });
}

class _CopyWithImpl$Input$CreateDiscussionInput<TRes>
    implements CopyWith$Input$CreateDiscussionInput<TRes> {
  _CopyWithImpl$Input$CreateDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CreateDiscussionInput _instance;

  final TRes Function(Input$CreateDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? categoryId = _undefined,
  }) =>
      _then(Input$CreateDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (categoryId != _undefined && categoryId != null)
          'categoryId': (categoryId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateDiscussionInput<TRes>
    implements CopyWith$Input$CreateDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CreateDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? title,
    String? body,
    String? categoryId,
  }) =>
      _res;
}

class Input$CreateEnterpriseOrganizationInput {
  factory Input$CreateEnterpriseOrganizationInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
    required String profileName,
    required String billingEmail,
    required List<String> adminLogins,
  }) =>
      Input$CreateEnterpriseOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
        r'profileName': profileName,
        r'billingEmail': billingEmail,
        r'adminLogins': adminLogins,
      });

  Input$CreateEnterpriseOrganizationInput._(this._$data);

  factory Input$CreateEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    final l$profileName = data['profileName'];
    result$data['profileName'] = (l$profileName as String);
    final l$billingEmail = data['billingEmail'];
    result$data['billingEmail'] = (l$billingEmail as String);
    final l$adminLogins = data['adminLogins'];
    result$data['adminLogins'] =
        (l$adminLogins as List<dynamic>).map((e) => (e as String)).toList();
    return Input$CreateEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get login => (_$data['login'] as String);

  String get profileName => (_$data['profileName'] as String);

  String get billingEmail => (_$data['billingEmail'] as String);

  List<String> get adminLogins => (_$data['adminLogins'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    final l$profileName = profileName;
    result$data['profileName'] = l$profileName;
    final l$billingEmail = billingEmail;
    result$data['billingEmail'] = l$billingEmail;
    final l$adminLogins = adminLogins;
    result$data['adminLogins'] = l$adminLogins.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$CreateEnterpriseOrganizationInput<
          Input$CreateEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$CreateEnterpriseOrganizationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateEnterpriseOrganizationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$profileName = profileName;
    final lOther$profileName = other.profileName;
    if (l$profileName != lOther$profileName) {
      return false;
    }
    final l$billingEmail = billingEmail;
    final lOther$billingEmail = other.billingEmail;
    if (l$billingEmail != lOther$billingEmail) {
      return false;
    }
    final l$adminLogins = adminLogins;
    final lOther$adminLogins = other.adminLogins;
    if (l$adminLogins.length != lOther$adminLogins.length) {
      return false;
    }
    for (int i = 0; i < l$adminLogins.length; i++) {
      final l$adminLogins$entry = l$adminLogins[i];
      final lOther$adminLogins$entry = lOther$adminLogins[i];
      if (l$adminLogins$entry != lOther$adminLogins$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$profileName = profileName;
    final l$billingEmail = billingEmail;
    final l$adminLogins = adminLogins;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
      l$profileName,
      l$billingEmail,
      Object.hashAll(l$adminLogins.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$CreateEnterpriseOrganizationInput(
    Input$CreateEnterpriseOrganizationInput instance,
    TRes Function(Input$CreateEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$CreateEnterpriseOrganizationInput;

  factory CopyWith$Input$CreateEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    String? profileName,
    String? billingEmail,
    List<String>? adminLogins,
  });
}

class _CopyWithImpl$Input$CreateEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$CreateEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnterpriseOrganizationInput _instance;

  final TRes Function(Input$CreateEnterpriseOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? profileName = _undefined,
    Object? billingEmail = _undefined,
    Object? adminLogins = _undefined,
  }) =>
      _then(Input$CreateEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (profileName != _undefined && profileName != null)
          'profileName': (profileName as String),
        if (billingEmail != _undefined && billingEmail != null)
          'billingEmail': (billingEmail as String),
        if (adminLogins != _undefined && adminLogins != null)
          'adminLogins': (adminLogins as List<String>),
      }));
}

class _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    String? profileName,
    String? billingEmail,
    List<String>? adminLogins,
  }) =>
      _res;
}

class Input$CreateEnvironmentInput {
  factory Input$CreateEnvironmentInput({
    String? clientMutationId,
    required String repositoryId,
    required String name,
  }) =>
      Input$CreateEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'name': name,
      });

  Input$CreateEnvironmentInput._(this._$data);

  factory Input$CreateEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$CreateEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get name => (_$data['name'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$CreateEnvironmentInput<Input$CreateEnvironmentInput>
      get copyWith => CopyWith$Input$CreateEnvironmentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateEnvironmentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$CreateEnvironmentInput<TRes> {
  factory CopyWith$Input$CreateEnvironmentInput(
    Input$CreateEnvironmentInput instance,
    TRes Function(Input$CreateEnvironmentInput) then,
  ) = _CopyWithImpl$Input$CreateEnvironmentInput;

  factory CopyWith$Input$CreateEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
  });
}

class _CopyWithImpl$Input$CreateEnvironmentInput<TRes>
    implements CopyWith$Input$CreateEnvironmentInput<TRes> {
  _CopyWithImpl$Input$CreateEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnvironmentInput _instance;

  final TRes Function(Input$CreateEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$CreateEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$CreateEnvironmentInput<TRes>
    implements CopyWith$Input$CreateEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
  }) =>
      _res;
}

class Input$CreateIpAllowListEntryInput {
  factory Input$CreateIpAllowListEntryInput({
    String? clientMutationId,
    required String ownerId,
    required String allowListValue,
    String? name,
    required bool isActive,
  }) =>
      Input$CreateIpAllowListEntryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'allowListValue': allowListValue,
        if (name != null) r'name': name,
        r'isActive': isActive,
      });

  Input$CreateIpAllowListEntryInput._(this._$data);

  factory Input$CreateIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$allowListValue = data['allowListValue'];
    result$data['allowListValue'] = (l$allowListValue as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    return Input$CreateIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  String get allowListValue => (_$data['allowListValue'] as String);

  String? get name => (_$data['name'] as String?);

  bool get isActive => (_$data['isActive'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$allowListValue = allowListValue;
    result$data['allowListValue'] = l$allowListValue;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    return result$data;
  }

  CopyWith$Input$CreateIpAllowListEntryInput<Input$CreateIpAllowListEntryInput>
      get copyWith => CopyWith$Input$CreateIpAllowListEntryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateIpAllowListEntryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$allowListValue = allowListValue;
    final lOther$allowListValue = other.allowListValue;
    if (l$allowListValue != lOther$allowListValue) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$allowListValue = allowListValue;
    final l$name = name;
    final l$isActive = isActive;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$allowListValue,
      _$data.containsKey('name') ? l$name : const {},
      l$isActive,
    ]);
  }
}

abstract class CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$CreateIpAllowListEntryInput(
    Input$CreateIpAllowListEntryInput instance,
    TRes Function(Input$CreateIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$CreateIpAllowListEntryInput;

  factory CopyWith$Input$CreateIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIpAllowListEntryInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    String? allowListValue,
    String? name,
    bool? isActive,
  });
}

class _CopyWithImpl$Input$CreateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$CreateIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$CreateIpAllowListEntryInput _instance;

  final TRes Function(Input$CreateIpAllowListEntryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? allowListValue = _undefined,
    Object? name = _undefined,
    Object? isActive = _undefined,
  }) =>
      _then(Input$CreateIpAllowListEntryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (allowListValue != _undefined && allowListValue != null)
          'allowListValue': (allowListValue as String),
        if (name != _undefined) 'name': (name as String?),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
      }));
}

class _CopyWithStubImpl$Input$CreateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$CreateIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    String? allowListValue,
    String? name,
    bool? isActive,
  }) =>
      _res;
}

class Input$CreateIssueInput {
  factory Input$CreateIssueInput({
    String? clientMutationId,
    required String repositoryId,
    required String title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? issueTemplate,
    String? issueTypeId,
    String? parentIssueId,
  }) =>
      Input$CreateIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (labelIds != null) r'labelIds': labelIds,
        if (projectIds != null) r'projectIds': projectIds,
        if (issueTemplate != null) r'issueTemplate': issueTemplate,
        if (issueTypeId != null) r'issueTypeId': issueTypeId,
        if (parentIssueId != null) r'parentIssueId': parentIssueId,
      });

  Input$CreateIssueInput._(this._$data);

  factory Input$CreateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('issueTemplate')) {
      final l$issueTemplate = data['issueTemplate'];
      result$data['issueTemplate'] = (l$issueTemplate as String?);
    }
    if (data.containsKey('issueTypeId')) {
      final l$issueTypeId = data['issueTypeId'];
      result$data['issueTypeId'] = (l$issueTypeId as String?);
    }
    if (data.containsKey('parentIssueId')) {
      final l$parentIssueId = data['parentIssueId'];
      result$data['parentIssueId'] = (l$parentIssueId as String?);
    }
    return Input$CreateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get title => (_$data['title'] as String);

  String? get body => (_$data['body'] as String?);

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);

  String? get milestoneId => (_$data['milestoneId'] as String?);

  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);

  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);

  String? get issueTemplate => (_$data['issueTemplate'] as String?);

  String? get issueTypeId => (_$data['issueTypeId'] as String?);

  String? get parentIssueId => (_$data['parentIssueId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('issueTemplate')) {
      final l$issueTemplate = issueTemplate;
      result$data['issueTemplate'] = l$issueTemplate;
    }
    if (_$data.containsKey('issueTypeId')) {
      final l$issueTypeId = issueTypeId;
      result$data['issueTypeId'] = l$issueTypeId;
    }
    if (_$data.containsKey('parentIssueId')) {
      final l$parentIssueId = parentIssueId;
      result$data['parentIssueId'] = l$parentIssueId;
    }
    return result$data;
  }

  CopyWith$Input$CreateIssueInput<Input$CreateIssueInput> get copyWith =>
      CopyWith$Input$CreateIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$issueTemplate = issueTemplate;
    final lOther$issueTemplate = other.issueTemplate;
    if (_$data.containsKey('issueTemplate') !=
        other._$data.containsKey('issueTemplate')) {
      return false;
    }
    if (l$issueTemplate != lOther$issueTemplate) {
      return false;
    }
    final l$issueTypeId = issueTypeId;
    final lOther$issueTypeId = other.issueTypeId;
    if (_$data.containsKey('issueTypeId') !=
        other._$data.containsKey('issueTypeId')) {
      return false;
    }
    if (l$issueTypeId != lOther$issueTypeId) {
      return false;
    }
    final l$parentIssueId = parentIssueId;
    final lOther$parentIssueId = other.parentIssueId;
    if (_$data.containsKey('parentIssueId') !=
        other._$data.containsKey('parentIssueId')) {
      return false;
    }
    if (l$parentIssueId != lOther$parentIssueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$milestoneId = milestoneId;
    final l$labelIds = labelIds;
    final l$projectIds = projectIds;
    final l$issueTemplate = issueTemplate;
    final l$issueTypeId = issueTypeId;
    final l$parentIssueId = parentIssueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$title,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      _$data.containsKey('issueTemplate') ? l$issueTemplate : const {},
      _$data.containsKey('issueTypeId') ? l$issueTypeId : const {},
      _$data.containsKey('parentIssueId') ? l$parentIssueId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateIssueInput<TRes> {
  factory CopyWith$Input$CreateIssueInput(
    Input$CreateIssueInput instance,
    TRes Function(Input$CreateIssueInput) then,
  ) = _CopyWithImpl$Input$CreateIssueInput;

  factory CopyWith$Input$CreateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIssueInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? issueTemplate,
    String? issueTypeId,
    String? parentIssueId,
  });
}

class _CopyWithImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithImpl$Input$CreateIssueInput(
    this._instance,
    this._then,
  );

  final Input$CreateIssueInput _instance;

  final TRes Function(Input$CreateIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? milestoneId = _undefined,
    Object? labelIds = _undefined,
    Object? projectIds = _undefined,
    Object? issueTemplate = _undefined,
    Object? issueTypeId = _undefined,
    Object? parentIssueId = _undefined,
  }) =>
      _then(Input$CreateIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (issueTemplate != _undefined)
          'issueTemplate': (issueTemplate as String?),
        if (issueTypeId != _undefined) 'issueTypeId': (issueTypeId as String?),
        if (parentIssueId != _undefined)
          'parentIssueId': (parentIssueId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithStubImpl$Input$CreateIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
    String? issueTemplate,
    String? issueTypeId,
    String? parentIssueId,
  }) =>
      _res;
}

class Input$CreateIssueTypeInput {
  factory Input$CreateIssueTypeInput({
    String? clientMutationId,
    required String ownerId,
    required bool isEnabled,
    required String name,
    String? description,
    Enum$IssueTypeColor? color,
  }) =>
      Input$CreateIssueTypeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'isEnabled': isEnabled,
        r'name': name,
        if (description != null) r'description': description,
        if (color != null) r'color': color,
      });

  Input$CreateIssueTypeInput._(this._$data);

  factory Input$CreateIssueTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$isEnabled = data['isEnabled'];
    result$data['isEnabled'] = (l$isEnabled as bool);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : fromJson$Enum$IssueTypeColor((l$color as String));
    }
    return Input$CreateIssueTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  bool get isEnabled => (_$data['isEnabled'] as bool);

  String get name => (_$data['name'] as String);

  String? get description => (_$data['description'] as String?);

  Enum$IssueTypeColor? get color => (_$data['color'] as Enum$IssueTypeColor?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$isEnabled = isEnabled;
    result$data['isEnabled'] = l$isEnabled;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] =
          l$color == null ? null : toJson$Enum$IssueTypeColor(l$color);
    }
    return result$data;
  }

  CopyWith$Input$CreateIssueTypeInput<Input$CreateIssueTypeInput>
      get copyWith => CopyWith$Input$CreateIssueTypeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateIssueTypeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$isEnabled = isEnabled;
    final lOther$isEnabled = other.isEnabled;
    if (l$isEnabled != lOther$isEnabled) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$isEnabled = isEnabled;
    final l$name = name;
    final l$description = description;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$isEnabled,
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateIssueTypeInput<TRes> {
  factory CopyWith$Input$CreateIssueTypeInput(
    Input$CreateIssueTypeInput instance,
    TRes Function(Input$CreateIssueTypeInput) then,
  ) = _CopyWithImpl$Input$CreateIssueTypeInput;

  factory CopyWith$Input$CreateIssueTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIssueTypeInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    bool? isEnabled,
    String? name,
    String? description,
    Enum$IssueTypeColor? color,
  });
}

class _CopyWithImpl$Input$CreateIssueTypeInput<TRes>
    implements CopyWith$Input$CreateIssueTypeInput<TRes> {
  _CopyWithImpl$Input$CreateIssueTypeInput(
    this._instance,
    this._then,
  );

  final Input$CreateIssueTypeInput _instance;

  final TRes Function(Input$CreateIssueTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? isEnabled = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$CreateIssueTypeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (isEnabled != _undefined && isEnabled != null)
          'isEnabled': (isEnabled as bool),
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined) 'description': (description as String?),
        if (color != _undefined) 'color': (color as Enum$IssueTypeColor?),
      }));
}

class _CopyWithStubImpl$Input$CreateIssueTypeInput<TRes>
    implements CopyWith$Input$CreateIssueTypeInput<TRes> {
  _CopyWithStubImpl$Input$CreateIssueTypeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    bool? isEnabled,
    String? name,
    String? description,
    Enum$IssueTypeColor? color,
  }) =>
      _res;
}

class Input$CreateLabelInput {
  factory Input$CreateLabelInput({
    String? clientMutationId,
    required String repositoryId,
    required String color,
    required String name,
    String? description,
  }) =>
      Input$CreateLabelInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'color': color,
        r'name': name,
        if (description != null) r'description': description,
      });

  Input$CreateLabelInput._(this._$data);

  factory Input$CreateLabelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$color = data['color'];
    result$data['color'] = (l$color as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    return Input$CreateLabelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get color => (_$data['color'] as String);

  String get name => (_$data['name'] as String);

  String? get description => (_$data['description'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$color = color;
    result$data['color'] = l$color;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    return result$data;
  }

  CopyWith$Input$CreateLabelInput<Input$CreateLabelInput> get copyWith =>
      CopyWith$Input$CreateLabelInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateLabelInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$color = color;
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$color,
      l$name,
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateLabelInput<TRes> {
  factory CopyWith$Input$CreateLabelInput(
    Input$CreateLabelInput instance,
    TRes Function(Input$CreateLabelInput) then,
  ) = _CopyWithImpl$Input$CreateLabelInput;

  factory CopyWith$Input$CreateLabelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateLabelInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? color,
    String? name,
    String? description,
  });
}

class _CopyWithImpl$Input$CreateLabelInput<TRes>
    implements CopyWith$Input$CreateLabelInput<TRes> {
  _CopyWithImpl$Input$CreateLabelInput(
    this._instance,
    this._then,
  );

  final Input$CreateLabelInput _instance;

  final TRes Function(Input$CreateLabelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? color = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$CreateLabelInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (color != _undefined && color != null) 'color': (color as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined) 'description': (description as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateLabelInput<TRes>
    implements CopyWith$Input$CreateLabelInput<TRes> {
  _CopyWithStubImpl$Input$CreateLabelInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? color,
    String? name,
    String? description,
  }) =>
      _res;
}

class Input$CreateLinkedBranchInput {
  factory Input$CreateLinkedBranchInput({
    String? clientMutationId,
    required String issueId,
    required String oid,
    String? name,
    String? repositoryId,
  }) =>
      Input$CreateLinkedBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        r'oid': oid,
        if (name != null) r'name': name,
        if (repositoryId != null) r'repositoryId': repositoryId,
      });

  Input$CreateLinkedBranchInput._(this._$data);

  factory Input$CreateLinkedBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    return Input$CreateLinkedBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  String get oid => (_$data['oid'] as String);

  String? get name => (_$data['name'] as String?);

  String? get repositoryId => (_$data['repositoryId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$oid = oid;
    result$data['oid'] = l$oid;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    return result$data;
  }

  CopyWith$Input$CreateLinkedBranchInput<Input$CreateLinkedBranchInput>
      get copyWith => CopyWith$Input$CreateLinkedBranchInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateLinkedBranchInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$oid = oid;
    final l$name = name;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      l$oid,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateLinkedBranchInput<TRes> {
  factory CopyWith$Input$CreateLinkedBranchInput(
    Input$CreateLinkedBranchInput instance,
    TRes Function(Input$CreateLinkedBranchInput) then,
  ) = _CopyWithImpl$Input$CreateLinkedBranchInput;

  factory CopyWith$Input$CreateLinkedBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateLinkedBranchInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? oid,
    String? name,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$CreateLinkedBranchInput<TRes>
    implements CopyWith$Input$CreateLinkedBranchInput<TRes> {
  _CopyWithImpl$Input$CreateLinkedBranchInput(
    this._instance,
    this._then,
  );

  final Input$CreateLinkedBranchInput _instance;

  final TRes Function(Input$CreateLinkedBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? oid = _undefined,
    Object? name = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$CreateLinkedBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (name != _undefined) 'name': (name as String?),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateLinkedBranchInput<TRes>
    implements CopyWith$Input$CreateLinkedBranchInput<TRes> {
  _CopyWithStubImpl$Input$CreateLinkedBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? oid,
    String? name,
    String? repositoryId,
  }) =>
      _res;
}

class Input$CreateMigrationSourceInput {
  factory Input$CreateMigrationSourceInput({
    String? clientMutationId,
    required String name,
    String? url,
    String? accessToken,
    required Enum$MigrationSourceType type,
    required String ownerId,
    String? githubPat,
  }) =>
      Input$CreateMigrationSourceInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        if (url != null) r'url': url,
        if (accessToken != null) r'accessToken': accessToken,
        r'type': type,
        r'ownerId': ownerId,
        if (githubPat != null) r'githubPat': githubPat,
      });

  Input$CreateMigrationSourceInput._(this._$data);

  factory Input$CreateMigrationSourceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$MigrationSourceType((l$type as String));
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    if (data.containsKey('githubPat')) {
      final l$githubPat = data['githubPat'];
      result$data['githubPat'] = (l$githubPat as String?);
    }
    return Input$CreateMigrationSourceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get name => (_$data['name'] as String);

  String? get url => (_$data['url'] as String?);

  String? get accessToken => (_$data['accessToken'] as String?);

  Enum$MigrationSourceType get type =>
      (_$data['type'] as Enum$MigrationSourceType);

  String get ownerId => (_$data['ownerId'] as String);

  String? get githubPat => (_$data['githubPat'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    final l$type = type;
    result$data['type'] = toJson$Enum$MigrationSourceType(l$type);
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    if (_$data.containsKey('githubPat')) {
      final l$githubPat = githubPat;
      result$data['githubPat'] = l$githubPat;
    }
    return result$data;
  }

  CopyWith$Input$CreateMigrationSourceInput<Input$CreateMigrationSourceInput>
      get copyWith => CopyWith$Input$CreateMigrationSourceInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateMigrationSourceInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$githubPat = githubPat;
    final lOther$githubPat = other.githubPat;
    if (_$data.containsKey('githubPat') !=
        other._$data.containsKey('githubPat')) {
      return false;
    }
    if (l$githubPat != lOther$githubPat) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$url = url;
    final l$accessToken = accessToken;
    final l$type = type;
    final l$ownerId = ownerId;
    final l$githubPat = githubPat;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      _$data.containsKey('url') ? l$url : const {},
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      l$type,
      l$ownerId,
      _$data.containsKey('githubPat') ? l$githubPat : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateMigrationSourceInput<TRes> {
  factory CopyWith$Input$CreateMigrationSourceInput(
    Input$CreateMigrationSourceInput instance,
    TRes Function(Input$CreateMigrationSourceInput) then,
  ) = _CopyWithImpl$Input$CreateMigrationSourceInput;

  factory CopyWith$Input$CreateMigrationSourceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateMigrationSourceInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? url,
    String? accessToken,
    Enum$MigrationSourceType? type,
    String? ownerId,
    String? githubPat,
  });
}

class _CopyWithImpl$Input$CreateMigrationSourceInput<TRes>
    implements CopyWith$Input$CreateMigrationSourceInput<TRes> {
  _CopyWithImpl$Input$CreateMigrationSourceInput(
    this._instance,
    this._then,
  );

  final Input$CreateMigrationSourceInput _instance;

  final TRes Function(Input$CreateMigrationSourceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? url = _undefined,
    Object? accessToken = _undefined,
    Object? type = _undefined,
    Object? ownerId = _undefined,
    Object? githubPat = _undefined,
  }) =>
      _then(Input$CreateMigrationSourceInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (url != _undefined) 'url': (url as String?),
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (type != _undefined && type != null)
          'type': (type as Enum$MigrationSourceType),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (githubPat != _undefined) 'githubPat': (githubPat as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateMigrationSourceInput<TRes>
    implements CopyWith$Input$CreateMigrationSourceInput<TRes> {
  _CopyWithStubImpl$Input$CreateMigrationSourceInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? url,
    String? accessToken,
    Enum$MigrationSourceType? type,
    String? ownerId,
    String? githubPat,
  }) =>
      _res;
}

class Input$CreateProjectInput {
  factory Input$CreateProjectInput({
    String? clientMutationId,
    required String ownerId,
    required String name,
    String? body,
    Enum$ProjectTemplate? template,
    List<String>? repositoryIds,
  }) =>
      Input$CreateProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'name': name,
        if (body != null) r'body': body,
        if (template != null) r'template': template,
        if (repositoryIds != null) r'repositoryIds': repositoryIds,
      });

  Input$CreateProjectInput._(this._$data);

  factory Input$CreateProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = l$template == null
          ? null
          : fromJson$Enum$ProjectTemplate((l$template as String));
    }
    if (data.containsKey('repositoryIds')) {
      final l$repositoryIds = data['repositoryIds'];
      result$data['repositoryIds'] = (l$repositoryIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$CreateProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  String get name => (_$data['name'] as String);

  String? get body => (_$data['body'] as String?);

  Enum$ProjectTemplate? get template =>
      (_$data['template'] as Enum$ProjectTemplate?);

  List<String>? get repositoryIds => (_$data['repositoryIds'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] =
          l$template == null ? null : toJson$Enum$ProjectTemplate(l$template);
    }
    if (_$data.containsKey('repositoryIds')) {
      final l$repositoryIds = repositoryIds;
      result$data['repositoryIds'] = l$repositoryIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectInput<Input$CreateProjectInput> get copyWith =>
      CopyWith$Input$CreateProjectInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateProjectInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$repositoryIds = repositoryIds;
    final lOther$repositoryIds = other.repositoryIds;
    if (_$data.containsKey('repositoryIds') !=
        other._$data.containsKey('repositoryIds')) {
      return false;
    }
    if (l$repositoryIds != null && lOther$repositoryIds != null) {
      if (l$repositoryIds.length != lOther$repositoryIds.length) {
        return false;
      }
      for (int i = 0; i < l$repositoryIds.length; i++) {
        final l$repositoryIds$entry = l$repositoryIds[i];
        final lOther$repositoryIds$entry = lOther$repositoryIds[i];
        if (l$repositoryIds$entry != lOther$repositoryIds$entry) {
          return false;
        }
      }
    } else if (l$repositoryIds != lOther$repositoryIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$name = name;
    final l$body = body;
    final l$template = template;
    final l$repositoryIds = repositoryIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$name,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('repositoryIds')
          ? l$repositoryIds == null
              ? null
              : Object.hashAll(l$repositoryIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectInput<TRes> {
  factory CopyWith$Input$CreateProjectInput(
    Input$CreateProjectInput instance,
    TRes Function(Input$CreateProjectInput) then,
  ) = _CopyWithImpl$Input$CreateProjectInput;

  factory CopyWith$Input$CreateProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    String? name,
    String? body,
    Enum$ProjectTemplate? template,
    List<String>? repositoryIds,
  });
}

class _CopyWithImpl$Input$CreateProjectInput<TRes>
    implements CopyWith$Input$CreateProjectInput<TRes> {
  _CopyWithImpl$Input$CreateProjectInput(
    this._instance,
    this._then,
  );

  final Input$CreateProjectInput _instance;

  final TRes Function(Input$CreateProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? name = _undefined,
    Object? body = _undefined,
    Object? template = _undefined,
    Object? repositoryIds = _undefined,
  }) =>
      _then(Input$CreateProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (body != _undefined) 'body': (body as String?),
        if (template != _undefined)
          'template': (template as Enum$ProjectTemplate?),
        if (repositoryIds != _undefined)
          'repositoryIds': (repositoryIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$CreateProjectInput<TRes>
    implements CopyWith$Input$CreateProjectInput<TRes> {
  _CopyWithStubImpl$Input$CreateProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    String? name,
    String? body,
    Enum$ProjectTemplate? template,
    List<String>? repositoryIds,
  }) =>
      _res;
}

class Input$CreateProjectV2FieldInput {
  factory Input$CreateProjectV2FieldInput({
    String? clientMutationId,
    required String projectId,
    required Enum$ProjectV2CustomFieldType dataType,
    required String name,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
    Input$ProjectV2IterationFieldConfigurationInput? iterationConfiguration,
  }) =>
      Input$CreateProjectV2FieldInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'dataType': dataType,
        r'name': name,
        if (singleSelectOptions != null)
          r'singleSelectOptions': singleSelectOptions,
        if (iterationConfiguration != null)
          r'iterationConfiguration': iterationConfiguration,
      });

  Input$CreateProjectV2FieldInput._(this._$data);

  factory Input$CreateProjectV2FieldInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$dataType = data['dataType'];
    result$data['dataType'] =
        fromJson$Enum$ProjectV2CustomFieldType((l$dataType as String));
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('singleSelectOptions')) {
      final l$singleSelectOptions = data['singleSelectOptions'];
      result$data['singleSelectOptions'] =
          (l$singleSelectOptions as List<dynamic>?)
              ?.map((e) => Input$ProjectV2SingleSelectFieldOptionInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('iterationConfiguration')) {
      final l$iterationConfiguration = data['iterationConfiguration'];
      result$data['iterationConfiguration'] = l$iterationConfiguration == null
          ? null
          : Input$ProjectV2IterationFieldConfigurationInput.fromJson(
              (l$iterationConfiguration as Map<String, dynamic>));
    }
    return Input$CreateProjectV2FieldInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  Enum$ProjectV2CustomFieldType get dataType =>
      (_$data['dataType'] as Enum$ProjectV2CustomFieldType);

  String get name => (_$data['name'] as String);

  List<Input$ProjectV2SingleSelectFieldOptionInput>? get singleSelectOptions =>
      (_$data['singleSelectOptions']
          as List<Input$ProjectV2SingleSelectFieldOptionInput>?);

  Input$ProjectV2IterationFieldConfigurationInput? get iterationConfiguration =>
      (_$data['iterationConfiguration']
          as Input$ProjectV2IterationFieldConfigurationInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$dataType = dataType;
    result$data['dataType'] = toJson$Enum$ProjectV2CustomFieldType(l$dataType);
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('singleSelectOptions')) {
      final l$singleSelectOptions = singleSelectOptions;
      result$data['singleSelectOptions'] =
          l$singleSelectOptions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('iterationConfiguration')) {
      final l$iterationConfiguration = iterationConfiguration;
      result$data['iterationConfiguration'] =
          l$iterationConfiguration?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectV2FieldInput<Input$CreateProjectV2FieldInput>
      get copyWith => CopyWith$Input$CreateProjectV2FieldInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateProjectV2FieldInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$dataType = dataType;
    final lOther$dataType = other.dataType;
    if (l$dataType != lOther$dataType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$singleSelectOptions = singleSelectOptions;
    final lOther$singleSelectOptions = other.singleSelectOptions;
    if (_$data.containsKey('singleSelectOptions') !=
        other._$data.containsKey('singleSelectOptions')) {
      return false;
    }
    if (l$singleSelectOptions != null && lOther$singleSelectOptions != null) {
      if (l$singleSelectOptions.length != lOther$singleSelectOptions.length) {
        return false;
      }
      for (int i = 0; i < l$singleSelectOptions.length; i++) {
        final l$singleSelectOptions$entry = l$singleSelectOptions[i];
        final lOther$singleSelectOptions$entry = lOther$singleSelectOptions[i];
        if (l$singleSelectOptions$entry != lOther$singleSelectOptions$entry) {
          return false;
        }
      }
    } else if (l$singleSelectOptions != lOther$singleSelectOptions) {
      return false;
    }
    final l$iterationConfiguration = iterationConfiguration;
    final lOther$iterationConfiguration = other.iterationConfiguration;
    if (_$data.containsKey('iterationConfiguration') !=
        other._$data.containsKey('iterationConfiguration')) {
      return false;
    }
    if (l$iterationConfiguration != lOther$iterationConfiguration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$dataType = dataType;
    final l$name = name;
    final l$singleSelectOptions = singleSelectOptions;
    final l$iterationConfiguration = iterationConfiguration;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$dataType,
      l$name,
      _$data.containsKey('singleSelectOptions')
          ? l$singleSelectOptions == null
              ? null
              : Object.hashAll(l$singleSelectOptions.map((v) => v))
          : const {},
      _$data.containsKey('iterationConfiguration')
          ? l$iterationConfiguration
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectV2FieldInput<TRes> {
  factory CopyWith$Input$CreateProjectV2FieldInput(
    Input$CreateProjectV2FieldInput instance,
    TRes Function(Input$CreateProjectV2FieldInput) then,
  ) = _CopyWithImpl$Input$CreateProjectV2FieldInput;

  factory CopyWith$Input$CreateProjectV2FieldInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectV2FieldInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    Enum$ProjectV2CustomFieldType? dataType,
    String? name,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
    Input$ProjectV2IterationFieldConfigurationInput? iterationConfiguration,
  });
  TRes singleSelectOptions(
      Iterable<Input$ProjectV2SingleSelectFieldOptionInput>? Function(
              Iterable<
                  CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
                      Input$ProjectV2SingleSelectFieldOptionInput>>?)
          _fn);
  CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes>
      get iterationConfiguration;
}

class _CopyWithImpl$Input$CreateProjectV2FieldInput<TRes>
    implements CopyWith$Input$CreateProjectV2FieldInput<TRes> {
  _CopyWithImpl$Input$CreateProjectV2FieldInput(
    this._instance,
    this._then,
  );

  final Input$CreateProjectV2FieldInput _instance;

  final TRes Function(Input$CreateProjectV2FieldInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? dataType = _undefined,
    Object? name = _undefined,
    Object? singleSelectOptions = _undefined,
    Object? iterationConfiguration = _undefined,
  }) =>
      _then(Input$CreateProjectV2FieldInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (dataType != _undefined && dataType != null)
          'dataType': (dataType as Enum$ProjectV2CustomFieldType),
        if (name != _undefined && name != null) 'name': (name as String),
        if (singleSelectOptions != _undefined)
          'singleSelectOptions': (singleSelectOptions
              as List<Input$ProjectV2SingleSelectFieldOptionInput>?),
        if (iterationConfiguration != _undefined)
          'iterationConfiguration': (iterationConfiguration
              as Input$ProjectV2IterationFieldConfigurationInput?),
      }));

  TRes singleSelectOptions(
          Iterable<Input$ProjectV2SingleSelectFieldOptionInput>? Function(
                  Iterable<
                      CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
                          Input$ProjectV2SingleSelectFieldOptionInput>>?)
              _fn) =>
      call(
          singleSelectOptions: _fn(_instance.singleSelectOptions
              ?.map((e) => CopyWith$Input$ProjectV2SingleSelectFieldOptionInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes>
      get iterationConfiguration {
    final local$iterationConfiguration = _instance.iterationConfiguration;
    return local$iterationConfiguration == null
        ? CopyWith$Input$ProjectV2IterationFieldConfigurationInput.stub(
            _then(_instance))
        : CopyWith$Input$ProjectV2IterationFieldConfigurationInput(
            local$iterationConfiguration,
            (e) => call(iterationConfiguration: e));
  }
}

class _CopyWithStubImpl$Input$CreateProjectV2FieldInput<TRes>
    implements CopyWith$Input$CreateProjectV2FieldInput<TRes> {
  _CopyWithStubImpl$Input$CreateProjectV2FieldInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    Enum$ProjectV2CustomFieldType? dataType,
    String? name,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
    Input$ProjectV2IterationFieldConfigurationInput? iterationConfiguration,
  }) =>
      _res;

  singleSelectOptions(_fn) => _res;

  CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes>
      get iterationConfiguration =>
          CopyWith$Input$ProjectV2IterationFieldConfigurationInput.stub(_res);
}

class Input$CreateProjectV2Input {
  factory Input$CreateProjectV2Input({
    String? clientMutationId,
    required String ownerId,
    required String title,
    String? repositoryId,
    String? teamId,
  }) =>
      Input$CreateProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'title': title,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (teamId != null) r'teamId': teamId,
      });

  Input$CreateProjectV2Input._(this._$data);

  factory Input$CreateProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    return Input$CreateProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  String get title => (_$data['title'] as String);

  String? get repositoryId => (_$data['repositoryId'] as String?);

  String? get teamId => (_$data['teamId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectV2Input<Input$CreateProjectV2Input>
      get copyWith => CopyWith$Input$CreateProjectV2Input(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateProjectV2Input ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$title = title;
    final l$repositoryId = repositoryId;
    final l$teamId = teamId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$title,
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectV2Input<TRes> {
  factory CopyWith$Input$CreateProjectV2Input(
    Input$CreateProjectV2Input instance,
    TRes Function(Input$CreateProjectV2Input) then,
  ) = _CopyWithImpl$Input$CreateProjectV2Input;

  factory CopyWith$Input$CreateProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectV2Input;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    String? title,
    String? repositoryId,
    String? teamId,
  });
}

class _CopyWithImpl$Input$CreateProjectV2Input<TRes>
    implements CopyWith$Input$CreateProjectV2Input<TRes> {
  _CopyWithImpl$Input$CreateProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$CreateProjectV2Input _instance;

  final TRes Function(Input$CreateProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? title = _undefined,
    Object? repositoryId = _undefined,
    Object? teamId = _undefined,
  }) =>
      _then(Input$CreateProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (title != _undefined && title != null) 'title': (title as String),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateProjectV2Input<TRes>
    implements CopyWith$Input$CreateProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$CreateProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    String? title,
    String? repositoryId,
    String? teamId,
  }) =>
      _res;
}

class Input$CreateProjectV2StatusUpdateInput {
  factory Input$CreateProjectV2StatusUpdateInput({
    String? clientMutationId,
    required String projectId,
    String? startDate,
    String? targetDate,
    Enum$ProjectV2StatusUpdateStatus? status,
    String? body,
  }) =>
      Input$CreateProjectV2StatusUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        if (startDate != null) r'startDate': startDate,
        if (targetDate != null) r'targetDate': targetDate,
        if (status != null) r'status': status,
        if (body != null) r'body': body,
      });

  Input$CreateProjectV2StatusUpdateInput._(this._$data);

  factory Input$CreateProjectV2StatusUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('targetDate')) {
      final l$targetDate = data['targetDate'];
      result$data['targetDate'] = (l$targetDate as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$ProjectV2StatusUpdateStatus((l$status as String));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$CreateProjectV2StatusUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String? get startDate => (_$data['startDate'] as String?);

  String? get targetDate => (_$data['targetDate'] as String?);

  Enum$ProjectV2StatusUpdateStatus? get status =>
      (_$data['status'] as Enum$ProjectV2StatusUpdateStatus?);

  String? get body => (_$data['body'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('targetDate')) {
      final l$targetDate = targetDate;
      result$data['targetDate'] = l$targetDate;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$ProjectV2StatusUpdateStatus(l$status);
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectV2StatusUpdateInput<
          Input$CreateProjectV2StatusUpdateInput>
      get copyWith => CopyWith$Input$CreateProjectV2StatusUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateProjectV2StatusUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$targetDate = targetDate;
    final lOther$targetDate = other.targetDate;
    if (_$data.containsKey('targetDate') !=
        other._$data.containsKey('targetDate')) {
      return false;
    }
    if (l$targetDate != lOther$targetDate) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$startDate = startDate;
    final l$targetDate = targetDate;
    final l$status = status;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('targetDate') ? l$targetDate : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectV2StatusUpdateInput<TRes> {
  factory CopyWith$Input$CreateProjectV2StatusUpdateInput(
    Input$CreateProjectV2StatusUpdateInput instance,
    TRes Function(Input$CreateProjectV2StatusUpdateInput) then,
  ) = _CopyWithImpl$Input$CreateProjectV2StatusUpdateInput;

  factory CopyWith$Input$CreateProjectV2StatusUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectV2StatusUpdateInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? startDate,
    String? targetDate,
    Enum$ProjectV2StatusUpdateStatus? status,
    String? body,
  });
}

class _CopyWithImpl$Input$CreateProjectV2StatusUpdateInput<TRes>
    implements CopyWith$Input$CreateProjectV2StatusUpdateInput<TRes> {
  _CopyWithImpl$Input$CreateProjectV2StatusUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CreateProjectV2StatusUpdateInput _instance;

  final TRes Function(Input$CreateProjectV2StatusUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? startDate = _undefined,
    Object? targetDate = _undefined,
    Object? status = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$CreateProjectV2StatusUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (targetDate != _undefined) 'targetDate': (targetDate as String?),
        if (status != _undefined)
          'status': (status as Enum$ProjectV2StatusUpdateStatus?),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateProjectV2StatusUpdateInput<TRes>
    implements CopyWith$Input$CreateProjectV2StatusUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CreateProjectV2StatusUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? startDate,
    String? targetDate,
    Enum$ProjectV2StatusUpdateStatus? status,
    String? body,
  }) =>
      _res;
}

class Input$CreatePullRequestInput {
  factory Input$CreatePullRequestInput({
    String? clientMutationId,
    required String repositoryId,
    required String baseRefName,
    required String headRefName,
    String? headRepositoryId,
    required String title,
    String? body,
    bool? maintainerCanModify,
    bool? draft,
  }) =>
      Input$CreatePullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'baseRefName': baseRefName,
        r'headRefName': headRefName,
        if (headRepositoryId != null) r'headRepositoryId': headRepositoryId,
        r'title': title,
        if (body != null) r'body': body,
        if (maintainerCanModify != null)
          r'maintainerCanModify': maintainerCanModify,
        if (draft != null) r'draft': draft,
      });

  Input$CreatePullRequestInput._(this._$data);

  factory Input$CreatePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$baseRefName = data['baseRefName'];
    result$data['baseRefName'] = (l$baseRefName as String);
    final l$headRefName = data['headRefName'];
    result$data['headRefName'] = (l$headRefName as String);
    if (data.containsKey('headRepositoryId')) {
      final l$headRepositoryId = data['headRepositoryId'];
      result$data['headRepositoryId'] = (l$headRepositoryId as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = data['maintainerCanModify'];
      result$data['maintainerCanModify'] = (l$maintainerCanModify as bool?);
    }
    if (data.containsKey('draft')) {
      final l$draft = data['draft'];
      result$data['draft'] = (l$draft as bool?);
    }
    return Input$CreatePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get baseRefName => (_$data['baseRefName'] as String);

  String get headRefName => (_$data['headRefName'] as String);

  String? get headRepositoryId => (_$data['headRepositoryId'] as String?);

  String get title => (_$data['title'] as String);

  String? get body => (_$data['body'] as String?);

  bool? get maintainerCanModify => (_$data['maintainerCanModify'] as bool?);

  bool? get draft => (_$data['draft'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$baseRefName = baseRefName;
    result$data['baseRefName'] = l$baseRefName;
    final l$headRefName = headRefName;
    result$data['headRefName'] = l$headRefName;
    if (_$data.containsKey('headRepositoryId')) {
      final l$headRepositoryId = headRepositoryId;
      result$data['headRepositoryId'] = l$headRepositoryId;
    }
    final l$title = title;
    result$data['title'] = l$title;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = maintainerCanModify;
      result$data['maintainerCanModify'] = l$maintainerCanModify;
    }
    if (_$data.containsKey('draft')) {
      final l$draft = draft;
      result$data['draft'] = l$draft;
    }
    return result$data;
  }

  CopyWith$Input$CreatePullRequestInput<Input$CreatePullRequestInput>
      get copyWith => CopyWith$Input$CreatePullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreatePullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$baseRefName = baseRefName;
    final lOther$baseRefName = other.baseRefName;
    if (l$baseRefName != lOther$baseRefName) {
      return false;
    }
    final l$headRefName = headRefName;
    final lOther$headRefName = other.headRefName;
    if (l$headRefName != lOther$headRefName) {
      return false;
    }
    final l$headRepositoryId = headRepositoryId;
    final lOther$headRepositoryId = other.headRepositoryId;
    if (_$data.containsKey('headRepositoryId') !=
        other._$data.containsKey('headRepositoryId')) {
      return false;
    }
    if (l$headRepositoryId != lOther$headRepositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$maintainerCanModify = maintainerCanModify;
    final lOther$maintainerCanModify = other.maintainerCanModify;
    if (_$data.containsKey('maintainerCanModify') !=
        other._$data.containsKey('maintainerCanModify')) {
      return false;
    }
    if (l$maintainerCanModify != lOther$maintainerCanModify) {
      return false;
    }
    final l$draft = draft;
    final lOther$draft = other.draft;
    if (_$data.containsKey('draft') != other._$data.containsKey('draft')) {
      return false;
    }
    if (l$draft != lOther$draft) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$baseRefName = baseRefName;
    final l$headRefName = headRefName;
    final l$headRepositoryId = headRepositoryId;
    final l$title = title;
    final l$body = body;
    final l$maintainerCanModify = maintainerCanModify;
    final l$draft = draft;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$baseRefName,
      l$headRefName,
      _$data.containsKey('headRepositoryId') ? l$headRepositoryId : const {},
      l$title,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('maintainerCanModify')
          ? l$maintainerCanModify
          : const {},
      _$data.containsKey('draft') ? l$draft : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreatePullRequestInput<TRes> {
  factory CopyWith$Input$CreatePullRequestInput(
    Input$CreatePullRequestInput instance,
    TRes Function(Input$CreatePullRequestInput) then,
  ) = _CopyWithImpl$Input$CreatePullRequestInput;

  factory CopyWith$Input$CreatePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePullRequestInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? baseRefName,
    String? headRefName,
    String? headRepositoryId,
    String? title,
    String? body,
    bool? maintainerCanModify,
    bool? draft,
  });
}

class _CopyWithImpl$Input$CreatePullRequestInput<TRes>
    implements CopyWith$Input$CreatePullRequestInput<TRes> {
  _CopyWithImpl$Input$CreatePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreatePullRequestInput _instance;

  final TRes Function(Input$CreatePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? baseRefName = _undefined,
    Object? headRefName = _undefined,
    Object? headRepositoryId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? maintainerCanModify = _undefined,
    Object? draft = _undefined,
  }) =>
      _then(Input$CreatePullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (baseRefName != _undefined && baseRefName != null)
          'baseRefName': (baseRefName as String),
        if (headRefName != _undefined && headRefName != null)
          'headRefName': (headRefName as String),
        if (headRepositoryId != _undefined)
          'headRepositoryId': (headRepositoryId as String?),
        if (title != _undefined && title != null) 'title': (title as String),
        if (body != _undefined) 'body': (body as String?),
        if (maintainerCanModify != _undefined)
          'maintainerCanModify': (maintainerCanModify as bool?),
        if (draft != _undefined) 'draft': (draft as bool?),
      }));
}

class _CopyWithStubImpl$Input$CreatePullRequestInput<TRes>
    implements CopyWith$Input$CreatePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreatePullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? baseRefName,
    String? headRefName,
    String? headRepositoryId,
    String? title,
    String? body,
    bool? maintainerCanModify,
    bool? draft,
  }) =>
      _res;
}

class Input$CreateRefInput {
  factory Input$CreateRefInput({
    String? clientMutationId,
    required String repositoryId,
    required String name,
    required String oid,
  }) =>
      Input$CreateRefInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'name': name,
        r'oid': oid,
      });

  Input$CreateRefInput._(this._$data);

  factory Input$CreateRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    return Input$CreateRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get name => (_$data['name'] as String);

  String get oid => (_$data['oid'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$name = name;
    result$data['name'] = l$name;
    final l$oid = oid;
    result$data['oid'] = l$oid;
    return result$data;
  }

  CopyWith$Input$CreateRefInput<Input$CreateRefInput> get copyWith =>
      CopyWith$Input$CreateRefInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateRefInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$oid = oid;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$name,
      l$oid,
    ]);
  }
}

abstract class CopyWith$Input$CreateRefInput<TRes> {
  factory CopyWith$Input$CreateRefInput(
    Input$CreateRefInput instance,
    TRes Function(Input$CreateRefInput) then,
  ) = _CopyWithImpl$Input$CreateRefInput;

  factory CopyWith$Input$CreateRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRefInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? oid,
  });
}

class _CopyWithImpl$Input$CreateRefInput<TRes>
    implements CopyWith$Input$CreateRefInput<TRes> {
  _CopyWithImpl$Input$CreateRefInput(
    this._instance,
    this._then,
  );

  final Input$CreateRefInput _instance;

  final TRes Function(Input$CreateRefInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? oid = _undefined,
  }) =>
      _then(Input$CreateRefInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
      }));
}

class _CopyWithStubImpl$Input$CreateRefInput<TRes>
    implements CopyWith$Input$CreateRefInput<TRes> {
  _CopyWithStubImpl$Input$CreateRefInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? oid,
  }) =>
      _res;
}

class Input$CreateRepositoryInput {
  factory Input$CreateRepositoryInput({
    String? clientMutationId,
    required String name,
    String? ownerId,
    String? description,
    required Enum$RepositoryVisibility visibility,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    String? teamId,
  }) =>
      Input$CreateRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        if (ownerId != null) r'ownerId': ownerId,
        if (description != null) r'description': description,
        r'visibility': visibility,
        if (template != null) r'template': template,
        if (homepageUrl != null) r'homepageUrl': homepageUrl,
        if (hasWikiEnabled != null) r'hasWikiEnabled': hasWikiEnabled,
        if (hasIssuesEnabled != null) r'hasIssuesEnabled': hasIssuesEnabled,
        if (teamId != null) r'teamId': teamId,
      });

  Input$CreateRepositoryInput._(this._$data);

  factory Input$CreateRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$visibility = data['visibility'];
    result$data['visibility'] =
        fromJson$Enum$RepositoryVisibility((l$visibility as String));
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as bool?);
    }
    if (data.containsKey('homepageUrl')) {
      final l$homepageUrl = data['homepageUrl'];
      result$data['homepageUrl'] = (l$homepageUrl as String?);
    }
    if (data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = data['hasWikiEnabled'];
      result$data['hasWikiEnabled'] = (l$hasWikiEnabled as bool?);
    }
    if (data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = data['hasIssuesEnabled'];
      result$data['hasIssuesEnabled'] = (l$hasIssuesEnabled as bool?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    return Input$CreateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get name => (_$data['name'] as String);

  String? get ownerId => (_$data['ownerId'] as String?);

  String? get description => (_$data['description'] as String?);

  Enum$RepositoryVisibility get visibility =>
      (_$data['visibility'] as Enum$RepositoryVisibility);

  bool? get template => (_$data['template'] as bool?);

  String? get homepageUrl => (_$data['homepageUrl'] as String?);

  bool? get hasWikiEnabled => (_$data['hasWikiEnabled'] as bool?);

  bool? get hasIssuesEnabled => (_$data['hasIssuesEnabled'] as bool?);

  String? get teamId => (_$data['teamId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$visibility = visibility;
    result$data['visibility'] = toJson$Enum$RepositoryVisibility(l$visibility);
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    if (_$data.containsKey('homepageUrl')) {
      final l$homepageUrl = homepageUrl;
      result$data['homepageUrl'] = l$homepageUrl;
    }
    if (_$data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = hasWikiEnabled;
      result$data['hasWikiEnabled'] = l$hasWikiEnabled;
    }
    if (_$data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = hasIssuesEnabled;
      result$data['hasIssuesEnabled'] = l$hasIssuesEnabled;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    return result$data;
  }

  CopyWith$Input$CreateRepositoryInput<Input$CreateRepositoryInput>
      get copyWith => CopyWith$Input$CreateRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$visibility = visibility;
    final lOther$visibility = other.visibility;
    if (l$visibility != lOther$visibility) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$homepageUrl = homepageUrl;
    final lOther$homepageUrl = other.homepageUrl;
    if (_$data.containsKey('homepageUrl') !=
        other._$data.containsKey('homepageUrl')) {
      return false;
    }
    if (l$homepageUrl != lOther$homepageUrl) {
      return false;
    }
    final l$hasWikiEnabled = hasWikiEnabled;
    final lOther$hasWikiEnabled = other.hasWikiEnabled;
    if (_$data.containsKey('hasWikiEnabled') !=
        other._$data.containsKey('hasWikiEnabled')) {
      return false;
    }
    if (l$hasWikiEnabled != lOther$hasWikiEnabled) {
      return false;
    }
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final lOther$hasIssuesEnabled = other.hasIssuesEnabled;
    if (_$data.containsKey('hasIssuesEnabled') !=
        other._$data.containsKey('hasIssuesEnabled')) {
      return false;
    }
    if (l$hasIssuesEnabled != lOther$hasIssuesEnabled) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$ownerId = ownerId;
    final l$description = description;
    final l$visibility = visibility;
    final l$template = template;
    final l$homepageUrl = homepageUrl;
    final l$hasWikiEnabled = hasWikiEnabled;
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final l$teamId = teamId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('description') ? l$description : const {},
      l$visibility,
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('homepageUrl') ? l$homepageUrl : const {},
      _$data.containsKey('hasWikiEnabled') ? l$hasWikiEnabled : const {},
      _$data.containsKey('hasIssuesEnabled') ? l$hasIssuesEnabled : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateRepositoryInput<TRes> {
  factory CopyWith$Input$CreateRepositoryInput(
    Input$CreateRepositoryInput instance,
    TRes Function(Input$CreateRepositoryInput) then,
  ) = _CopyWithImpl$Input$CreateRepositoryInput;

  factory CopyWith$Input$CreateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    String? teamId,
  });
}

class _CopyWithImpl$Input$CreateRepositoryInput<TRes>
    implements CopyWith$Input$CreateRepositoryInput<TRes> {
  _CopyWithImpl$Input$CreateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$CreateRepositoryInput _instance;

  final TRes Function(Input$CreateRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? description = _undefined,
    Object? visibility = _undefined,
    Object? template = _undefined,
    Object? homepageUrl = _undefined,
    Object? hasWikiEnabled = _undefined,
    Object? hasIssuesEnabled = _undefined,
    Object? teamId = _undefined,
  }) =>
      _then(Input$CreateRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (visibility != _undefined && visibility != null)
          'visibility': (visibility as Enum$RepositoryVisibility),
        if (template != _undefined) 'template': (template as bool?),
        if (homepageUrl != _undefined) 'homepageUrl': (homepageUrl as String?),
        if (hasWikiEnabled != _undefined)
          'hasWikiEnabled': (hasWikiEnabled as bool?),
        if (hasIssuesEnabled != _undefined)
          'hasIssuesEnabled': (hasIssuesEnabled as bool?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateRepositoryInput<TRes>
    implements CopyWith$Input$CreateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$CreateRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? ownerId,
    String? description,
    Enum$RepositoryVisibility? visibility,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    String? teamId,
  }) =>
      _res;
}

class Input$CreateRepositoryRulesetInput {
  factory Input$CreateRepositoryRulesetInput({
    String? clientMutationId,
    required String sourceId,
    required String name,
    Enum$RepositoryRulesetTarget? target,
    List<Input$RepositoryRuleInput>? rules,
    required Input$RepositoryRuleConditionsInput conditions,
    required Enum$RuleEnforcement enforcement,
    List<Input$RepositoryRulesetBypassActorInput>? bypassActors,
  }) =>
      Input$CreateRepositoryRulesetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'sourceId': sourceId,
        r'name': name,
        if (target != null) r'target': target,
        if (rules != null) r'rules': rules,
        r'conditions': conditions,
        r'enforcement': enforcement,
        if (bypassActors != null) r'bypassActors': bypassActors,
      });

  Input$CreateRepositoryRulesetInput._(this._$data);

  factory Input$CreateRepositoryRulesetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('target')) {
      final l$target = data['target'];
      result$data['target'] = l$target == null
          ? null
          : fromJson$Enum$RepositoryRulesetTarget((l$target as String));
    }
    if (data.containsKey('rules')) {
      final l$rules = data['rules'];
      result$data['rules'] = (l$rules as List<dynamic>?)
          ?.map((e) =>
              Input$RepositoryRuleInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    final l$conditions = data['conditions'];
    result$data['conditions'] = Input$RepositoryRuleConditionsInput.fromJson(
        (l$conditions as Map<String, dynamic>));
    final l$enforcement = data['enforcement'];
    result$data['enforcement'] =
        fromJson$Enum$RuleEnforcement((l$enforcement as String));
    if (data.containsKey('bypassActors')) {
      final l$bypassActors = data['bypassActors'];
      result$data['bypassActors'] = (l$bypassActors as List<dynamic>?)
          ?.map((e) => Input$RepositoryRulesetBypassActorInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$CreateRepositoryRulesetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get sourceId => (_$data['sourceId'] as String);

  String get name => (_$data['name'] as String);

  Enum$RepositoryRulesetTarget? get target =>
      (_$data['target'] as Enum$RepositoryRulesetTarget?);

  List<Input$RepositoryRuleInput>? get rules =>
      (_$data['rules'] as List<Input$RepositoryRuleInput>?);

  Input$RepositoryRuleConditionsInput get conditions =>
      (_$data['conditions'] as Input$RepositoryRuleConditionsInput);

  Enum$RuleEnforcement get enforcement =>
      (_$data['enforcement'] as Enum$RuleEnforcement);

  List<Input$RepositoryRulesetBypassActorInput>? get bypassActors =>
      (_$data['bypassActors']
          as List<Input$RepositoryRulesetBypassActorInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('target')) {
      final l$target = target;
      result$data['target'] = l$target == null
          ? null
          : toJson$Enum$RepositoryRulesetTarget(l$target);
    }
    if (_$data.containsKey('rules')) {
      final l$rules = rules;
      result$data['rules'] = l$rules?.map((e) => e.toJson()).toList();
    }
    final l$conditions = conditions;
    result$data['conditions'] = l$conditions.toJson();
    final l$enforcement = enforcement;
    result$data['enforcement'] = toJson$Enum$RuleEnforcement(l$enforcement);
    if (_$data.containsKey('bypassActors')) {
      final l$bypassActors = bypassActors;
      result$data['bypassActors'] =
          l$bypassActors?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateRepositoryRulesetInput<
          Input$CreateRepositoryRulesetInput>
      get copyWith => CopyWith$Input$CreateRepositoryRulesetInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateRepositoryRulesetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$target = target;
    final lOther$target = other.target;
    if (_$data.containsKey('target') != other._$data.containsKey('target')) {
      return false;
    }
    if (l$target != lOther$target) {
      return false;
    }
    final l$rules = rules;
    final lOther$rules = other.rules;
    if (_$data.containsKey('rules') != other._$data.containsKey('rules')) {
      return false;
    }
    if (l$rules != null && lOther$rules != null) {
      if (l$rules.length != lOther$rules.length) {
        return false;
      }
      for (int i = 0; i < l$rules.length; i++) {
        final l$rules$entry = l$rules[i];
        final lOther$rules$entry = lOther$rules[i];
        if (l$rules$entry != lOther$rules$entry) {
          return false;
        }
      }
    } else if (l$rules != lOther$rules) {
      return false;
    }
    final l$conditions = conditions;
    final lOther$conditions = other.conditions;
    if (l$conditions != lOther$conditions) {
      return false;
    }
    final l$enforcement = enforcement;
    final lOther$enforcement = other.enforcement;
    if (l$enforcement != lOther$enforcement) {
      return false;
    }
    final l$bypassActors = bypassActors;
    final lOther$bypassActors = other.bypassActors;
    if (_$data.containsKey('bypassActors') !=
        other._$data.containsKey('bypassActors')) {
      return false;
    }
    if (l$bypassActors != null && lOther$bypassActors != null) {
      if (l$bypassActors.length != lOther$bypassActors.length) {
        return false;
      }
      for (int i = 0; i < l$bypassActors.length; i++) {
        final l$bypassActors$entry = l$bypassActors[i];
        final lOther$bypassActors$entry = lOther$bypassActors[i];
        if (l$bypassActors$entry != lOther$bypassActors$entry) {
          return false;
        }
      }
    } else if (l$bypassActors != lOther$bypassActors) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sourceId = sourceId;
    final l$name = name;
    final l$target = target;
    final l$rules = rules;
    final l$conditions = conditions;
    final l$enforcement = enforcement;
    final l$bypassActors = bypassActors;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$sourceId,
      l$name,
      _$data.containsKey('target') ? l$target : const {},
      _$data.containsKey('rules')
          ? l$rules == null
              ? null
              : Object.hashAll(l$rules.map((v) => v))
          : const {},
      l$conditions,
      l$enforcement,
      _$data.containsKey('bypassActors')
          ? l$bypassActors == null
              ? null
              : Object.hashAll(l$bypassActors.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateRepositoryRulesetInput<TRes> {
  factory CopyWith$Input$CreateRepositoryRulesetInput(
    Input$CreateRepositoryRulesetInput instance,
    TRes Function(Input$CreateRepositoryRulesetInput) then,
  ) = _CopyWithImpl$Input$CreateRepositoryRulesetInput;

  factory CopyWith$Input$CreateRepositoryRulesetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRepositoryRulesetInput;

  TRes call({
    String? clientMutationId,
    String? sourceId,
    String? name,
    Enum$RepositoryRulesetTarget? target,
    List<Input$RepositoryRuleInput>? rules,
    Input$RepositoryRuleConditionsInput? conditions,
    Enum$RuleEnforcement? enforcement,
    List<Input$RepositoryRulesetBypassActorInput>? bypassActors,
  });
  TRes rules(
      Iterable<Input$RepositoryRuleInput>? Function(
              Iterable<
                  CopyWith$Input$RepositoryRuleInput<
                      Input$RepositoryRuleInput>>?)
          _fn);
  CopyWith$Input$RepositoryRuleConditionsInput<TRes> get conditions;
  TRes bypassActors(
      Iterable<Input$RepositoryRulesetBypassActorInput>? Function(
              Iterable<
                  CopyWith$Input$RepositoryRulesetBypassActorInput<
                      Input$RepositoryRulesetBypassActorInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateRepositoryRulesetInput<TRes>
    implements CopyWith$Input$CreateRepositoryRulesetInput<TRes> {
  _CopyWithImpl$Input$CreateRepositoryRulesetInput(
    this._instance,
    this._then,
  );

  final Input$CreateRepositoryRulesetInput _instance;

  final TRes Function(Input$CreateRepositoryRulesetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sourceId = _undefined,
    Object? name = _undefined,
    Object? target = _undefined,
    Object? rules = _undefined,
    Object? conditions = _undefined,
    Object? enforcement = _undefined,
    Object? bypassActors = _undefined,
  }) =>
      _then(Input$CreateRepositoryRulesetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (target != _undefined)
          'target': (target as Enum$RepositoryRulesetTarget?),
        if (rules != _undefined)
          'rules': (rules as List<Input$RepositoryRuleInput>?),
        if (conditions != _undefined && conditions != null)
          'conditions': (conditions as Input$RepositoryRuleConditionsInput),
        if (enforcement != _undefined && enforcement != null)
          'enforcement': (enforcement as Enum$RuleEnforcement),
        if (bypassActors != _undefined)
          'bypassActors':
              (bypassActors as List<Input$RepositoryRulesetBypassActorInput>?),
      }));

  TRes rules(
          Iterable<Input$RepositoryRuleInput>? Function(
                  Iterable<
                      CopyWith$Input$RepositoryRuleInput<
                          Input$RepositoryRuleInput>>?)
              _fn) =>
      call(
          rules: _fn(
              _instance.rules?.map((e) => CopyWith$Input$RepositoryRuleInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$RepositoryRuleConditionsInput<TRes> get conditions {
    final local$conditions = _instance.conditions;
    return CopyWith$Input$RepositoryRuleConditionsInput(
        local$conditions, (e) => call(conditions: e));
  }

  TRes bypassActors(
          Iterable<Input$RepositoryRulesetBypassActorInput>? Function(
                  Iterable<
                      CopyWith$Input$RepositoryRulesetBypassActorInput<
                          Input$RepositoryRulesetBypassActorInput>>?)
              _fn) =>
      call(
          bypassActors: _fn(_instance.bypassActors
              ?.map((e) => CopyWith$Input$RepositoryRulesetBypassActorInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateRepositoryRulesetInput<TRes>
    implements CopyWith$Input$CreateRepositoryRulesetInput<TRes> {
  _CopyWithStubImpl$Input$CreateRepositoryRulesetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sourceId,
    String? name,
    Enum$RepositoryRulesetTarget? target,
    List<Input$RepositoryRuleInput>? rules,
    Input$RepositoryRuleConditionsInput? conditions,
    Enum$RuleEnforcement? enforcement,
    List<Input$RepositoryRulesetBypassActorInput>? bypassActors,
  }) =>
      _res;

  rules(_fn) => _res;

  CopyWith$Input$RepositoryRuleConditionsInput<TRes> get conditions =>
      CopyWith$Input$RepositoryRuleConditionsInput.stub(_res);

  bypassActors(_fn) => _res;
}

class Input$CreateSponsorshipInput {
  factory Input$CreateSponsorshipInput({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
    int? amount,
    bool? isRecurring,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
  }) =>
      Input$CreateSponsorshipInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (tierId != null) r'tierId': tierId,
        if (amount != null) r'amount': amount,
        if (isRecurring != null) r'isRecurring': isRecurring,
        if (receiveEmails != null) r'receiveEmails': receiveEmails,
        if (privacyLevel != null) r'privacyLevel': privacyLevel,
      });

  Input$CreateSponsorshipInput._(this._$data);

  factory Input$CreateSponsorshipInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('tierId')) {
      final l$tierId = data['tierId'];
      result$data['tierId'] = (l$tierId as String?);
    }
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = (l$amount as int?);
    }
    if (data.containsKey('isRecurring')) {
      final l$isRecurring = data['isRecurring'];
      result$data['isRecurring'] = (l$isRecurring as bool?);
    }
    if (data.containsKey('receiveEmails')) {
      final l$receiveEmails = data['receiveEmails'];
      result$data['receiveEmails'] = (l$receiveEmails as bool?);
    }
    if (data.containsKey('privacyLevel')) {
      final l$privacyLevel = data['privacyLevel'];
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : fromJson$Enum$SponsorshipPrivacy((l$privacyLevel as String));
    }
    return Input$CreateSponsorshipInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get sponsorId => (_$data['sponsorId'] as String?);

  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);

  String? get sponsorableId => (_$data['sponsorableId'] as String?);

  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);

  String? get tierId => (_$data['tierId'] as String?);

  int? get amount => (_$data['amount'] as int?);

  bool? get isRecurring => (_$data['isRecurring'] as bool?);

  bool? get receiveEmails => (_$data['receiveEmails'] as bool?);

  Enum$SponsorshipPrivacy? get privacyLevel =>
      (_$data['privacyLevel'] as Enum$SponsorshipPrivacy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('tierId')) {
      final l$tierId = tierId;
      result$data['tierId'] = l$tierId;
    }
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount;
    }
    if (_$data.containsKey('isRecurring')) {
      final l$isRecurring = isRecurring;
      result$data['isRecurring'] = l$isRecurring;
    }
    if (_$data.containsKey('receiveEmails')) {
      final l$receiveEmails = receiveEmails;
      result$data['receiveEmails'] = l$receiveEmails;
    }
    if (_$data.containsKey('privacyLevel')) {
      final l$privacyLevel = privacyLevel;
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : toJson$Enum$SponsorshipPrivacy(l$privacyLevel);
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorshipInput<Input$CreateSponsorshipInput>
      get copyWith => CopyWith$Input$CreateSponsorshipInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateSponsorshipInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$tierId = tierId;
    final lOther$tierId = other.tierId;
    if (_$data.containsKey('tierId') != other._$data.containsKey('tierId')) {
      return false;
    }
    if (l$tierId != lOther$tierId) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$isRecurring = isRecurring;
    final lOther$isRecurring = other.isRecurring;
    if (_$data.containsKey('isRecurring') !=
        other._$data.containsKey('isRecurring')) {
      return false;
    }
    if (l$isRecurring != lOther$isRecurring) {
      return false;
    }
    final l$receiveEmails = receiveEmails;
    final lOther$receiveEmails = other.receiveEmails;
    if (_$data.containsKey('receiveEmails') !=
        other._$data.containsKey('receiveEmails')) {
      return false;
    }
    if (l$receiveEmails != lOther$receiveEmails) {
      return false;
    }
    final l$privacyLevel = privacyLevel;
    final lOther$privacyLevel = other.privacyLevel;
    if (_$data.containsKey('privacyLevel') !=
        other._$data.containsKey('privacyLevel')) {
      return false;
    }
    if (l$privacyLevel != lOther$privacyLevel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$tierId = tierId;
    final l$amount = amount;
    final l$isRecurring = isRecurring;
    final l$receiveEmails = receiveEmails;
    final l$privacyLevel = privacyLevel;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('tierId') ? l$tierId : const {},
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('isRecurring') ? l$isRecurring : const {},
      _$data.containsKey('receiveEmails') ? l$receiveEmails : const {},
      _$data.containsKey('privacyLevel') ? l$privacyLevel : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorshipInput<TRes> {
  factory CopyWith$Input$CreateSponsorshipInput(
    Input$CreateSponsorshipInput instance,
    TRes Function(Input$CreateSponsorshipInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorshipInput;

  factory CopyWith$Input$CreateSponsorshipInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorshipInput;

  TRes call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
    int? amount,
    bool? isRecurring,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
  });
}

class _CopyWithImpl$Input$CreateSponsorshipInput<TRes>
    implements CopyWith$Input$CreateSponsorshipInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorshipInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorshipInput _instance;

  final TRes Function(Input$CreateSponsorshipInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? tierId = _undefined,
    Object? amount = _undefined,
    Object? isRecurring = _undefined,
    Object? receiveEmails = _undefined,
    Object? privacyLevel = _undefined,
  }) =>
      _then(Input$CreateSponsorshipInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (tierId != _undefined) 'tierId': (tierId as String?),
        if (amount != _undefined) 'amount': (amount as int?),
        if (isRecurring != _undefined) 'isRecurring': (isRecurring as bool?),
        if (receiveEmails != _undefined)
          'receiveEmails': (receiveEmails as bool?),
        if (privacyLevel != _undefined)
          'privacyLevel': (privacyLevel as Enum$SponsorshipPrivacy?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorshipInput<TRes>
    implements CopyWith$Input$CreateSponsorshipInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorshipInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
    int? amount,
    bool? isRecurring,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
  }) =>
      _res;
}

class Input$CreateSponsorshipsInput {
  factory Input$CreateSponsorshipsInput({
    String? clientMutationId,
    required String sponsorLogin,
    required List<Input$BulkSponsorship> sponsorships,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? recurring,
  }) =>
      Input$CreateSponsorshipsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'sponsorLogin': sponsorLogin,
        r'sponsorships': sponsorships,
        if (receiveEmails != null) r'receiveEmails': receiveEmails,
        if (privacyLevel != null) r'privacyLevel': privacyLevel,
        if (recurring != null) r'recurring': recurring,
      });

  Input$CreateSponsorshipsInput._(this._$data);

  factory Input$CreateSponsorshipsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$sponsorLogin = data['sponsorLogin'];
    result$data['sponsorLogin'] = (l$sponsorLogin as String);
    final l$sponsorships = data['sponsorships'];
    result$data['sponsorships'] = (l$sponsorships as List<dynamic>)
        .map((e) => Input$BulkSponsorship.fromJson((e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('receiveEmails')) {
      final l$receiveEmails = data['receiveEmails'];
      result$data['receiveEmails'] = (l$receiveEmails as bool?);
    }
    if (data.containsKey('privacyLevel')) {
      final l$privacyLevel = data['privacyLevel'];
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : fromJson$Enum$SponsorshipPrivacy((l$privacyLevel as String));
    }
    if (data.containsKey('recurring')) {
      final l$recurring = data['recurring'];
      result$data['recurring'] = (l$recurring as bool?);
    }
    return Input$CreateSponsorshipsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get sponsorLogin => (_$data['sponsorLogin'] as String);

  List<Input$BulkSponsorship> get sponsorships =>
      (_$data['sponsorships'] as List<Input$BulkSponsorship>);

  bool? get receiveEmails => (_$data['receiveEmails'] as bool?);

  Enum$SponsorshipPrivacy? get privacyLevel =>
      (_$data['privacyLevel'] as Enum$SponsorshipPrivacy?);

  bool? get recurring => (_$data['recurring'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$sponsorLogin = sponsorLogin;
    result$data['sponsorLogin'] = l$sponsorLogin;
    final l$sponsorships = sponsorships;
    result$data['sponsorships'] =
        l$sponsorships.map((e) => e.toJson()).toList();
    if (_$data.containsKey('receiveEmails')) {
      final l$receiveEmails = receiveEmails;
      result$data['receiveEmails'] = l$receiveEmails;
    }
    if (_$data.containsKey('privacyLevel')) {
      final l$privacyLevel = privacyLevel;
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : toJson$Enum$SponsorshipPrivacy(l$privacyLevel);
    }
    if (_$data.containsKey('recurring')) {
      final l$recurring = recurring;
      result$data['recurring'] = l$recurring;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorshipsInput<Input$CreateSponsorshipsInput>
      get copyWith => CopyWith$Input$CreateSponsorshipsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateSponsorshipsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorships = sponsorships;
    final lOther$sponsorships = other.sponsorships;
    if (l$sponsorships.length != lOther$sponsorships.length) {
      return false;
    }
    for (int i = 0; i < l$sponsorships.length; i++) {
      final l$sponsorships$entry = l$sponsorships[i];
      final lOther$sponsorships$entry = lOther$sponsorships[i];
      if (l$sponsorships$entry != lOther$sponsorships$entry) {
        return false;
      }
    }
    final l$receiveEmails = receiveEmails;
    final lOther$receiveEmails = other.receiveEmails;
    if (_$data.containsKey('receiveEmails') !=
        other._$data.containsKey('receiveEmails')) {
      return false;
    }
    if (l$receiveEmails != lOther$receiveEmails) {
      return false;
    }
    final l$privacyLevel = privacyLevel;
    final lOther$privacyLevel = other.privacyLevel;
    if (_$data.containsKey('privacyLevel') !=
        other._$data.containsKey('privacyLevel')) {
      return false;
    }
    if (l$privacyLevel != lOther$privacyLevel) {
      return false;
    }
    final l$recurring = recurring;
    final lOther$recurring = other.recurring;
    if (_$data.containsKey('recurring') !=
        other._$data.containsKey('recurring')) {
      return false;
    }
    if (l$recurring != lOther$recurring) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorships = sponsorships;
    final l$receiveEmails = receiveEmails;
    final l$privacyLevel = privacyLevel;
    final l$recurring = recurring;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$sponsorLogin,
      Object.hashAll(l$sponsorships.map((v) => v)),
      _$data.containsKey('receiveEmails') ? l$receiveEmails : const {},
      _$data.containsKey('privacyLevel') ? l$privacyLevel : const {},
      _$data.containsKey('recurring') ? l$recurring : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorshipsInput<TRes> {
  factory CopyWith$Input$CreateSponsorshipsInput(
    Input$CreateSponsorshipsInput instance,
    TRes Function(Input$CreateSponsorshipsInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorshipsInput;

  factory CopyWith$Input$CreateSponsorshipsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorshipsInput;

  TRes call({
    String? clientMutationId,
    String? sponsorLogin,
    List<Input$BulkSponsorship>? sponsorships,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? recurring,
  });
  TRes sponsorships(
      Iterable<Input$BulkSponsorship> Function(
              Iterable<CopyWith$Input$BulkSponsorship<Input$BulkSponsorship>>)
          _fn);
}

class _CopyWithImpl$Input$CreateSponsorshipsInput<TRes>
    implements CopyWith$Input$CreateSponsorshipsInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorshipsInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorshipsInput _instance;

  final TRes Function(Input$CreateSponsorshipsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorships = _undefined,
    Object? receiveEmails = _undefined,
    Object? privacyLevel = _undefined,
    Object? recurring = _undefined,
  }) =>
      _then(Input$CreateSponsorshipsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorLogin != _undefined && sponsorLogin != null)
          'sponsorLogin': (sponsorLogin as String),
        if (sponsorships != _undefined && sponsorships != null)
          'sponsorships': (sponsorships as List<Input$BulkSponsorship>),
        if (receiveEmails != _undefined)
          'receiveEmails': (receiveEmails as bool?),
        if (privacyLevel != _undefined)
          'privacyLevel': (privacyLevel as Enum$SponsorshipPrivacy?),
        if (recurring != _undefined) 'recurring': (recurring as bool?),
      }));

  TRes sponsorships(
          Iterable<Input$BulkSponsorship> Function(
                  Iterable<
                      CopyWith$Input$BulkSponsorship<Input$BulkSponsorship>>)
              _fn) =>
      call(
          sponsorships: _fn(
              _instance.sponsorships.map((e) => CopyWith$Input$BulkSponsorship(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$CreateSponsorshipsInput<TRes>
    implements CopyWith$Input$CreateSponsorshipsInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorshipsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorLogin,
    List<Input$BulkSponsorship>? sponsorships,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? recurring,
  }) =>
      _res;

  sponsorships(_fn) => _res;
}

class Input$CreateSponsorsListingInput {
  factory Input$CreateSponsorsListingInput({
    String? clientMutationId,
    String? sponsorableLogin,
    String? fiscalHostLogin,
    String? fiscallyHostedProjectProfileUrl,
    Enum$SponsorsCountryOrRegionCode? billingCountryOrRegionCode,
    Enum$SponsorsCountryOrRegionCode? residenceCountryOrRegionCode,
    String? contactEmail,
    String? fullDescription,
  }) =>
      Input$CreateSponsorsListingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (fiscalHostLogin != null) r'fiscalHostLogin': fiscalHostLogin,
        if (fiscallyHostedProjectProfileUrl != null)
          r'fiscallyHostedProjectProfileUrl': fiscallyHostedProjectProfileUrl,
        if (billingCountryOrRegionCode != null)
          r'billingCountryOrRegionCode': billingCountryOrRegionCode,
        if (residenceCountryOrRegionCode != null)
          r'residenceCountryOrRegionCode': residenceCountryOrRegionCode,
        if (contactEmail != null) r'contactEmail': contactEmail,
        if (fullDescription != null) r'fullDescription': fullDescription,
      });

  Input$CreateSponsorsListingInput._(this._$data);

  factory Input$CreateSponsorsListingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('fiscalHostLogin')) {
      final l$fiscalHostLogin = data['fiscalHostLogin'];
      result$data['fiscalHostLogin'] = (l$fiscalHostLogin as String?);
    }
    if (data.containsKey('fiscallyHostedProjectProfileUrl')) {
      final l$fiscallyHostedProjectProfileUrl =
          data['fiscallyHostedProjectProfileUrl'];
      result$data['fiscallyHostedProjectProfileUrl'] =
          (l$fiscallyHostedProjectProfileUrl as String?);
    }
    if (data.containsKey('billingCountryOrRegionCode')) {
      final l$billingCountryOrRegionCode = data['billingCountryOrRegionCode'];
      result$data['billingCountryOrRegionCode'] =
          l$billingCountryOrRegionCode == null
              ? null
              : fromJson$Enum$SponsorsCountryOrRegionCode(
                  (l$billingCountryOrRegionCode as String));
    }
    if (data.containsKey('residenceCountryOrRegionCode')) {
      final l$residenceCountryOrRegionCode =
          data['residenceCountryOrRegionCode'];
      result$data['residenceCountryOrRegionCode'] =
          l$residenceCountryOrRegionCode == null
              ? null
              : fromJson$Enum$SponsorsCountryOrRegionCode(
                  (l$residenceCountryOrRegionCode as String));
    }
    if (data.containsKey('contactEmail')) {
      final l$contactEmail = data['contactEmail'];
      result$data['contactEmail'] = (l$contactEmail as String?);
    }
    if (data.containsKey('fullDescription')) {
      final l$fullDescription = data['fullDescription'];
      result$data['fullDescription'] = (l$fullDescription as String?);
    }
    return Input$CreateSponsorsListingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);

  String? get fiscalHostLogin => (_$data['fiscalHostLogin'] as String?);

  String? get fiscallyHostedProjectProfileUrl =>
      (_$data['fiscallyHostedProjectProfileUrl'] as String?);

  Enum$SponsorsCountryOrRegionCode? get billingCountryOrRegionCode =>
      (_$data['billingCountryOrRegionCode']
          as Enum$SponsorsCountryOrRegionCode?);

  Enum$SponsorsCountryOrRegionCode? get residenceCountryOrRegionCode =>
      (_$data['residenceCountryOrRegionCode']
          as Enum$SponsorsCountryOrRegionCode?);

  String? get contactEmail => (_$data['contactEmail'] as String?);

  String? get fullDescription => (_$data['fullDescription'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('fiscalHostLogin')) {
      final l$fiscalHostLogin = fiscalHostLogin;
      result$data['fiscalHostLogin'] = l$fiscalHostLogin;
    }
    if (_$data.containsKey('fiscallyHostedProjectProfileUrl')) {
      final l$fiscallyHostedProjectProfileUrl = fiscallyHostedProjectProfileUrl;
      result$data['fiscallyHostedProjectProfileUrl'] =
          l$fiscallyHostedProjectProfileUrl;
    }
    if (_$data.containsKey('billingCountryOrRegionCode')) {
      final l$billingCountryOrRegionCode = billingCountryOrRegionCode;
      result$data['billingCountryOrRegionCode'] =
          l$billingCountryOrRegionCode == null
              ? null
              : toJson$Enum$SponsorsCountryOrRegionCode(
                  l$billingCountryOrRegionCode);
    }
    if (_$data.containsKey('residenceCountryOrRegionCode')) {
      final l$residenceCountryOrRegionCode = residenceCountryOrRegionCode;
      result$data['residenceCountryOrRegionCode'] =
          l$residenceCountryOrRegionCode == null
              ? null
              : toJson$Enum$SponsorsCountryOrRegionCode(
                  l$residenceCountryOrRegionCode);
    }
    if (_$data.containsKey('contactEmail')) {
      final l$contactEmail = contactEmail;
      result$data['contactEmail'] = l$contactEmail;
    }
    if (_$data.containsKey('fullDescription')) {
      final l$fullDescription = fullDescription;
      result$data['fullDescription'] = l$fullDescription;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorsListingInput<Input$CreateSponsorsListingInput>
      get copyWith => CopyWith$Input$CreateSponsorsListingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateSponsorsListingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$fiscalHostLogin = fiscalHostLogin;
    final lOther$fiscalHostLogin = other.fiscalHostLogin;
    if (_$data.containsKey('fiscalHostLogin') !=
        other._$data.containsKey('fiscalHostLogin')) {
      return false;
    }
    if (l$fiscalHostLogin != lOther$fiscalHostLogin) {
      return false;
    }
    final l$fiscallyHostedProjectProfileUrl = fiscallyHostedProjectProfileUrl;
    final lOther$fiscallyHostedProjectProfileUrl =
        other.fiscallyHostedProjectProfileUrl;
    if (_$data.containsKey('fiscallyHostedProjectProfileUrl') !=
        other._$data.containsKey('fiscallyHostedProjectProfileUrl')) {
      return false;
    }
    if (l$fiscallyHostedProjectProfileUrl !=
        lOther$fiscallyHostedProjectProfileUrl) {
      return false;
    }
    final l$billingCountryOrRegionCode = billingCountryOrRegionCode;
    final lOther$billingCountryOrRegionCode = other.billingCountryOrRegionCode;
    if (_$data.containsKey('billingCountryOrRegionCode') !=
        other._$data.containsKey('billingCountryOrRegionCode')) {
      return false;
    }
    if (l$billingCountryOrRegionCode != lOther$billingCountryOrRegionCode) {
      return false;
    }
    final l$residenceCountryOrRegionCode = residenceCountryOrRegionCode;
    final lOther$residenceCountryOrRegionCode =
        other.residenceCountryOrRegionCode;
    if (_$data.containsKey('residenceCountryOrRegionCode') !=
        other._$data.containsKey('residenceCountryOrRegionCode')) {
      return false;
    }
    if (l$residenceCountryOrRegionCode != lOther$residenceCountryOrRegionCode) {
      return false;
    }
    final l$contactEmail = contactEmail;
    final lOther$contactEmail = other.contactEmail;
    if (_$data.containsKey('contactEmail') !=
        other._$data.containsKey('contactEmail')) {
      return false;
    }
    if (l$contactEmail != lOther$contactEmail) {
      return false;
    }
    final l$fullDescription = fullDescription;
    final lOther$fullDescription = other.fullDescription;
    if (_$data.containsKey('fullDescription') !=
        other._$data.containsKey('fullDescription')) {
      return false;
    }
    if (l$fullDescription != lOther$fullDescription) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$fiscalHostLogin = fiscalHostLogin;
    final l$fiscallyHostedProjectProfileUrl = fiscallyHostedProjectProfileUrl;
    final l$billingCountryOrRegionCode = billingCountryOrRegionCode;
    final l$residenceCountryOrRegionCode = residenceCountryOrRegionCode;
    final l$contactEmail = contactEmail;
    final l$fullDescription = fullDescription;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('fiscalHostLogin') ? l$fiscalHostLogin : const {},
      _$data.containsKey('fiscallyHostedProjectProfileUrl')
          ? l$fiscallyHostedProjectProfileUrl
          : const {},
      _$data.containsKey('billingCountryOrRegionCode')
          ? l$billingCountryOrRegionCode
          : const {},
      _$data.containsKey('residenceCountryOrRegionCode')
          ? l$residenceCountryOrRegionCode
          : const {},
      _$data.containsKey('contactEmail') ? l$contactEmail : const {},
      _$data.containsKey('fullDescription') ? l$fullDescription : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorsListingInput<TRes> {
  factory CopyWith$Input$CreateSponsorsListingInput(
    Input$CreateSponsorsListingInput instance,
    TRes Function(Input$CreateSponsorsListingInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorsListingInput;

  factory CopyWith$Input$CreateSponsorsListingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorsListingInput;

  TRes call({
    String? clientMutationId,
    String? sponsorableLogin,
    String? fiscalHostLogin,
    String? fiscallyHostedProjectProfileUrl,
    Enum$SponsorsCountryOrRegionCode? billingCountryOrRegionCode,
    Enum$SponsorsCountryOrRegionCode? residenceCountryOrRegionCode,
    String? contactEmail,
    String? fullDescription,
  });
}

class _CopyWithImpl$Input$CreateSponsorsListingInput<TRes>
    implements CopyWith$Input$CreateSponsorsListingInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorsListingInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorsListingInput _instance;

  final TRes Function(Input$CreateSponsorsListingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? fiscalHostLogin = _undefined,
    Object? fiscallyHostedProjectProfileUrl = _undefined,
    Object? billingCountryOrRegionCode = _undefined,
    Object? residenceCountryOrRegionCode = _undefined,
    Object? contactEmail = _undefined,
    Object? fullDescription = _undefined,
  }) =>
      _then(Input$CreateSponsorsListingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (fiscalHostLogin != _undefined)
          'fiscalHostLogin': (fiscalHostLogin as String?),
        if (fiscallyHostedProjectProfileUrl != _undefined)
          'fiscallyHostedProjectProfileUrl':
              (fiscallyHostedProjectProfileUrl as String?),
        if (billingCountryOrRegionCode != _undefined)
          'billingCountryOrRegionCode':
              (billingCountryOrRegionCode as Enum$SponsorsCountryOrRegionCode?),
        if (residenceCountryOrRegionCode != _undefined)
          'residenceCountryOrRegionCode': (residenceCountryOrRegionCode
              as Enum$SponsorsCountryOrRegionCode?),
        if (contactEmail != _undefined)
          'contactEmail': (contactEmail as String?),
        if (fullDescription != _undefined)
          'fullDescription': (fullDescription as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorsListingInput<TRes>
    implements CopyWith$Input$CreateSponsorsListingInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorsListingInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorableLogin,
    String? fiscalHostLogin,
    String? fiscallyHostedProjectProfileUrl,
    Enum$SponsorsCountryOrRegionCode? billingCountryOrRegionCode,
    Enum$SponsorsCountryOrRegionCode? residenceCountryOrRegionCode,
    String? contactEmail,
    String? fullDescription,
  }) =>
      _res;
}

class Input$CreateSponsorsTierInput {
  factory Input$CreateSponsorsTierInput({
    String? clientMutationId,
    String? sponsorableId,
    String? sponsorableLogin,
    required int amount,
    bool? isRecurring,
    String? repositoryId,
    String? repositoryOwnerLogin,
    String? repositoryName,
    String? welcomeMessage,
    required String description,
    bool? publish,
  }) =>
      Input$CreateSponsorsTierInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        r'amount': amount,
        if (isRecurring != null) r'isRecurring': isRecurring,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (repositoryOwnerLogin != null)
          r'repositoryOwnerLogin': repositoryOwnerLogin,
        if (repositoryName != null) r'repositoryName': repositoryName,
        if (welcomeMessage != null) r'welcomeMessage': welcomeMessage,
        r'description': description,
        if (publish != null) r'publish': publish,
      });

  Input$CreateSponsorsTierInput._(this._$data);

  factory Input$CreateSponsorsTierInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as int);
    if (data.containsKey('isRecurring')) {
      final l$isRecurring = data['isRecurring'];
      result$data['isRecurring'] = (l$isRecurring as bool?);
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('repositoryOwnerLogin')) {
      final l$repositoryOwnerLogin = data['repositoryOwnerLogin'];
      result$data['repositoryOwnerLogin'] = (l$repositoryOwnerLogin as String?);
    }
    if (data.containsKey('repositoryName')) {
      final l$repositoryName = data['repositoryName'];
      result$data['repositoryName'] = (l$repositoryName as String?);
    }
    if (data.containsKey('welcomeMessage')) {
      final l$welcomeMessage = data['welcomeMessage'];
      result$data['welcomeMessage'] = (l$welcomeMessage as String?);
    }
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('publish')) {
      final l$publish = data['publish'];
      result$data['publish'] = (l$publish as bool?);
    }
    return Input$CreateSponsorsTierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get sponsorableId => (_$data['sponsorableId'] as String?);

  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);

  int get amount => (_$data['amount'] as int);

  bool? get isRecurring => (_$data['isRecurring'] as bool?);

  String? get repositoryId => (_$data['repositoryId'] as String?);

  String? get repositoryOwnerLogin =>
      (_$data['repositoryOwnerLogin'] as String?);

  String? get repositoryName => (_$data['repositoryName'] as String?);

  String? get welcomeMessage => (_$data['welcomeMessage'] as String?);

  String get description => (_$data['description'] as String);

  bool? get publish => (_$data['publish'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    final l$amount = amount;
    result$data['amount'] = l$amount;
    if (_$data.containsKey('isRecurring')) {
      final l$isRecurring = isRecurring;
      result$data['isRecurring'] = l$isRecurring;
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('repositoryOwnerLogin')) {
      final l$repositoryOwnerLogin = repositoryOwnerLogin;
      result$data['repositoryOwnerLogin'] = l$repositoryOwnerLogin;
    }
    if (_$data.containsKey('repositoryName')) {
      final l$repositoryName = repositoryName;
      result$data['repositoryName'] = l$repositoryName;
    }
    if (_$data.containsKey('welcomeMessage')) {
      final l$welcomeMessage = welcomeMessage;
      result$data['welcomeMessage'] = l$welcomeMessage;
    }
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('publish')) {
      final l$publish = publish;
      result$data['publish'] = l$publish;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorsTierInput<Input$CreateSponsorsTierInput>
      get copyWith => CopyWith$Input$CreateSponsorsTierInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateSponsorsTierInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$isRecurring = isRecurring;
    final lOther$isRecurring = other.isRecurring;
    if (_$data.containsKey('isRecurring') !=
        other._$data.containsKey('isRecurring')) {
      return false;
    }
    if (l$isRecurring != lOther$isRecurring) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$repositoryOwnerLogin = repositoryOwnerLogin;
    final lOther$repositoryOwnerLogin = other.repositoryOwnerLogin;
    if (_$data.containsKey('repositoryOwnerLogin') !=
        other._$data.containsKey('repositoryOwnerLogin')) {
      return false;
    }
    if (l$repositoryOwnerLogin != lOther$repositoryOwnerLogin) {
      return false;
    }
    final l$repositoryName = repositoryName;
    final lOther$repositoryName = other.repositoryName;
    if (_$data.containsKey('repositoryName') !=
        other._$data.containsKey('repositoryName')) {
      return false;
    }
    if (l$repositoryName != lOther$repositoryName) {
      return false;
    }
    final l$welcomeMessage = welcomeMessage;
    final lOther$welcomeMessage = other.welcomeMessage;
    if (_$data.containsKey('welcomeMessage') !=
        other._$data.containsKey('welcomeMessage')) {
      return false;
    }
    if (l$welcomeMessage != lOther$welcomeMessage) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$publish = publish;
    final lOther$publish = other.publish;
    if (_$data.containsKey('publish') != other._$data.containsKey('publish')) {
      return false;
    }
    if (l$publish != lOther$publish) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$amount = amount;
    final l$isRecurring = isRecurring;
    final l$repositoryId = repositoryId;
    final l$repositoryOwnerLogin = repositoryOwnerLogin;
    final l$repositoryName = repositoryName;
    final l$welcomeMessage = welcomeMessage;
    final l$description = description;
    final l$publish = publish;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      l$amount,
      _$data.containsKey('isRecurring') ? l$isRecurring : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('repositoryOwnerLogin')
          ? l$repositoryOwnerLogin
          : const {},
      _$data.containsKey('repositoryName') ? l$repositoryName : const {},
      _$data.containsKey('welcomeMessage') ? l$welcomeMessage : const {},
      l$description,
      _$data.containsKey('publish') ? l$publish : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorsTierInput<TRes> {
  factory CopyWith$Input$CreateSponsorsTierInput(
    Input$CreateSponsorsTierInput instance,
    TRes Function(Input$CreateSponsorsTierInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorsTierInput;

  factory CopyWith$Input$CreateSponsorsTierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorsTierInput;

  TRes call({
    String? clientMutationId,
    String? sponsorableId,
    String? sponsorableLogin,
    int? amount,
    bool? isRecurring,
    String? repositoryId,
    String? repositoryOwnerLogin,
    String? repositoryName,
    String? welcomeMessage,
    String? description,
    bool? publish,
  });
}

class _CopyWithImpl$Input$CreateSponsorsTierInput<TRes>
    implements CopyWith$Input$CreateSponsorsTierInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorsTierInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorsTierInput _instance;

  final TRes Function(Input$CreateSponsorsTierInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? amount = _undefined,
    Object? isRecurring = _undefined,
    Object? repositoryId = _undefined,
    Object? repositoryOwnerLogin = _undefined,
    Object? repositoryName = _undefined,
    Object? welcomeMessage = _undefined,
    Object? description = _undefined,
    Object? publish = _undefined,
  }) =>
      _then(Input$CreateSponsorsTierInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (amount != _undefined && amount != null) 'amount': (amount as int),
        if (isRecurring != _undefined) 'isRecurring': (isRecurring as bool?),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (repositoryOwnerLogin != _undefined)
          'repositoryOwnerLogin': (repositoryOwnerLogin as String?),
        if (repositoryName != _undefined)
          'repositoryName': (repositoryName as String?),
        if (welcomeMessage != _undefined)
          'welcomeMessage': (welcomeMessage as String?),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (publish != _undefined) 'publish': (publish as bool?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorsTierInput<TRes>
    implements CopyWith$Input$CreateSponsorsTierInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorsTierInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorableId,
    String? sponsorableLogin,
    int? amount,
    bool? isRecurring,
    String? repositoryId,
    String? repositoryOwnerLogin,
    String? repositoryName,
    String? welcomeMessage,
    String? description,
    bool? publish,
  }) =>
      _res;
}

class Input$CreateTeamDiscussionCommentInput {
  factory Input$CreateTeamDiscussionCommentInput({
    String? clientMutationId,
    String? discussionId,
    String? body,
  }) =>
      Input$CreateTeamDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (discussionId != null) r'discussionId': discussionId,
        if (body != null) r'body': body,
      });

  Input$CreateTeamDiscussionCommentInput._(this._$data);

  factory Input$CreateTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('discussionId')) {
      final l$discussionId = data['discussionId'];
      result$data['discussionId'] = (l$discussionId as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$CreateTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get discussionId => (_$data['discussionId'] as String?);

  String? get body => (_$data['body'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('discussionId')) {
      final l$discussionId = discussionId;
      result$data['discussionId'] = l$discussionId;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$CreateTeamDiscussionCommentInput<
          Input$CreateTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$CreateTeamDiscussionCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateTeamDiscussionCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (_$data.containsKey('discussionId') !=
        other._$data.containsKey('discussionId')) {
      return false;
    }
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('discussionId') ? l$discussionId : const {},
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$CreateTeamDiscussionCommentInput(
    Input$CreateTeamDiscussionCommentInput instance,
    TRes Function(Input$CreateTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$CreateTeamDiscussionCommentInput;

  factory CopyWith$Input$CreateTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? discussionId,
    String? body,
  });
}

class _CopyWithImpl$Input$CreateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$CreateTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$CreateTeamDiscussionCommentInput _instance;

  final TRes Function(Input$CreateTeamDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$CreateTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined)
          'discussionId': (discussionId as String?),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? discussionId,
    String? body,
  }) =>
      _res;
}

class Input$CreateTeamDiscussionInput {
  factory Input$CreateTeamDiscussionInput({
    String? clientMutationId,
    String? teamId,
    String? title,
    String? body,
    bool? private,
  }) =>
      Input$CreateTeamDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (teamId != null) r'teamId': teamId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (private != null) r'private': private,
      });

  Input$CreateTeamDiscussionInput._(this._$data);

  factory Input$CreateTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('private')) {
      final l$private = data['private'];
      result$data['private'] = (l$private as bool?);
    }
    return Input$CreateTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get teamId => (_$data['teamId'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  bool? get private => (_$data['private'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('private')) {
      final l$private = private;
      result$data['private'] = l$private;
    }
    return result$data;
  }

  CopyWith$Input$CreateTeamDiscussionInput<Input$CreateTeamDiscussionInput>
      get copyWith => CopyWith$Input$CreateTeamDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateTeamDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$private = private;
    final lOther$private = other.private;
    if (_$data.containsKey('private') != other._$data.containsKey('private')) {
      return false;
    }
    if (l$private != lOther$private) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$teamId = teamId;
    final l$title = title;
    final l$body = body;
    final l$private = private;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('private') ? l$private : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  factory CopyWith$Input$CreateTeamDiscussionInput(
    Input$CreateTeamDiscussionInput instance,
    TRes Function(Input$CreateTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$CreateTeamDiscussionInput;

  factory CopyWith$Input$CreateTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTeamDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? teamId,
    String? title,
    String? body,
    bool? private,
  });
}

class _CopyWithImpl$Input$CreateTeamDiscussionInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$CreateTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CreateTeamDiscussionInput _instance;

  final TRes Function(Input$CreateTeamDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? teamId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? private = _undefined,
  }) =>
      _then(Input$CreateTeamDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (private != _undefined) 'private': (private as bool?),
      }));
}

class _CopyWithStubImpl$Input$CreateTeamDiscussionInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CreateTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? teamId,
    String? title,
    String? body,
    bool? private,
  }) =>
      _res;
}

class Input$CreateUserListInput {
  factory Input$CreateUserListInput({
    String? clientMutationId,
    required String name,
    String? description,
    bool? isPrivate,
  }) =>
      Input$CreateUserListInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        if (description != null) r'description': description,
        if (isPrivate != null) r'isPrivate': isPrivate,
      });

  Input$CreateUserListInput._(this._$data);

  factory Input$CreateUserListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('isPrivate')) {
      final l$isPrivate = data['isPrivate'];
      result$data['isPrivate'] = (l$isPrivate as bool?);
    }
    return Input$CreateUserListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get name => (_$data['name'] as String);

  String? get description => (_$data['description'] as String?);

  bool? get isPrivate => (_$data['isPrivate'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('isPrivate')) {
      final l$isPrivate = isPrivate;
      result$data['isPrivate'] = l$isPrivate;
    }
    return result$data;
  }

  CopyWith$Input$CreateUserListInput<Input$CreateUserListInput> get copyWith =>
      CopyWith$Input$CreateUserListInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$CreateUserListInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isPrivate = isPrivate;
    final lOther$isPrivate = other.isPrivate;
    if (_$data.containsKey('isPrivate') !=
        other._$data.containsKey('isPrivate')) {
      return false;
    }
    if (l$isPrivate != lOther$isPrivate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$description = description;
    final l$isPrivate = isPrivate;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isPrivate') ? l$isPrivate : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateUserListInput<TRes> {
  factory CopyWith$Input$CreateUserListInput(
    Input$CreateUserListInput instance,
    TRes Function(Input$CreateUserListInput) then,
  ) = _CopyWithImpl$Input$CreateUserListInput;

  factory CopyWith$Input$CreateUserListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateUserListInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? description,
    bool? isPrivate,
  });
}

class _CopyWithImpl$Input$CreateUserListInput<TRes>
    implements CopyWith$Input$CreateUserListInput<TRes> {
  _CopyWithImpl$Input$CreateUserListInput(
    this._instance,
    this._then,
  );

  final Input$CreateUserListInput _instance;

  final TRes Function(Input$CreateUserListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? isPrivate = _undefined,
  }) =>
      _then(Input$CreateUserListInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined) 'description': (description as String?),
        if (isPrivate != _undefined) 'isPrivate': (isPrivate as bool?),
      }));
}

class _CopyWithStubImpl$Input$CreateUserListInput<TRes>
    implements CopyWith$Input$CreateUserListInput<TRes> {
  _CopyWithStubImpl$Input$CreateUserListInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? description,
    bool? isPrivate,
  }) =>
      _res;
}

class Input$DeclineTopicSuggestionInput {
  factory Input$DeclineTopicSuggestionInput({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    Enum$TopicSuggestionDeclineReason? reason,
  }) =>
      Input$DeclineTopicSuggestionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (name != null) r'name': name,
        if (reason != null) r'reason': reason,
      });

  Input$DeclineTopicSuggestionInput._(this._$data);

  factory Input$DeclineTopicSuggestionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = l$reason == null
          ? null
          : fromJson$Enum$TopicSuggestionDeclineReason((l$reason as String));
    }
    return Input$DeclineTopicSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get repositoryId => (_$data['repositoryId'] as String?);

  String? get name => (_$data['name'] as String?);

  Enum$TopicSuggestionDeclineReason? get reason =>
      (_$data['reason'] as Enum$TopicSuggestionDeclineReason?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] = l$reason == null
          ? null
          : toJson$Enum$TopicSuggestionDeclineReason(l$reason);
    }
    return result$data;
  }

  CopyWith$Input$DeclineTopicSuggestionInput<Input$DeclineTopicSuggestionInput>
      get copyWith => CopyWith$Input$DeclineTopicSuggestionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeclineTopicSuggestionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$reason = reason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('reason') ? l$reason : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  factory CopyWith$Input$DeclineTopicSuggestionInput(
    Input$DeclineTopicSuggestionInput instance,
    TRes Function(Input$DeclineTopicSuggestionInput) then,
  ) = _CopyWithImpl$Input$DeclineTopicSuggestionInput;

  factory CopyWith$Input$DeclineTopicSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeclineTopicSuggestionInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    Enum$TopicSuggestionDeclineReason? reason,
  });
}

class _CopyWithImpl$Input$DeclineTopicSuggestionInput<TRes>
    implements CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  _CopyWithImpl$Input$DeclineTopicSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$DeclineTopicSuggestionInput _instance;

  final TRes Function(Input$DeclineTopicSuggestionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? reason = _undefined,
  }) =>
      _then(Input$DeclineTopicSuggestionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (reason != _undefined)
          'reason': (reason as Enum$TopicSuggestionDeclineReason?),
      }));
}

class _CopyWithStubImpl$Input$DeclineTopicSuggestionInput<TRes>
    implements CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$DeclineTopicSuggestionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    Enum$TopicSuggestionDeclineReason? reason,
  }) =>
      _res;
}

class Input$DeleteBranchProtectionRuleInput {
  factory Input$DeleteBranchProtectionRuleInput({
    String? clientMutationId,
    required String branchProtectionRuleId,
  }) =>
      Input$DeleteBranchProtectionRuleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'branchProtectionRuleId': branchProtectionRuleId,
      });

  Input$DeleteBranchProtectionRuleInput._(this._$data);

  factory Input$DeleteBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$branchProtectionRuleId = data['branchProtectionRuleId'];
    result$data['branchProtectionRuleId'] =
        (l$branchProtectionRuleId as String);
    return Input$DeleteBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get branchProtectionRuleId =>
      (_$data['branchProtectionRuleId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    result$data['branchProtectionRuleId'] = l$branchProtectionRuleId;
    return result$data;
  }

  CopyWith$Input$DeleteBranchProtectionRuleInput<
          Input$DeleteBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$DeleteBranchProtectionRuleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteBranchProtectionRuleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final lOther$branchProtectionRuleId = other.branchProtectionRuleId;
    if (l$branchProtectionRuleId != lOther$branchProtectionRuleId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$branchProtectionRuleId = branchProtectionRuleId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$branchProtectionRuleId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$DeleteBranchProtectionRuleInput(
    Input$DeleteBranchProtectionRuleInput instance,
    TRes Function(Input$DeleteBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$DeleteBranchProtectionRuleInput;

  factory CopyWith$Input$DeleteBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput;

  TRes call({
    String? clientMutationId,
    String? branchProtectionRuleId,
  });
}

class _CopyWithImpl$Input$DeleteBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$DeleteBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$DeleteBranchProtectionRuleInput _instance;

  final TRes Function(Input$DeleteBranchProtectionRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? branchProtectionRuleId = _undefined,
  }) =>
      _then(Input$DeleteBranchProtectionRuleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (branchProtectionRuleId != _undefined &&
            branchProtectionRuleId != null)
          'branchProtectionRuleId': (branchProtectionRuleId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? branchProtectionRuleId,
  }) =>
      _res;
}

class Input$DeleteDeploymentInput {
  factory Input$DeleteDeploymentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteDeploymentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteDeploymentInput._(this._$data);

  factory Input$DeleteDeploymentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteDeploymentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteDeploymentInput<Input$DeleteDeploymentInput>
      get copyWith => CopyWith$Input$DeleteDeploymentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteDeploymentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteDeploymentInput<TRes> {
  factory CopyWith$Input$DeleteDeploymentInput(
    Input$DeleteDeploymentInput instance,
    TRes Function(Input$DeleteDeploymentInput) then,
  ) = _CopyWithImpl$Input$DeleteDeploymentInput;

  factory CopyWith$Input$DeleteDeploymentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDeploymentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteDeploymentInput<TRes>
    implements CopyWith$Input$DeleteDeploymentInput<TRes> {
  _CopyWithImpl$Input$DeleteDeploymentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDeploymentInput _instance;

  final TRes Function(Input$DeleteDeploymentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteDeploymentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteDeploymentInput<TRes>
    implements CopyWith$Input$DeleteDeploymentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDeploymentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteDiscussionCommentInput {
  factory Input$DeleteDiscussionCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteDiscussionCommentInput._(this._$data);

  factory Input$DeleteDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteDiscussionCommentInput<
          Input$DeleteDiscussionCommentInput>
      get copyWith => CopyWith$Input$DeleteDiscussionCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteDiscussionCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  factory CopyWith$Input$DeleteDiscussionCommentInput(
    Input$DeleteDiscussionCommentInput instance,
    TRes Function(Input$DeleteDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteDiscussionCommentInput;

  factory CopyWith$Input$DeleteDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDiscussionCommentInput _instance;

  final TRes Function(Input$DeleteDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteDiscussionInput {
  factory Input$DeleteDiscussionInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteDiscussionInput._(this._$data);

  factory Input$DeleteDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteDiscussionInput<Input$DeleteDiscussionInput>
      get copyWith => CopyWith$Input$DeleteDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteDiscussionInput<TRes> {
  factory CopyWith$Input$DeleteDiscussionInput(
    Input$DeleteDiscussionInput instance,
    TRes Function(Input$DeleteDiscussionInput) then,
  ) = _CopyWithImpl$Input$DeleteDiscussionInput;

  factory CopyWith$Input$DeleteDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteDiscussionInput<TRes>
    implements CopyWith$Input$DeleteDiscussionInput<TRes> {
  _CopyWithImpl$Input$DeleteDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDiscussionInput _instance;

  final TRes Function(Input$DeleteDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteDiscussionInput<TRes>
    implements CopyWith$Input$DeleteDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteEnvironmentInput {
  factory Input$DeleteEnvironmentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteEnvironmentInput._(this._$data);

  factory Input$DeleteEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteEnvironmentInput<Input$DeleteEnvironmentInput>
      get copyWith => CopyWith$Input$DeleteEnvironmentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteEnvironmentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteEnvironmentInput<TRes> {
  factory CopyWith$Input$DeleteEnvironmentInput(
    Input$DeleteEnvironmentInput instance,
    TRes Function(Input$DeleteEnvironmentInput) then,
  ) = _CopyWithImpl$Input$DeleteEnvironmentInput;

  factory CopyWith$Input$DeleteEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteEnvironmentInput<TRes>
    implements CopyWith$Input$DeleteEnvironmentInput<TRes> {
  _CopyWithImpl$Input$DeleteEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteEnvironmentInput _instance;

  final TRes Function(Input$DeleteEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteEnvironmentInput<TRes>
    implements CopyWith$Input$DeleteEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteIpAllowListEntryInput {
  factory Input$DeleteIpAllowListEntryInput({
    String? clientMutationId,
    required String ipAllowListEntryId,
  }) =>
      Input$DeleteIpAllowListEntryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ipAllowListEntryId': ipAllowListEntryId,
      });

  Input$DeleteIpAllowListEntryInput._(this._$data);

  factory Input$DeleteIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ipAllowListEntryId = data['ipAllowListEntryId'];
    result$data['ipAllowListEntryId'] = (l$ipAllowListEntryId as String);
    return Input$DeleteIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ipAllowListEntryId => (_$data['ipAllowListEntryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    result$data['ipAllowListEntryId'] = l$ipAllowListEntryId;
    return result$data;
  }

  CopyWith$Input$DeleteIpAllowListEntryInput<Input$DeleteIpAllowListEntryInput>
      get copyWith => CopyWith$Input$DeleteIpAllowListEntryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteIpAllowListEntryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final lOther$ipAllowListEntryId = other.ipAllowListEntryId;
    if (l$ipAllowListEntryId != lOther$ipAllowListEntryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ipAllowListEntryId = ipAllowListEntryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ipAllowListEntryId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$DeleteIpAllowListEntryInput(
    Input$DeleteIpAllowListEntryInput instance,
    TRes Function(Input$DeleteIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$DeleteIpAllowListEntryInput;

  factory CopyWith$Input$DeleteIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput;

  TRes call({
    String? clientMutationId,
    String? ipAllowListEntryId,
  });
}

class _CopyWithImpl$Input$DeleteIpAllowListEntryInput<TRes>
    implements CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$DeleteIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIpAllowListEntryInput _instance;

  final TRes Function(Input$DeleteIpAllowListEntryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ipAllowListEntryId = _undefined,
  }) =>
      _then(Input$DeleteIpAllowListEntryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ipAllowListEntryId != _undefined && ipAllowListEntryId != null)
          'ipAllowListEntryId': (ipAllowListEntryId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput<TRes>
    implements CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ipAllowListEntryId,
  }) =>
      _res;
}

class Input$DeleteIssueCommentInput {
  factory Input$DeleteIssueCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteIssueCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteIssueCommentInput._(this._$data);

  factory Input$DeleteIssueCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteIssueCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteIssueCommentInput<Input$DeleteIssueCommentInput>
      get copyWith => CopyWith$Input$DeleteIssueCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteIssueCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteIssueCommentInput<TRes> {
  factory CopyWith$Input$DeleteIssueCommentInput(
    Input$DeleteIssueCommentInput instance,
    TRes Function(Input$DeleteIssueCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteIssueCommentInput;

  factory CopyWith$Input$DeleteIssueCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIssueCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteIssueCommentInput<TRes>
    implements CopyWith$Input$DeleteIssueCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteIssueCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIssueCommentInput _instance;

  final TRes Function(Input$DeleteIssueCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteIssueCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteIssueCommentInput<TRes>
    implements CopyWith$Input$DeleteIssueCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIssueCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteIssueInput {
  factory Input$DeleteIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$DeleteIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$DeleteIssueInput._(this._$data);

  factory Input$DeleteIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$DeleteIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$DeleteIssueInput<Input$DeleteIssueInput> get copyWith =>
      CopyWith$Input$DeleteIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteIssueInput<TRes> {
  factory CopyWith$Input$DeleteIssueInput(
    Input$DeleteIssueInput instance,
    TRes Function(Input$DeleteIssueInput) then,
  ) = _CopyWithImpl$Input$DeleteIssueInput;

  factory CopyWith$Input$DeleteIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$DeleteIssueInput<TRes>
    implements CopyWith$Input$DeleteIssueInput<TRes> {
  _CopyWithImpl$Input$DeleteIssueInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIssueInput _instance;

  final TRes Function(Input$DeleteIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$DeleteIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteIssueInput<TRes>
    implements CopyWith$Input$DeleteIssueInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$DeleteIssueTypeInput {
  factory Input$DeleteIssueTypeInput({
    String? clientMutationId,
    required String issueTypeId,
  }) =>
      Input$DeleteIssueTypeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueTypeId': issueTypeId,
      });

  Input$DeleteIssueTypeInput._(this._$data);

  factory Input$DeleteIssueTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueTypeId = data['issueTypeId'];
    result$data['issueTypeId'] = (l$issueTypeId as String);
    return Input$DeleteIssueTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueTypeId => (_$data['issueTypeId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueTypeId = issueTypeId;
    result$data['issueTypeId'] = l$issueTypeId;
    return result$data;
  }

  CopyWith$Input$DeleteIssueTypeInput<Input$DeleteIssueTypeInput>
      get copyWith => CopyWith$Input$DeleteIssueTypeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteIssueTypeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueTypeId = issueTypeId;
    final lOther$issueTypeId = other.issueTypeId;
    if (l$issueTypeId != lOther$issueTypeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueTypeId = issueTypeId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueTypeId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteIssueTypeInput<TRes> {
  factory CopyWith$Input$DeleteIssueTypeInput(
    Input$DeleteIssueTypeInput instance,
    TRes Function(Input$DeleteIssueTypeInput) then,
  ) = _CopyWithImpl$Input$DeleteIssueTypeInput;

  factory CopyWith$Input$DeleteIssueTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIssueTypeInput;

  TRes call({
    String? clientMutationId,
    String? issueTypeId,
  });
}

class _CopyWithImpl$Input$DeleteIssueTypeInput<TRes>
    implements CopyWith$Input$DeleteIssueTypeInput<TRes> {
  _CopyWithImpl$Input$DeleteIssueTypeInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIssueTypeInput _instance;

  final TRes Function(Input$DeleteIssueTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueTypeId = _undefined,
  }) =>
      _then(Input$DeleteIssueTypeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueTypeId != _undefined && issueTypeId != null)
          'issueTypeId': (issueTypeId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteIssueTypeInput<TRes>
    implements CopyWith$Input$DeleteIssueTypeInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIssueTypeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueTypeId,
  }) =>
      _res;
}

class Input$DeleteLabelInput {
  factory Input$DeleteLabelInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteLabelInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteLabelInput._(this._$data);

  factory Input$DeleteLabelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteLabelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteLabelInput<Input$DeleteLabelInput> get copyWith =>
      CopyWith$Input$DeleteLabelInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteLabelInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteLabelInput<TRes> {
  factory CopyWith$Input$DeleteLabelInput(
    Input$DeleteLabelInput instance,
    TRes Function(Input$DeleteLabelInput) then,
  ) = _CopyWithImpl$Input$DeleteLabelInput;

  factory CopyWith$Input$DeleteLabelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteLabelInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteLabelInput<TRes>
    implements CopyWith$Input$DeleteLabelInput<TRes> {
  _CopyWithImpl$Input$DeleteLabelInput(
    this._instance,
    this._then,
  );

  final Input$DeleteLabelInput _instance;

  final TRes Function(Input$DeleteLabelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteLabelInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteLabelInput<TRes>
    implements CopyWith$Input$DeleteLabelInput<TRes> {
  _CopyWithStubImpl$Input$DeleteLabelInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteLinkedBranchInput {
  factory Input$DeleteLinkedBranchInput({
    String? clientMutationId,
    required String linkedBranchId,
  }) =>
      Input$DeleteLinkedBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'linkedBranchId': linkedBranchId,
      });

  Input$DeleteLinkedBranchInput._(this._$data);

  factory Input$DeleteLinkedBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$linkedBranchId = data['linkedBranchId'];
    result$data['linkedBranchId'] = (l$linkedBranchId as String);
    return Input$DeleteLinkedBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get linkedBranchId => (_$data['linkedBranchId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$linkedBranchId = linkedBranchId;
    result$data['linkedBranchId'] = l$linkedBranchId;
    return result$data;
  }

  CopyWith$Input$DeleteLinkedBranchInput<Input$DeleteLinkedBranchInput>
      get copyWith => CopyWith$Input$DeleteLinkedBranchInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteLinkedBranchInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$linkedBranchId = linkedBranchId;
    final lOther$linkedBranchId = other.linkedBranchId;
    if (l$linkedBranchId != lOther$linkedBranchId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$linkedBranchId = linkedBranchId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$linkedBranchId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  factory CopyWith$Input$DeleteLinkedBranchInput(
    Input$DeleteLinkedBranchInput instance,
    TRes Function(Input$DeleteLinkedBranchInput) then,
  ) = _CopyWithImpl$Input$DeleteLinkedBranchInput;

  factory CopyWith$Input$DeleteLinkedBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteLinkedBranchInput;

  TRes call({
    String? clientMutationId,
    String? linkedBranchId,
  });
}

class _CopyWithImpl$Input$DeleteLinkedBranchInput<TRes>
    implements CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  _CopyWithImpl$Input$DeleteLinkedBranchInput(
    this._instance,
    this._then,
  );

  final Input$DeleteLinkedBranchInput _instance;

  final TRes Function(Input$DeleteLinkedBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? linkedBranchId = _undefined,
  }) =>
      _then(Input$DeleteLinkedBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (linkedBranchId != _undefined && linkedBranchId != null)
          'linkedBranchId': (linkedBranchId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteLinkedBranchInput<TRes>
    implements CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  _CopyWithStubImpl$Input$DeleteLinkedBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? linkedBranchId,
  }) =>
      _res;
}

class Input$DeletePackageVersionInput {
  factory Input$DeletePackageVersionInput({
    String? clientMutationId,
    required String packageVersionId,
  }) =>
      Input$DeletePackageVersionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'packageVersionId': packageVersionId,
      });

  Input$DeletePackageVersionInput._(this._$data);

  factory Input$DeletePackageVersionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$packageVersionId = data['packageVersionId'];
    result$data['packageVersionId'] = (l$packageVersionId as String);
    return Input$DeletePackageVersionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get packageVersionId => (_$data['packageVersionId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$packageVersionId = packageVersionId;
    result$data['packageVersionId'] = l$packageVersionId;
    return result$data;
  }

  CopyWith$Input$DeletePackageVersionInput<Input$DeletePackageVersionInput>
      get copyWith => CopyWith$Input$DeletePackageVersionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeletePackageVersionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$packageVersionId = packageVersionId;
    final lOther$packageVersionId = other.packageVersionId;
    if (l$packageVersionId != lOther$packageVersionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$packageVersionId = packageVersionId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$packageVersionId,
    ]);
  }
}

abstract class CopyWith$Input$DeletePackageVersionInput<TRes> {
  factory CopyWith$Input$DeletePackageVersionInput(
    Input$DeletePackageVersionInput instance,
    TRes Function(Input$DeletePackageVersionInput) then,
  ) = _CopyWithImpl$Input$DeletePackageVersionInput;

  factory CopyWith$Input$DeletePackageVersionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePackageVersionInput;

  TRes call({
    String? clientMutationId,
    String? packageVersionId,
  });
}

class _CopyWithImpl$Input$DeletePackageVersionInput<TRes>
    implements CopyWith$Input$DeletePackageVersionInput<TRes> {
  _CopyWithImpl$Input$DeletePackageVersionInput(
    this._instance,
    this._then,
  );

  final Input$DeletePackageVersionInput _instance;

  final TRes Function(Input$DeletePackageVersionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? packageVersionId = _undefined,
  }) =>
      _then(Input$DeletePackageVersionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (packageVersionId != _undefined && packageVersionId != null)
          'packageVersionId': (packageVersionId as String),
      }));
}

class _CopyWithStubImpl$Input$DeletePackageVersionInput<TRes>
    implements CopyWith$Input$DeletePackageVersionInput<TRes> {
  _CopyWithStubImpl$Input$DeletePackageVersionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? packageVersionId,
  }) =>
      _res;
}

class Input$DeleteProjectCardInput {
  factory Input$DeleteProjectCardInput({
    String? clientMutationId,
    required String cardId,
  }) =>
      Input$DeleteProjectCardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'cardId': cardId,
      });

  Input$DeleteProjectCardInput._(this._$data);

  factory Input$DeleteProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$cardId = data['cardId'];
    result$data['cardId'] = (l$cardId as String);
    return Input$DeleteProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get cardId => (_$data['cardId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$cardId = cardId;
    result$data['cardId'] = l$cardId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectCardInput<Input$DeleteProjectCardInput>
      get copyWith => CopyWith$Input$DeleteProjectCardInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectCardInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$cardId = cardId;
    final lOther$cardId = other.cardId;
    if (l$cardId != lOther$cardId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$cardId = cardId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$cardId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectCardInput<TRes> {
  factory CopyWith$Input$DeleteProjectCardInput(
    Input$DeleteProjectCardInput instance,
    TRes Function(Input$DeleteProjectCardInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectCardInput;

  factory CopyWith$Input$DeleteProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectCardInput;

  TRes call({
    String? clientMutationId,
    String? cardId,
  });
}

class _CopyWithImpl$Input$DeleteProjectCardInput<TRes>
    implements CopyWith$Input$DeleteProjectCardInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectCardInput _instance;

  final TRes Function(Input$DeleteProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? cardId = _undefined,
  }) =>
      _then(Input$DeleteProjectCardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (cardId != _undefined && cardId != null)
          'cardId': (cardId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectCardInput<TRes>
    implements CopyWith$Input$DeleteProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectCardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? cardId,
  }) =>
      _res;
}

class Input$DeleteProjectColumnInput {
  factory Input$DeleteProjectColumnInput({
    String? clientMutationId,
    required String columnId,
  }) =>
      Input$DeleteProjectColumnInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'columnId': columnId,
      });

  Input$DeleteProjectColumnInput._(this._$data);

  factory Input$DeleteProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    return Input$DeleteProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get columnId => (_$data['columnId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectColumnInput<Input$DeleteProjectColumnInput>
      get copyWith => CopyWith$Input$DeleteProjectColumnInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectColumnInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$columnId = columnId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$columnId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectColumnInput<TRes> {
  factory CopyWith$Input$DeleteProjectColumnInput(
    Input$DeleteProjectColumnInput instance,
    TRes Function(Input$DeleteProjectColumnInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectColumnInput;

  factory CopyWith$Input$DeleteProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectColumnInput;

  TRes call({
    String? clientMutationId,
    String? columnId,
  });
}

class _CopyWithImpl$Input$DeleteProjectColumnInput<TRes>
    implements CopyWith$Input$DeleteProjectColumnInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectColumnInput _instance;

  final TRes Function(Input$DeleteProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? columnId = _undefined,
  }) =>
      _then(Input$DeleteProjectColumnInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectColumnInput<TRes>
    implements CopyWith$Input$DeleteProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectColumnInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? columnId,
  }) =>
      _res;
}

class Input$DeleteProjectInput {
  factory Input$DeleteProjectInput({
    String? clientMutationId,
    required String projectId,
  }) =>
      Input$DeleteProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
      });

  Input$DeleteProjectInput._(this._$data);

  factory Input$DeleteProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$DeleteProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectInput<Input$DeleteProjectInput> get copyWith =>
      CopyWith$Input$DeleteProjectInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectInput<TRes> {
  factory CopyWith$Input$DeleteProjectInput(
    Input$DeleteProjectInput instance,
    TRes Function(Input$DeleteProjectInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectInput;

  factory CopyWith$Input$DeleteProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$DeleteProjectInput<TRes>
    implements CopyWith$Input$DeleteProjectInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectInput _instance;

  final TRes Function(Input$DeleteProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$DeleteProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectInput<TRes>
    implements CopyWith$Input$DeleteProjectInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
  }) =>
      _res;
}

class Input$DeleteProjectV2FieldInput {
  factory Input$DeleteProjectV2FieldInput({
    String? clientMutationId,
    required String fieldId,
  }) =>
      Input$DeleteProjectV2FieldInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fieldId': fieldId,
      });

  Input$DeleteProjectV2FieldInput._(this._$data);

  factory Input$DeleteProjectV2FieldInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    return Input$DeleteProjectV2FieldInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get fieldId => (_$data['fieldId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2FieldInput<Input$DeleteProjectV2FieldInput>
      get copyWith => CopyWith$Input$DeleteProjectV2FieldInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectV2FieldInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fieldId = fieldId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fieldId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2FieldInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2FieldInput(
    Input$DeleteProjectV2FieldInput instance,
    TRes Function(Input$DeleteProjectV2FieldInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2FieldInput;

  factory CopyWith$Input$DeleteProjectV2FieldInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2FieldInput;

  TRes call({
    String? clientMutationId,
    String? fieldId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2FieldInput<TRes>
    implements CopyWith$Input$DeleteProjectV2FieldInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2FieldInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2FieldInput _instance;

  final TRes Function(Input$DeleteProjectV2FieldInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fieldId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2FieldInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2FieldInput<TRes>
    implements CopyWith$Input$DeleteProjectV2FieldInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2FieldInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fieldId,
  }) =>
      _res;
}

class Input$DeleteProjectV2Input {
  factory Input$DeleteProjectV2Input({
    String? clientMutationId,
    required String projectId,
  }) =>
      Input$DeleteProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
      });

  Input$DeleteProjectV2Input._(this._$data);

  factory Input$DeleteProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$DeleteProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2Input<Input$DeleteProjectV2Input>
      get copyWith => CopyWith$Input$DeleteProjectV2Input(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectV2Input ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2Input<TRes> {
  factory CopyWith$Input$DeleteProjectV2Input(
    Input$DeleteProjectV2Input instance,
    TRes Function(Input$DeleteProjectV2Input) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2Input;

  factory CopyWith$Input$DeleteProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2Input;

  TRes call({
    String? clientMutationId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2Input<TRes>
    implements CopyWith$Input$DeleteProjectV2Input<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2Input _instance;

  final TRes Function(Input$DeleteProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2Input<TRes>
    implements CopyWith$Input$DeleteProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
  }) =>
      _res;
}

class Input$DeleteProjectV2ItemInput {
  factory Input$DeleteProjectV2ItemInput({
    String? clientMutationId,
    required String projectId,
    required String itemId,
  }) =>
      Input$DeleteProjectV2ItemInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'itemId': itemId,
      });

  Input$DeleteProjectV2ItemInput._(this._$data);

  factory Input$DeleteProjectV2ItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    return Input$DeleteProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get itemId => (_$data['itemId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2ItemInput<Input$DeleteProjectV2ItemInput>
      get copyWith => CopyWith$Input$DeleteProjectV2ItemInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectV2ItemInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$itemId = itemId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$itemId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2ItemInput(
    Input$DeleteProjectV2ItemInput instance,
    TRes Function(Input$DeleteProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2ItemInput;

  factory CopyWith$Input$DeleteProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2ItemInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2ItemInput<TRes>
    implements CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2ItemInput _instance;

  final TRes Function(Input$DeleteProjectV2ItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? itemId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2ItemInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2ItemInput<TRes>
    implements CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
  }) =>
      _res;
}

class Input$DeleteProjectV2StatusUpdateInput {
  factory Input$DeleteProjectV2StatusUpdateInput({
    String? clientMutationId,
    required String statusUpdateId,
  }) =>
      Input$DeleteProjectV2StatusUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'statusUpdateId': statusUpdateId,
      });

  Input$DeleteProjectV2StatusUpdateInput._(this._$data);

  factory Input$DeleteProjectV2StatusUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$statusUpdateId = data['statusUpdateId'];
    result$data['statusUpdateId'] = (l$statusUpdateId as String);
    return Input$DeleteProjectV2StatusUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get statusUpdateId => (_$data['statusUpdateId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$statusUpdateId = statusUpdateId;
    result$data['statusUpdateId'] = l$statusUpdateId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2StatusUpdateInput<
          Input$DeleteProjectV2StatusUpdateInput>
      get copyWith => CopyWith$Input$DeleteProjectV2StatusUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectV2StatusUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$statusUpdateId = statusUpdateId;
    final lOther$statusUpdateId = other.statusUpdateId;
    if (l$statusUpdateId != lOther$statusUpdateId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$statusUpdateId = statusUpdateId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$statusUpdateId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2StatusUpdateInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2StatusUpdateInput(
    Input$DeleteProjectV2StatusUpdateInput instance,
    TRes Function(Input$DeleteProjectV2StatusUpdateInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2StatusUpdateInput;

  factory CopyWith$Input$DeleteProjectV2StatusUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2StatusUpdateInput;

  TRes call({
    String? clientMutationId,
    String? statusUpdateId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2StatusUpdateInput<TRes>
    implements CopyWith$Input$DeleteProjectV2StatusUpdateInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2StatusUpdateInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2StatusUpdateInput _instance;

  final TRes Function(Input$DeleteProjectV2StatusUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? statusUpdateId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2StatusUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (statusUpdateId != _undefined && statusUpdateId != null)
          'statusUpdateId': (statusUpdateId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2StatusUpdateInput<TRes>
    implements CopyWith$Input$DeleteProjectV2StatusUpdateInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2StatusUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? statusUpdateId,
  }) =>
      _res;
}

class Input$DeleteProjectV2WorkflowInput {
  factory Input$DeleteProjectV2WorkflowInput({
    String? clientMutationId,
    required String workflowId,
  }) =>
      Input$DeleteProjectV2WorkflowInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'workflowId': workflowId,
      });

  Input$DeleteProjectV2WorkflowInput._(this._$data);

  factory Input$DeleteProjectV2WorkflowInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$workflowId = data['workflowId'];
    result$data['workflowId'] = (l$workflowId as String);
    return Input$DeleteProjectV2WorkflowInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get workflowId => (_$data['workflowId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$workflowId = workflowId;
    result$data['workflowId'] = l$workflowId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2WorkflowInput<
          Input$DeleteProjectV2WorkflowInput>
      get copyWith => CopyWith$Input$DeleteProjectV2WorkflowInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteProjectV2WorkflowInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$workflowId = workflowId;
    final lOther$workflowId = other.workflowId;
    if (l$workflowId != lOther$workflowId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$workflowId = workflowId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$workflowId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2WorkflowInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2WorkflowInput(
    Input$DeleteProjectV2WorkflowInput instance,
    TRes Function(Input$DeleteProjectV2WorkflowInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2WorkflowInput;

  factory CopyWith$Input$DeleteProjectV2WorkflowInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2WorkflowInput;

  TRes call({
    String? clientMutationId,
    String? workflowId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2WorkflowInput<TRes>
    implements CopyWith$Input$DeleteProjectV2WorkflowInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2WorkflowInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2WorkflowInput _instance;

  final TRes Function(Input$DeleteProjectV2WorkflowInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? workflowId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2WorkflowInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (workflowId != _undefined && workflowId != null)
          'workflowId': (workflowId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2WorkflowInput<TRes>
    implements CopyWith$Input$DeleteProjectV2WorkflowInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2WorkflowInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? workflowId,
  }) =>
      _res;
}

class Input$DeletePullRequestReviewCommentInput {
  factory Input$DeletePullRequestReviewCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeletePullRequestReviewCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeletePullRequestReviewCommentInput._(this._$data);

  factory Input$DeletePullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeletePullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeletePullRequestReviewCommentInput<
          Input$DeletePullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$DeletePullRequestReviewCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeletePullRequestReviewCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$DeletePullRequestReviewCommentInput(
    Input$DeletePullRequestReviewCommentInput instance,
    TRes Function(Input$DeletePullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$DeletePullRequestReviewCommentInput;

  factory CopyWith$Input$DeletePullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeletePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$DeletePullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeletePullRequestReviewCommentInput _instance;

  final TRes Function(Input$DeletePullRequestReviewCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeletePullRequestReviewCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeletePullRequestReviewInput {
  factory Input$DeletePullRequestReviewInput({
    String? clientMutationId,
    required String pullRequestReviewId,
  }) =>
      Input$DeletePullRequestReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestReviewId': pullRequestReviewId,
      });

  Input$DeletePullRequestReviewInput._(this._$data);

  factory Input$DeletePullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    return Input$DeletePullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    return result$data;
  }

  CopyWith$Input$DeletePullRequestReviewInput<
          Input$DeletePullRequestReviewInput>
      get copyWith => CopyWith$Input$DeletePullRequestReviewInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeletePullRequestReviewInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewId = pullRequestReviewId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestReviewId,
    ]);
  }
}

abstract class CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  factory CopyWith$Input$DeletePullRequestReviewInput(
    Input$DeletePullRequestReviewInput instance,
    TRes Function(Input$DeletePullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$DeletePullRequestReviewInput;

  factory CopyWith$Input$DeletePullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePullRequestReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestReviewId,
  });
}

class _CopyWithImpl$Input$DeletePullRequestReviewInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$DeletePullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$DeletePullRequestReviewInput _instance;

  final TRes Function(Input$DeletePullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewId = _undefined,
  }) =>
      _then(Input$DeletePullRequestReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
      }));
}

class _CopyWithStubImpl$Input$DeletePullRequestReviewInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$DeletePullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestReviewId,
  }) =>
      _res;
}

class Input$DeleteRefInput {
  factory Input$DeleteRefInput({
    String? clientMutationId,
    required String refId,
  }) =>
      Input$DeleteRefInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'refId': refId,
      });

  Input$DeleteRefInput._(this._$data);

  factory Input$DeleteRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    return Input$DeleteRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get refId => (_$data['refId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$refId = refId;
    result$data['refId'] = l$refId;
    return result$data;
  }

  CopyWith$Input$DeleteRefInput<Input$DeleteRefInput> get copyWith =>
      CopyWith$Input$DeleteRefInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteRefInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$refId = refId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$refId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteRefInput<TRes> {
  factory CopyWith$Input$DeleteRefInput(
    Input$DeleteRefInput instance,
    TRes Function(Input$DeleteRefInput) then,
  ) = _CopyWithImpl$Input$DeleteRefInput;

  factory CopyWith$Input$DeleteRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteRefInput;

  TRes call({
    String? clientMutationId,
    String? refId,
  });
}

class _CopyWithImpl$Input$DeleteRefInput<TRes>
    implements CopyWith$Input$DeleteRefInput<TRes> {
  _CopyWithImpl$Input$DeleteRefInput(
    this._instance,
    this._then,
  );

  final Input$DeleteRefInput _instance;

  final TRes Function(Input$DeleteRefInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? refId = _undefined,
  }) =>
      _then(Input$DeleteRefInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (refId != _undefined && refId != null) 'refId': (refId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteRefInput<TRes>
    implements CopyWith$Input$DeleteRefInput<TRes> {
  _CopyWithStubImpl$Input$DeleteRefInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? refId,
  }) =>
      _res;
}

class Input$DeleteRepositoryRulesetInput {
  factory Input$DeleteRepositoryRulesetInput({
    String? clientMutationId,
    required String repositoryRulesetId,
  }) =>
      Input$DeleteRepositoryRulesetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryRulesetId': repositoryRulesetId,
      });

  Input$DeleteRepositoryRulesetInput._(this._$data);

  factory Input$DeleteRepositoryRulesetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryRulesetId = data['repositoryRulesetId'];
    result$data['repositoryRulesetId'] = (l$repositoryRulesetId as String);
    return Input$DeleteRepositoryRulesetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryRulesetId => (_$data['repositoryRulesetId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryRulesetId = repositoryRulesetId;
    result$data['repositoryRulesetId'] = l$repositoryRulesetId;
    return result$data;
  }

  CopyWith$Input$DeleteRepositoryRulesetInput<
          Input$DeleteRepositoryRulesetInput>
      get copyWith => CopyWith$Input$DeleteRepositoryRulesetInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteRepositoryRulesetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryRulesetId = repositoryRulesetId;
    final lOther$repositoryRulesetId = other.repositoryRulesetId;
    if (l$repositoryRulesetId != lOther$repositoryRulesetId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryRulesetId = repositoryRulesetId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryRulesetId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteRepositoryRulesetInput<TRes> {
  factory CopyWith$Input$DeleteRepositoryRulesetInput(
    Input$DeleteRepositoryRulesetInput instance,
    TRes Function(Input$DeleteRepositoryRulesetInput) then,
  ) = _CopyWithImpl$Input$DeleteRepositoryRulesetInput;

  factory CopyWith$Input$DeleteRepositoryRulesetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteRepositoryRulesetInput;

  TRes call({
    String? clientMutationId,
    String? repositoryRulesetId,
  });
}

class _CopyWithImpl$Input$DeleteRepositoryRulesetInput<TRes>
    implements CopyWith$Input$DeleteRepositoryRulesetInput<TRes> {
  _CopyWithImpl$Input$DeleteRepositoryRulesetInput(
    this._instance,
    this._then,
  );

  final Input$DeleteRepositoryRulesetInput _instance;

  final TRes Function(Input$DeleteRepositoryRulesetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryRulesetId = _undefined,
  }) =>
      _then(Input$DeleteRepositoryRulesetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryRulesetId != _undefined && repositoryRulesetId != null)
          'repositoryRulesetId': (repositoryRulesetId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteRepositoryRulesetInput<TRes>
    implements CopyWith$Input$DeleteRepositoryRulesetInput<TRes> {
  _CopyWithStubImpl$Input$DeleteRepositoryRulesetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryRulesetId,
  }) =>
      _res;
}

class Input$DeleteTeamDiscussionCommentInput {
  factory Input$DeleteTeamDiscussionCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteTeamDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteTeamDiscussionCommentInput._(this._$data);

  factory Input$DeleteTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteTeamDiscussionCommentInput<
          Input$DeleteTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$DeleteTeamDiscussionCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteTeamDiscussionCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$DeleteTeamDiscussionCommentInput(
    Input$DeleteTeamDiscussionCommentInput instance,
    TRes Function(Input$DeleteTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput;

  factory CopyWith$Input$DeleteTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteTeamDiscussionCommentInput _instance;

  final TRes Function(Input$DeleteTeamDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteTeamDiscussionInput {
  factory Input$DeleteTeamDiscussionInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteTeamDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteTeamDiscussionInput._(this._$data);

  factory Input$DeleteTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteTeamDiscussionInput<Input$DeleteTeamDiscussionInput>
      get copyWith => CopyWith$Input$DeleteTeamDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteTeamDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  factory CopyWith$Input$DeleteTeamDiscussionInput(
    Input$DeleteTeamDiscussionInput instance,
    TRes Function(Input$DeleteTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$DeleteTeamDiscussionInput;

  factory CopyWith$Input$DeleteTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteTeamDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteTeamDiscussionInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$DeleteTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$DeleteTeamDiscussionInput _instance;

  final TRes Function(Input$DeleteTeamDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteTeamDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteTeamDiscussionInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$DeleteTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteUserListInput {
  factory Input$DeleteUserListInput({
    String? clientMutationId,
    required String listId,
  }) =>
      Input$DeleteUserListInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'listId': listId,
      });

  Input$DeleteUserListInput._(this._$data);

  factory Input$DeleteUserListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    return Input$DeleteUserListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get listId => (_$data['listId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$listId = listId;
    result$data['listId'] = l$listId;
    return result$data;
  }

  CopyWith$Input$DeleteUserListInput<Input$DeleteUserListInput> get copyWith =>
      CopyWith$Input$DeleteUserListInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteUserListInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$listId = listId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$listId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteUserListInput<TRes> {
  factory CopyWith$Input$DeleteUserListInput(
    Input$DeleteUserListInput instance,
    TRes Function(Input$DeleteUserListInput) then,
  ) = _CopyWithImpl$Input$DeleteUserListInput;

  factory CopyWith$Input$DeleteUserListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteUserListInput;

  TRes call({
    String? clientMutationId,
    String? listId,
  });
}

class _CopyWithImpl$Input$DeleteUserListInput<TRes>
    implements CopyWith$Input$DeleteUserListInput<TRes> {
  _CopyWithImpl$Input$DeleteUserListInput(
    this._instance,
    this._then,
  );

  final Input$DeleteUserListInput _instance;

  final TRes Function(Input$DeleteUserListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? listId = _undefined,
  }) =>
      _then(Input$DeleteUserListInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteUserListInput<TRes>
    implements CopyWith$Input$DeleteUserListInput<TRes> {
  _CopyWithStubImpl$Input$DeleteUserListInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? listId,
  }) =>
      _res;
}

class Input$DeleteVerifiableDomainInput {
  factory Input$DeleteVerifiableDomainInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteVerifiableDomainInput._(this._$data);

  factory Input$DeleteVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteVerifiableDomainInput<Input$DeleteVerifiableDomainInput>
      get copyWith => CopyWith$Input$DeleteVerifiableDomainInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeleteVerifiableDomainInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  factory CopyWith$Input$DeleteVerifiableDomainInput(
    Input$DeleteVerifiableDomainInput instance,
    TRes Function(Input$DeleteVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$DeleteVerifiableDomainInput;

  factory CopyWith$Input$DeleteVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteVerifiableDomainInput<TRes>
    implements CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$DeleteVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$DeleteVerifiableDomainInput _instance;

  final TRes Function(Input$DeleteVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteVerifiableDomainInput<TRes>
    implements CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$DeleteVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeploymentOrder {
  factory Input$DeploymentOrder({
    required Enum$DeploymentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$DeploymentOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$DeploymentOrder._(this._$data);

  factory Input$DeploymentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DeploymentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$DeploymentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DeploymentOrderField get field =>
      (_$data['field'] as Enum$DeploymentOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$DeploymentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$DeploymentOrder<Input$DeploymentOrder> get copyWith =>
      CopyWith$Input$DeploymentOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DeploymentOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$DeploymentOrder<TRes> {
  factory CopyWith$Input$DeploymentOrder(
    Input$DeploymentOrder instance,
    TRes Function(Input$DeploymentOrder) then,
  ) = _CopyWithImpl$Input$DeploymentOrder;

  factory CopyWith$Input$DeploymentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DeploymentOrder;

  TRes call({
    Enum$DeploymentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$DeploymentOrder<TRes>
    implements CopyWith$Input$DeploymentOrder<TRes> {
  _CopyWithImpl$Input$DeploymentOrder(
    this._instance,
    this._then,
  );

  final Input$DeploymentOrder _instance;

  final TRes Function(Input$DeploymentOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$DeploymentOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$DeploymentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$DeploymentOrder<TRes>
    implements CopyWith$Input$DeploymentOrder<TRes> {
  _CopyWithStubImpl$Input$DeploymentOrder(this._res);

  TRes _res;

  call({
    Enum$DeploymentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$DequeuePullRequestInput {
  factory Input$DequeuePullRequestInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DequeuePullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DequeuePullRequestInput._(this._$data);

  factory Input$DequeuePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DequeuePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DequeuePullRequestInput<Input$DequeuePullRequestInput>
      get copyWith => CopyWith$Input$DequeuePullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DequeuePullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DequeuePullRequestInput<TRes> {
  factory CopyWith$Input$DequeuePullRequestInput(
    Input$DequeuePullRequestInput instance,
    TRes Function(Input$DequeuePullRequestInput) then,
  ) = _CopyWithImpl$Input$DequeuePullRequestInput;

  factory CopyWith$Input$DequeuePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DequeuePullRequestInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DequeuePullRequestInput<TRes>
    implements CopyWith$Input$DequeuePullRequestInput<TRes> {
  _CopyWithImpl$Input$DequeuePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$DequeuePullRequestInput _instance;

  final TRes Function(Input$DequeuePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DequeuePullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DequeuePullRequestInput<TRes>
    implements CopyWith$Input$DequeuePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$DequeuePullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DisablePullRequestAutoMergeInput {
  factory Input$DisablePullRequestAutoMergeInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$DisablePullRequestAutoMergeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$DisablePullRequestAutoMergeInput._(this._$data);

  factory Input$DisablePullRequestAutoMergeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$DisablePullRequestAutoMergeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$DisablePullRequestAutoMergeInput<
          Input$DisablePullRequestAutoMergeInput>
      get copyWith => CopyWith$Input$DisablePullRequestAutoMergeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DisablePullRequestAutoMergeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  factory CopyWith$Input$DisablePullRequestAutoMergeInput(
    Input$DisablePullRequestAutoMergeInput instance,
    TRes Function(Input$DisablePullRequestAutoMergeInput) then,
  ) = _CopyWithImpl$Input$DisablePullRequestAutoMergeInput;

  factory CopyWith$Input$DisablePullRequestAutoMergeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$DisablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  _CopyWithImpl$Input$DisablePullRequestAutoMergeInput(
    this._instance,
    this._then,
  );

  final Input$DisablePullRequestAutoMergeInput _instance;

  final TRes Function(Input$DisablePullRequestAutoMergeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$DisablePullRequestAutoMergeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$DiscussionOrder {
  factory Input$DiscussionOrder({
    required Enum$DiscussionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$DiscussionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$DiscussionOrder._(this._$data);

  factory Input$DiscussionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DiscussionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$DiscussionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DiscussionOrderField get field =>
      (_$data['field'] as Enum$DiscussionOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$DiscussionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$DiscussionOrder<Input$DiscussionOrder> get copyWith =>
      CopyWith$Input$DiscussionOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DiscussionOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$DiscussionOrder<TRes> {
  factory CopyWith$Input$DiscussionOrder(
    Input$DiscussionOrder instance,
    TRes Function(Input$DiscussionOrder) then,
  ) = _CopyWithImpl$Input$DiscussionOrder;

  factory CopyWith$Input$DiscussionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscussionOrder;

  TRes call({
    Enum$DiscussionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$DiscussionOrder<TRes>
    implements CopyWith$Input$DiscussionOrder<TRes> {
  _CopyWithImpl$Input$DiscussionOrder(
    this._instance,
    this._then,
  );

  final Input$DiscussionOrder _instance;

  final TRes Function(Input$DiscussionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$DiscussionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$DiscussionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$DiscussionOrder<TRes>
    implements CopyWith$Input$DiscussionOrder<TRes> {
  _CopyWithStubImpl$Input$DiscussionOrder(this._res);

  TRes _res;

  call({
    Enum$DiscussionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$DiscussionPollOptionOrder {
  factory Input$DiscussionPollOptionOrder({
    required Enum$DiscussionPollOptionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$DiscussionPollOptionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$DiscussionPollOptionOrder._(this._$data);

  factory Input$DiscussionPollOptionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DiscussionPollOptionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$DiscussionPollOptionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$DiscussionPollOptionOrderField get field =>
      (_$data['field'] as Enum$DiscussionPollOptionOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$DiscussionPollOptionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$DiscussionPollOptionOrder<Input$DiscussionPollOptionOrder>
      get copyWith => CopyWith$Input$DiscussionPollOptionOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DiscussionPollOptionOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  factory CopyWith$Input$DiscussionPollOptionOrder(
    Input$DiscussionPollOptionOrder instance,
    TRes Function(Input$DiscussionPollOptionOrder) then,
  ) = _CopyWithImpl$Input$DiscussionPollOptionOrder;

  factory CopyWith$Input$DiscussionPollOptionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscussionPollOptionOrder;

  TRes call({
    Enum$DiscussionPollOptionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$DiscussionPollOptionOrder<TRes>
    implements CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  _CopyWithImpl$Input$DiscussionPollOptionOrder(
    this._instance,
    this._then,
  );

  final Input$DiscussionPollOptionOrder _instance;

  final TRes Function(Input$DiscussionPollOptionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$DiscussionPollOptionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$DiscussionPollOptionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$DiscussionPollOptionOrder<TRes>
    implements CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  _CopyWithStubImpl$Input$DiscussionPollOptionOrder(this._res);

  TRes _res;

  call({
    Enum$DiscussionPollOptionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$DismissPullRequestReviewInput {
  factory Input$DismissPullRequestReviewInput({
    String? clientMutationId,
    required String pullRequestReviewId,
    required String message,
  }) =>
      Input$DismissPullRequestReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestReviewId': pullRequestReviewId,
        r'message': message,
      });

  Input$DismissPullRequestReviewInput._(this._$data);

  factory Input$DismissPullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    return Input$DismissPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);

  String get message => (_$data['message'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    final l$message = message;
    result$data['message'] = l$message;
    return result$data;
  }

  CopyWith$Input$DismissPullRequestReviewInput<
          Input$DismissPullRequestReviewInput>
      get copyWith => CopyWith$Input$DismissPullRequestReviewInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DismissPullRequestReviewInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$message = message;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestReviewId,
      l$message,
    ]);
  }
}

abstract class CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  factory CopyWith$Input$DismissPullRequestReviewInput(
    Input$DismissPullRequestReviewInput instance,
    TRes Function(Input$DismissPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$DismissPullRequestReviewInput;

  factory CopyWith$Input$DismissPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DismissPullRequestReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestReviewId,
    String? message,
  });
}

class _CopyWithImpl$Input$DismissPullRequestReviewInput<TRes>
    implements CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$DismissPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$DismissPullRequestReviewInput _instance;

  final TRes Function(Input$DismissPullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? message = _undefined,
  }) =>
      _then(Input$DismissPullRequestReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
        if (message != _undefined && message != null)
          'message': (message as String),
      }));
}

class _CopyWithStubImpl$Input$DismissPullRequestReviewInput<TRes>
    implements CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$DismissPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestReviewId,
    String? message,
  }) =>
      _res;
}

class Input$DismissRepositoryVulnerabilityAlertInput {
  factory Input$DismissRepositoryVulnerabilityAlertInput({
    String? clientMutationId,
    required String repositoryVulnerabilityAlertId,
    required Enum$DismissReason dismissReason,
  }) =>
      Input$DismissRepositoryVulnerabilityAlertInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryVulnerabilityAlertId': repositoryVulnerabilityAlertId,
        r'dismissReason': dismissReason,
      });

  Input$DismissRepositoryVulnerabilityAlertInput._(this._$data);

  factory Input$DismissRepositoryVulnerabilityAlertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryVulnerabilityAlertId =
        data['repositoryVulnerabilityAlertId'];
    result$data['repositoryVulnerabilityAlertId'] =
        (l$repositoryVulnerabilityAlertId as String);
    final l$dismissReason = data['dismissReason'];
    result$data['dismissReason'] =
        fromJson$Enum$DismissReason((l$dismissReason as String));
    return Input$DismissRepositoryVulnerabilityAlertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryVulnerabilityAlertId =>
      (_$data['repositoryVulnerabilityAlertId'] as String);

  Enum$DismissReason get dismissReason =>
      (_$data['dismissReason'] as Enum$DismissReason);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    result$data['repositoryVulnerabilityAlertId'] =
        l$repositoryVulnerabilityAlertId;
    final l$dismissReason = dismissReason;
    result$data['dismissReason'] = toJson$Enum$DismissReason(l$dismissReason);
    return result$data;
  }

  CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<
          Input$DismissRepositoryVulnerabilityAlertInput>
      get copyWith => CopyWith$Input$DismissRepositoryVulnerabilityAlertInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DismissRepositoryVulnerabilityAlertInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    final lOther$repositoryVulnerabilityAlertId =
        other.repositoryVulnerabilityAlertId;
    if (l$repositoryVulnerabilityAlertId !=
        lOther$repositoryVulnerabilityAlertId) {
      return false;
    }
    final l$dismissReason = dismissReason;
    final lOther$dismissReason = other.dismissReason;
    if (l$dismissReason != lOther$dismissReason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    final l$dismissReason = dismissReason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryVulnerabilityAlertId,
      l$dismissReason,
    ]);
  }
}

abstract class CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  factory CopyWith$Input$DismissRepositoryVulnerabilityAlertInput(
    Input$DismissRepositoryVulnerabilityAlertInput instance,
    TRes Function(Input$DismissRepositoryVulnerabilityAlertInput) then,
  ) = _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput;

  factory CopyWith$Input$DismissRepositoryVulnerabilityAlertInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput;

  TRes call({
    String? clientMutationId,
    String? repositoryVulnerabilityAlertId,
    Enum$DismissReason? dismissReason,
  });
}

class _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput<TRes>
    implements CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput(
    this._instance,
    this._then,
  );

  final Input$DismissRepositoryVulnerabilityAlertInput _instance;

  final TRes Function(Input$DismissRepositoryVulnerabilityAlertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryVulnerabilityAlertId = _undefined,
    Object? dismissReason = _undefined,
  }) =>
      _then(Input$DismissRepositoryVulnerabilityAlertInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryVulnerabilityAlertId != _undefined &&
            repositoryVulnerabilityAlertId != null)
          'repositoryVulnerabilityAlertId':
              (repositoryVulnerabilityAlertId as String),
        if (dismissReason != _undefined && dismissReason != null)
          'dismissReason': (dismissReason as Enum$DismissReason),
      }));
}

class _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput<TRes>
    implements CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryVulnerabilityAlertId,
    Enum$DismissReason? dismissReason,
  }) =>
      _res;
}

class Input$DraftPullRequestReviewComment {
  factory Input$DraftPullRequestReviewComment({
    required String path,
    required int position,
    required String body,
  }) =>
      Input$DraftPullRequestReviewComment._({
        r'path': path,
        r'position': position,
        r'body': body,
      });

  Input$DraftPullRequestReviewComment._(this._$data);

  factory Input$DraftPullRequestReviewComment.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$position = data['position'];
    result$data['position'] = (l$position as int);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$DraftPullRequestReviewComment._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);

  int get position => (_$data['position'] as int);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$position = position;
    result$data['position'] = l$position;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$DraftPullRequestReviewComment<
          Input$DraftPullRequestReviewComment>
      get copyWith => CopyWith$Input$DraftPullRequestReviewComment(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DraftPullRequestReviewComment ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$position = position;
    final l$body = body;
    return Object.hashAll([
      l$path,
      l$position,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  factory CopyWith$Input$DraftPullRequestReviewComment(
    Input$DraftPullRequestReviewComment instance,
    TRes Function(Input$DraftPullRequestReviewComment) then,
  ) = _CopyWithImpl$Input$DraftPullRequestReviewComment;

  factory CopyWith$Input$DraftPullRequestReviewComment.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftPullRequestReviewComment;

  TRes call({
    String? path,
    int? position,
    String? body,
  });
}

class _CopyWithImpl$Input$DraftPullRequestReviewComment<TRes>
    implements CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  _CopyWithImpl$Input$DraftPullRequestReviewComment(
    this._instance,
    this._then,
  );

  final Input$DraftPullRequestReviewComment _instance;

  final TRes Function(Input$DraftPullRequestReviewComment) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? position = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$DraftPullRequestReviewComment._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (position != _undefined && position != null)
          'position': (position as int),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$DraftPullRequestReviewComment<TRes>
    implements CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  _CopyWithStubImpl$Input$DraftPullRequestReviewComment(this._res);

  TRes _res;

  call({
    String? path,
    int? position,
    String? body,
  }) =>
      _res;
}

class Input$DraftPullRequestReviewThread {
  factory Input$DraftPullRequestReviewThread({
    String? path,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    required String body,
  }) =>
      Input$DraftPullRequestReviewThread._({
        if (path != null) r'path': path,
        if (line != null) r'line': line,
        if (side != null) r'side': side,
        if (startLine != null) r'startLine': startLine,
        if (startSide != null) r'startSide': startSide,
        r'body': body,
      });

  Input$DraftPullRequestReviewThread._(this._$data);

  factory Input$DraftPullRequestReviewThread.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as String?);
    }
    if (data.containsKey('line')) {
      final l$line = data['line'];
      result$data['line'] = (l$line as int?);
    }
    if (data.containsKey('side')) {
      final l$side = data['side'];
      result$data['side'] =
          l$side == null ? null : fromJson$Enum$DiffSide((l$side as String));
    }
    if (data.containsKey('startLine')) {
      final l$startLine = data['startLine'];
      result$data['startLine'] = (l$startLine as int?);
    }
    if (data.containsKey('startSide')) {
      final l$startSide = data['startSide'];
      result$data['startSide'] = l$startSide == null
          ? null
          : fromJson$Enum$DiffSide((l$startSide as String));
    }
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$DraftPullRequestReviewThread._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get path => (_$data['path'] as String?);

  int? get line => (_$data['line'] as int?);

  Enum$DiffSide? get side => (_$data['side'] as Enum$DiffSide?);

  int? get startLine => (_$data['startLine'] as int?);

  Enum$DiffSide? get startSide => (_$data['startSide'] as Enum$DiffSide?);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('line')) {
      final l$line = line;
      result$data['line'] = l$line;
    }
    if (_$data.containsKey('side')) {
      final l$side = side;
      result$data['side'] =
          l$side == null ? null : toJson$Enum$DiffSide(l$side);
    }
    if (_$data.containsKey('startLine')) {
      final l$startLine = startLine;
      result$data['startLine'] = l$startLine;
    }
    if (_$data.containsKey('startSide')) {
      final l$startSide = startSide;
      result$data['startSide'] =
          l$startSide == null ? null : toJson$Enum$DiffSide(l$startSide);
    }
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$DraftPullRequestReviewThread<
          Input$DraftPullRequestReviewThread>
      get copyWith => CopyWith$Input$DraftPullRequestReviewThread(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$DraftPullRequestReviewThread ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$line = line;
    final lOther$line = other.line;
    if (_$data.containsKey('line') != other._$data.containsKey('line')) {
      return false;
    }
    if (l$line != lOther$line) {
      return false;
    }
    final l$side = side;
    final lOther$side = other.side;
    if (_$data.containsKey('side') != other._$data.containsKey('side')) {
      return false;
    }
    if (l$side != lOther$side) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (_$data.containsKey('startLine') !=
        other._$data.containsKey('startLine')) {
      return false;
    }
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startSide = startSide;
    final lOther$startSide = other.startSide;
    if (_$data.containsKey('startSide') !=
        other._$data.containsKey('startSide')) {
      return false;
    }
    if (l$startSide != lOther$startSide) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$line = line;
    final l$side = side;
    final l$startLine = startLine;
    final l$startSide = startSide;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('line') ? l$line : const {},
      _$data.containsKey('side') ? l$side : const {},
      _$data.containsKey('startLine') ? l$startLine : const {},
      _$data.containsKey('startSide') ? l$startSide : const {},
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  factory CopyWith$Input$DraftPullRequestReviewThread(
    Input$DraftPullRequestReviewThread instance,
    TRes Function(Input$DraftPullRequestReviewThread) then,
  ) = _CopyWithImpl$Input$DraftPullRequestReviewThread;

  factory CopyWith$Input$DraftPullRequestReviewThread.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftPullRequestReviewThread;

  TRes call({
    String? path,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    String? body,
  });
}

class _CopyWithImpl$Input$DraftPullRequestReviewThread<TRes>
    implements CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  _CopyWithImpl$Input$DraftPullRequestReviewThread(
    this._instance,
    this._then,
  );

  final Input$DraftPullRequestReviewThread _instance;

  final TRes Function(Input$DraftPullRequestReviewThread) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? line = _undefined,
    Object? side = _undefined,
    Object? startLine = _undefined,
    Object? startSide = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$DraftPullRequestReviewThread._({
        ..._instance._$data,
        if (path != _undefined) 'path': (path as String?),
        if (line != _undefined) 'line': (line as int?),
        if (side != _undefined) 'side': (side as Enum$DiffSide?),
        if (startLine != _undefined) 'startLine': (startLine as int?),
        if (startSide != _undefined) 'startSide': (startSide as Enum$DiffSide?),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$DraftPullRequestReviewThread<TRes>
    implements CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  _CopyWithStubImpl$Input$DraftPullRequestReviewThread(this._res);

  TRes _res;

  call({
    String? path,
    int? line,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
    String? body,
  }) =>
      _res;
}

class Input$EnablePullRequestAutoMergeInput {
  factory Input$EnablePullRequestAutoMergeInput({
    String? clientMutationId,
    required String pullRequestId,
    String? commitHeadline,
    String? commitBody,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? expectedHeadOid,
  }) =>
      Input$EnablePullRequestAutoMergeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (commitHeadline != null) r'commitHeadline': commitHeadline,
        if (commitBody != null) r'commitBody': commitBody,
        if (mergeMethod != null) r'mergeMethod': mergeMethod,
        if (authorEmail != null) r'authorEmail': authorEmail,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
      });

  Input$EnablePullRequestAutoMergeInput._(this._$data);

  factory Input$EnablePullRequestAutoMergeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('commitHeadline')) {
      final l$commitHeadline = data['commitHeadline'];
      result$data['commitHeadline'] = (l$commitHeadline as String?);
    }
    if (data.containsKey('commitBody')) {
      final l$commitBody = data['commitBody'];
      result$data['commitBody'] = (l$commitBody as String?);
    }
    if (data.containsKey('mergeMethod')) {
      final l$mergeMethod = data['mergeMethod'];
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : fromJson$Enum$PullRequestMergeMethod((l$mergeMethod as String));
    }
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    return Input$EnablePullRequestAutoMergeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String? get commitHeadline => (_$data['commitHeadline'] as String?);

  String? get commitBody => (_$data['commitBody'] as String?);

  Enum$PullRequestMergeMethod? get mergeMethod =>
      (_$data['mergeMethod'] as Enum$PullRequestMergeMethod?);

  String? get authorEmail => (_$data['authorEmail'] as String?);

  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('commitHeadline')) {
      final l$commitHeadline = commitHeadline;
      result$data['commitHeadline'] = l$commitHeadline;
    }
    if (_$data.containsKey('commitBody')) {
      final l$commitBody = commitBody;
      result$data['commitBody'] = l$commitBody;
    }
    if (_$data.containsKey('mergeMethod')) {
      final l$mergeMethod = mergeMethod;
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : toJson$Enum$PullRequestMergeMethod(l$mergeMethod);
    }
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    return result$data;
  }

  CopyWith$Input$EnablePullRequestAutoMergeInput<
          Input$EnablePullRequestAutoMergeInput>
      get copyWith => CopyWith$Input$EnablePullRequestAutoMergeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnablePullRequestAutoMergeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$commitHeadline = commitHeadline;
    final lOther$commitHeadline = other.commitHeadline;
    if (_$data.containsKey('commitHeadline') !=
        other._$data.containsKey('commitHeadline')) {
      return false;
    }
    if (l$commitHeadline != lOther$commitHeadline) {
      return false;
    }
    final l$commitBody = commitBody;
    final lOther$commitBody = other.commitBody;
    if (_$data.containsKey('commitBody') !=
        other._$data.containsKey('commitBody')) {
      return false;
    }
    if (l$commitBody != lOther$commitBody) {
      return false;
    }
    final l$mergeMethod = mergeMethod;
    final lOther$mergeMethod = other.mergeMethod;
    if (_$data.containsKey('mergeMethod') !=
        other._$data.containsKey('mergeMethod')) {
      return false;
    }
    if (l$mergeMethod != lOther$mergeMethod) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$commitHeadline = commitHeadline;
    final l$commitBody = commitBody;
    final l$mergeMethod = mergeMethod;
    final l$authorEmail = authorEmail;
    final l$expectedHeadOid = expectedHeadOid;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('commitHeadline') ? l$commitHeadline : const {},
      _$data.containsKey('commitBody') ? l$commitBody : const {},
      _$data.containsKey('mergeMethod') ? l$mergeMethod : const {},
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  factory CopyWith$Input$EnablePullRequestAutoMergeInput(
    Input$EnablePullRequestAutoMergeInput instance,
    TRes Function(Input$EnablePullRequestAutoMergeInput) then,
  ) = _CopyWithImpl$Input$EnablePullRequestAutoMergeInput;

  factory CopyWith$Input$EnablePullRequestAutoMergeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? expectedHeadOid,
  });
}

class _CopyWithImpl$Input$EnablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  _CopyWithImpl$Input$EnablePullRequestAutoMergeInput(
    this._instance,
    this._then,
  );

  final Input$EnablePullRequestAutoMergeInput _instance;

  final TRes Function(Input$EnablePullRequestAutoMergeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? commitHeadline = _undefined,
    Object? commitBody = _undefined,
    Object? mergeMethod = _undefined,
    Object? authorEmail = _undefined,
    Object? expectedHeadOid = _undefined,
  }) =>
      _then(Input$EnablePullRequestAutoMergeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (commitHeadline != _undefined)
          'commitHeadline': (commitHeadline as String?),
        if (commitBody != _undefined) 'commitBody': (commitBody as String?),
        if (mergeMethod != _undefined)
          'mergeMethod': (mergeMethod as Enum$PullRequestMergeMethod?),
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
      }));
}

class _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
    String? expectedHeadOid,
  }) =>
      _res;
}

class Input$EnqueuePullRequestInput {
  factory Input$EnqueuePullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
    bool? jump,
    String? expectedHeadOid,
  }) =>
      Input$EnqueuePullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (jump != null) r'jump': jump,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
      });

  Input$EnqueuePullRequestInput._(this._$data);

  factory Input$EnqueuePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('jump')) {
      final l$jump = data['jump'];
      result$data['jump'] = (l$jump as bool?);
    }
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    return Input$EnqueuePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  bool? get jump => (_$data['jump'] as bool?);

  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('jump')) {
      final l$jump = jump;
      result$data['jump'] = l$jump;
    }
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    return result$data;
  }

  CopyWith$Input$EnqueuePullRequestInput<Input$EnqueuePullRequestInput>
      get copyWith => CopyWith$Input$EnqueuePullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnqueuePullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$jump = jump;
    final lOther$jump = other.jump;
    if (_$data.containsKey('jump') != other._$data.containsKey('jump')) {
      return false;
    }
    if (l$jump != lOther$jump) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$jump = jump;
    final l$expectedHeadOid = expectedHeadOid;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('jump') ? l$jump : const {},
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnqueuePullRequestInput<TRes> {
  factory CopyWith$Input$EnqueuePullRequestInput(
    Input$EnqueuePullRequestInput instance,
    TRes Function(Input$EnqueuePullRequestInput) then,
  ) = _CopyWithImpl$Input$EnqueuePullRequestInput;

  factory CopyWith$Input$EnqueuePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnqueuePullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    bool? jump,
    String? expectedHeadOid,
  });
}

class _CopyWithImpl$Input$EnqueuePullRequestInput<TRes>
    implements CopyWith$Input$EnqueuePullRequestInput<TRes> {
  _CopyWithImpl$Input$EnqueuePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$EnqueuePullRequestInput _instance;

  final TRes Function(Input$EnqueuePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? jump = _undefined,
    Object? expectedHeadOid = _undefined,
  }) =>
      _then(Input$EnqueuePullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (jump != _undefined) 'jump': (jump as bool?),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
      }));
}

class _CopyWithStubImpl$Input$EnqueuePullRequestInput<TRes>
    implements CopyWith$Input$EnqueuePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$EnqueuePullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    bool? jump,
    String? expectedHeadOid,
  }) =>
      _res;
}

class Input$EnterpriseAdministratorInvitationOrder {
  factory Input$EnterpriseAdministratorInvitationOrder({
    required Enum$EnterpriseAdministratorInvitationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseAdministratorInvitationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseAdministratorInvitationOrder._(this._$data);

  factory Input$EnterpriseAdministratorInvitationOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseAdministratorInvitationOrderField(
            (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseAdministratorInvitationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseAdministratorInvitationOrderField get field =>
      (_$data['field'] as Enum$EnterpriseAdministratorInvitationOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseAdministratorInvitationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseAdministratorInvitationOrder<
          Input$EnterpriseAdministratorInvitationOrder>
      get copyWith => CopyWith$Input$EnterpriseAdministratorInvitationOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseAdministratorInvitationOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  factory CopyWith$Input$EnterpriseAdministratorInvitationOrder(
    Input$EnterpriseAdministratorInvitationOrder instance,
    TRes Function(Input$EnterpriseAdministratorInvitationOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder;

  factory CopyWith$Input$EnterpriseAdministratorInvitationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder;

  TRes call({
    Enum$EnterpriseAdministratorInvitationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseAdministratorInvitationOrder _instance;

  final TRes Function(Input$EnterpriseAdministratorInvitationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseAdministratorInvitationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseAdministratorInvitationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseAdministratorInvitationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseMemberInvitationOrder {
  factory Input$EnterpriseMemberInvitationOrder({
    required Enum$EnterpriseMemberInvitationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseMemberInvitationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseMemberInvitationOrder._(this._$data);

  factory Input$EnterpriseMemberInvitationOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseMemberInvitationOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseMemberInvitationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseMemberInvitationOrderField get field =>
      (_$data['field'] as Enum$EnterpriseMemberInvitationOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseMemberInvitationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseMemberInvitationOrder<
          Input$EnterpriseMemberInvitationOrder>
      get copyWith => CopyWith$Input$EnterpriseMemberInvitationOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseMemberInvitationOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseMemberInvitationOrder<TRes> {
  factory CopyWith$Input$EnterpriseMemberInvitationOrder(
    Input$EnterpriseMemberInvitationOrder instance,
    TRes Function(Input$EnterpriseMemberInvitationOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseMemberInvitationOrder;

  factory CopyWith$Input$EnterpriseMemberInvitationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseMemberInvitationOrder;

  TRes call({
    Enum$EnterpriseMemberInvitationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseMemberInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberInvitationOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseMemberInvitationOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseMemberInvitationOrder _instance;

  final TRes Function(Input$EnterpriseMemberInvitationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseMemberInvitationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseMemberInvitationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseMemberInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberInvitationOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseMemberInvitationOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseMemberInvitationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseMemberOrder {
  factory Input$EnterpriseMemberOrder({
    required Enum$EnterpriseMemberOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseMemberOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseMemberOrder._(this._$data);

  factory Input$EnterpriseMemberOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseMemberOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseMemberOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseMemberOrderField get field =>
      (_$data['field'] as Enum$EnterpriseMemberOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$EnterpriseMemberOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseMemberOrder<Input$EnterpriseMemberOrder>
      get copyWith => CopyWith$Input$EnterpriseMemberOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseMemberOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseMemberOrder<TRes> {
  factory CopyWith$Input$EnterpriseMemberOrder(
    Input$EnterpriseMemberOrder instance,
    TRes Function(Input$EnterpriseMemberOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseMemberOrder;

  factory CopyWith$Input$EnterpriseMemberOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseMemberOrder;

  TRes call({
    Enum$EnterpriseMemberOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseMemberOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseMemberOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseMemberOrder _instance;

  final TRes Function(Input$EnterpriseMemberOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseMemberOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseMemberOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseMemberOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseMemberOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseMemberOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseOrder {
  factory Input$EnterpriseOrder({
    required Enum$EnterpriseOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseOrder._(this._$data);

  factory Input$EnterpriseOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseOrderField get field =>
      (_$data['field'] as Enum$EnterpriseOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$EnterpriseOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseOrder<Input$EnterpriseOrder> get copyWith =>
      CopyWith$Input$EnterpriseOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseOrder<TRes> {
  factory CopyWith$Input$EnterpriseOrder(
    Input$EnterpriseOrder instance,
    TRes Function(Input$EnterpriseOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseOrder;

  factory CopyWith$Input$EnterpriseOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseOrder;

  TRes call({
    Enum$EnterpriseOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseOrder<TRes>
    implements CopyWith$Input$EnterpriseOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseOrder _instance;

  final TRes Function(Input$EnterpriseOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseOrder<TRes>
    implements CopyWith$Input$EnterpriseOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerInstallationOrder {
  factory Input$EnterpriseServerInstallationOrder({
    required Enum$EnterpriseServerInstallationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerInstallationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerInstallationOrder._(this._$data);

  factory Input$EnterpriseServerInstallationOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$EnterpriseServerInstallationOrderField(
        (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerInstallationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerInstallationOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerInstallationOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerInstallationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerInstallationOrder<
          Input$EnterpriseServerInstallationOrder>
      get copyWith => CopyWith$Input$EnterpriseServerInstallationOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseServerInstallationOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerInstallationOrder(
    Input$EnterpriseServerInstallationOrder instance,
    TRes Function(Input$EnterpriseServerInstallationOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerInstallationOrder;

  factory CopyWith$Input$EnterpriseServerInstallationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder;

  TRes call({
    Enum$EnterpriseServerInstallationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerInstallationOrder<TRes>
    implements CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerInstallationOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerInstallationOrder _instance;

  final TRes Function(Input$EnterpriseServerInstallationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerInstallationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerInstallationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder<TRes>
    implements CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerInstallationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountEmailOrder {
  factory Input$EnterpriseServerUserAccountEmailOrder({
    required Enum$EnterpriseServerUserAccountEmailOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerUserAccountEmailOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerUserAccountEmailOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountEmailOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseServerUserAccountEmailOrderField(
            (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerUserAccountEmailOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerUserAccountEmailOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountEmailOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountEmailOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountEmailOrder<
          Input$EnterpriseServerUserAccountEmailOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountEmailOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseServerUserAccountEmailOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountEmailOrder(
    Input$EnterpriseServerUserAccountEmailOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountEmailOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountEmailOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder;

  TRes call({
    Enum$EnterpriseServerUserAccountEmailOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountEmailOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountEmailOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountEmailOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountEmailOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerUserAccountEmailOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountOrder {
  factory Input$EnterpriseServerUserAccountOrder({
    required Enum$EnterpriseServerUserAccountOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerUserAccountOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerUserAccountOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$EnterpriseServerUserAccountOrderField(
        (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerUserAccountOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerUserAccountOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountOrder<
          Input$EnterpriseServerUserAccountOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseServerUserAccountOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountOrder(
    Input$EnterpriseServerUserAccountOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder;

  TRes call({
    Enum$EnterpriseServerUserAccountOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerUserAccountOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountsUploadOrder {
  factory Input$EnterpriseServerUserAccountsUploadOrder({
    required Enum$EnterpriseServerUserAccountsUploadOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$EnterpriseServerUserAccountsUploadOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$EnterpriseServerUserAccountsUploadOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountsUploadOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseServerUserAccountsUploadOrderField(
            (l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$EnterpriseServerUserAccountsUploadOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnterpriseServerUserAccountsUploadOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountsUploadOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountsUploadOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<
          Input$EnterpriseServerUserAccountsUploadOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountsUploadOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$EnterpriseServerUserAccountsUploadOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountsUploadOrder(
    Input$EnterpriseServerUserAccountsUploadOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountsUploadOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountsUploadOrder.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder;

  TRes call({
    Enum$EnterpriseServerUserAccountsUploadOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountsUploadOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountsUploadOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountsUploadOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountsUploadOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder(this._res);

  TRes _res;

  call({
    Enum$EnterpriseServerUserAccountsUploadOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$Environments {
  factory Input$Environments({
    required Enum$EnvironmentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$Environments._({
        r'field': field,
        r'direction': direction,
      });

  Input$Environments._(this._$data);

  factory Input$Environments.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnvironmentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$Environments._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$EnvironmentOrderField get field =>
      (_$data['field'] as Enum$EnvironmentOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$EnvironmentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$Environments<Input$Environments> get copyWith =>
      CopyWith$Input$Environments(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$Environments || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$Environments<TRes> {
  factory CopyWith$Input$Environments(
    Input$Environments instance,
    TRes Function(Input$Environments) then,
  ) = _CopyWithImpl$Input$Environments;

  factory CopyWith$Input$Environments.stub(TRes res) =
      _CopyWithStubImpl$Input$Environments;

  TRes call({
    Enum$EnvironmentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$Environments<TRes>
    implements CopyWith$Input$Environments<TRes> {
  _CopyWithImpl$Input$Environments(
    this._instance,
    this._then,
  );

  final Input$Environments _instance;

  final TRes Function(Input$Environments) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$Environments._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$EnvironmentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$Environments<TRes>
    implements CopyWith$Input$Environments<TRes> {
  _CopyWithStubImpl$Input$Environments(this._res);

  TRes _res;

  call({
    Enum$EnvironmentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$FileAddition {
  factory Input$FileAddition({
    required String path,
    required String contents,
  }) =>
      Input$FileAddition._({
        r'path': path,
        r'contents': contents,
      });

  Input$FileAddition._(this._$data);

  factory Input$FileAddition.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$contents = data['contents'];
    result$data['contents'] = (l$contents as String);
    return Input$FileAddition._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);

  String get contents => (_$data['contents'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    final l$contents = contents;
    result$data['contents'] = l$contents;
    return result$data;
  }

  CopyWith$Input$FileAddition<Input$FileAddition> get copyWith =>
      CopyWith$Input$FileAddition(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FileAddition || runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$contents = contents;
    final lOther$contents = other.contents;
    if (l$contents != lOther$contents) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$contents = contents;
    return Object.hashAll([
      l$path,
      l$contents,
    ]);
  }
}

abstract class CopyWith$Input$FileAddition<TRes> {
  factory CopyWith$Input$FileAddition(
    Input$FileAddition instance,
    TRes Function(Input$FileAddition) then,
  ) = _CopyWithImpl$Input$FileAddition;

  factory CopyWith$Input$FileAddition.stub(TRes res) =
      _CopyWithStubImpl$Input$FileAddition;

  TRes call({
    String? path,
    String? contents,
  });
}

class _CopyWithImpl$Input$FileAddition<TRes>
    implements CopyWith$Input$FileAddition<TRes> {
  _CopyWithImpl$Input$FileAddition(
    this._instance,
    this._then,
  );

  final Input$FileAddition _instance;

  final TRes Function(Input$FileAddition) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? contents = _undefined,
  }) =>
      _then(Input$FileAddition._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (contents != _undefined && contents != null)
          'contents': (contents as String),
      }));
}

class _CopyWithStubImpl$Input$FileAddition<TRes>
    implements CopyWith$Input$FileAddition<TRes> {
  _CopyWithStubImpl$Input$FileAddition(this._res);

  TRes _res;

  call({
    String? path,
    String? contents,
  }) =>
      _res;
}

class Input$FileChanges {
  factory Input$FileChanges({
    List<Input$FileDeletion>? deletions,
    List<Input$FileAddition>? additions,
  }) =>
      Input$FileChanges._({
        if (deletions != null) r'deletions': deletions,
        if (additions != null) r'additions': additions,
      });

  Input$FileChanges._(this._$data);

  factory Input$FileChanges.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('deletions')) {
      final l$deletions = data['deletions'];
      result$data['deletions'] = (l$deletions as List<dynamic>?)
          ?.map((e) => Input$FileDeletion.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('additions')) {
      final l$additions = data['additions'];
      result$data['additions'] = (l$additions as List<dynamic>?)
          ?.map((e) => Input$FileAddition.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$FileChanges._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$FileDeletion>? get deletions =>
      (_$data['deletions'] as List<Input$FileDeletion>?);

  List<Input$FileAddition>? get additions =>
      (_$data['additions'] as List<Input$FileAddition>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('deletions')) {
      final l$deletions = deletions;
      result$data['deletions'] = l$deletions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('additions')) {
      final l$additions = additions;
      result$data['additions'] = l$additions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$FileChanges<Input$FileChanges> get copyWith =>
      CopyWith$Input$FileChanges(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FileChanges || runtimeType != other.runtimeType) {
      return false;
    }
    final l$deletions = deletions;
    final lOther$deletions = other.deletions;
    if (_$data.containsKey('deletions') !=
        other._$data.containsKey('deletions')) {
      return false;
    }
    if (l$deletions != null && lOther$deletions != null) {
      if (l$deletions.length != lOther$deletions.length) {
        return false;
      }
      for (int i = 0; i < l$deletions.length; i++) {
        final l$deletions$entry = l$deletions[i];
        final lOther$deletions$entry = lOther$deletions[i];
        if (l$deletions$entry != lOther$deletions$entry) {
          return false;
        }
      }
    } else if (l$deletions != lOther$deletions) {
      return false;
    }
    final l$additions = additions;
    final lOther$additions = other.additions;
    if (_$data.containsKey('additions') !=
        other._$data.containsKey('additions')) {
      return false;
    }
    if (l$additions != null && lOther$additions != null) {
      if (l$additions.length != lOther$additions.length) {
        return false;
      }
      for (int i = 0; i < l$additions.length; i++) {
        final l$additions$entry = l$additions[i];
        final lOther$additions$entry = lOther$additions[i];
        if (l$additions$entry != lOther$additions$entry) {
          return false;
        }
      }
    } else if (l$additions != lOther$additions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$deletions = deletions;
    final l$additions = additions;
    return Object.hashAll([
      _$data.containsKey('deletions')
          ? l$deletions == null
              ? null
              : Object.hashAll(l$deletions.map((v) => v))
          : const {},
      _$data.containsKey('additions')
          ? l$additions == null
              ? null
              : Object.hashAll(l$additions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$FileChanges<TRes> {
  factory CopyWith$Input$FileChanges(
    Input$FileChanges instance,
    TRes Function(Input$FileChanges) then,
  ) = _CopyWithImpl$Input$FileChanges;

  factory CopyWith$Input$FileChanges.stub(TRes res) =
      _CopyWithStubImpl$Input$FileChanges;

  TRes call({
    List<Input$FileDeletion>? deletions,
    List<Input$FileAddition>? additions,
  });
  TRes deletions(
      Iterable<Input$FileDeletion>? Function(
              Iterable<CopyWith$Input$FileDeletion<Input$FileDeletion>>?)
          _fn);
  TRes additions(
      Iterable<Input$FileAddition>? Function(
              Iterable<CopyWith$Input$FileAddition<Input$FileAddition>>?)
          _fn);
}

class _CopyWithImpl$Input$FileChanges<TRes>
    implements CopyWith$Input$FileChanges<TRes> {
  _CopyWithImpl$Input$FileChanges(
    this._instance,
    this._then,
  );

  final Input$FileChanges _instance;

  final TRes Function(Input$FileChanges) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? deletions = _undefined,
    Object? additions = _undefined,
  }) =>
      _then(Input$FileChanges._({
        ..._instance._$data,
        if (deletions != _undefined)
          'deletions': (deletions as List<Input$FileDeletion>?),
        if (additions != _undefined)
          'additions': (additions as List<Input$FileAddition>?),
      }));

  TRes deletions(
          Iterable<Input$FileDeletion>? Function(
                  Iterable<CopyWith$Input$FileDeletion<Input$FileDeletion>>?)
              _fn) =>
      call(
          deletions:
              _fn(_instance.deletions?.map((e) => CopyWith$Input$FileDeletion(
                    e,
                    (i) => i,
                  )))?.toList());

  TRes additions(
          Iterable<Input$FileAddition>? Function(
                  Iterable<CopyWith$Input$FileAddition<Input$FileAddition>>?)
              _fn) =>
      call(
          additions:
              _fn(_instance.additions?.map((e) => CopyWith$Input$FileAddition(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$FileChanges<TRes>
    implements CopyWith$Input$FileChanges<TRes> {
  _CopyWithStubImpl$Input$FileChanges(this._res);

  TRes _res;

  call({
    List<Input$FileDeletion>? deletions,
    List<Input$FileAddition>? additions,
  }) =>
      _res;

  deletions(_fn) => _res;

  additions(_fn) => _res;
}

class Input$FileDeletion {
  factory Input$FileDeletion({required String path}) => Input$FileDeletion._({
        r'path': path,
      });

  Input$FileDeletion._(this._$data);

  factory Input$FileDeletion.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    return Input$FileDeletion._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    return result$data;
  }

  CopyWith$Input$FileDeletion<Input$FileDeletion> get copyWith =>
      CopyWith$Input$FileDeletion(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FileDeletion || runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    return Object.hashAll([l$path]);
  }
}

abstract class CopyWith$Input$FileDeletion<TRes> {
  factory CopyWith$Input$FileDeletion(
    Input$FileDeletion instance,
    TRes Function(Input$FileDeletion) then,
  ) = _CopyWithImpl$Input$FileDeletion;

  factory CopyWith$Input$FileDeletion.stub(TRes res) =
      _CopyWithStubImpl$Input$FileDeletion;

  TRes call({String? path});
}

class _CopyWithImpl$Input$FileDeletion<TRes>
    implements CopyWith$Input$FileDeletion<TRes> {
  _CopyWithImpl$Input$FileDeletion(
    this._instance,
    this._then,
  );

  final Input$FileDeletion _instance;

  final TRes Function(Input$FileDeletion) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? path = _undefined}) => _then(Input$FileDeletion._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
      }));
}

class _CopyWithStubImpl$Input$FileDeletion<TRes>
    implements CopyWith$Input$FileDeletion<TRes> {
  _CopyWithStubImpl$Input$FileDeletion(this._res);

  TRes _res;

  call({String? path}) => _res;
}

class Input$FileExtensionRestrictionParametersInput {
  factory Input$FileExtensionRestrictionParametersInput(
          {required List<String> restrictedFileExtensions}) =>
      Input$FileExtensionRestrictionParametersInput._({
        r'restrictedFileExtensions': restrictedFileExtensions,
      });

  Input$FileExtensionRestrictionParametersInput._(this._$data);

  factory Input$FileExtensionRestrictionParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$restrictedFileExtensions = data['restrictedFileExtensions'];
    result$data['restrictedFileExtensions'] =
        (l$restrictedFileExtensions as List<dynamic>)
            .map((e) => (e as String))
            .toList();
    return Input$FileExtensionRestrictionParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get restrictedFileExtensions =>
      (_$data['restrictedFileExtensions'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$restrictedFileExtensions = restrictedFileExtensions;
    result$data['restrictedFileExtensions'] =
        l$restrictedFileExtensions.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$FileExtensionRestrictionParametersInput<
          Input$FileExtensionRestrictionParametersInput>
      get copyWith => CopyWith$Input$FileExtensionRestrictionParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FileExtensionRestrictionParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$restrictedFileExtensions = restrictedFileExtensions;
    final lOther$restrictedFileExtensions = other.restrictedFileExtensions;
    if (l$restrictedFileExtensions.length !=
        lOther$restrictedFileExtensions.length) {
      return false;
    }
    for (int i = 0; i < l$restrictedFileExtensions.length; i++) {
      final l$restrictedFileExtensions$entry = l$restrictedFileExtensions[i];
      final lOther$restrictedFileExtensions$entry =
          lOther$restrictedFileExtensions[i];
      if (l$restrictedFileExtensions$entry !=
          lOther$restrictedFileExtensions$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$restrictedFileExtensions = restrictedFileExtensions;
    return Object.hashAll(
        [Object.hashAll(l$restrictedFileExtensions.map((v) => v))]);
  }
}

abstract class CopyWith$Input$FileExtensionRestrictionParametersInput<TRes> {
  factory CopyWith$Input$FileExtensionRestrictionParametersInput(
    Input$FileExtensionRestrictionParametersInput instance,
    TRes Function(Input$FileExtensionRestrictionParametersInput) then,
  ) = _CopyWithImpl$Input$FileExtensionRestrictionParametersInput;

  factory CopyWith$Input$FileExtensionRestrictionParametersInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$FileExtensionRestrictionParametersInput;

  TRes call({List<String>? restrictedFileExtensions});
}

class _CopyWithImpl$Input$FileExtensionRestrictionParametersInput<TRes>
    implements CopyWith$Input$FileExtensionRestrictionParametersInput<TRes> {
  _CopyWithImpl$Input$FileExtensionRestrictionParametersInput(
    this._instance,
    this._then,
  );

  final Input$FileExtensionRestrictionParametersInput _instance;

  final TRes Function(Input$FileExtensionRestrictionParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? restrictedFileExtensions = _undefined}) =>
      _then(Input$FileExtensionRestrictionParametersInput._({
        ..._instance._$data,
        if (restrictedFileExtensions != _undefined &&
            restrictedFileExtensions != null)
          'restrictedFileExtensions':
              (restrictedFileExtensions as List<String>),
      }));
}

class _CopyWithStubImpl$Input$FileExtensionRestrictionParametersInput<TRes>
    implements CopyWith$Input$FileExtensionRestrictionParametersInput<TRes> {
  _CopyWithStubImpl$Input$FileExtensionRestrictionParametersInput(this._res);

  TRes _res;

  call({List<String>? restrictedFileExtensions}) => _res;
}

class Input$FilePathRestrictionParametersInput {
  factory Input$FilePathRestrictionParametersInput(
          {required List<String> restrictedFilePaths}) =>
      Input$FilePathRestrictionParametersInput._({
        r'restrictedFilePaths': restrictedFilePaths,
      });

  Input$FilePathRestrictionParametersInput._(this._$data);

  factory Input$FilePathRestrictionParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$restrictedFilePaths = data['restrictedFilePaths'];
    result$data['restrictedFilePaths'] =
        (l$restrictedFilePaths as List<dynamic>)
            .map((e) => (e as String))
            .toList();
    return Input$FilePathRestrictionParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get restrictedFilePaths =>
      (_$data['restrictedFilePaths'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$restrictedFilePaths = restrictedFilePaths;
    result$data['restrictedFilePaths'] =
        l$restrictedFilePaths.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$FilePathRestrictionParametersInput<
          Input$FilePathRestrictionParametersInput>
      get copyWith => CopyWith$Input$FilePathRestrictionParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FilePathRestrictionParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$restrictedFilePaths = restrictedFilePaths;
    final lOther$restrictedFilePaths = other.restrictedFilePaths;
    if (l$restrictedFilePaths.length != lOther$restrictedFilePaths.length) {
      return false;
    }
    for (int i = 0; i < l$restrictedFilePaths.length; i++) {
      final l$restrictedFilePaths$entry = l$restrictedFilePaths[i];
      final lOther$restrictedFilePaths$entry = lOther$restrictedFilePaths[i];
      if (l$restrictedFilePaths$entry != lOther$restrictedFilePaths$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$restrictedFilePaths = restrictedFilePaths;
    return Object.hashAll(
        [Object.hashAll(l$restrictedFilePaths.map((v) => v))]);
  }
}

abstract class CopyWith$Input$FilePathRestrictionParametersInput<TRes> {
  factory CopyWith$Input$FilePathRestrictionParametersInput(
    Input$FilePathRestrictionParametersInput instance,
    TRes Function(Input$FilePathRestrictionParametersInput) then,
  ) = _CopyWithImpl$Input$FilePathRestrictionParametersInput;

  factory CopyWith$Input$FilePathRestrictionParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FilePathRestrictionParametersInput;

  TRes call({List<String>? restrictedFilePaths});
}

class _CopyWithImpl$Input$FilePathRestrictionParametersInput<TRes>
    implements CopyWith$Input$FilePathRestrictionParametersInput<TRes> {
  _CopyWithImpl$Input$FilePathRestrictionParametersInput(
    this._instance,
    this._then,
  );

  final Input$FilePathRestrictionParametersInput _instance;

  final TRes Function(Input$FilePathRestrictionParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? restrictedFilePaths = _undefined}) =>
      _then(Input$FilePathRestrictionParametersInput._({
        ..._instance._$data,
        if (restrictedFilePaths != _undefined && restrictedFilePaths != null)
          'restrictedFilePaths': (restrictedFilePaths as List<String>),
      }));
}

class _CopyWithStubImpl$Input$FilePathRestrictionParametersInput<TRes>
    implements CopyWith$Input$FilePathRestrictionParametersInput<TRes> {
  _CopyWithStubImpl$Input$FilePathRestrictionParametersInput(this._res);

  TRes _res;

  call({List<String>? restrictedFilePaths}) => _res;
}

class Input$FollowOrganizationInput {
  factory Input$FollowOrganizationInput({
    String? clientMutationId,
    required String organizationId,
  }) =>
      Input$FollowOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
      });

  Input$FollowOrganizationInput._(this._$data);

  factory Input$FollowOrganizationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$FollowOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$FollowOrganizationInput<Input$FollowOrganizationInput>
      get copyWith => CopyWith$Input$FollowOrganizationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FollowOrganizationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$FollowOrganizationInput<TRes> {
  factory CopyWith$Input$FollowOrganizationInput(
    Input$FollowOrganizationInput instance,
    TRes Function(Input$FollowOrganizationInput) then,
  ) = _CopyWithImpl$Input$FollowOrganizationInput;

  factory CopyWith$Input$FollowOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FollowOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$FollowOrganizationInput<TRes>
    implements CopyWith$Input$FollowOrganizationInput<TRes> {
  _CopyWithImpl$Input$FollowOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$FollowOrganizationInput _instance;

  final TRes Function(Input$FollowOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$FollowOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$FollowOrganizationInput<TRes>
    implements CopyWith$Input$FollowOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$FollowOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
  }) =>
      _res;
}

class Input$FollowUserInput {
  factory Input$FollowUserInput({
    String? clientMutationId,
    required String userId,
  }) =>
      Input$FollowUserInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'userId': userId,
      });

  Input$FollowUserInput._(this._$data);

  factory Input$FollowUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$FollowUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get userId => (_$data['userId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$FollowUserInput<Input$FollowUserInput> get copyWith =>
      CopyWith$Input$FollowUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$FollowUserInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$FollowUserInput<TRes> {
  factory CopyWith$Input$FollowUserInput(
    Input$FollowUserInput instance,
    TRes Function(Input$FollowUserInput) then,
  ) = _CopyWithImpl$Input$FollowUserInput;

  factory CopyWith$Input$FollowUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FollowUserInput;

  TRes call({
    String? clientMutationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$FollowUserInput<TRes>
    implements CopyWith$Input$FollowUserInput<TRes> {
  _CopyWithImpl$Input$FollowUserInput(
    this._instance,
    this._then,
  );

  final Input$FollowUserInput _instance;

  final TRes Function(Input$FollowUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$FollowUserInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$FollowUserInput<TRes>
    implements CopyWith$Input$FollowUserInput<TRes> {
  _CopyWithStubImpl$Input$FollowUserInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? userId,
  }) =>
      _res;
}

class Input$GistOrder {
  factory Input$GistOrder({
    required Enum$GistOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$GistOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$GistOrder._(this._$data);

  factory Input$GistOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$GistOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$GistOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$GistOrderField get field => (_$data['field'] as Enum$GistOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$GistOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$GistOrder<Input$GistOrder> get copyWith =>
      CopyWith$Input$GistOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GistOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$GistOrder<TRes> {
  factory CopyWith$Input$GistOrder(
    Input$GistOrder instance,
    TRes Function(Input$GistOrder) then,
  ) = _CopyWithImpl$Input$GistOrder;

  factory CopyWith$Input$GistOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$GistOrder;

  TRes call({
    Enum$GistOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$GistOrder<TRes>
    implements CopyWith$Input$GistOrder<TRes> {
  _CopyWithImpl$Input$GistOrder(
    this._instance,
    this._then,
  );

  final Input$GistOrder _instance;

  final TRes Function(Input$GistOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$GistOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$GistOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$GistOrder<TRes>
    implements CopyWith$Input$GistOrder<TRes> {
  _CopyWithStubImpl$Input$GistOrder(this._res);

  TRes _res;

  call({
    Enum$GistOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$GrantEnterpriseOrganizationsMigratorRoleInput {
  factory Input$GrantEnterpriseOrganizationsMigratorRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$GrantEnterpriseOrganizationsMigratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$GrantEnterpriseOrganizationsMigratorRoleInput._(this._$data);

  factory Input$GrantEnterpriseOrganizationsMigratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$GrantEnterpriseOrganizationsMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get login => (_$data['login'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
          Input$GrantEnterpriseOrganizationsMigratorRoleInput>
      get copyWith =>
          CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GrantEnterpriseOrganizationsMigratorRoleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
    TRes> {
  factory CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
    Input$GrantEnterpriseOrganizationsMigratorRoleInput instance,
    TRes Function(Input$GrantEnterpriseOrganizationsMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput;

  factory CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes>
    implements
        CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$GrantEnterpriseOrganizationsMigratorRoleInput _instance;

  final TRes Function(Input$GrantEnterpriseOrganizationsMigratorRoleInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$GrantEnterpriseOrganizationsMigratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
        TRes>
    implements
        CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$GrantMigratorRoleInput {
  factory Input$GrantMigratorRoleInput({
    String? clientMutationId,
    required String organizationId,
    required String actor,
    required Enum$ActorType actorType,
  }) =>
      Input$GrantMigratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'actor': actor,
        r'actorType': actorType,
      });

  Input$GrantMigratorRoleInput._(this._$data);

  factory Input$GrantMigratorRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$actor = data['actor'];
    result$data['actor'] = (l$actor as String);
    final l$actorType = data['actorType'];
    result$data['actorType'] = fromJson$Enum$ActorType((l$actorType as String));
    return Input$GrantMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  String get actor => (_$data['actor'] as String);

  Enum$ActorType get actorType => (_$data['actorType'] as Enum$ActorType);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$actor = actor;
    result$data['actor'] = l$actor;
    final l$actorType = actorType;
    result$data['actorType'] = toJson$Enum$ActorType(l$actorType);
    return result$data;
  }

  CopyWith$Input$GrantMigratorRoleInput<Input$GrantMigratorRoleInput>
      get copyWith => CopyWith$Input$GrantMigratorRoleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$GrantMigratorRoleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$actor = actor;
    final lOther$actor = other.actor;
    if (l$actor != lOther$actor) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (l$actorType != lOther$actorType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$actor = actor;
    final l$actorType = actorType;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$actor,
      l$actorType,
    ]);
  }
}

abstract class CopyWith$Input$GrantMigratorRoleInput<TRes> {
  factory CopyWith$Input$GrantMigratorRoleInput(
    Input$GrantMigratorRoleInput instance,
    TRes Function(Input$GrantMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$GrantMigratorRoleInput;

  factory CopyWith$Input$GrantMigratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GrantMigratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
  });
}

class _CopyWithImpl$Input$GrantMigratorRoleInput<TRes>
    implements CopyWith$Input$GrantMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$GrantMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$GrantMigratorRoleInput _instance;

  final TRes Function(Input$GrantMigratorRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? actor = _undefined,
    Object? actorType = _undefined,
  }) =>
      _then(Input$GrantMigratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (actor != _undefined && actor != null) 'actor': (actor as String),
        if (actorType != _undefined && actorType != null)
          'actorType': (actorType as Enum$ActorType),
      }));
}

class _CopyWithStubImpl$Input$GrantMigratorRoleInput<TRes>
    implements CopyWith$Input$GrantMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$GrantMigratorRoleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
  }) =>
      _res;
}

class Input$ImportProjectInput {
  factory Input$ImportProjectInput({
    String? clientMutationId,
    required String ownerName,
    required String name,
    String? body,
    bool? public,
    required List<Input$ProjectColumnImport> columnImports,
  }) =>
      Input$ImportProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerName': ownerName,
        r'name': name,
        if (body != null) r'body': body,
        if (public != null) r'public': public,
        r'columnImports': columnImports,
      });

  Input$ImportProjectInput._(this._$data);

  factory Input$ImportProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerName = data['ownerName'];
    result$data['ownerName'] = (l$ownerName as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    final l$columnImports = data['columnImports'];
    result$data['columnImports'] = (l$columnImports as List<dynamic>)
        .map((e) =>
            Input$ProjectColumnImport.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$ImportProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerName => (_$data['ownerName'] as String);

  String get name => (_$data['name'] as String);

  String? get body => (_$data['body'] as String?);

  bool? get public => (_$data['public'] as bool?);

  List<Input$ProjectColumnImport> get columnImports =>
      (_$data['columnImports'] as List<Input$ProjectColumnImport>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerName = ownerName;
    result$data['ownerName'] = l$ownerName;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    final l$columnImports = columnImports;
    result$data['columnImports'] =
        l$columnImports.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$ImportProjectInput<Input$ImportProjectInput> get copyWith =>
      CopyWith$Input$ImportProjectInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ImportProjectInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerName = ownerName;
    final lOther$ownerName = other.ownerName;
    if (l$ownerName != lOther$ownerName) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$columnImports = columnImports;
    final lOther$columnImports = other.columnImports;
    if (l$columnImports.length != lOther$columnImports.length) {
      return false;
    }
    for (int i = 0; i < l$columnImports.length; i++) {
      final l$columnImports$entry = l$columnImports[i];
      final lOther$columnImports$entry = lOther$columnImports[i];
      if (l$columnImports$entry != lOther$columnImports$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerName = ownerName;
    final l$name = name;
    final l$body = body;
    final l$public = public;
    final l$columnImports = columnImports;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerName,
      l$name,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('public') ? l$public : const {},
      Object.hashAll(l$columnImports.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$ImportProjectInput<TRes> {
  factory CopyWith$Input$ImportProjectInput(
    Input$ImportProjectInput instance,
    TRes Function(Input$ImportProjectInput) then,
  ) = _CopyWithImpl$Input$ImportProjectInput;

  factory CopyWith$Input$ImportProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ImportProjectInput;

  TRes call({
    String? clientMutationId,
    String? ownerName,
    String? name,
    String? body,
    bool? public,
    List<Input$ProjectColumnImport>? columnImports,
  });
  TRes columnImports(
      Iterable<Input$ProjectColumnImport> Function(
              Iterable<
                  CopyWith$Input$ProjectColumnImport<
                      Input$ProjectColumnImport>>)
          _fn);
}

class _CopyWithImpl$Input$ImportProjectInput<TRes>
    implements CopyWith$Input$ImportProjectInput<TRes> {
  _CopyWithImpl$Input$ImportProjectInput(
    this._instance,
    this._then,
  );

  final Input$ImportProjectInput _instance;

  final TRes Function(Input$ImportProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerName = _undefined,
    Object? name = _undefined,
    Object? body = _undefined,
    Object? public = _undefined,
    Object? columnImports = _undefined,
  }) =>
      _then(Input$ImportProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerName != _undefined && ownerName != null)
          'ownerName': (ownerName as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (body != _undefined) 'body': (body as String?),
        if (public != _undefined) 'public': (public as bool?),
        if (columnImports != _undefined && columnImports != null)
          'columnImports': (columnImports as List<Input$ProjectColumnImport>),
      }));

  TRes columnImports(
          Iterable<Input$ProjectColumnImport> Function(
                  Iterable<
                      CopyWith$Input$ProjectColumnImport<
                          Input$ProjectColumnImport>>)
              _fn) =>
      call(
          columnImports: _fn(_instance.columnImports
              .map((e) => CopyWith$Input$ProjectColumnImport(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$ImportProjectInput<TRes>
    implements CopyWith$Input$ImportProjectInput<TRes> {
  _CopyWithStubImpl$Input$ImportProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerName,
    String? name,
    String? body,
    bool? public,
    List<Input$ProjectColumnImport>? columnImports,
  }) =>
      _res;

  columnImports(_fn) => _res;
}

class Input$InviteEnterpriseAdminInput {
  factory Input$InviteEnterpriseAdminInput({
    String? clientMutationId,
    required String enterpriseId,
    String? invitee,
    String? email,
    Enum$EnterpriseAdministratorRole? role,
  }) =>
      Input$InviteEnterpriseAdminInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        if (invitee != null) r'invitee': invitee,
        if (email != null) r'email': email,
        if (role != null) r'role': role,
      });

  Input$InviteEnterpriseAdminInput._(this._$data);

  factory Input$InviteEnterpriseAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('invitee')) {
      final l$invitee = data['invitee'];
      result$data['invitee'] = (l$invitee as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : fromJson$Enum$EnterpriseAdministratorRole((l$role as String));
    }
    return Input$InviteEnterpriseAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String? get invitee => (_$data['invitee'] as String?);

  String? get email => (_$data['email'] as String?);

  Enum$EnterpriseAdministratorRole? get role =>
      (_$data['role'] as Enum$EnterpriseAdministratorRole?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('invitee')) {
      final l$invitee = invitee;
      result$data['invitee'] = l$invitee;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null
          ? null
          : toJson$Enum$EnterpriseAdministratorRole(l$role);
    }
    return result$data;
  }

  CopyWith$Input$InviteEnterpriseAdminInput<Input$InviteEnterpriseAdminInput>
      get copyWith => CopyWith$Input$InviteEnterpriseAdminInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$InviteEnterpriseAdminInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$invitee = invitee;
    final lOther$invitee = other.invitee;
    if (_$data.containsKey('invitee') != other._$data.containsKey('invitee')) {
      return false;
    }
    if (l$invitee != lOther$invitee) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$invitee = invitee;
    final l$email = email;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      _$data.containsKey('invitee') ? l$invitee : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  factory CopyWith$Input$InviteEnterpriseAdminInput(
    Input$InviteEnterpriseAdminInput instance,
    TRes Function(Input$InviteEnterpriseAdminInput) then,
  ) = _CopyWithImpl$Input$InviteEnterpriseAdminInput;

  factory CopyWith$Input$InviteEnterpriseAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InviteEnterpriseAdminInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? invitee,
    String? email,
    Enum$EnterpriseAdministratorRole? role,
  });
}

class _CopyWithImpl$Input$InviteEnterpriseAdminInput<TRes>
    implements CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  _CopyWithImpl$Input$InviteEnterpriseAdminInput(
    this._instance,
    this._then,
  );

  final Input$InviteEnterpriseAdminInput _instance;

  final TRes Function(Input$InviteEnterpriseAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? invitee = _undefined,
    Object? email = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$InviteEnterpriseAdminInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (invitee != _undefined) 'invitee': (invitee as String?),
        if (email != _undefined) 'email': (email as String?),
        if (role != _undefined)
          'role': (role as Enum$EnterpriseAdministratorRole?),
      }));
}

class _CopyWithStubImpl$Input$InviteEnterpriseAdminInput<TRes>
    implements CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  _CopyWithStubImpl$Input$InviteEnterpriseAdminInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? invitee,
    String? email,
    Enum$EnterpriseAdministratorRole? role,
  }) =>
      _res;
}

class Input$InviteEnterpriseMemberInput {
  factory Input$InviteEnterpriseMemberInput({
    String? clientMutationId,
    required String enterpriseId,
    String? invitee,
    String? email,
  }) =>
      Input$InviteEnterpriseMemberInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        if (invitee != null) r'invitee': invitee,
        if (email != null) r'email': email,
      });

  Input$InviteEnterpriseMemberInput._(this._$data);

  factory Input$InviteEnterpriseMemberInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('invitee')) {
      final l$invitee = data['invitee'];
      result$data['invitee'] = (l$invitee as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    return Input$InviteEnterpriseMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String? get invitee => (_$data['invitee'] as String?);

  String? get email => (_$data['email'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('invitee')) {
      final l$invitee = invitee;
      result$data['invitee'] = l$invitee;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    return result$data;
  }

  CopyWith$Input$InviteEnterpriseMemberInput<Input$InviteEnterpriseMemberInput>
      get copyWith => CopyWith$Input$InviteEnterpriseMemberInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$InviteEnterpriseMemberInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$invitee = invitee;
    final lOther$invitee = other.invitee;
    if (_$data.containsKey('invitee') != other._$data.containsKey('invitee')) {
      return false;
    }
    if (l$invitee != lOther$invitee) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$invitee = invitee;
    final l$email = email;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      _$data.containsKey('invitee') ? l$invitee : const {},
      _$data.containsKey('email') ? l$email : const {},
    ]);
  }
}

abstract class CopyWith$Input$InviteEnterpriseMemberInput<TRes> {
  factory CopyWith$Input$InviteEnterpriseMemberInput(
    Input$InviteEnterpriseMemberInput instance,
    TRes Function(Input$InviteEnterpriseMemberInput) then,
  ) = _CopyWithImpl$Input$InviteEnterpriseMemberInput;

  factory CopyWith$Input$InviteEnterpriseMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InviteEnterpriseMemberInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? invitee,
    String? email,
  });
}

class _CopyWithImpl$Input$InviteEnterpriseMemberInput<TRes>
    implements CopyWith$Input$InviteEnterpriseMemberInput<TRes> {
  _CopyWithImpl$Input$InviteEnterpriseMemberInput(
    this._instance,
    this._then,
  );

  final Input$InviteEnterpriseMemberInput _instance;

  final TRes Function(Input$InviteEnterpriseMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? invitee = _undefined,
    Object? email = _undefined,
  }) =>
      _then(Input$InviteEnterpriseMemberInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (invitee != _undefined) 'invitee': (invitee as String?),
        if (email != _undefined) 'email': (email as String?),
      }));
}

class _CopyWithStubImpl$Input$InviteEnterpriseMemberInput<TRes>
    implements CopyWith$Input$InviteEnterpriseMemberInput<TRes> {
  _CopyWithStubImpl$Input$InviteEnterpriseMemberInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? invitee,
    String? email,
  }) =>
      _res;
}

class Input$IpAllowListEntryOrder {
  factory Input$IpAllowListEntryOrder({
    required Enum$IpAllowListEntryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IpAllowListEntryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IpAllowListEntryOrder._(this._$data);

  factory Input$IpAllowListEntryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IpAllowListEntryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IpAllowListEntryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IpAllowListEntryOrderField get field =>
      (_$data['field'] as Enum$IpAllowListEntryOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IpAllowListEntryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IpAllowListEntryOrder<Input$IpAllowListEntryOrder>
      get copyWith => CopyWith$Input$IpAllowListEntryOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IpAllowListEntryOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IpAllowListEntryOrder<TRes> {
  factory CopyWith$Input$IpAllowListEntryOrder(
    Input$IpAllowListEntryOrder instance,
    TRes Function(Input$IpAllowListEntryOrder) then,
  ) = _CopyWithImpl$Input$IpAllowListEntryOrder;

  factory CopyWith$Input$IpAllowListEntryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IpAllowListEntryOrder;

  TRes call({
    Enum$IpAllowListEntryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IpAllowListEntryOrder<TRes>
    implements CopyWith$Input$IpAllowListEntryOrder<TRes> {
  _CopyWithImpl$Input$IpAllowListEntryOrder(
    this._instance,
    this._then,
  );

  final Input$IpAllowListEntryOrder _instance;

  final TRes Function(Input$IpAllowListEntryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IpAllowListEntryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IpAllowListEntryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IpAllowListEntryOrder<TRes>
    implements CopyWith$Input$IpAllowListEntryOrder<TRes> {
  _CopyWithStubImpl$Input$IpAllowListEntryOrder(this._res);

  TRes _res;

  call({
    Enum$IpAllowListEntryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$IssueCommentOrder {
  factory Input$IssueCommentOrder({
    required Enum$IssueCommentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IssueCommentOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IssueCommentOrder._(this._$data);

  factory Input$IssueCommentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IssueCommentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IssueCommentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IssueCommentOrderField get field =>
      (_$data['field'] as Enum$IssueCommentOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueCommentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IssueCommentOrder<Input$IssueCommentOrder> get copyWith =>
      CopyWith$Input$IssueCommentOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IssueCommentOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IssueCommentOrder<TRes> {
  factory CopyWith$Input$IssueCommentOrder(
    Input$IssueCommentOrder instance,
    TRes Function(Input$IssueCommentOrder) then,
  ) = _CopyWithImpl$Input$IssueCommentOrder;

  factory CopyWith$Input$IssueCommentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueCommentOrder;

  TRes call({
    Enum$IssueCommentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IssueCommentOrder<TRes>
    implements CopyWith$Input$IssueCommentOrder<TRes> {
  _CopyWithImpl$Input$IssueCommentOrder(
    this._instance,
    this._then,
  );

  final Input$IssueCommentOrder _instance;

  final TRes Function(Input$IssueCommentOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IssueCommentOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueCommentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IssueCommentOrder<TRes>
    implements CopyWith$Input$IssueCommentOrder<TRes> {
  _CopyWithStubImpl$Input$IssueCommentOrder(this._res);

  TRes _res;

  call({
    Enum$IssueCommentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$IssueDependencyOrder {
  factory Input$IssueDependencyOrder({
    required Enum$IssueDependencyOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IssueDependencyOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IssueDependencyOrder._(this._$data);

  factory Input$IssueDependencyOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IssueDependencyOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IssueDependencyOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IssueDependencyOrderField get field =>
      (_$data['field'] as Enum$IssueDependencyOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueDependencyOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IssueDependencyOrder<Input$IssueDependencyOrder>
      get copyWith => CopyWith$Input$IssueDependencyOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IssueDependencyOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IssueDependencyOrder<TRes> {
  factory CopyWith$Input$IssueDependencyOrder(
    Input$IssueDependencyOrder instance,
    TRes Function(Input$IssueDependencyOrder) then,
  ) = _CopyWithImpl$Input$IssueDependencyOrder;

  factory CopyWith$Input$IssueDependencyOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueDependencyOrder;

  TRes call({
    Enum$IssueDependencyOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IssueDependencyOrder<TRes>
    implements CopyWith$Input$IssueDependencyOrder<TRes> {
  _CopyWithImpl$Input$IssueDependencyOrder(
    this._instance,
    this._then,
  );

  final Input$IssueDependencyOrder _instance;

  final TRes Function(Input$IssueDependencyOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IssueDependencyOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueDependencyOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IssueDependencyOrder<TRes>
    implements CopyWith$Input$IssueDependencyOrder<TRes> {
  _CopyWithStubImpl$Input$IssueDependencyOrder(this._res);

  TRes _res;

  call({
    Enum$IssueDependencyOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$IssueFilters {
  factory Input$IssueFilters({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    String? since,
    List<Enum$IssueState>? states,
    String? type,
    bool? viewerSubscribed,
  }) =>
      Input$IssueFilters._({
        if (assignee != null) r'assignee': assignee,
        if (createdBy != null) r'createdBy': createdBy,
        if (labels != null) r'labels': labels,
        if (mentioned != null) r'mentioned': mentioned,
        if (milestone != null) r'milestone': milestone,
        if (milestoneNumber != null) r'milestoneNumber': milestoneNumber,
        if (since != null) r'since': since,
        if (states != null) r'states': states,
        if (type != null) r'type': type,
        if (viewerSubscribed != null) r'viewerSubscribed': viewerSubscribed,
      });

  Input$IssueFilters._(this._$data);

  factory Input$IssueFilters.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assignee')) {
      final l$assignee = data['assignee'];
      result$data['assignee'] = (l$assignee as String?);
    }
    if (data.containsKey('createdBy')) {
      final l$createdBy = data['createdBy'];
      result$data['createdBy'] = (l$createdBy as String?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('mentioned')) {
      final l$mentioned = data['mentioned'];
      result$data['mentioned'] = (l$mentioned as String?);
    }
    if (data.containsKey('milestone')) {
      final l$milestone = data['milestone'];
      result$data['milestone'] = (l$milestone as String?);
    }
    if (data.containsKey('milestoneNumber')) {
      final l$milestoneNumber = data['milestoneNumber'];
      result$data['milestoneNumber'] = (l$milestoneNumber as String?);
    }
    if (data.containsKey('since')) {
      final l$since = data['since'];
      result$data['since'] = (l$since as String?);
    }
    if (data.containsKey('states')) {
      final l$states = data['states'];
      result$data['states'] = (l$states as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IssueState((e as String)))
          .toList();
    }
    if (data.containsKey('type')) {
      final l$type = data['type'];
      result$data['type'] = (l$type as String?);
    }
    if (data.containsKey('viewerSubscribed')) {
      final l$viewerSubscribed = data['viewerSubscribed'];
      result$data['viewerSubscribed'] = (l$viewerSubscribed as bool?);
    }
    return Input$IssueFilters._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get assignee => (_$data['assignee'] as String?);

  String? get createdBy => (_$data['createdBy'] as String?);

  List<String>? get labels => (_$data['labels'] as List<String>?);

  String? get mentioned => (_$data['mentioned'] as String?);

  String? get milestone => (_$data['milestone'] as String?);

  String? get milestoneNumber => (_$data['milestoneNumber'] as String?);

  String? get since => (_$data['since'] as String?);

  List<Enum$IssueState>? get states =>
      (_$data['states'] as List<Enum$IssueState>?);

  String? get type => (_$data['type'] as String?);

  bool? get viewerSubscribed => (_$data['viewerSubscribed'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assignee')) {
      final l$assignee = assignee;
      result$data['assignee'] = l$assignee;
    }
    if (_$data.containsKey('createdBy')) {
      final l$createdBy = createdBy;
      result$data['createdBy'] = l$createdBy;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('mentioned')) {
      final l$mentioned = mentioned;
      result$data['mentioned'] = l$mentioned;
    }
    if (_$data.containsKey('milestone')) {
      final l$milestone = milestone;
      result$data['milestone'] = l$milestone;
    }
    if (_$data.containsKey('milestoneNumber')) {
      final l$milestoneNumber = milestoneNumber;
      result$data['milestoneNumber'] = l$milestoneNumber;
    }
    if (_$data.containsKey('since')) {
      final l$since = since;
      result$data['since'] = l$since;
    }
    if (_$data.containsKey('states')) {
      final l$states = states;
      result$data['states'] =
          l$states?.map((e) => toJson$Enum$IssueState(e)).toList();
    }
    if (_$data.containsKey('type')) {
      final l$type = type;
      result$data['type'] = l$type;
    }
    if (_$data.containsKey('viewerSubscribed')) {
      final l$viewerSubscribed = viewerSubscribed;
      result$data['viewerSubscribed'] = l$viewerSubscribed;
    }
    return result$data;
  }

  CopyWith$Input$IssueFilters<Input$IssueFilters> get copyWith =>
      CopyWith$Input$IssueFilters(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IssueFilters || runtimeType != other.runtimeType) {
      return false;
    }
    final l$assignee = assignee;
    final lOther$assignee = other.assignee;
    if (_$data.containsKey('assignee') !=
        other._$data.containsKey('assignee')) {
      return false;
    }
    if (l$assignee != lOther$assignee) {
      return false;
    }
    final l$createdBy = createdBy;
    final lOther$createdBy = other.createdBy;
    if (_$data.containsKey('createdBy') !=
        other._$data.containsKey('createdBy')) {
      return false;
    }
    if (l$createdBy != lOther$createdBy) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$mentioned = mentioned;
    final lOther$mentioned = other.mentioned;
    if (_$data.containsKey('mentioned') !=
        other._$data.containsKey('mentioned')) {
      return false;
    }
    if (l$mentioned != lOther$mentioned) {
      return false;
    }
    final l$milestone = milestone;
    final lOther$milestone = other.milestone;
    if (_$data.containsKey('milestone') !=
        other._$data.containsKey('milestone')) {
      return false;
    }
    if (l$milestone != lOther$milestone) {
      return false;
    }
    final l$milestoneNumber = milestoneNumber;
    final lOther$milestoneNumber = other.milestoneNumber;
    if (_$data.containsKey('milestoneNumber') !=
        other._$data.containsKey('milestoneNumber')) {
      return false;
    }
    if (l$milestoneNumber != lOther$milestoneNumber) {
      return false;
    }
    final l$since = since;
    final lOther$since = other.since;
    if (_$data.containsKey('since') != other._$data.containsKey('since')) {
      return false;
    }
    if (l$since != lOther$since) {
      return false;
    }
    final l$states = states;
    final lOther$states = other.states;
    if (_$data.containsKey('states') != other._$data.containsKey('states')) {
      return false;
    }
    if (l$states != null && lOther$states != null) {
      if (l$states.length != lOther$states.length) {
        return false;
      }
      for (int i = 0; i < l$states.length; i++) {
        final l$states$entry = l$states[i];
        final lOther$states$entry = lOther$states[i];
        if (l$states$entry != lOther$states$entry) {
          return false;
        }
      }
    } else if (l$states != lOther$states) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (_$data.containsKey('type') != other._$data.containsKey('type')) {
      return false;
    }
    if (l$type != lOther$type) {
      return false;
    }
    final l$viewerSubscribed = viewerSubscribed;
    final lOther$viewerSubscribed = other.viewerSubscribed;
    if (_$data.containsKey('viewerSubscribed') !=
        other._$data.containsKey('viewerSubscribed')) {
      return false;
    }
    if (l$viewerSubscribed != lOther$viewerSubscribed) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assignee = assignee;
    final l$createdBy = createdBy;
    final l$labels = labels;
    final l$mentioned = mentioned;
    final l$milestone = milestone;
    final l$milestoneNumber = milestoneNumber;
    final l$since = since;
    final l$states = states;
    final l$type = type;
    final l$viewerSubscribed = viewerSubscribed;
    return Object.hashAll([
      _$data.containsKey('assignee') ? l$assignee : const {},
      _$data.containsKey('createdBy') ? l$createdBy : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('mentioned') ? l$mentioned : const {},
      _$data.containsKey('milestone') ? l$milestone : const {},
      _$data.containsKey('milestoneNumber') ? l$milestoneNumber : const {},
      _$data.containsKey('since') ? l$since : const {},
      _$data.containsKey('states')
          ? l$states == null
              ? null
              : Object.hashAll(l$states.map((v) => v))
          : const {},
      _$data.containsKey('type') ? l$type : const {},
      _$data.containsKey('viewerSubscribed') ? l$viewerSubscribed : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueFilters<TRes> {
  factory CopyWith$Input$IssueFilters(
    Input$IssueFilters instance,
    TRes Function(Input$IssueFilters) then,
  ) = _CopyWithImpl$Input$IssueFilters;

  factory CopyWith$Input$IssueFilters.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueFilters;

  TRes call({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    String? since,
    List<Enum$IssueState>? states,
    String? type,
    bool? viewerSubscribed,
  });
}

class _CopyWithImpl$Input$IssueFilters<TRes>
    implements CopyWith$Input$IssueFilters<TRes> {
  _CopyWithImpl$Input$IssueFilters(
    this._instance,
    this._then,
  );

  final Input$IssueFilters _instance;

  final TRes Function(Input$IssueFilters) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assignee = _undefined,
    Object? createdBy = _undefined,
    Object? labels = _undefined,
    Object? mentioned = _undefined,
    Object? milestone = _undefined,
    Object? milestoneNumber = _undefined,
    Object? since = _undefined,
    Object? states = _undefined,
    Object? type = _undefined,
    Object? viewerSubscribed = _undefined,
  }) =>
      _then(Input$IssueFilters._({
        ..._instance._$data,
        if (assignee != _undefined) 'assignee': (assignee as String?),
        if (createdBy != _undefined) 'createdBy': (createdBy as String?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (mentioned != _undefined) 'mentioned': (mentioned as String?),
        if (milestone != _undefined) 'milestone': (milestone as String?),
        if (milestoneNumber != _undefined)
          'milestoneNumber': (milestoneNumber as String?),
        if (since != _undefined) 'since': (since as String?),
        if (states != _undefined) 'states': (states as List<Enum$IssueState>?),
        if (type != _undefined) 'type': (type as String?),
        if (viewerSubscribed != _undefined)
          'viewerSubscribed': (viewerSubscribed as bool?),
      }));
}

class _CopyWithStubImpl$Input$IssueFilters<TRes>
    implements CopyWith$Input$IssueFilters<TRes> {
  _CopyWithStubImpl$Input$IssueFilters(this._res);

  TRes _res;

  call({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    String? since,
    List<Enum$IssueState>? states,
    String? type,
    bool? viewerSubscribed,
  }) =>
      _res;
}

class Input$IssueOrder {
  factory Input$IssueOrder({
    required Enum$IssueOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IssueOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IssueOrder._(this._$data);

  factory Input$IssueOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$IssueOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IssueOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IssueOrderField get field => (_$data['field'] as Enum$IssueOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IssueOrder<Input$IssueOrder> get copyWith =>
      CopyWith$Input$IssueOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IssueOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IssueOrder<TRes> {
  factory CopyWith$Input$IssueOrder(
    Input$IssueOrder instance,
    TRes Function(Input$IssueOrder) then,
  ) = _CopyWithImpl$Input$IssueOrder;

  factory CopyWith$Input$IssueOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueOrder;

  TRes call({
    Enum$IssueOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IssueOrder<TRes>
    implements CopyWith$Input$IssueOrder<TRes> {
  _CopyWithImpl$Input$IssueOrder(
    this._instance,
    this._then,
  );

  final Input$IssueOrder _instance;

  final TRes Function(Input$IssueOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IssueOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IssueOrder<TRes>
    implements CopyWith$Input$IssueOrder<TRes> {
  _CopyWithStubImpl$Input$IssueOrder(this._res);

  TRes _res;

  call({
    Enum$IssueOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$IssueTypeOrder {
  factory Input$IssueTypeOrder({
    required Enum$IssueTypeOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$IssueTypeOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$IssueTypeOrder._(this._$data);

  factory Input$IssueTypeOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IssueTypeOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$IssueTypeOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$IssueTypeOrderField get field =>
      (_$data['field'] as Enum$IssueTypeOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueTypeOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$IssueTypeOrder<Input$IssueTypeOrder> get copyWith =>
      CopyWith$Input$IssueTypeOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$IssueTypeOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$IssueTypeOrder<TRes> {
  factory CopyWith$Input$IssueTypeOrder(
    Input$IssueTypeOrder instance,
    TRes Function(Input$IssueTypeOrder) then,
  ) = _CopyWithImpl$Input$IssueTypeOrder;

  factory CopyWith$Input$IssueTypeOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueTypeOrder;

  TRes call({
    Enum$IssueTypeOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$IssueTypeOrder<TRes>
    implements CopyWith$Input$IssueTypeOrder<TRes> {
  _CopyWithImpl$Input$IssueTypeOrder(
    this._instance,
    this._then,
  );

  final Input$IssueTypeOrder _instance;

  final TRes Function(Input$IssueTypeOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$IssueTypeOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueTypeOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$IssueTypeOrder<TRes>
    implements CopyWith$Input$IssueTypeOrder<TRes> {
  _CopyWithStubImpl$Input$IssueTypeOrder(this._res);

  TRes _res;

  call({
    Enum$IssueTypeOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$LabelOrder {
  factory Input$LabelOrder({
    required Enum$LabelOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$LabelOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$LabelOrder._(this._$data);

  factory Input$LabelOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$LabelOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$LabelOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$LabelOrderField get field => (_$data['field'] as Enum$LabelOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$LabelOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$LabelOrder<Input$LabelOrder> get copyWith =>
      CopyWith$Input$LabelOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LabelOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$LabelOrder<TRes> {
  factory CopyWith$Input$LabelOrder(
    Input$LabelOrder instance,
    TRes Function(Input$LabelOrder) then,
  ) = _CopyWithImpl$Input$LabelOrder;

  factory CopyWith$Input$LabelOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$LabelOrder;

  TRes call({
    Enum$LabelOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$LabelOrder<TRes>
    implements CopyWith$Input$LabelOrder<TRes> {
  _CopyWithImpl$Input$LabelOrder(
    this._instance,
    this._then,
  );

  final Input$LabelOrder _instance;

  final TRes Function(Input$LabelOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$LabelOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$LabelOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$LabelOrder<TRes>
    implements CopyWith$Input$LabelOrder<TRes> {
  _CopyWithStubImpl$Input$LabelOrder(this._res);

  TRes _res;

  call({
    Enum$LabelOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$LanguageOrder {
  factory Input$LanguageOrder({
    required Enum$LanguageOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$LanguageOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$LanguageOrder._(this._$data);

  factory Input$LanguageOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$LanguageOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$LanguageOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$LanguageOrderField get field =>
      (_$data['field'] as Enum$LanguageOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$LanguageOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$LanguageOrder<Input$LanguageOrder> get copyWith =>
      CopyWith$Input$LanguageOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LanguageOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$LanguageOrder<TRes> {
  factory CopyWith$Input$LanguageOrder(
    Input$LanguageOrder instance,
    TRes Function(Input$LanguageOrder) then,
  ) = _CopyWithImpl$Input$LanguageOrder;

  factory CopyWith$Input$LanguageOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$LanguageOrder;

  TRes call({
    Enum$LanguageOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$LanguageOrder<TRes>
    implements CopyWith$Input$LanguageOrder<TRes> {
  _CopyWithImpl$Input$LanguageOrder(
    this._instance,
    this._then,
  );

  final Input$LanguageOrder _instance;

  final TRes Function(Input$LanguageOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$LanguageOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$LanguageOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$LanguageOrder<TRes>
    implements CopyWith$Input$LanguageOrder<TRes> {
  _CopyWithStubImpl$Input$LanguageOrder(this._res);

  TRes _res;

  call({
    Enum$LanguageOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$LinkProjectV2ToRepositoryInput {
  factory Input$LinkProjectV2ToRepositoryInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$LinkProjectV2ToRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$LinkProjectV2ToRepositoryInput._(this._$data);

  factory Input$LinkProjectV2ToRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$LinkProjectV2ToRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$LinkProjectV2ToRepositoryInput<
          Input$LinkProjectV2ToRepositoryInput>
      get copyWith => CopyWith$Input$LinkProjectV2ToRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LinkProjectV2ToRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  factory CopyWith$Input$LinkProjectV2ToRepositoryInput(
    Input$LinkProjectV2ToRepositoryInput instance,
    TRes Function(Input$LinkProjectV2ToRepositoryInput) then,
  ) = _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput;

  factory CopyWith$Input$LinkProjectV2ToRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$LinkProjectV2ToRepositoryInput _instance;

  final TRes Function(Input$LinkProjectV2ToRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$LinkProjectV2ToRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$LinkProjectV2ToTeamInput {
  factory Input$LinkProjectV2ToTeamInput({
    String? clientMutationId,
    required String projectId,
    required String teamId,
  }) =>
      Input$LinkProjectV2ToTeamInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'teamId': teamId,
      });

  Input$LinkProjectV2ToTeamInput._(this._$data);

  factory Input$LinkProjectV2ToTeamInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    return Input$LinkProjectV2ToTeamInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get teamId => (_$data['teamId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    return result$data;
  }

  CopyWith$Input$LinkProjectV2ToTeamInput<Input$LinkProjectV2ToTeamInput>
      get copyWith => CopyWith$Input$LinkProjectV2ToTeamInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LinkProjectV2ToTeamInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$teamId = teamId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$teamId,
    ]);
  }
}

abstract class CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  factory CopyWith$Input$LinkProjectV2ToTeamInput(
    Input$LinkProjectV2ToTeamInput instance,
    TRes Function(Input$LinkProjectV2ToTeamInput) then,
  ) = _CopyWithImpl$Input$LinkProjectV2ToTeamInput;

  factory CopyWith$Input$LinkProjectV2ToTeamInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  });
}

class _CopyWithImpl$Input$LinkProjectV2ToTeamInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  _CopyWithImpl$Input$LinkProjectV2ToTeamInput(
    this._instance,
    this._then,
  );

  final Input$LinkProjectV2ToTeamInput _instance;

  final TRes Function(Input$LinkProjectV2ToTeamInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? teamId = _undefined,
  }) =>
      _then(Input$LinkProjectV2ToTeamInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
      }));
}

class _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  }) =>
      _res;
}

class Input$LinkRepositoryToProjectInput {
  factory Input$LinkRepositoryToProjectInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$LinkRepositoryToProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$LinkRepositoryToProjectInput._(this._$data);

  factory Input$LinkRepositoryToProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$LinkRepositoryToProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$LinkRepositoryToProjectInput<
          Input$LinkRepositoryToProjectInput>
      get copyWith => CopyWith$Input$LinkRepositoryToProjectInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LinkRepositoryToProjectInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  factory CopyWith$Input$LinkRepositoryToProjectInput(
    Input$LinkRepositoryToProjectInput instance,
    TRes Function(Input$LinkRepositoryToProjectInput) then,
  ) = _CopyWithImpl$Input$LinkRepositoryToProjectInput;

  factory CopyWith$Input$LinkRepositoryToProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkRepositoryToProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$LinkRepositoryToProjectInput<TRes>
    implements CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  _CopyWithImpl$Input$LinkRepositoryToProjectInput(
    this._instance,
    this._then,
  );

  final Input$LinkRepositoryToProjectInput _instance;

  final TRes Function(Input$LinkRepositoryToProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$LinkRepositoryToProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$LinkRepositoryToProjectInput<TRes>
    implements CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  _CopyWithStubImpl$Input$LinkRepositoryToProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$LockLockableInput {
  factory Input$LockLockableInput({
    String? clientMutationId,
    required String lockableId,
    Enum$LockReason? lockReason,
  }) =>
      Input$LockLockableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'lockableId': lockableId,
        if (lockReason != null) r'lockReason': lockReason,
      });

  Input$LockLockableInput._(this._$data);

  factory Input$LockLockableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$lockableId = data['lockableId'];
    result$data['lockableId'] = (l$lockableId as String);
    if (data.containsKey('lockReason')) {
      final l$lockReason = data['lockReason'];
      result$data['lockReason'] = l$lockReason == null
          ? null
          : fromJson$Enum$LockReason((l$lockReason as String));
    }
    return Input$LockLockableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get lockableId => (_$data['lockableId'] as String);

  Enum$LockReason? get lockReason => (_$data['lockReason'] as Enum$LockReason?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$lockableId = lockableId;
    result$data['lockableId'] = l$lockableId;
    if (_$data.containsKey('lockReason')) {
      final l$lockReason = lockReason;
      result$data['lockReason'] =
          l$lockReason == null ? null : toJson$Enum$LockReason(l$lockReason);
    }
    return result$data;
  }

  CopyWith$Input$LockLockableInput<Input$LockLockableInput> get copyWith =>
      CopyWith$Input$LockLockableInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$LockLockableInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$lockableId = lockableId;
    final lOther$lockableId = other.lockableId;
    if (l$lockableId != lOther$lockableId) {
      return false;
    }
    final l$lockReason = lockReason;
    final lOther$lockReason = other.lockReason;
    if (_$data.containsKey('lockReason') !=
        other._$data.containsKey('lockReason')) {
      return false;
    }
    if (l$lockReason != lOther$lockReason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$lockableId = lockableId;
    final l$lockReason = lockReason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$lockableId,
      _$data.containsKey('lockReason') ? l$lockReason : const {},
    ]);
  }
}

abstract class CopyWith$Input$LockLockableInput<TRes> {
  factory CopyWith$Input$LockLockableInput(
    Input$LockLockableInput instance,
    TRes Function(Input$LockLockableInput) then,
  ) = _CopyWithImpl$Input$LockLockableInput;

  factory CopyWith$Input$LockLockableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LockLockableInput;

  TRes call({
    String? clientMutationId,
    String? lockableId,
    Enum$LockReason? lockReason,
  });
}

class _CopyWithImpl$Input$LockLockableInput<TRes>
    implements CopyWith$Input$LockLockableInput<TRes> {
  _CopyWithImpl$Input$LockLockableInput(
    this._instance,
    this._then,
  );

  final Input$LockLockableInput _instance;

  final TRes Function(Input$LockLockableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? lockableId = _undefined,
    Object? lockReason = _undefined,
  }) =>
      _then(Input$LockLockableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (lockableId != _undefined && lockableId != null)
          'lockableId': (lockableId as String),
        if (lockReason != _undefined)
          'lockReason': (lockReason as Enum$LockReason?),
      }));
}

class _CopyWithStubImpl$Input$LockLockableInput<TRes>
    implements CopyWith$Input$LockLockableInput<TRes> {
  _CopyWithStubImpl$Input$LockLockableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? lockableId,
    Enum$LockReason? lockReason,
  }) =>
      _res;
}

class Input$MannequinOrder {
  factory Input$MannequinOrder({
    required Enum$MannequinOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$MannequinOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$MannequinOrder._(this._$data);

  factory Input$MannequinOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$MannequinOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$MannequinOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$MannequinOrderField get field =>
      (_$data['field'] as Enum$MannequinOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$MannequinOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$MannequinOrder<Input$MannequinOrder> get copyWith =>
      CopyWith$Input$MannequinOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MannequinOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$MannequinOrder<TRes> {
  factory CopyWith$Input$MannequinOrder(
    Input$MannequinOrder instance,
    TRes Function(Input$MannequinOrder) then,
  ) = _CopyWithImpl$Input$MannequinOrder;

  factory CopyWith$Input$MannequinOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$MannequinOrder;

  TRes call({
    Enum$MannequinOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$MannequinOrder<TRes>
    implements CopyWith$Input$MannequinOrder<TRes> {
  _CopyWithImpl$Input$MannequinOrder(
    this._instance,
    this._then,
  );

  final Input$MannequinOrder _instance;

  final TRes Function(Input$MannequinOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$MannequinOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$MannequinOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$MannequinOrder<TRes>
    implements CopyWith$Input$MannequinOrder<TRes> {
  _CopyWithStubImpl$Input$MannequinOrder(this._res);

  TRes _res;

  call({
    Enum$MannequinOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$MarkDiscussionCommentAsAnswerInput {
  factory Input$MarkDiscussionCommentAsAnswerInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$MarkDiscussionCommentAsAnswerInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$MarkDiscussionCommentAsAnswerInput._(this._$data);

  factory Input$MarkDiscussionCommentAsAnswerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$MarkDiscussionCommentAsAnswerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$MarkDiscussionCommentAsAnswerInput<
          Input$MarkDiscussionCommentAsAnswerInput>
      get copyWith => CopyWith$Input$MarkDiscussionCommentAsAnswerInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MarkDiscussionCommentAsAnswerInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  factory CopyWith$Input$MarkDiscussionCommentAsAnswerInput(
    Input$MarkDiscussionCommentAsAnswerInput instance,
    TRes Function(Input$MarkDiscussionCommentAsAnswerInput) then,
  ) = _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput;

  factory CopyWith$Input$MarkDiscussionCommentAsAnswerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput(
    this._instance,
    this._then,
  );

  final Input$MarkDiscussionCommentAsAnswerInput _instance;

  final TRes Function(Input$MarkDiscussionCommentAsAnswerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$MarkDiscussionCommentAsAnswerInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$MarkFileAsViewedInput {
  factory Input$MarkFileAsViewedInput({
    String? clientMutationId,
    required String pullRequestId,
    required String path,
  }) =>
      Input$MarkFileAsViewedInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        r'path': path,
      });

  Input$MarkFileAsViewedInput._(this._$data);

  factory Input$MarkFileAsViewedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    return Input$MarkFileAsViewedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String get path => (_$data['path'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    final l$path = path;
    result$data['path'] = l$path;
    return result$data;
  }

  CopyWith$Input$MarkFileAsViewedInput<Input$MarkFileAsViewedInput>
      get copyWith => CopyWith$Input$MarkFileAsViewedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MarkFileAsViewedInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$path = path;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      l$path,
    ]);
  }
}

abstract class CopyWith$Input$MarkFileAsViewedInput<TRes> {
  factory CopyWith$Input$MarkFileAsViewedInput(
    Input$MarkFileAsViewedInput instance,
    TRes Function(Input$MarkFileAsViewedInput) then,
  ) = _CopyWithImpl$Input$MarkFileAsViewedInput;

  factory CopyWith$Input$MarkFileAsViewedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkFileAsViewedInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? path,
  });
}

class _CopyWithImpl$Input$MarkFileAsViewedInput<TRes>
    implements CopyWith$Input$MarkFileAsViewedInput<TRes> {
  _CopyWithImpl$Input$MarkFileAsViewedInput(
    this._instance,
    this._then,
  );

  final Input$MarkFileAsViewedInput _instance;

  final TRes Function(Input$MarkFileAsViewedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? path = _undefined,
  }) =>
      _then(Input$MarkFileAsViewedInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (path != _undefined && path != null) 'path': (path as String),
      }));
}

class _CopyWithStubImpl$Input$MarkFileAsViewedInput<TRes>
    implements CopyWith$Input$MarkFileAsViewedInput<TRes> {
  _CopyWithStubImpl$Input$MarkFileAsViewedInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? path,
  }) =>
      _res;
}

class Input$MarkProjectV2AsTemplateInput {
  factory Input$MarkProjectV2AsTemplateInput({
    String? clientMutationId,
    required String projectId,
  }) =>
      Input$MarkProjectV2AsTemplateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
      });

  Input$MarkProjectV2AsTemplateInput._(this._$data);

  factory Input$MarkProjectV2AsTemplateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$MarkProjectV2AsTemplateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$MarkProjectV2AsTemplateInput<
          Input$MarkProjectV2AsTemplateInput>
      get copyWith => CopyWith$Input$MarkProjectV2AsTemplateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MarkProjectV2AsTemplateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$MarkProjectV2AsTemplateInput<TRes> {
  factory CopyWith$Input$MarkProjectV2AsTemplateInput(
    Input$MarkProjectV2AsTemplateInput instance,
    TRes Function(Input$MarkProjectV2AsTemplateInput) then,
  ) = _CopyWithImpl$Input$MarkProjectV2AsTemplateInput;

  factory CopyWith$Input$MarkProjectV2AsTemplateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkProjectV2AsTemplateInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$MarkProjectV2AsTemplateInput<TRes>
    implements CopyWith$Input$MarkProjectV2AsTemplateInput<TRes> {
  _CopyWithImpl$Input$MarkProjectV2AsTemplateInput(
    this._instance,
    this._then,
  );

  final Input$MarkProjectV2AsTemplateInput _instance;

  final TRes Function(Input$MarkProjectV2AsTemplateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$MarkProjectV2AsTemplateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$MarkProjectV2AsTemplateInput<TRes>
    implements CopyWith$Input$MarkProjectV2AsTemplateInput<TRes> {
  _CopyWithStubImpl$Input$MarkProjectV2AsTemplateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
  }) =>
      _res;
}

class Input$MarkPullRequestReadyForReviewInput {
  factory Input$MarkPullRequestReadyForReviewInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$MarkPullRequestReadyForReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$MarkPullRequestReadyForReviewInput._(this._$data);

  factory Input$MarkPullRequestReadyForReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$MarkPullRequestReadyForReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$MarkPullRequestReadyForReviewInput<
          Input$MarkPullRequestReadyForReviewInput>
      get copyWith => CopyWith$Input$MarkPullRequestReadyForReviewInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MarkPullRequestReadyForReviewInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  factory CopyWith$Input$MarkPullRequestReadyForReviewInput(
    Input$MarkPullRequestReadyForReviewInput instance,
    TRes Function(Input$MarkPullRequestReadyForReviewInput) then,
  ) = _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput;

  factory CopyWith$Input$MarkPullRequestReadyForReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput<TRes>
    implements CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput(
    this._instance,
    this._then,
  );

  final Input$MarkPullRequestReadyForReviewInput _instance;

  final TRes Function(Input$MarkPullRequestReadyForReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$MarkPullRequestReadyForReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput<TRes>
    implements CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$MaxFilePathLengthParametersInput {
  factory Input$MaxFilePathLengthParametersInput(
          {required int maxFilePathLength}) =>
      Input$MaxFilePathLengthParametersInput._({
        r'maxFilePathLength': maxFilePathLength,
      });

  Input$MaxFilePathLengthParametersInput._(this._$data);

  factory Input$MaxFilePathLengthParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$maxFilePathLength = data['maxFilePathLength'];
    result$data['maxFilePathLength'] = (l$maxFilePathLength as int);
    return Input$MaxFilePathLengthParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get maxFilePathLength => (_$data['maxFilePathLength'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$maxFilePathLength = maxFilePathLength;
    result$data['maxFilePathLength'] = l$maxFilePathLength;
    return result$data;
  }

  CopyWith$Input$MaxFilePathLengthParametersInput<
          Input$MaxFilePathLengthParametersInput>
      get copyWith => CopyWith$Input$MaxFilePathLengthParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MaxFilePathLengthParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$maxFilePathLength = maxFilePathLength;
    final lOther$maxFilePathLength = other.maxFilePathLength;
    if (l$maxFilePathLength != lOther$maxFilePathLength) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$maxFilePathLength = maxFilePathLength;
    return Object.hashAll([l$maxFilePathLength]);
  }
}

abstract class CopyWith$Input$MaxFilePathLengthParametersInput<TRes> {
  factory CopyWith$Input$MaxFilePathLengthParametersInput(
    Input$MaxFilePathLengthParametersInput instance,
    TRes Function(Input$MaxFilePathLengthParametersInput) then,
  ) = _CopyWithImpl$Input$MaxFilePathLengthParametersInput;

  factory CopyWith$Input$MaxFilePathLengthParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MaxFilePathLengthParametersInput;

  TRes call({int? maxFilePathLength});
}

class _CopyWithImpl$Input$MaxFilePathLengthParametersInput<TRes>
    implements CopyWith$Input$MaxFilePathLengthParametersInput<TRes> {
  _CopyWithImpl$Input$MaxFilePathLengthParametersInput(
    this._instance,
    this._then,
  );

  final Input$MaxFilePathLengthParametersInput _instance;

  final TRes Function(Input$MaxFilePathLengthParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? maxFilePathLength = _undefined}) =>
      _then(Input$MaxFilePathLengthParametersInput._({
        ..._instance._$data,
        if (maxFilePathLength != _undefined && maxFilePathLength != null)
          'maxFilePathLength': (maxFilePathLength as int),
      }));
}

class _CopyWithStubImpl$Input$MaxFilePathLengthParametersInput<TRes>
    implements CopyWith$Input$MaxFilePathLengthParametersInput<TRes> {
  _CopyWithStubImpl$Input$MaxFilePathLengthParametersInput(this._res);

  TRes _res;

  call({int? maxFilePathLength}) => _res;
}

class Input$MaxFileSizeParametersInput {
  factory Input$MaxFileSizeParametersInput({required int maxFileSize}) =>
      Input$MaxFileSizeParametersInput._({
        r'maxFileSize': maxFileSize,
      });

  Input$MaxFileSizeParametersInput._(this._$data);

  factory Input$MaxFileSizeParametersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$maxFileSize = data['maxFileSize'];
    result$data['maxFileSize'] = (l$maxFileSize as int);
    return Input$MaxFileSizeParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get maxFileSize => (_$data['maxFileSize'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$maxFileSize = maxFileSize;
    result$data['maxFileSize'] = l$maxFileSize;
    return result$data;
  }

  CopyWith$Input$MaxFileSizeParametersInput<Input$MaxFileSizeParametersInput>
      get copyWith => CopyWith$Input$MaxFileSizeParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MaxFileSizeParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$maxFileSize = maxFileSize;
    final lOther$maxFileSize = other.maxFileSize;
    if (l$maxFileSize != lOther$maxFileSize) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$maxFileSize = maxFileSize;
    return Object.hashAll([l$maxFileSize]);
  }
}

abstract class CopyWith$Input$MaxFileSizeParametersInput<TRes> {
  factory CopyWith$Input$MaxFileSizeParametersInput(
    Input$MaxFileSizeParametersInput instance,
    TRes Function(Input$MaxFileSizeParametersInput) then,
  ) = _CopyWithImpl$Input$MaxFileSizeParametersInput;

  factory CopyWith$Input$MaxFileSizeParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MaxFileSizeParametersInput;

  TRes call({int? maxFileSize});
}

class _CopyWithImpl$Input$MaxFileSizeParametersInput<TRes>
    implements CopyWith$Input$MaxFileSizeParametersInput<TRes> {
  _CopyWithImpl$Input$MaxFileSizeParametersInput(
    this._instance,
    this._then,
  );

  final Input$MaxFileSizeParametersInput _instance;

  final TRes Function(Input$MaxFileSizeParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? maxFileSize = _undefined}) =>
      _then(Input$MaxFileSizeParametersInput._({
        ..._instance._$data,
        if (maxFileSize != _undefined && maxFileSize != null)
          'maxFileSize': (maxFileSize as int),
      }));
}

class _CopyWithStubImpl$Input$MaxFileSizeParametersInput<TRes>
    implements CopyWith$Input$MaxFileSizeParametersInput<TRes> {
  _CopyWithStubImpl$Input$MaxFileSizeParametersInput(this._res);

  TRes _res;

  call({int? maxFileSize}) => _res;
}

class Input$MergeBranchInput {
  factory Input$MergeBranchInput({
    String? clientMutationId,
    required String repositoryId,
    required String base,
    required String head,
    String? commitMessage,
    String? authorEmail,
  }) =>
      Input$MergeBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'base': base,
        r'head': head,
        if (commitMessage != null) r'commitMessage': commitMessage,
        if (authorEmail != null) r'authorEmail': authorEmail,
      });

  Input$MergeBranchInput._(this._$data);

  factory Input$MergeBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$base = data['base'];
    result$data['base'] = (l$base as String);
    final l$head = data['head'];
    result$data['head'] = (l$head as String);
    if (data.containsKey('commitMessage')) {
      final l$commitMessage = data['commitMessage'];
      result$data['commitMessage'] = (l$commitMessage as String?);
    }
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    return Input$MergeBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get base => (_$data['base'] as String);

  String get head => (_$data['head'] as String);

  String? get commitMessage => (_$data['commitMessage'] as String?);

  String? get authorEmail => (_$data['authorEmail'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$base = base;
    result$data['base'] = l$base;
    final l$head = head;
    result$data['head'] = l$head;
    if (_$data.containsKey('commitMessage')) {
      final l$commitMessage = commitMessage;
      result$data['commitMessage'] = l$commitMessage;
    }
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    return result$data;
  }

  CopyWith$Input$MergeBranchInput<Input$MergeBranchInput> get copyWith =>
      CopyWith$Input$MergeBranchInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MergeBranchInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$base = base;
    final lOther$base = other.base;
    if (l$base != lOther$base) {
      return false;
    }
    final l$head = head;
    final lOther$head = other.head;
    if (l$head != lOther$head) {
      return false;
    }
    final l$commitMessage = commitMessage;
    final lOther$commitMessage = other.commitMessage;
    if (_$data.containsKey('commitMessage') !=
        other._$data.containsKey('commitMessage')) {
      return false;
    }
    if (l$commitMessage != lOther$commitMessage) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$base = base;
    final l$head = head;
    final l$commitMessage = commitMessage;
    final l$authorEmail = authorEmail;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$base,
      l$head,
      _$data.containsKey('commitMessage') ? l$commitMessage : const {},
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergeBranchInput<TRes> {
  factory CopyWith$Input$MergeBranchInput(
    Input$MergeBranchInput instance,
    TRes Function(Input$MergeBranchInput) then,
  ) = _CopyWithImpl$Input$MergeBranchInput;

  factory CopyWith$Input$MergeBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeBranchInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? base,
    String? head,
    String? commitMessage,
    String? authorEmail,
  });
}

class _CopyWithImpl$Input$MergeBranchInput<TRes>
    implements CopyWith$Input$MergeBranchInput<TRes> {
  _CopyWithImpl$Input$MergeBranchInput(
    this._instance,
    this._then,
  );

  final Input$MergeBranchInput _instance;

  final TRes Function(Input$MergeBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? base = _undefined,
    Object? head = _undefined,
    Object? commitMessage = _undefined,
    Object? authorEmail = _undefined,
  }) =>
      _then(Input$MergeBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (base != _undefined && base != null) 'base': (base as String),
        if (head != _undefined && head != null) 'head': (head as String),
        if (commitMessage != _undefined)
          'commitMessage': (commitMessage as String?),
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
      }));
}

class _CopyWithStubImpl$Input$MergeBranchInput<TRes>
    implements CopyWith$Input$MergeBranchInput<TRes> {
  _CopyWithStubImpl$Input$MergeBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? base,
    String? head,
    String? commitMessage,
    String? authorEmail,
  }) =>
      _res;
}

class Input$MergePullRequestInput {
  factory Input$MergePullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
    String? commitHeadline,
    String? commitBody,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
  }) =>
      Input$MergePullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (commitHeadline != null) r'commitHeadline': commitHeadline,
        if (commitBody != null) r'commitBody': commitBody,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
        if (mergeMethod != null) r'mergeMethod': mergeMethod,
        if (authorEmail != null) r'authorEmail': authorEmail,
      });

  Input$MergePullRequestInput._(this._$data);

  factory Input$MergePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('commitHeadline')) {
      final l$commitHeadline = data['commitHeadline'];
      result$data['commitHeadline'] = (l$commitHeadline as String?);
    }
    if (data.containsKey('commitBody')) {
      final l$commitBody = data['commitBody'];
      result$data['commitBody'] = (l$commitBody as String?);
    }
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    if (data.containsKey('mergeMethod')) {
      final l$mergeMethod = data['mergeMethod'];
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : fromJson$Enum$PullRequestMergeMethod((l$mergeMethod as String));
    }
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    return Input$MergePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String? get commitHeadline => (_$data['commitHeadline'] as String?);

  String? get commitBody => (_$data['commitBody'] as String?);

  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);

  Enum$PullRequestMergeMethod? get mergeMethod =>
      (_$data['mergeMethod'] as Enum$PullRequestMergeMethod?);

  String? get authorEmail => (_$data['authorEmail'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('commitHeadline')) {
      final l$commitHeadline = commitHeadline;
      result$data['commitHeadline'] = l$commitHeadline;
    }
    if (_$data.containsKey('commitBody')) {
      final l$commitBody = commitBody;
      result$data['commitBody'] = l$commitBody;
    }
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    if (_$data.containsKey('mergeMethod')) {
      final l$mergeMethod = mergeMethod;
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : toJson$Enum$PullRequestMergeMethod(l$mergeMethod);
    }
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    return result$data;
  }

  CopyWith$Input$MergePullRequestInput<Input$MergePullRequestInput>
      get copyWith => CopyWith$Input$MergePullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MergePullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$commitHeadline = commitHeadline;
    final lOther$commitHeadline = other.commitHeadline;
    if (_$data.containsKey('commitHeadline') !=
        other._$data.containsKey('commitHeadline')) {
      return false;
    }
    if (l$commitHeadline != lOther$commitHeadline) {
      return false;
    }
    final l$commitBody = commitBody;
    final lOther$commitBody = other.commitBody;
    if (_$data.containsKey('commitBody') !=
        other._$data.containsKey('commitBody')) {
      return false;
    }
    if (l$commitBody != lOther$commitBody) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$mergeMethod = mergeMethod;
    final lOther$mergeMethod = other.mergeMethod;
    if (_$data.containsKey('mergeMethod') !=
        other._$data.containsKey('mergeMethod')) {
      return false;
    }
    if (l$mergeMethod != lOther$mergeMethod) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$commitHeadline = commitHeadline;
    final l$commitBody = commitBody;
    final l$expectedHeadOid = expectedHeadOid;
    final l$mergeMethod = mergeMethod;
    final l$authorEmail = authorEmail;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('commitHeadline') ? l$commitHeadline : const {},
      _$data.containsKey('commitBody') ? l$commitBody : const {},
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
      _$data.containsKey('mergeMethod') ? l$mergeMethod : const {},
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
    ]);
  }
}

abstract class CopyWith$Input$MergePullRequestInput<TRes> {
  factory CopyWith$Input$MergePullRequestInput(
    Input$MergePullRequestInput instance,
    TRes Function(Input$MergePullRequestInput) then,
  ) = _CopyWithImpl$Input$MergePullRequestInput;

  factory CopyWith$Input$MergePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergePullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
  });
}

class _CopyWithImpl$Input$MergePullRequestInput<TRes>
    implements CopyWith$Input$MergePullRequestInput<TRes> {
  _CopyWithImpl$Input$MergePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$MergePullRequestInput _instance;

  final TRes Function(Input$MergePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? commitHeadline = _undefined,
    Object? commitBody = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? mergeMethod = _undefined,
    Object? authorEmail = _undefined,
  }) =>
      _then(Input$MergePullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (commitHeadline != _undefined)
          'commitHeadline': (commitHeadline as String?),
        if (commitBody != _undefined) 'commitBody': (commitBody as String?),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
        if (mergeMethod != _undefined)
          'mergeMethod': (mergeMethod as Enum$PullRequestMergeMethod?),
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
      }));
}

class _CopyWithStubImpl$Input$MergePullRequestInput<TRes>
    implements CopyWith$Input$MergePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$MergePullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? commitHeadline,
    String? commitBody,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? authorEmail,
  }) =>
      _res;
}

class Input$MergeQueueParametersInput {
  factory Input$MergeQueueParametersInput({
    required int checkResponseTimeoutMinutes,
    required Enum$MergeQueueGroupingStrategy groupingStrategy,
    required int maxEntriesToBuild,
    required int maxEntriesToMerge,
    required Enum$MergeQueueMergeMethod mergeMethod,
    required int minEntriesToMerge,
    required int minEntriesToMergeWaitMinutes,
  }) =>
      Input$MergeQueueParametersInput._({
        r'checkResponseTimeoutMinutes': checkResponseTimeoutMinutes,
        r'groupingStrategy': groupingStrategy,
        r'maxEntriesToBuild': maxEntriesToBuild,
        r'maxEntriesToMerge': maxEntriesToMerge,
        r'mergeMethod': mergeMethod,
        r'minEntriesToMerge': minEntriesToMerge,
        r'minEntriesToMergeWaitMinutes': minEntriesToMergeWaitMinutes,
      });

  Input$MergeQueueParametersInput._(this._$data);

  factory Input$MergeQueueParametersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$checkResponseTimeoutMinutes = data['checkResponseTimeoutMinutes'];
    result$data['checkResponseTimeoutMinutes'] =
        (l$checkResponseTimeoutMinutes as int);
    final l$groupingStrategy = data['groupingStrategy'];
    result$data['groupingStrategy'] = fromJson$Enum$MergeQueueGroupingStrategy(
        (l$groupingStrategy as String));
    final l$maxEntriesToBuild = data['maxEntriesToBuild'];
    result$data['maxEntriesToBuild'] = (l$maxEntriesToBuild as int);
    final l$maxEntriesToMerge = data['maxEntriesToMerge'];
    result$data['maxEntriesToMerge'] = (l$maxEntriesToMerge as int);
    final l$mergeMethod = data['mergeMethod'];
    result$data['mergeMethod'] =
        fromJson$Enum$MergeQueueMergeMethod((l$mergeMethod as String));
    final l$minEntriesToMerge = data['minEntriesToMerge'];
    result$data['minEntriesToMerge'] = (l$minEntriesToMerge as int);
    final l$minEntriesToMergeWaitMinutes = data['minEntriesToMergeWaitMinutes'];
    result$data['minEntriesToMergeWaitMinutes'] =
        (l$minEntriesToMergeWaitMinutes as int);
    return Input$MergeQueueParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get checkResponseTimeoutMinutes =>
      (_$data['checkResponseTimeoutMinutes'] as int);

  Enum$MergeQueueGroupingStrategy get groupingStrategy =>
      (_$data['groupingStrategy'] as Enum$MergeQueueGroupingStrategy);

  int get maxEntriesToBuild => (_$data['maxEntriesToBuild'] as int);

  int get maxEntriesToMerge => (_$data['maxEntriesToMerge'] as int);

  Enum$MergeQueueMergeMethod get mergeMethod =>
      (_$data['mergeMethod'] as Enum$MergeQueueMergeMethod);

  int get minEntriesToMerge => (_$data['minEntriesToMerge'] as int);

  int get minEntriesToMergeWaitMinutes =>
      (_$data['minEntriesToMergeWaitMinutes'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$checkResponseTimeoutMinutes = checkResponseTimeoutMinutes;
    result$data['checkResponseTimeoutMinutes'] = l$checkResponseTimeoutMinutes;
    final l$groupingStrategy = groupingStrategy;
    result$data['groupingStrategy'] =
        toJson$Enum$MergeQueueGroupingStrategy(l$groupingStrategy);
    final l$maxEntriesToBuild = maxEntriesToBuild;
    result$data['maxEntriesToBuild'] = l$maxEntriesToBuild;
    final l$maxEntriesToMerge = maxEntriesToMerge;
    result$data['maxEntriesToMerge'] = l$maxEntriesToMerge;
    final l$mergeMethod = mergeMethod;
    result$data['mergeMethod'] =
        toJson$Enum$MergeQueueMergeMethod(l$mergeMethod);
    final l$minEntriesToMerge = minEntriesToMerge;
    result$data['minEntriesToMerge'] = l$minEntriesToMerge;
    final l$minEntriesToMergeWaitMinutes = minEntriesToMergeWaitMinutes;
    result$data['minEntriesToMergeWaitMinutes'] =
        l$minEntriesToMergeWaitMinutes;
    return result$data;
  }

  CopyWith$Input$MergeQueueParametersInput<Input$MergeQueueParametersInput>
      get copyWith => CopyWith$Input$MergeQueueParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MergeQueueParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$checkResponseTimeoutMinutes = checkResponseTimeoutMinutes;
    final lOther$checkResponseTimeoutMinutes =
        other.checkResponseTimeoutMinutes;
    if (l$checkResponseTimeoutMinutes != lOther$checkResponseTimeoutMinutes) {
      return false;
    }
    final l$groupingStrategy = groupingStrategy;
    final lOther$groupingStrategy = other.groupingStrategy;
    if (l$groupingStrategy != lOther$groupingStrategy) {
      return false;
    }
    final l$maxEntriesToBuild = maxEntriesToBuild;
    final lOther$maxEntriesToBuild = other.maxEntriesToBuild;
    if (l$maxEntriesToBuild != lOther$maxEntriesToBuild) {
      return false;
    }
    final l$maxEntriesToMerge = maxEntriesToMerge;
    final lOther$maxEntriesToMerge = other.maxEntriesToMerge;
    if (l$maxEntriesToMerge != lOther$maxEntriesToMerge) {
      return false;
    }
    final l$mergeMethod = mergeMethod;
    final lOther$mergeMethod = other.mergeMethod;
    if (l$mergeMethod != lOther$mergeMethod) {
      return false;
    }
    final l$minEntriesToMerge = minEntriesToMerge;
    final lOther$minEntriesToMerge = other.minEntriesToMerge;
    if (l$minEntriesToMerge != lOther$minEntriesToMerge) {
      return false;
    }
    final l$minEntriesToMergeWaitMinutes = minEntriesToMergeWaitMinutes;
    final lOther$minEntriesToMergeWaitMinutes =
        other.minEntriesToMergeWaitMinutes;
    if (l$minEntriesToMergeWaitMinutes != lOther$minEntriesToMergeWaitMinutes) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$checkResponseTimeoutMinutes = checkResponseTimeoutMinutes;
    final l$groupingStrategy = groupingStrategy;
    final l$maxEntriesToBuild = maxEntriesToBuild;
    final l$maxEntriesToMerge = maxEntriesToMerge;
    final l$mergeMethod = mergeMethod;
    final l$minEntriesToMerge = minEntriesToMerge;
    final l$minEntriesToMergeWaitMinutes = minEntriesToMergeWaitMinutes;
    return Object.hashAll([
      l$checkResponseTimeoutMinutes,
      l$groupingStrategy,
      l$maxEntriesToBuild,
      l$maxEntriesToMerge,
      l$mergeMethod,
      l$minEntriesToMerge,
      l$minEntriesToMergeWaitMinutes,
    ]);
  }
}

abstract class CopyWith$Input$MergeQueueParametersInput<TRes> {
  factory CopyWith$Input$MergeQueueParametersInput(
    Input$MergeQueueParametersInput instance,
    TRes Function(Input$MergeQueueParametersInput) then,
  ) = _CopyWithImpl$Input$MergeQueueParametersInput;

  factory CopyWith$Input$MergeQueueParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeQueueParametersInput;

  TRes call({
    int? checkResponseTimeoutMinutes,
    Enum$MergeQueueGroupingStrategy? groupingStrategy,
    int? maxEntriesToBuild,
    int? maxEntriesToMerge,
    Enum$MergeQueueMergeMethod? mergeMethod,
    int? minEntriesToMerge,
    int? minEntriesToMergeWaitMinutes,
  });
}

class _CopyWithImpl$Input$MergeQueueParametersInput<TRes>
    implements CopyWith$Input$MergeQueueParametersInput<TRes> {
  _CopyWithImpl$Input$MergeQueueParametersInput(
    this._instance,
    this._then,
  );

  final Input$MergeQueueParametersInput _instance;

  final TRes Function(Input$MergeQueueParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? checkResponseTimeoutMinutes = _undefined,
    Object? groupingStrategy = _undefined,
    Object? maxEntriesToBuild = _undefined,
    Object? maxEntriesToMerge = _undefined,
    Object? mergeMethod = _undefined,
    Object? minEntriesToMerge = _undefined,
    Object? minEntriesToMergeWaitMinutes = _undefined,
  }) =>
      _then(Input$MergeQueueParametersInput._({
        ..._instance._$data,
        if (checkResponseTimeoutMinutes != _undefined &&
            checkResponseTimeoutMinutes != null)
          'checkResponseTimeoutMinutes': (checkResponseTimeoutMinutes as int),
        if (groupingStrategy != _undefined && groupingStrategy != null)
          'groupingStrategy':
              (groupingStrategy as Enum$MergeQueueGroupingStrategy),
        if (maxEntriesToBuild != _undefined && maxEntriesToBuild != null)
          'maxEntriesToBuild': (maxEntriesToBuild as int),
        if (maxEntriesToMerge != _undefined && maxEntriesToMerge != null)
          'maxEntriesToMerge': (maxEntriesToMerge as int),
        if (mergeMethod != _undefined && mergeMethod != null)
          'mergeMethod': (mergeMethod as Enum$MergeQueueMergeMethod),
        if (minEntriesToMerge != _undefined && minEntriesToMerge != null)
          'minEntriesToMerge': (minEntriesToMerge as int),
        if (minEntriesToMergeWaitMinutes != _undefined &&
            minEntriesToMergeWaitMinutes != null)
          'minEntriesToMergeWaitMinutes': (minEntriesToMergeWaitMinutes as int),
      }));
}

class _CopyWithStubImpl$Input$MergeQueueParametersInput<TRes>
    implements CopyWith$Input$MergeQueueParametersInput<TRes> {
  _CopyWithStubImpl$Input$MergeQueueParametersInput(this._res);

  TRes _res;

  call({
    int? checkResponseTimeoutMinutes,
    Enum$MergeQueueGroupingStrategy? groupingStrategy,
    int? maxEntriesToBuild,
    int? maxEntriesToMerge,
    Enum$MergeQueueMergeMethod? mergeMethod,
    int? minEntriesToMerge,
    int? minEntriesToMergeWaitMinutes,
  }) =>
      _res;
}

class Input$MilestoneOrder {
  factory Input$MilestoneOrder({
    required Enum$MilestoneOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$MilestoneOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$MilestoneOrder._(this._$data);

  factory Input$MilestoneOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$MilestoneOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$MilestoneOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$MilestoneOrderField get field =>
      (_$data['field'] as Enum$MilestoneOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$MilestoneOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$MilestoneOrder<Input$MilestoneOrder> get copyWith =>
      CopyWith$Input$MilestoneOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MilestoneOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$MilestoneOrder<TRes> {
  factory CopyWith$Input$MilestoneOrder(
    Input$MilestoneOrder instance,
    TRes Function(Input$MilestoneOrder) then,
  ) = _CopyWithImpl$Input$MilestoneOrder;

  factory CopyWith$Input$MilestoneOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$MilestoneOrder;

  TRes call({
    Enum$MilestoneOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$MilestoneOrder<TRes>
    implements CopyWith$Input$MilestoneOrder<TRes> {
  _CopyWithImpl$Input$MilestoneOrder(
    this._instance,
    this._then,
  );

  final Input$MilestoneOrder _instance;

  final TRes Function(Input$MilestoneOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$MilestoneOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$MilestoneOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$MilestoneOrder<TRes>
    implements CopyWith$Input$MilestoneOrder<TRes> {
  _CopyWithStubImpl$Input$MilestoneOrder(this._res);

  TRes _res;

  call({
    Enum$MilestoneOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$MinimizeCommentInput {
  factory Input$MinimizeCommentInput({
    String? clientMutationId,
    required String subjectId,
    required Enum$ReportedContentClassifiers classifier,
  }) =>
      Input$MinimizeCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
        r'classifier': classifier,
      });

  Input$MinimizeCommentInput._(this._$data);

  factory Input$MinimizeCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$classifier = data['classifier'];
    result$data['classifier'] =
        fromJson$Enum$ReportedContentClassifiers((l$classifier as String));
    return Input$MinimizeCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subjectId => (_$data['subjectId'] as String);

  Enum$ReportedContentClassifiers get classifier =>
      (_$data['classifier'] as Enum$ReportedContentClassifiers);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$classifier = classifier;
    result$data['classifier'] =
        toJson$Enum$ReportedContentClassifiers(l$classifier);
    return result$data;
  }

  CopyWith$Input$MinimizeCommentInput<Input$MinimizeCommentInput>
      get copyWith => CopyWith$Input$MinimizeCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MinimizeCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$classifier = classifier;
    final lOther$classifier = other.classifier;
    if (l$classifier != lOther$classifier) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    final l$classifier = classifier;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
      l$classifier,
    ]);
  }
}

abstract class CopyWith$Input$MinimizeCommentInput<TRes> {
  factory CopyWith$Input$MinimizeCommentInput(
    Input$MinimizeCommentInput instance,
    TRes Function(Input$MinimizeCommentInput) then,
  ) = _CopyWithImpl$Input$MinimizeCommentInput;

  factory CopyWith$Input$MinimizeCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MinimizeCommentInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
    Enum$ReportedContentClassifiers? classifier,
  });
}

class _CopyWithImpl$Input$MinimizeCommentInput<TRes>
    implements CopyWith$Input$MinimizeCommentInput<TRes> {
  _CopyWithImpl$Input$MinimizeCommentInput(
    this._instance,
    this._then,
  );

  final Input$MinimizeCommentInput _instance;

  final TRes Function(Input$MinimizeCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
    Object? classifier = _undefined,
  }) =>
      _then(Input$MinimizeCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (classifier != _undefined && classifier != null)
          'classifier': (classifier as Enum$ReportedContentClassifiers),
      }));
}

class _CopyWithStubImpl$Input$MinimizeCommentInput<TRes>
    implements CopyWith$Input$MinimizeCommentInput<TRes> {
  _CopyWithStubImpl$Input$MinimizeCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
    Enum$ReportedContentClassifiers? classifier,
  }) =>
      _res;
}

class Input$MoveProjectCardInput {
  factory Input$MoveProjectCardInput({
    String? clientMutationId,
    required String cardId,
    required String columnId,
    String? afterCardId,
  }) =>
      Input$MoveProjectCardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'cardId': cardId,
        r'columnId': columnId,
        if (afterCardId != null) r'afterCardId': afterCardId,
      });

  Input$MoveProjectCardInput._(this._$data);

  factory Input$MoveProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$cardId = data['cardId'];
    result$data['cardId'] = (l$cardId as String);
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    if (data.containsKey('afterCardId')) {
      final l$afterCardId = data['afterCardId'];
      result$data['afterCardId'] = (l$afterCardId as String?);
    }
    return Input$MoveProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get cardId => (_$data['cardId'] as String);

  String get columnId => (_$data['columnId'] as String);

  String? get afterCardId => (_$data['afterCardId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$cardId = cardId;
    result$data['cardId'] = l$cardId;
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    if (_$data.containsKey('afterCardId')) {
      final l$afterCardId = afterCardId;
      result$data['afterCardId'] = l$afterCardId;
    }
    return result$data;
  }

  CopyWith$Input$MoveProjectCardInput<Input$MoveProjectCardInput>
      get copyWith => CopyWith$Input$MoveProjectCardInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MoveProjectCardInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$cardId = cardId;
    final lOther$cardId = other.cardId;
    if (l$cardId != lOther$cardId) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    final l$afterCardId = afterCardId;
    final lOther$afterCardId = other.afterCardId;
    if (_$data.containsKey('afterCardId') !=
        other._$data.containsKey('afterCardId')) {
      return false;
    }
    if (l$afterCardId != lOther$afterCardId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$cardId = cardId;
    final l$columnId = columnId;
    final l$afterCardId = afterCardId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$cardId,
      l$columnId,
      _$data.containsKey('afterCardId') ? l$afterCardId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MoveProjectCardInput<TRes> {
  factory CopyWith$Input$MoveProjectCardInput(
    Input$MoveProjectCardInput instance,
    TRes Function(Input$MoveProjectCardInput) then,
  ) = _CopyWithImpl$Input$MoveProjectCardInput;

  factory CopyWith$Input$MoveProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveProjectCardInput;

  TRes call({
    String? clientMutationId,
    String? cardId,
    String? columnId,
    String? afterCardId,
  });
}

class _CopyWithImpl$Input$MoveProjectCardInput<TRes>
    implements CopyWith$Input$MoveProjectCardInput<TRes> {
  _CopyWithImpl$Input$MoveProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$MoveProjectCardInput _instance;

  final TRes Function(Input$MoveProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? cardId = _undefined,
    Object? columnId = _undefined,
    Object? afterCardId = _undefined,
  }) =>
      _then(Input$MoveProjectCardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (cardId != _undefined && cardId != null)
          'cardId': (cardId as String),
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
        if (afterCardId != _undefined) 'afterCardId': (afterCardId as String?),
      }));
}

class _CopyWithStubImpl$Input$MoveProjectCardInput<TRes>
    implements CopyWith$Input$MoveProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$MoveProjectCardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? cardId,
    String? columnId,
    String? afterCardId,
  }) =>
      _res;
}

class Input$MoveProjectColumnInput {
  factory Input$MoveProjectColumnInput({
    String? clientMutationId,
    required String columnId,
    String? afterColumnId,
  }) =>
      Input$MoveProjectColumnInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'columnId': columnId,
        if (afterColumnId != null) r'afterColumnId': afterColumnId,
      });

  Input$MoveProjectColumnInput._(this._$data);

  factory Input$MoveProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    if (data.containsKey('afterColumnId')) {
      final l$afterColumnId = data['afterColumnId'];
      result$data['afterColumnId'] = (l$afterColumnId as String?);
    }
    return Input$MoveProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get columnId => (_$data['columnId'] as String);

  String? get afterColumnId => (_$data['afterColumnId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    if (_$data.containsKey('afterColumnId')) {
      final l$afterColumnId = afterColumnId;
      result$data['afterColumnId'] = l$afterColumnId;
    }
    return result$data;
  }

  CopyWith$Input$MoveProjectColumnInput<Input$MoveProjectColumnInput>
      get copyWith => CopyWith$Input$MoveProjectColumnInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$MoveProjectColumnInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    final l$afterColumnId = afterColumnId;
    final lOther$afterColumnId = other.afterColumnId;
    if (_$data.containsKey('afterColumnId') !=
        other._$data.containsKey('afterColumnId')) {
      return false;
    }
    if (l$afterColumnId != lOther$afterColumnId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$columnId = columnId;
    final l$afterColumnId = afterColumnId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$columnId,
      _$data.containsKey('afterColumnId') ? l$afterColumnId : const {},
    ]);
  }
}

abstract class CopyWith$Input$MoveProjectColumnInput<TRes> {
  factory CopyWith$Input$MoveProjectColumnInput(
    Input$MoveProjectColumnInput instance,
    TRes Function(Input$MoveProjectColumnInput) then,
  ) = _CopyWithImpl$Input$MoveProjectColumnInput;

  factory CopyWith$Input$MoveProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveProjectColumnInput;

  TRes call({
    String? clientMutationId,
    String? columnId,
    String? afterColumnId,
  });
}

class _CopyWithImpl$Input$MoveProjectColumnInput<TRes>
    implements CopyWith$Input$MoveProjectColumnInput<TRes> {
  _CopyWithImpl$Input$MoveProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$MoveProjectColumnInput _instance;

  final TRes Function(Input$MoveProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? columnId = _undefined,
    Object? afterColumnId = _undefined,
  }) =>
      _then(Input$MoveProjectColumnInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
        if (afterColumnId != _undefined)
          'afterColumnId': (afterColumnId as String?),
      }));
}

class _CopyWithStubImpl$Input$MoveProjectColumnInput<TRes>
    implements CopyWith$Input$MoveProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$MoveProjectColumnInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? columnId,
    String? afterColumnId,
  }) =>
      _res;
}

class Input$OrganizationOrder {
  factory Input$OrganizationOrder({
    required Enum$OrganizationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$OrganizationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$OrganizationOrder._(this._$data);

  factory Input$OrganizationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$OrganizationOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$OrganizationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrganizationOrderField get field =>
      (_$data['field'] as Enum$OrganizationOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$OrganizationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$OrganizationOrder<Input$OrganizationOrder> get copyWith =>
      CopyWith$Input$OrganizationOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrganizationOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$OrganizationOrder<TRes> {
  factory CopyWith$Input$OrganizationOrder(
    Input$OrganizationOrder instance,
    TRes Function(Input$OrganizationOrder) then,
  ) = _CopyWithImpl$Input$OrganizationOrder;

  factory CopyWith$Input$OrganizationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$OrganizationOrder;

  TRes call({
    Enum$OrganizationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$OrganizationOrder<TRes>
    implements CopyWith$Input$OrganizationOrder<TRes> {
  _CopyWithImpl$Input$OrganizationOrder(
    this._instance,
    this._then,
  );

  final Input$OrganizationOrder _instance;

  final TRes Function(Input$OrganizationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$OrganizationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$OrganizationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$OrganizationOrder<TRes>
    implements CopyWith$Input$OrganizationOrder<TRes> {
  _CopyWithStubImpl$Input$OrganizationOrder(this._res);

  TRes _res;

  call({
    Enum$OrganizationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$OrgEnterpriseOwnerOrder {
  factory Input$OrgEnterpriseOwnerOrder({
    required Enum$OrgEnterpriseOwnerOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$OrgEnterpriseOwnerOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$OrgEnterpriseOwnerOrder._(this._$data);

  factory Input$OrgEnterpriseOwnerOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$OrgEnterpriseOwnerOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$OrgEnterpriseOwnerOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrgEnterpriseOwnerOrderField get field =>
      (_$data['field'] as Enum$OrgEnterpriseOwnerOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$OrgEnterpriseOwnerOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$OrgEnterpriseOwnerOrder<Input$OrgEnterpriseOwnerOrder>
      get copyWith => CopyWith$Input$OrgEnterpriseOwnerOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$OrgEnterpriseOwnerOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  factory CopyWith$Input$OrgEnterpriseOwnerOrder(
    Input$OrgEnterpriseOwnerOrder instance,
    TRes Function(Input$OrgEnterpriseOwnerOrder) then,
  ) = _CopyWithImpl$Input$OrgEnterpriseOwnerOrder;

  factory CopyWith$Input$OrgEnterpriseOwnerOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder;

  TRes call({
    Enum$OrgEnterpriseOwnerOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$OrgEnterpriseOwnerOrder<TRes>
    implements CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  _CopyWithImpl$Input$OrgEnterpriseOwnerOrder(
    this._instance,
    this._then,
  );

  final Input$OrgEnterpriseOwnerOrder _instance;

  final TRes Function(Input$OrgEnterpriseOwnerOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$OrgEnterpriseOwnerOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$OrgEnterpriseOwnerOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder<TRes>
    implements CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder(this._res);

  TRes _res;

  call({
    Enum$OrgEnterpriseOwnerOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PackageFileOrder {
  factory Input$PackageFileOrder({
    Enum$PackageFileOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$PackageFileOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$PackageFileOrder._(this._$data);

  factory Input$PackageFileOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageFileOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$PackageFileOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PackageFileOrderField? get field =>
      (_$data['field'] as Enum$PackageFileOrderField?);

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$PackageFileOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$PackageFileOrder<Input$PackageFileOrder> get copyWith =>
      CopyWith$Input$PackageFileOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageFileOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageFileOrder<TRes> {
  factory CopyWith$Input$PackageFileOrder(
    Input$PackageFileOrder instance,
    TRes Function(Input$PackageFileOrder) then,
  ) = _CopyWithImpl$Input$PackageFileOrder;

  factory CopyWith$Input$PackageFileOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageFileOrder;

  TRes call({
    Enum$PackageFileOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PackageFileOrder<TRes>
    implements CopyWith$Input$PackageFileOrder<TRes> {
  _CopyWithImpl$Input$PackageFileOrder(
    this._instance,
    this._then,
  );

  final Input$PackageFileOrder _instance;

  final TRes Function(Input$PackageFileOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PackageFileOrder._({
        ..._instance._$data,
        if (field != _undefined)
          'field': (field as Enum$PackageFileOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$PackageFileOrder<TRes>
    implements CopyWith$Input$PackageFileOrder<TRes> {
  _CopyWithStubImpl$Input$PackageFileOrder(this._res);

  TRes _res;

  call({
    Enum$PackageFileOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PackageOrder {
  factory Input$PackageOrder({
    Enum$PackageOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$PackageOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$PackageOrder._(this._$data);

  factory Input$PackageOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$PackageOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PackageOrderField? get field =>
      (_$data['field'] as Enum$PackageOrderField?);

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$PackageOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$PackageOrder<Input$PackageOrder> get copyWith =>
      CopyWith$Input$PackageOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrder<TRes> {
  factory CopyWith$Input$PackageOrder(
    Input$PackageOrder instance,
    TRes Function(Input$PackageOrder) then,
  ) = _CopyWithImpl$Input$PackageOrder;

  factory CopyWith$Input$PackageOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrder;

  TRes call({
    Enum$PackageOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PackageOrder<TRes>
    implements CopyWith$Input$PackageOrder<TRes> {
  _CopyWithImpl$Input$PackageOrder(
    this._instance,
    this._then,
  );

  final Input$PackageOrder _instance;

  final TRes Function(Input$PackageOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PackageOrder._({
        ..._instance._$data,
        if (field != _undefined) 'field': (field as Enum$PackageOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$PackageOrder<TRes>
    implements CopyWith$Input$PackageOrder<TRes> {
  _CopyWithStubImpl$Input$PackageOrder(this._res);

  TRes _res;

  call({
    Enum$PackageOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PackageVersionOrder {
  factory Input$PackageVersionOrder({
    Enum$PackageVersionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      Input$PackageVersionOrder._({
        if (field != null) r'field': field,
        if (direction != null) r'direction': direction,
      });

  Input$PackageVersionOrder._(this._$data);

  factory Input$PackageVersionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageVersionOrderField((l$field as String));
    }
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    return Input$PackageVersionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PackageVersionOrderField? get field =>
      (_$data['field'] as Enum$PackageVersionOrderField?);

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] = l$field == null
          ? null
          : toJson$Enum$PackageVersionOrderField(l$field);
    }
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    return result$data;
  }

  CopyWith$Input$PackageVersionOrder<Input$PackageVersionOrder> get copyWith =>
      CopyWith$Input$PackageVersionOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PackageVersionOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      _$data.containsKey('field') ? l$field : const {},
      _$data.containsKey('direction') ? l$direction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageVersionOrder<TRes> {
  factory CopyWith$Input$PackageVersionOrder(
    Input$PackageVersionOrder instance,
    TRes Function(Input$PackageVersionOrder) then,
  ) = _CopyWithImpl$Input$PackageVersionOrder;

  factory CopyWith$Input$PackageVersionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageVersionOrder;

  TRes call({
    Enum$PackageVersionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PackageVersionOrder<TRes>
    implements CopyWith$Input$PackageVersionOrder<TRes> {
  _CopyWithImpl$Input$PackageVersionOrder(
    this._instance,
    this._then,
  );

  final Input$PackageVersionOrder _instance;

  final TRes Function(Input$PackageVersionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PackageVersionOrder._({
        ..._instance._$data,
        if (field != _undefined)
          'field': (field as Enum$PackageVersionOrderField?),
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
      }));
}

class _CopyWithStubImpl$Input$PackageVersionOrder<TRes>
    implements CopyWith$Input$PackageVersionOrder<TRes> {
  _CopyWithStubImpl$Input$PackageVersionOrder(this._res);

  TRes _res;

  call({
    Enum$PackageVersionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PinEnvironmentInput {
  factory Input$PinEnvironmentInput({
    String? clientMutationId,
    required String environmentId,
    required bool pinned,
  }) =>
      Input$PinEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'environmentId': environmentId,
        r'pinned': pinned,
      });

  Input$PinEnvironmentInput._(this._$data);

  factory Input$PinEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$environmentId = data['environmentId'];
    result$data['environmentId'] = (l$environmentId as String);
    final l$pinned = data['pinned'];
    result$data['pinned'] = (l$pinned as bool);
    return Input$PinEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get environmentId => (_$data['environmentId'] as String);

  bool get pinned => (_$data['pinned'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$environmentId = environmentId;
    result$data['environmentId'] = l$environmentId;
    final l$pinned = pinned;
    result$data['pinned'] = l$pinned;
    return result$data;
  }

  CopyWith$Input$PinEnvironmentInput<Input$PinEnvironmentInput> get copyWith =>
      CopyWith$Input$PinEnvironmentInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PinEnvironmentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$environmentId = environmentId;
    final lOther$environmentId = other.environmentId;
    if (l$environmentId != lOther$environmentId) {
      return false;
    }
    final l$pinned = pinned;
    final lOther$pinned = other.pinned;
    if (l$pinned != lOther$pinned) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$environmentId = environmentId;
    final l$pinned = pinned;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$environmentId,
      l$pinned,
    ]);
  }
}

abstract class CopyWith$Input$PinEnvironmentInput<TRes> {
  factory CopyWith$Input$PinEnvironmentInput(
    Input$PinEnvironmentInput instance,
    TRes Function(Input$PinEnvironmentInput) then,
  ) = _CopyWithImpl$Input$PinEnvironmentInput;

  factory CopyWith$Input$PinEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PinEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? environmentId,
    bool? pinned,
  });
}

class _CopyWithImpl$Input$PinEnvironmentInput<TRes>
    implements CopyWith$Input$PinEnvironmentInput<TRes> {
  _CopyWithImpl$Input$PinEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$PinEnvironmentInput _instance;

  final TRes Function(Input$PinEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? environmentId = _undefined,
    Object? pinned = _undefined,
  }) =>
      _then(Input$PinEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (environmentId != _undefined && environmentId != null)
          'environmentId': (environmentId as String),
        if (pinned != _undefined && pinned != null) 'pinned': (pinned as bool),
      }));
}

class _CopyWithStubImpl$Input$PinEnvironmentInput<TRes>
    implements CopyWith$Input$PinEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$PinEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? environmentId,
    bool? pinned,
  }) =>
      _res;
}

class Input$PinIssueInput {
  factory Input$PinIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$PinIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$PinIssueInput._(this._$data);

  factory Input$PinIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$PinIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$PinIssueInput<Input$PinIssueInput> get copyWith =>
      CopyWith$Input$PinIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PinIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$PinIssueInput<TRes> {
  factory CopyWith$Input$PinIssueInput(
    Input$PinIssueInput instance,
    TRes Function(Input$PinIssueInput) then,
  ) = _CopyWithImpl$Input$PinIssueInput;

  factory CopyWith$Input$PinIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PinIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$PinIssueInput<TRes>
    implements CopyWith$Input$PinIssueInput<TRes> {
  _CopyWithImpl$Input$PinIssueInput(
    this._instance,
    this._then,
  );

  final Input$PinIssueInput _instance;

  final TRes Function(Input$PinIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$PinIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$PinIssueInput<TRes>
    implements CopyWith$Input$PinIssueInput<TRes> {
  _CopyWithStubImpl$Input$PinIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$PinnedEnvironmentOrder {
  factory Input$PinnedEnvironmentOrder({
    required Enum$PinnedEnvironmentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$PinnedEnvironmentOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$PinnedEnvironmentOrder._(this._$data);

  factory Input$PinnedEnvironmentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$PinnedEnvironmentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$PinnedEnvironmentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PinnedEnvironmentOrderField get field =>
      (_$data['field'] as Enum$PinnedEnvironmentOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$PinnedEnvironmentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$PinnedEnvironmentOrder<Input$PinnedEnvironmentOrder>
      get copyWith => CopyWith$Input$PinnedEnvironmentOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PinnedEnvironmentOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$PinnedEnvironmentOrder<TRes> {
  factory CopyWith$Input$PinnedEnvironmentOrder(
    Input$PinnedEnvironmentOrder instance,
    TRes Function(Input$PinnedEnvironmentOrder) then,
  ) = _CopyWithImpl$Input$PinnedEnvironmentOrder;

  factory CopyWith$Input$PinnedEnvironmentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PinnedEnvironmentOrder;

  TRes call({
    Enum$PinnedEnvironmentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PinnedEnvironmentOrder<TRes>
    implements CopyWith$Input$PinnedEnvironmentOrder<TRes> {
  _CopyWithImpl$Input$PinnedEnvironmentOrder(
    this._instance,
    this._then,
  );

  final Input$PinnedEnvironmentOrder _instance;

  final TRes Function(Input$PinnedEnvironmentOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PinnedEnvironmentOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$PinnedEnvironmentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$PinnedEnvironmentOrder<TRes>
    implements CopyWith$Input$PinnedEnvironmentOrder<TRes> {
  _CopyWithStubImpl$Input$PinnedEnvironmentOrder(this._res);

  TRes _res;

  call({
    Enum$PinnedEnvironmentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectCardImport {
  factory Input$ProjectCardImport({
    required String repository,
    required int number,
  }) =>
      Input$ProjectCardImport._({
        r'repository': repository,
        r'number': number,
      });

  Input$ProjectCardImport._(this._$data);

  factory Input$ProjectCardImport.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repository = data['repository'];
    result$data['repository'] = (l$repository as String);
    final l$number = data['number'];
    result$data['number'] = (l$number as int);
    return Input$ProjectCardImport._(result$data);
  }

  Map<String, dynamic> _$data;

  String get repository => (_$data['repository'] as String);

  int get number => (_$data['number'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repository = repository;
    result$data['repository'] = l$repository;
    final l$number = number;
    result$data['number'] = l$number;
    return result$data;
  }

  CopyWith$Input$ProjectCardImport<Input$ProjectCardImport> get copyWith =>
      CopyWith$Input$ProjectCardImport(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectCardImport || runtimeType != other.runtimeType) {
      return false;
    }
    final l$repository = repository;
    final lOther$repository = other.repository;
    if (l$repository != lOther$repository) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repository = repository;
    final l$number = number;
    return Object.hashAll([
      l$repository,
      l$number,
    ]);
  }
}

abstract class CopyWith$Input$ProjectCardImport<TRes> {
  factory CopyWith$Input$ProjectCardImport(
    Input$ProjectCardImport instance,
    TRes Function(Input$ProjectCardImport) then,
  ) = _CopyWithImpl$Input$ProjectCardImport;

  factory CopyWith$Input$ProjectCardImport.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectCardImport;

  TRes call({
    String? repository,
    int? number,
  });
}

class _CopyWithImpl$Input$ProjectCardImport<TRes>
    implements CopyWith$Input$ProjectCardImport<TRes> {
  _CopyWithImpl$Input$ProjectCardImport(
    this._instance,
    this._then,
  );

  final Input$ProjectCardImport _instance;

  final TRes Function(Input$ProjectCardImport) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? repository = _undefined,
    Object? number = _undefined,
  }) =>
      _then(Input$ProjectCardImport._({
        ..._instance._$data,
        if (repository != _undefined && repository != null)
          'repository': (repository as String),
        if (number != _undefined && number != null) 'number': (number as int),
      }));
}

class _CopyWithStubImpl$Input$ProjectCardImport<TRes>
    implements CopyWith$Input$ProjectCardImport<TRes> {
  _CopyWithStubImpl$Input$ProjectCardImport(this._res);

  TRes _res;

  call({
    String? repository,
    int? number,
  }) =>
      _res;
}

class Input$ProjectColumnImport {
  factory Input$ProjectColumnImport({
    required String columnName,
    required int position,
    List<Input$ProjectCardImport>? issues,
  }) =>
      Input$ProjectColumnImport._({
        r'columnName': columnName,
        r'position': position,
        if (issues != null) r'issues': issues,
      });

  Input$ProjectColumnImport._(this._$data);

  factory Input$ProjectColumnImport.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$columnName = data['columnName'];
    result$data['columnName'] = (l$columnName as String);
    final l$position = data['position'];
    result$data['position'] = (l$position as int);
    if (data.containsKey('issues')) {
      final l$issues = data['issues'];
      result$data['issues'] = (l$issues as List<dynamic>?)
          ?.map((e) =>
              Input$ProjectCardImport.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProjectColumnImport._(result$data);
  }

  Map<String, dynamic> _$data;

  String get columnName => (_$data['columnName'] as String);

  int get position => (_$data['position'] as int);

  List<Input$ProjectCardImport>? get issues =>
      (_$data['issues'] as List<Input$ProjectCardImport>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$columnName = columnName;
    result$data['columnName'] = l$columnName;
    final l$position = position;
    result$data['position'] = l$position;
    if (_$data.containsKey('issues')) {
      final l$issues = issues;
      result$data['issues'] = l$issues?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProjectColumnImport<Input$ProjectColumnImport> get copyWith =>
      CopyWith$Input$ProjectColumnImport(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectColumnImport ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$columnName = columnName;
    final lOther$columnName = other.columnName;
    if (l$columnName != lOther$columnName) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    final l$issues = issues;
    final lOther$issues = other.issues;
    if (_$data.containsKey('issues') != other._$data.containsKey('issues')) {
      return false;
    }
    if (l$issues != null && lOther$issues != null) {
      if (l$issues.length != lOther$issues.length) {
        return false;
      }
      for (int i = 0; i < l$issues.length; i++) {
        final l$issues$entry = l$issues[i];
        final lOther$issues$entry = lOther$issues[i];
        if (l$issues$entry != lOther$issues$entry) {
          return false;
        }
      }
    } else if (l$issues != lOther$issues) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$columnName = columnName;
    final l$position = position;
    final l$issues = issues;
    return Object.hashAll([
      l$columnName,
      l$position,
      _$data.containsKey('issues')
          ? l$issues == null
              ? null
              : Object.hashAll(l$issues.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProjectColumnImport<TRes> {
  factory CopyWith$Input$ProjectColumnImport(
    Input$ProjectColumnImport instance,
    TRes Function(Input$ProjectColumnImport) then,
  ) = _CopyWithImpl$Input$ProjectColumnImport;

  factory CopyWith$Input$ProjectColumnImport.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectColumnImport;

  TRes call({
    String? columnName,
    int? position,
    List<Input$ProjectCardImport>? issues,
  });
  TRes issues(
      Iterable<Input$ProjectCardImport>? Function(
              Iterable<
                  CopyWith$Input$ProjectCardImport<Input$ProjectCardImport>>?)
          _fn);
}

class _CopyWithImpl$Input$ProjectColumnImport<TRes>
    implements CopyWith$Input$ProjectColumnImport<TRes> {
  _CopyWithImpl$Input$ProjectColumnImport(
    this._instance,
    this._then,
  );

  final Input$ProjectColumnImport _instance;

  final TRes Function(Input$ProjectColumnImport) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? columnName = _undefined,
    Object? position = _undefined,
    Object? issues = _undefined,
  }) =>
      _then(Input$ProjectColumnImport._({
        ..._instance._$data,
        if (columnName != _undefined && columnName != null)
          'columnName': (columnName as String),
        if (position != _undefined && position != null)
          'position': (position as int),
        if (issues != _undefined)
          'issues': (issues as List<Input$ProjectCardImport>?),
      }));

  TRes issues(
          Iterable<Input$ProjectCardImport>? Function(
                  Iterable<
                      CopyWith$Input$ProjectCardImport<
                          Input$ProjectCardImport>>?)
              _fn) =>
      call(
          issues:
              _fn(_instance.issues?.map((e) => CopyWith$Input$ProjectCardImport(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProjectColumnImport<TRes>
    implements CopyWith$Input$ProjectColumnImport<TRes> {
  _CopyWithStubImpl$Input$ProjectColumnImport(this._res);

  TRes _res;

  call({
    String? columnName,
    int? position,
    List<Input$ProjectCardImport>? issues,
  }) =>
      _res;

  issues(_fn) => _res;
}

class Input$ProjectOrder {
  factory Input$ProjectOrder({
    required Enum$ProjectOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectOrder._(this._$data);

  factory Input$ProjectOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$ProjectOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectOrderField get field =>
      (_$data['field'] as Enum$ProjectOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectOrder<Input$ProjectOrder> get copyWith =>
      CopyWith$Input$ProjectOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectOrder<TRes> {
  factory CopyWith$Input$ProjectOrder(
    Input$ProjectOrder instance,
    TRes Function(Input$ProjectOrder) then,
  ) = _CopyWithImpl$Input$ProjectOrder;

  factory CopyWith$Input$ProjectOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectOrder;

  TRes call({
    Enum$ProjectOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectOrder<TRes>
    implements CopyWith$Input$ProjectOrder<TRes> {
  _CopyWithImpl$Input$ProjectOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectOrder _instance;

  final TRes Function(Input$ProjectOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectOrder<TRes>
    implements CopyWith$Input$ProjectOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2Collaborator {
  factory Input$ProjectV2Collaborator({
    String? userId,
    String? teamId,
    required Enum$ProjectV2Roles role,
  }) =>
      Input$ProjectV2Collaborator._({
        if (userId != null) r'userId': userId,
        if (teamId != null) r'teamId': teamId,
        r'role': role,
      });

  Input$ProjectV2Collaborator._(this._$data);

  factory Input$ProjectV2Collaborator.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$ProjectV2Roles((l$role as String));
    return Input$ProjectV2Collaborator._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get userId => (_$data['userId'] as String?);

  String? get teamId => (_$data['teamId'] as String?);

  Enum$ProjectV2Roles get role => (_$data['role'] as Enum$ProjectV2Roles);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$ProjectV2Roles(l$role);
    return result$data;
  }

  CopyWith$Input$ProjectV2Collaborator<Input$ProjectV2Collaborator>
      get copyWith => CopyWith$Input$ProjectV2Collaborator(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2Collaborator ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$teamId = teamId;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
      l$role,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2Collaborator<TRes> {
  factory CopyWith$Input$ProjectV2Collaborator(
    Input$ProjectV2Collaborator instance,
    TRes Function(Input$ProjectV2Collaborator) then,
  ) = _CopyWithImpl$Input$ProjectV2Collaborator;

  factory CopyWith$Input$ProjectV2Collaborator.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Collaborator;

  TRes call({
    String? userId,
    String? teamId,
    Enum$ProjectV2Roles? role,
  });
}

class _CopyWithImpl$Input$ProjectV2Collaborator<TRes>
    implements CopyWith$Input$ProjectV2Collaborator<TRes> {
  _CopyWithImpl$Input$ProjectV2Collaborator(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Collaborator _instance;

  final TRes Function(Input$ProjectV2Collaborator) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? teamId = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$ProjectV2Collaborator._({
        ..._instance._$data,
        if (userId != _undefined) 'userId': (userId as String?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
        if (role != _undefined && role != null)
          'role': (role as Enum$ProjectV2Roles),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Collaborator<TRes>
    implements CopyWith$Input$ProjectV2Collaborator<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Collaborator(this._res);

  TRes _res;

  call({
    String? userId,
    String? teamId,
    Enum$ProjectV2Roles? role,
  }) =>
      _res;
}

class Input$ProjectV2FieldOrder {
  factory Input$ProjectV2FieldOrder({
    required Enum$ProjectV2FieldOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2FieldOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2FieldOrder._(this._$data);

  factory Input$ProjectV2FieldOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2FieldOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2FieldOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2FieldOrderField get field =>
      (_$data['field'] as Enum$ProjectV2FieldOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2FieldOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2FieldOrder<Input$ProjectV2FieldOrder> get copyWith =>
      CopyWith$Input$ProjectV2FieldOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2FieldOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2FieldOrder<TRes> {
  factory CopyWith$Input$ProjectV2FieldOrder(
    Input$ProjectV2FieldOrder instance,
    TRes Function(Input$ProjectV2FieldOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2FieldOrder;

  factory CopyWith$Input$ProjectV2FieldOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2FieldOrder;

  TRes call({
    Enum$ProjectV2FieldOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2FieldOrder<TRes>
    implements CopyWith$Input$ProjectV2FieldOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2FieldOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2FieldOrder _instance;

  final TRes Function(Input$ProjectV2FieldOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2FieldOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2FieldOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2FieldOrder<TRes>
    implements CopyWith$Input$ProjectV2FieldOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2FieldOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2FieldOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2FieldValue {
  factory Input$ProjectV2FieldValue({
    String? text,
    double? number,
    String? date,
    String? singleSelectOptionId,
    String? iterationId,
  }) =>
      Input$ProjectV2FieldValue._({
        if (text != null) r'text': text,
        if (number != null) r'number': number,
        if (date != null) r'date': date,
        if (singleSelectOptionId != null)
          r'singleSelectOptionId': singleSelectOptionId,
        if (iterationId != null) r'iterationId': iterationId,
      });

  Input$ProjectV2FieldValue._(this._$data);

  factory Input$ProjectV2FieldValue.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = (l$text as String?);
    }
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = (l$number as num?)?.toDouble();
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = (l$date as String?);
    }
    if (data.containsKey('singleSelectOptionId')) {
      final l$singleSelectOptionId = data['singleSelectOptionId'];
      result$data['singleSelectOptionId'] = (l$singleSelectOptionId as String?);
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    return Input$ProjectV2FieldValue._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get text => (_$data['text'] as String?);

  double? get number => (_$data['number'] as double?);

  String? get date => (_$data['date'] as String?);

  String? get singleSelectOptionId =>
      (_$data['singleSelectOptionId'] as String?);

  String? get iterationId => (_$data['iterationId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text;
    }
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number;
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date;
    }
    if (_$data.containsKey('singleSelectOptionId')) {
      final l$singleSelectOptionId = singleSelectOptionId;
      result$data['singleSelectOptionId'] = l$singleSelectOptionId;
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    return result$data;
  }

  CopyWith$Input$ProjectV2FieldValue<Input$ProjectV2FieldValue> get copyWith =>
      CopyWith$Input$ProjectV2FieldValue(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2FieldValue ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$singleSelectOptionId = singleSelectOptionId;
    final lOther$singleSelectOptionId = other.singleSelectOptionId;
    if (_$data.containsKey('singleSelectOptionId') !=
        other._$data.containsKey('singleSelectOptionId')) {
      return false;
    }
    if (l$singleSelectOptionId != lOther$singleSelectOptionId) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$text = text;
    final l$number = number;
    final l$date = date;
    final l$singleSelectOptionId = singleSelectOptionId;
    final l$iterationId = iterationId;
    return Object.hashAll([
      _$data.containsKey('text') ? l$text : const {},
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('singleSelectOptionId')
          ? l$singleSelectOptionId
          : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2FieldValue<TRes> {
  factory CopyWith$Input$ProjectV2FieldValue(
    Input$ProjectV2FieldValue instance,
    TRes Function(Input$ProjectV2FieldValue) then,
  ) = _CopyWithImpl$Input$ProjectV2FieldValue;

  factory CopyWith$Input$ProjectV2FieldValue.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2FieldValue;

  TRes call({
    String? text,
    double? number,
    String? date,
    String? singleSelectOptionId,
    String? iterationId,
  });
}

class _CopyWithImpl$Input$ProjectV2FieldValue<TRes>
    implements CopyWith$Input$ProjectV2FieldValue<TRes> {
  _CopyWithImpl$Input$ProjectV2FieldValue(
    this._instance,
    this._then,
  );

  final Input$ProjectV2FieldValue _instance;

  final TRes Function(Input$ProjectV2FieldValue) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? text = _undefined,
    Object? number = _undefined,
    Object? date = _undefined,
    Object? singleSelectOptionId = _undefined,
    Object? iterationId = _undefined,
  }) =>
      _then(Input$ProjectV2FieldValue._({
        ..._instance._$data,
        if (text != _undefined) 'text': (text as String?),
        if (number != _undefined) 'number': (number as double?),
        if (date != _undefined) 'date': (date as String?),
        if (singleSelectOptionId != _undefined)
          'singleSelectOptionId': (singleSelectOptionId as String?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2FieldValue<TRes>
    implements CopyWith$Input$ProjectV2FieldValue<TRes> {
  _CopyWithStubImpl$Input$ProjectV2FieldValue(this._res);

  TRes _res;

  call({
    String? text,
    double? number,
    String? date,
    String? singleSelectOptionId,
    String? iterationId,
  }) =>
      _res;
}

class Input$ProjectV2Filters {
  factory Input$ProjectV2Filters({Enum$ProjectV2State? state}) =>
      Input$ProjectV2Filters._({
        if (state != null) r'state': state,
      });

  Input$ProjectV2Filters._(this._$data);

  factory Input$ProjectV2Filters.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$ProjectV2State((l$state as String));
    }
    return Input$ProjectV2Filters._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2State? get state => (_$data['state'] as Enum$ProjectV2State?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$ProjectV2State(l$state);
    }
    return result$data;
  }

  CopyWith$Input$ProjectV2Filters<Input$ProjectV2Filters> get copyWith =>
      CopyWith$Input$ProjectV2Filters(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2Filters || runtimeType != other.runtimeType) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$state = state;
    return Object.hashAll([_$data.containsKey('state') ? l$state : const {}]);
  }
}

abstract class CopyWith$Input$ProjectV2Filters<TRes> {
  factory CopyWith$Input$ProjectV2Filters(
    Input$ProjectV2Filters instance,
    TRes Function(Input$ProjectV2Filters) then,
  ) = _CopyWithImpl$Input$ProjectV2Filters;

  factory CopyWith$Input$ProjectV2Filters.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Filters;

  TRes call({Enum$ProjectV2State? state});
}

class _CopyWithImpl$Input$ProjectV2Filters<TRes>
    implements CopyWith$Input$ProjectV2Filters<TRes> {
  _CopyWithImpl$Input$ProjectV2Filters(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Filters _instance;

  final TRes Function(Input$ProjectV2Filters) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? state = _undefined}) => _then(Input$ProjectV2Filters._({
        ..._instance._$data,
        if (state != _undefined) 'state': (state as Enum$ProjectV2State?),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Filters<TRes>
    implements CopyWith$Input$ProjectV2Filters<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Filters(this._res);

  TRes _res;

  call({Enum$ProjectV2State? state}) => _res;
}

class Input$ProjectV2ItemFieldValueOrder {
  factory Input$ProjectV2ItemFieldValueOrder({
    required Enum$ProjectV2ItemFieldValueOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2ItemFieldValueOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2ItemFieldValueOrder._(this._$data);

  factory Input$ProjectV2ItemFieldValueOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ItemFieldValueOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2ItemFieldValueOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2ItemFieldValueOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ItemFieldValueOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$ProjectV2ItemFieldValueOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2ItemFieldValueOrder<
          Input$ProjectV2ItemFieldValueOrder>
      get copyWith => CopyWith$Input$ProjectV2ItemFieldValueOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2ItemFieldValueOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  factory CopyWith$Input$ProjectV2ItemFieldValueOrder(
    Input$ProjectV2ItemFieldValueOrder instance,
    TRes Function(Input$ProjectV2ItemFieldValueOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder;

  factory CopyWith$Input$ProjectV2ItemFieldValueOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder;

  TRes call({
    Enum$ProjectV2ItemFieldValueOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ItemFieldValueOrder _instance;

  final TRes Function(Input$ProjectV2ItemFieldValueOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2ItemFieldValueOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ItemFieldValueOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2ItemFieldValueOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2ItemOrder {
  factory Input$ProjectV2ItemOrder({
    required Enum$ProjectV2ItemOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2ItemOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2ItemOrder._(this._$data);

  factory Input$ProjectV2ItemOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ItemOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2ItemOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2ItemOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ItemOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2ItemOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2ItemOrder<Input$ProjectV2ItemOrder> get copyWith =>
      CopyWith$Input$ProjectV2ItemOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2ItemOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ItemOrder<TRes> {
  factory CopyWith$Input$ProjectV2ItemOrder(
    Input$ProjectV2ItemOrder instance,
    TRes Function(Input$ProjectV2ItemOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ItemOrder;

  factory CopyWith$Input$ProjectV2ItemOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ItemOrder;

  TRes call({
    Enum$ProjectV2ItemOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2ItemOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ItemOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ItemOrder _instance;

  final TRes Function(Input$ProjectV2ItemOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2ItemOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ItemOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ItemOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ItemOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2ItemOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2Iteration {
  factory Input$ProjectV2Iteration({
    required String startDate,
    required int duration,
    required String title,
  }) =>
      Input$ProjectV2Iteration._({
        r'startDate': startDate,
        r'duration': duration,
        r'title': title,
      });

  Input$ProjectV2Iteration._(this._$data);

  factory Input$ProjectV2Iteration.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$startDate = data['startDate'];
    result$data['startDate'] = (l$startDate as String);
    final l$duration = data['duration'];
    result$data['duration'] = (l$duration as int);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$ProjectV2Iteration._(result$data);
  }

  Map<String, dynamic> _$data;

  String get startDate => (_$data['startDate'] as String);

  int get duration => (_$data['duration'] as int);

  String get title => (_$data['title'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$startDate = startDate;
    result$data['startDate'] = l$startDate;
    final l$duration = duration;
    result$data['duration'] = l$duration;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$ProjectV2Iteration<Input$ProjectV2Iteration> get copyWith =>
      CopyWith$Input$ProjectV2Iteration(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2Iteration ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$startDate = startDate;
    final l$duration = duration;
    final l$title = title;
    return Object.hashAll([
      l$startDate,
      l$duration,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2Iteration<TRes> {
  factory CopyWith$Input$ProjectV2Iteration(
    Input$ProjectV2Iteration instance,
    TRes Function(Input$ProjectV2Iteration) then,
  ) = _CopyWithImpl$Input$ProjectV2Iteration;

  factory CopyWith$Input$ProjectV2Iteration.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Iteration;

  TRes call({
    String? startDate,
    int? duration,
    String? title,
  });
}

class _CopyWithImpl$Input$ProjectV2Iteration<TRes>
    implements CopyWith$Input$ProjectV2Iteration<TRes> {
  _CopyWithImpl$Input$ProjectV2Iteration(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Iteration _instance;

  final TRes Function(Input$ProjectV2Iteration) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? startDate = _undefined,
    Object? duration = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$ProjectV2Iteration._({
        ..._instance._$data,
        if (startDate != _undefined && startDate != null)
          'startDate': (startDate as String),
        if (duration != _undefined && duration != null)
          'duration': (duration as int),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Iteration<TRes>
    implements CopyWith$Input$ProjectV2Iteration<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Iteration(this._res);

  TRes _res;

  call({
    String? startDate,
    int? duration,
    String? title,
  }) =>
      _res;
}

class Input$ProjectV2IterationFieldConfigurationInput {
  factory Input$ProjectV2IterationFieldConfigurationInput({
    required String startDate,
    required int duration,
    required List<Input$ProjectV2Iteration> iterations,
  }) =>
      Input$ProjectV2IterationFieldConfigurationInput._({
        r'startDate': startDate,
        r'duration': duration,
        r'iterations': iterations,
      });

  Input$ProjectV2IterationFieldConfigurationInput._(this._$data);

  factory Input$ProjectV2IterationFieldConfigurationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$startDate = data['startDate'];
    result$data['startDate'] = (l$startDate as String);
    final l$duration = data['duration'];
    result$data['duration'] = (l$duration as int);
    final l$iterations = data['iterations'];
    result$data['iterations'] = (l$iterations as List<dynamic>)
        .map((e) =>
            Input$ProjectV2Iteration.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$ProjectV2IterationFieldConfigurationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get startDate => (_$data['startDate'] as String);

  int get duration => (_$data['duration'] as int);

  List<Input$ProjectV2Iteration> get iterations =>
      (_$data['iterations'] as List<Input$ProjectV2Iteration>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$startDate = startDate;
    result$data['startDate'] = l$startDate;
    final l$duration = duration;
    result$data['duration'] = l$duration;
    final l$iterations = iterations;
    result$data['iterations'] = l$iterations.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$ProjectV2IterationFieldConfigurationInput<
          Input$ProjectV2IterationFieldConfigurationInput>
      get copyWith => CopyWith$Input$ProjectV2IterationFieldConfigurationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2IterationFieldConfigurationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$duration = duration;
    final lOther$duration = other.duration;
    if (l$duration != lOther$duration) {
      return false;
    }
    final l$iterations = iterations;
    final lOther$iterations = other.iterations;
    if (l$iterations.length != lOther$iterations.length) {
      return false;
    }
    for (int i = 0; i < l$iterations.length; i++) {
      final l$iterations$entry = l$iterations[i];
      final lOther$iterations$entry = lOther$iterations[i];
      if (l$iterations$entry != lOther$iterations$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$startDate = startDate;
    final l$duration = duration;
    final l$iterations = iterations;
    return Object.hashAll([
      l$startDate,
      l$duration,
      Object.hashAll(l$iterations.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes> {
  factory CopyWith$Input$ProjectV2IterationFieldConfigurationInput(
    Input$ProjectV2IterationFieldConfigurationInput instance,
    TRes Function(Input$ProjectV2IterationFieldConfigurationInput) then,
  ) = _CopyWithImpl$Input$ProjectV2IterationFieldConfigurationInput;

  factory CopyWith$Input$ProjectV2IterationFieldConfigurationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProjectV2IterationFieldConfigurationInput;

  TRes call({
    String? startDate,
    int? duration,
    List<Input$ProjectV2Iteration>? iterations,
  });
  TRes iterations(
      Iterable<Input$ProjectV2Iteration> Function(
              Iterable<
                  CopyWith$Input$ProjectV2Iteration<Input$ProjectV2Iteration>>)
          _fn);
}

class _CopyWithImpl$Input$ProjectV2IterationFieldConfigurationInput<TRes>
    implements CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes> {
  _CopyWithImpl$Input$ProjectV2IterationFieldConfigurationInput(
    this._instance,
    this._then,
  );

  final Input$ProjectV2IterationFieldConfigurationInput _instance;

  final TRes Function(Input$ProjectV2IterationFieldConfigurationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? startDate = _undefined,
    Object? duration = _undefined,
    Object? iterations = _undefined,
  }) =>
      _then(Input$ProjectV2IterationFieldConfigurationInput._({
        ..._instance._$data,
        if (startDate != _undefined && startDate != null)
          'startDate': (startDate as String),
        if (duration != _undefined && duration != null)
          'duration': (duration as int),
        if (iterations != _undefined && iterations != null)
          'iterations': (iterations as List<Input$ProjectV2Iteration>),
      }));

  TRes iterations(
          Iterable<Input$ProjectV2Iteration> Function(
                  Iterable<
                      CopyWith$Input$ProjectV2Iteration<
                          Input$ProjectV2Iteration>>)
              _fn) =>
      call(
          iterations: _fn(
              _instance.iterations.map((e) => CopyWith$Input$ProjectV2Iteration(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$ProjectV2IterationFieldConfigurationInput<TRes>
    implements CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes> {
  _CopyWithStubImpl$Input$ProjectV2IterationFieldConfigurationInput(this._res);

  TRes _res;

  call({
    String? startDate,
    int? duration,
    List<Input$ProjectV2Iteration>? iterations,
  }) =>
      _res;

  iterations(_fn) => _res;
}

class Input$ProjectV2Order {
  factory Input$ProjectV2Order({
    required Enum$ProjectV2OrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2Order._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2Order._(this._$data);

  factory Input$ProjectV2Order.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2OrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2Order._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2OrderField get field =>
      (_$data['field'] as Enum$ProjectV2OrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2OrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2Order<Input$ProjectV2Order> get copyWith =>
      CopyWith$Input$ProjectV2Order(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2Order || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2Order<TRes> {
  factory CopyWith$Input$ProjectV2Order(
    Input$ProjectV2Order instance,
    TRes Function(Input$ProjectV2Order) then,
  ) = _CopyWithImpl$Input$ProjectV2Order;

  factory CopyWith$Input$ProjectV2Order.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Order;

  TRes call({
    Enum$ProjectV2OrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2Order<TRes>
    implements CopyWith$Input$ProjectV2Order<TRes> {
  _CopyWithImpl$Input$ProjectV2Order(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Order _instance;

  final TRes Function(Input$ProjectV2Order) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2Order._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2OrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Order<TRes>
    implements CopyWith$Input$ProjectV2Order<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Order(this._res);

  TRes _res;

  call({
    Enum$ProjectV2OrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2SingleSelectFieldOptionInput {
  factory Input$ProjectV2SingleSelectFieldOptionInput({
    required String name,
    required Enum$ProjectV2SingleSelectFieldOptionColor color,
    required String description,
  }) =>
      Input$ProjectV2SingleSelectFieldOptionInput._({
        r'name': name,
        r'color': color,
        r'description': description,
      });

  Input$ProjectV2SingleSelectFieldOptionInput._(this._$data);

  factory Input$ProjectV2SingleSelectFieldOptionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$color = data['color'];
    result$data['color'] = fromJson$Enum$ProjectV2SingleSelectFieldOptionColor(
        (l$color as String));
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    return Input$ProjectV2SingleSelectFieldOptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  Enum$ProjectV2SingleSelectFieldOptionColor get color =>
      (_$data['color'] as Enum$ProjectV2SingleSelectFieldOptionColor);

  String get description => (_$data['description'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$color = color;
    result$data['color'] =
        toJson$Enum$ProjectV2SingleSelectFieldOptionColor(l$color);
    final l$description = description;
    result$data['description'] = l$description;
    return result$data;
  }

  CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
          Input$ProjectV2SingleSelectFieldOptionInput>
      get copyWith => CopyWith$Input$ProjectV2SingleSelectFieldOptionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2SingleSelectFieldOptionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$color = color;
    final l$description = description;
    return Object.hashAll([
      l$name,
      l$color,
      l$description,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<TRes> {
  factory CopyWith$Input$ProjectV2SingleSelectFieldOptionInput(
    Input$ProjectV2SingleSelectFieldOptionInput instance,
    TRes Function(Input$ProjectV2SingleSelectFieldOptionInput) then,
  ) = _CopyWithImpl$Input$ProjectV2SingleSelectFieldOptionInput;

  factory CopyWith$Input$ProjectV2SingleSelectFieldOptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2SingleSelectFieldOptionInput;

  TRes call({
    String? name,
    Enum$ProjectV2SingleSelectFieldOptionColor? color,
    String? description,
  });
}

class _CopyWithImpl$Input$ProjectV2SingleSelectFieldOptionInput<TRes>
    implements CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<TRes> {
  _CopyWithImpl$Input$ProjectV2SingleSelectFieldOptionInput(
    this._instance,
    this._then,
  );

  final Input$ProjectV2SingleSelectFieldOptionInput _instance;

  final TRes Function(Input$ProjectV2SingleSelectFieldOptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? color = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$ProjectV2SingleSelectFieldOptionInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (color != _undefined && color != null)
          'color': (color as Enum$ProjectV2SingleSelectFieldOptionColor),
        if (description != _undefined && description != null)
          'description': (description as String),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2SingleSelectFieldOptionInput<TRes>
    implements CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<TRes> {
  _CopyWithStubImpl$Input$ProjectV2SingleSelectFieldOptionInput(this._res);

  TRes _res;

  call({
    String? name,
    Enum$ProjectV2SingleSelectFieldOptionColor? color,
    String? description,
  }) =>
      _res;
}

class Input$ProjectV2StatusOrder {
  factory Input$ProjectV2StatusOrder({
    required Enum$ProjectV2StatusUpdateOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2StatusOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2StatusOrder._(this._$data);

  factory Input$ProjectV2StatusOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2StatusUpdateOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2StatusOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2StatusUpdateOrderField get field =>
      (_$data['field'] as Enum$ProjectV2StatusUpdateOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2StatusUpdateOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2StatusOrder<Input$ProjectV2StatusOrder>
      get copyWith => CopyWith$Input$ProjectV2StatusOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2StatusOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2StatusOrder<TRes> {
  factory CopyWith$Input$ProjectV2StatusOrder(
    Input$ProjectV2StatusOrder instance,
    TRes Function(Input$ProjectV2StatusOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2StatusOrder;

  factory CopyWith$Input$ProjectV2StatusOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2StatusOrder;

  TRes call({
    Enum$ProjectV2StatusUpdateOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2StatusOrder<TRes>
    implements CopyWith$Input$ProjectV2StatusOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2StatusOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2StatusOrder _instance;

  final TRes Function(Input$ProjectV2StatusOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2StatusOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2StatusUpdateOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2StatusOrder<TRes>
    implements CopyWith$Input$ProjectV2StatusOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2StatusOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2StatusUpdateOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2ViewOrder {
  factory Input$ProjectV2ViewOrder({
    required Enum$ProjectV2ViewOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2ViewOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2ViewOrder._(this._$data);

  factory Input$ProjectV2ViewOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ViewOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2ViewOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2ViewOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ViewOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2ViewOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2ViewOrder<Input$ProjectV2ViewOrder> get copyWith =>
      CopyWith$Input$ProjectV2ViewOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2ViewOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ViewOrder<TRes> {
  factory CopyWith$Input$ProjectV2ViewOrder(
    Input$ProjectV2ViewOrder instance,
    TRes Function(Input$ProjectV2ViewOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ViewOrder;

  factory CopyWith$Input$ProjectV2ViewOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ViewOrder;

  TRes call({
    Enum$ProjectV2ViewOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2ViewOrder<TRes>
    implements CopyWith$Input$ProjectV2ViewOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ViewOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ViewOrder _instance;

  final TRes Function(Input$ProjectV2ViewOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2ViewOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ViewOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ViewOrder<TRes>
    implements CopyWith$Input$ProjectV2ViewOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ViewOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2ViewOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$ProjectV2WorkflowOrder {
  factory Input$ProjectV2WorkflowOrder({
    required Enum$ProjectV2WorkflowsOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ProjectV2WorkflowOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ProjectV2WorkflowOrder._(this._$data);

  factory Input$ProjectV2WorkflowOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2WorkflowsOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ProjectV2WorkflowOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2WorkflowsOrderField get field =>
      (_$data['field'] as Enum$ProjectV2WorkflowsOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2WorkflowsOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ProjectV2WorkflowOrder<Input$ProjectV2WorkflowOrder>
      get copyWith => CopyWith$Input$ProjectV2WorkflowOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ProjectV2WorkflowOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2WorkflowOrder<TRes> {
  factory CopyWith$Input$ProjectV2WorkflowOrder(
    Input$ProjectV2WorkflowOrder instance,
    TRes Function(Input$ProjectV2WorkflowOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2WorkflowOrder;

  factory CopyWith$Input$ProjectV2WorkflowOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2WorkflowOrder;

  TRes call({
    Enum$ProjectV2WorkflowsOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ProjectV2WorkflowOrder<TRes>
    implements CopyWith$Input$ProjectV2WorkflowOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2WorkflowOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2WorkflowOrder _instance;

  final TRes Function(Input$ProjectV2WorkflowOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ProjectV2WorkflowOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2WorkflowsOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2WorkflowOrder<TRes>
    implements CopyWith$Input$ProjectV2WorkflowOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2WorkflowOrder(this._res);

  TRes _res;

  call({
    Enum$ProjectV2WorkflowsOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PropertyTargetDefinitionInput {
  factory Input$PropertyTargetDefinitionInput({
    required String name,
    required List<String> propertyValues,
    String? source,
  }) =>
      Input$PropertyTargetDefinitionInput._({
        r'name': name,
        r'propertyValues': propertyValues,
        if (source != null) r'source': source,
      });

  Input$PropertyTargetDefinitionInput._(this._$data);

  factory Input$PropertyTargetDefinitionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$propertyValues = data['propertyValues'];
    result$data['propertyValues'] =
        (l$propertyValues as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    return Input$PropertyTargetDefinitionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  List<String> get propertyValues => (_$data['propertyValues'] as List<String>);

  String? get source => (_$data['source'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$propertyValues = propertyValues;
    result$data['propertyValues'] = l$propertyValues.map((e) => e).toList();
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    return result$data;
  }

  CopyWith$Input$PropertyTargetDefinitionInput<
          Input$PropertyTargetDefinitionInput>
      get copyWith => CopyWith$Input$PropertyTargetDefinitionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PropertyTargetDefinitionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$propertyValues = propertyValues;
    final lOther$propertyValues = other.propertyValues;
    if (l$propertyValues.length != lOther$propertyValues.length) {
      return false;
    }
    for (int i = 0; i < l$propertyValues.length; i++) {
      final l$propertyValues$entry = l$propertyValues[i];
      final lOther$propertyValues$entry = lOther$propertyValues[i];
      if (l$propertyValues$entry != lOther$propertyValues$entry) {
        return false;
      }
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$propertyValues = propertyValues;
    final l$source = source;
    return Object.hashAll([
      l$name,
      Object.hashAll(l$propertyValues.map((v) => v)),
      _$data.containsKey('source') ? l$source : const {},
    ]);
  }
}

abstract class CopyWith$Input$PropertyTargetDefinitionInput<TRes> {
  factory CopyWith$Input$PropertyTargetDefinitionInput(
    Input$PropertyTargetDefinitionInput instance,
    TRes Function(Input$PropertyTargetDefinitionInput) then,
  ) = _CopyWithImpl$Input$PropertyTargetDefinitionInput;

  factory CopyWith$Input$PropertyTargetDefinitionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PropertyTargetDefinitionInput;

  TRes call({
    String? name,
    List<String>? propertyValues,
    String? source,
  });
}

class _CopyWithImpl$Input$PropertyTargetDefinitionInput<TRes>
    implements CopyWith$Input$PropertyTargetDefinitionInput<TRes> {
  _CopyWithImpl$Input$PropertyTargetDefinitionInput(
    this._instance,
    this._then,
  );

  final Input$PropertyTargetDefinitionInput _instance;

  final TRes Function(Input$PropertyTargetDefinitionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? propertyValues = _undefined,
    Object? source = _undefined,
  }) =>
      _then(Input$PropertyTargetDefinitionInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (propertyValues != _undefined && propertyValues != null)
          'propertyValues': (propertyValues as List<String>),
        if (source != _undefined) 'source': (source as String?),
      }));
}

class _CopyWithStubImpl$Input$PropertyTargetDefinitionInput<TRes>
    implements CopyWith$Input$PropertyTargetDefinitionInput<TRes> {
  _CopyWithStubImpl$Input$PropertyTargetDefinitionInput(this._res);

  TRes _res;

  call({
    String? name,
    List<String>? propertyValues,
    String? source,
  }) =>
      _res;
}

class Input$PublishSponsorsTierInput {
  factory Input$PublishSponsorsTierInput({
    String? clientMutationId,
    required String tierId,
  }) =>
      Input$PublishSponsorsTierInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'tierId': tierId,
      });

  Input$PublishSponsorsTierInput._(this._$data);

  factory Input$PublishSponsorsTierInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$tierId = data['tierId'];
    result$data['tierId'] = (l$tierId as String);
    return Input$PublishSponsorsTierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get tierId => (_$data['tierId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$tierId = tierId;
    result$data['tierId'] = l$tierId;
    return result$data;
  }

  CopyWith$Input$PublishSponsorsTierInput<Input$PublishSponsorsTierInput>
      get copyWith => CopyWith$Input$PublishSponsorsTierInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PublishSponsorsTierInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$tierId = tierId;
    final lOther$tierId = other.tierId;
    if (l$tierId != lOther$tierId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$tierId = tierId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$tierId,
    ]);
  }
}

abstract class CopyWith$Input$PublishSponsorsTierInput<TRes> {
  factory CopyWith$Input$PublishSponsorsTierInput(
    Input$PublishSponsorsTierInput instance,
    TRes Function(Input$PublishSponsorsTierInput) then,
  ) = _CopyWithImpl$Input$PublishSponsorsTierInput;

  factory CopyWith$Input$PublishSponsorsTierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PublishSponsorsTierInput;

  TRes call({
    String? clientMutationId,
    String? tierId,
  });
}

class _CopyWithImpl$Input$PublishSponsorsTierInput<TRes>
    implements CopyWith$Input$PublishSponsorsTierInput<TRes> {
  _CopyWithImpl$Input$PublishSponsorsTierInput(
    this._instance,
    this._then,
  );

  final Input$PublishSponsorsTierInput _instance;

  final TRes Function(Input$PublishSponsorsTierInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? tierId = _undefined,
  }) =>
      _then(Input$PublishSponsorsTierInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (tierId != _undefined && tierId != null)
          'tierId': (tierId as String),
      }));
}

class _CopyWithStubImpl$Input$PublishSponsorsTierInput<TRes>
    implements CopyWith$Input$PublishSponsorsTierInput<TRes> {
  _CopyWithStubImpl$Input$PublishSponsorsTierInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? tierId,
  }) =>
      _res;
}

class Input$PullRequestOrder {
  factory Input$PullRequestOrder({
    required Enum$PullRequestOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$PullRequestOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$PullRequestOrder._(this._$data);

  factory Input$PullRequestOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$PullRequestOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$PullRequestOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$PullRequestOrderField get field =>
      (_$data['field'] as Enum$PullRequestOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$PullRequestOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$PullRequestOrder<Input$PullRequestOrder> get copyWith =>
      CopyWith$Input$PullRequestOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PullRequestOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$PullRequestOrder<TRes> {
  factory CopyWith$Input$PullRequestOrder(
    Input$PullRequestOrder instance,
    TRes Function(Input$PullRequestOrder) then,
  ) = _CopyWithImpl$Input$PullRequestOrder;

  factory CopyWith$Input$PullRequestOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PullRequestOrder;

  TRes call({
    Enum$PullRequestOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$PullRequestOrder<TRes>
    implements CopyWith$Input$PullRequestOrder<TRes> {
  _CopyWithImpl$Input$PullRequestOrder(
    this._instance,
    this._then,
  );

  final Input$PullRequestOrder _instance;

  final TRes Function(Input$PullRequestOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$PullRequestOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$PullRequestOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$PullRequestOrder<TRes>
    implements CopyWith$Input$PullRequestOrder<TRes> {
  _CopyWithStubImpl$Input$PullRequestOrder(this._res);

  TRes _res;

  call({
    Enum$PullRequestOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$PullRequestParametersInput {
  factory Input$PullRequestParametersInput({
    List<Enum$PullRequestAllowedMergeMethods>? allowedMergeMethods,
    bool? automaticCopilotCodeReviewEnabled,
    required bool dismissStaleReviewsOnPush,
    required bool requireCodeOwnerReview,
    required bool requireLastPushApproval,
    required int requiredApprovingReviewCount,
    required bool requiredReviewThreadResolution,
  }) =>
      Input$PullRequestParametersInput._({
        if (allowedMergeMethods != null)
          r'allowedMergeMethods': allowedMergeMethods,
        if (automaticCopilotCodeReviewEnabled != null)
          r'automaticCopilotCodeReviewEnabled':
              automaticCopilotCodeReviewEnabled,
        r'dismissStaleReviewsOnPush': dismissStaleReviewsOnPush,
        r'requireCodeOwnerReview': requireCodeOwnerReview,
        r'requireLastPushApproval': requireLastPushApproval,
        r'requiredApprovingReviewCount': requiredApprovingReviewCount,
        r'requiredReviewThreadResolution': requiredReviewThreadResolution,
      });

  Input$PullRequestParametersInput._(this._$data);

  factory Input$PullRequestParametersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('allowedMergeMethods')) {
      final l$allowedMergeMethods = data['allowedMergeMethods'];
      result$data['allowedMergeMethods'] =
          (l$allowedMergeMethods as List<dynamic>?)
              ?.map((e) =>
                  fromJson$Enum$PullRequestAllowedMergeMethods((e as String)))
              .toList();
    }
    if (data.containsKey('automaticCopilotCodeReviewEnabled')) {
      final l$automaticCopilotCodeReviewEnabled =
          data['automaticCopilotCodeReviewEnabled'];
      result$data['automaticCopilotCodeReviewEnabled'] =
          (l$automaticCopilotCodeReviewEnabled as bool?);
    }
    final l$dismissStaleReviewsOnPush = data['dismissStaleReviewsOnPush'];
    result$data['dismissStaleReviewsOnPush'] =
        (l$dismissStaleReviewsOnPush as bool);
    final l$requireCodeOwnerReview = data['requireCodeOwnerReview'];
    result$data['requireCodeOwnerReview'] = (l$requireCodeOwnerReview as bool);
    final l$requireLastPushApproval = data['requireLastPushApproval'];
    result$data['requireLastPushApproval'] =
        (l$requireLastPushApproval as bool);
    final l$requiredApprovingReviewCount = data['requiredApprovingReviewCount'];
    result$data['requiredApprovingReviewCount'] =
        (l$requiredApprovingReviewCount as int);
    final l$requiredReviewThreadResolution =
        data['requiredReviewThreadResolution'];
    result$data['requiredReviewThreadResolution'] =
        (l$requiredReviewThreadResolution as bool);
    return Input$PullRequestParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Enum$PullRequestAllowedMergeMethods>? get allowedMergeMethods =>
      (_$data['allowedMergeMethods']
          as List<Enum$PullRequestAllowedMergeMethods>?);

  bool? get automaticCopilotCodeReviewEnabled =>
      (_$data['automaticCopilotCodeReviewEnabled'] as bool?);

  bool get dismissStaleReviewsOnPush =>
      (_$data['dismissStaleReviewsOnPush'] as bool);

  bool get requireCodeOwnerReview => (_$data['requireCodeOwnerReview'] as bool);

  bool get requireLastPushApproval =>
      (_$data['requireLastPushApproval'] as bool);

  int get requiredApprovingReviewCount =>
      (_$data['requiredApprovingReviewCount'] as int);

  bool get requiredReviewThreadResolution =>
      (_$data['requiredReviewThreadResolution'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('allowedMergeMethods')) {
      final l$allowedMergeMethods = allowedMergeMethods;
      result$data['allowedMergeMethods'] = l$allowedMergeMethods
          ?.map((e) => toJson$Enum$PullRequestAllowedMergeMethods(e))
          .toList();
    }
    if (_$data.containsKey('automaticCopilotCodeReviewEnabled')) {
      final l$automaticCopilotCodeReviewEnabled =
          automaticCopilotCodeReviewEnabled;
      result$data['automaticCopilotCodeReviewEnabled'] =
          l$automaticCopilotCodeReviewEnabled;
    }
    final l$dismissStaleReviewsOnPush = dismissStaleReviewsOnPush;
    result$data['dismissStaleReviewsOnPush'] = l$dismissStaleReviewsOnPush;
    final l$requireCodeOwnerReview = requireCodeOwnerReview;
    result$data['requireCodeOwnerReview'] = l$requireCodeOwnerReview;
    final l$requireLastPushApproval = requireLastPushApproval;
    result$data['requireLastPushApproval'] = l$requireLastPushApproval;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    result$data['requiredApprovingReviewCount'] =
        l$requiredApprovingReviewCount;
    final l$requiredReviewThreadResolution = requiredReviewThreadResolution;
    result$data['requiredReviewThreadResolution'] =
        l$requiredReviewThreadResolution;
    return result$data;
  }

  CopyWith$Input$PullRequestParametersInput<Input$PullRequestParametersInput>
      get copyWith => CopyWith$Input$PullRequestParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$PullRequestParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$allowedMergeMethods = allowedMergeMethods;
    final lOther$allowedMergeMethods = other.allowedMergeMethods;
    if (_$data.containsKey('allowedMergeMethods') !=
        other._$data.containsKey('allowedMergeMethods')) {
      return false;
    }
    if (l$allowedMergeMethods != null && lOther$allowedMergeMethods != null) {
      if (l$allowedMergeMethods.length != lOther$allowedMergeMethods.length) {
        return false;
      }
      for (int i = 0; i < l$allowedMergeMethods.length; i++) {
        final l$allowedMergeMethods$entry = l$allowedMergeMethods[i];
        final lOther$allowedMergeMethods$entry = lOther$allowedMergeMethods[i];
        if (l$allowedMergeMethods$entry != lOther$allowedMergeMethods$entry) {
          return false;
        }
      }
    } else if (l$allowedMergeMethods != lOther$allowedMergeMethods) {
      return false;
    }
    final l$automaticCopilotCodeReviewEnabled =
        automaticCopilotCodeReviewEnabled;
    final lOther$automaticCopilotCodeReviewEnabled =
        other.automaticCopilotCodeReviewEnabled;
    if (_$data.containsKey('automaticCopilotCodeReviewEnabled') !=
        other._$data.containsKey('automaticCopilotCodeReviewEnabled')) {
      return false;
    }
    if (l$automaticCopilotCodeReviewEnabled !=
        lOther$automaticCopilotCodeReviewEnabled) {
      return false;
    }
    final l$dismissStaleReviewsOnPush = dismissStaleReviewsOnPush;
    final lOther$dismissStaleReviewsOnPush = other.dismissStaleReviewsOnPush;
    if (l$dismissStaleReviewsOnPush != lOther$dismissStaleReviewsOnPush) {
      return false;
    }
    final l$requireCodeOwnerReview = requireCodeOwnerReview;
    final lOther$requireCodeOwnerReview = other.requireCodeOwnerReview;
    if (l$requireCodeOwnerReview != lOther$requireCodeOwnerReview) {
      return false;
    }
    final l$requireLastPushApproval = requireLastPushApproval;
    final lOther$requireLastPushApproval = other.requireLastPushApproval;
    if (l$requireLastPushApproval != lOther$requireLastPushApproval) {
      return false;
    }
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final lOther$requiredApprovingReviewCount =
        other.requiredApprovingReviewCount;
    if (l$requiredApprovingReviewCount != lOther$requiredApprovingReviewCount) {
      return false;
    }
    final l$requiredReviewThreadResolution = requiredReviewThreadResolution;
    final lOther$requiredReviewThreadResolution =
        other.requiredReviewThreadResolution;
    if (l$requiredReviewThreadResolution !=
        lOther$requiredReviewThreadResolution) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$allowedMergeMethods = allowedMergeMethods;
    final l$automaticCopilotCodeReviewEnabled =
        automaticCopilotCodeReviewEnabled;
    final l$dismissStaleReviewsOnPush = dismissStaleReviewsOnPush;
    final l$requireCodeOwnerReview = requireCodeOwnerReview;
    final l$requireLastPushApproval = requireLastPushApproval;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final l$requiredReviewThreadResolution = requiredReviewThreadResolution;
    return Object.hashAll([
      _$data.containsKey('allowedMergeMethods')
          ? l$allowedMergeMethods == null
              ? null
              : Object.hashAll(l$allowedMergeMethods.map((v) => v))
          : const {},
      _$data.containsKey('automaticCopilotCodeReviewEnabled')
          ? l$automaticCopilotCodeReviewEnabled
          : const {},
      l$dismissStaleReviewsOnPush,
      l$requireCodeOwnerReview,
      l$requireLastPushApproval,
      l$requiredApprovingReviewCount,
      l$requiredReviewThreadResolution,
    ]);
  }
}

abstract class CopyWith$Input$PullRequestParametersInput<TRes> {
  factory CopyWith$Input$PullRequestParametersInput(
    Input$PullRequestParametersInput instance,
    TRes Function(Input$PullRequestParametersInput) then,
  ) = _CopyWithImpl$Input$PullRequestParametersInput;

  factory CopyWith$Input$PullRequestParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PullRequestParametersInput;

  TRes call({
    List<Enum$PullRequestAllowedMergeMethods>? allowedMergeMethods,
    bool? automaticCopilotCodeReviewEnabled,
    bool? dismissStaleReviewsOnPush,
    bool? requireCodeOwnerReview,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    bool? requiredReviewThreadResolution,
  });
}

class _CopyWithImpl$Input$PullRequestParametersInput<TRes>
    implements CopyWith$Input$PullRequestParametersInput<TRes> {
  _CopyWithImpl$Input$PullRequestParametersInput(
    this._instance,
    this._then,
  );

  final Input$PullRequestParametersInput _instance;

  final TRes Function(Input$PullRequestParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? allowedMergeMethods = _undefined,
    Object? automaticCopilotCodeReviewEnabled = _undefined,
    Object? dismissStaleReviewsOnPush = _undefined,
    Object? requireCodeOwnerReview = _undefined,
    Object? requireLastPushApproval = _undefined,
    Object? requiredApprovingReviewCount = _undefined,
    Object? requiredReviewThreadResolution = _undefined,
  }) =>
      _then(Input$PullRequestParametersInput._({
        ..._instance._$data,
        if (allowedMergeMethods != _undefined)
          'allowedMergeMethods': (allowedMergeMethods
              as List<Enum$PullRequestAllowedMergeMethods>?),
        if (automaticCopilotCodeReviewEnabled != _undefined)
          'automaticCopilotCodeReviewEnabled':
              (automaticCopilotCodeReviewEnabled as bool?),
        if (dismissStaleReviewsOnPush != _undefined &&
            dismissStaleReviewsOnPush != null)
          'dismissStaleReviewsOnPush': (dismissStaleReviewsOnPush as bool),
        if (requireCodeOwnerReview != _undefined &&
            requireCodeOwnerReview != null)
          'requireCodeOwnerReview': (requireCodeOwnerReview as bool),
        if (requireLastPushApproval != _undefined &&
            requireLastPushApproval != null)
          'requireLastPushApproval': (requireLastPushApproval as bool),
        if (requiredApprovingReviewCount != _undefined &&
            requiredApprovingReviewCount != null)
          'requiredApprovingReviewCount': (requiredApprovingReviewCount as int),
        if (requiredReviewThreadResolution != _undefined &&
            requiredReviewThreadResolution != null)
          'requiredReviewThreadResolution':
              (requiredReviewThreadResolution as bool),
      }));
}

class _CopyWithStubImpl$Input$PullRequestParametersInput<TRes>
    implements CopyWith$Input$PullRequestParametersInput<TRes> {
  _CopyWithStubImpl$Input$PullRequestParametersInput(this._res);

  TRes _res;

  call({
    List<Enum$PullRequestAllowedMergeMethods>? allowedMergeMethods,
    bool? automaticCopilotCodeReviewEnabled,
    bool? dismissStaleReviewsOnPush,
    bool? requireCodeOwnerReview,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    bool? requiredReviewThreadResolution,
  }) =>
      _res;
}

class Input$ReactionOrder {
  factory Input$ReactionOrder({
    required Enum$ReactionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ReactionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ReactionOrder._(this._$data);

  factory Input$ReactionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ReactionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ReactionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReactionOrderField get field =>
      (_$data['field'] as Enum$ReactionOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ReactionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ReactionOrder<Input$ReactionOrder> get copyWith =>
      CopyWith$Input$ReactionOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReactionOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ReactionOrder<TRes> {
  factory CopyWith$Input$ReactionOrder(
    Input$ReactionOrder instance,
    TRes Function(Input$ReactionOrder) then,
  ) = _CopyWithImpl$Input$ReactionOrder;

  factory CopyWith$Input$ReactionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ReactionOrder;

  TRes call({
    Enum$ReactionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ReactionOrder<TRes>
    implements CopyWith$Input$ReactionOrder<TRes> {
  _CopyWithImpl$Input$ReactionOrder(
    this._instance,
    this._then,
  );

  final Input$ReactionOrder _instance;

  final TRes Function(Input$ReactionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ReactionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ReactionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ReactionOrder<TRes>
    implements CopyWith$Input$ReactionOrder<TRes> {
  _CopyWithStubImpl$Input$ReactionOrder(this._res);

  TRes _res;

  call({
    Enum$ReactionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RefNameConditionTargetInput {
  factory Input$RefNameConditionTargetInput({
    required List<String> exclude,
    required List<String> include,
  }) =>
      Input$RefNameConditionTargetInput._({
        r'exclude': exclude,
        r'include': include,
      });

  Input$RefNameConditionTargetInput._(this._$data);

  factory Input$RefNameConditionTargetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$exclude = data['exclude'];
    result$data['exclude'] =
        (l$exclude as List<dynamic>).map((e) => (e as String)).toList();
    final l$include = data['include'];
    result$data['include'] =
        (l$include as List<dynamic>).map((e) => (e as String)).toList();
    return Input$RefNameConditionTargetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get exclude => (_$data['exclude'] as List<String>);

  List<String> get include => (_$data['include'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$exclude = exclude;
    result$data['exclude'] = l$exclude.map((e) => e).toList();
    final l$include = include;
    result$data['include'] = l$include.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$RefNameConditionTargetInput<Input$RefNameConditionTargetInput>
      get copyWith => CopyWith$Input$RefNameConditionTargetInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RefNameConditionTargetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$exclude = exclude;
    final lOther$exclude = other.exclude;
    if (l$exclude.length != lOther$exclude.length) {
      return false;
    }
    for (int i = 0; i < l$exclude.length; i++) {
      final l$exclude$entry = l$exclude[i];
      final lOther$exclude$entry = lOther$exclude[i];
      if (l$exclude$entry != lOther$exclude$entry) {
        return false;
      }
    }
    final l$include = include;
    final lOther$include = other.include;
    if (l$include.length != lOther$include.length) {
      return false;
    }
    for (int i = 0; i < l$include.length; i++) {
      final l$include$entry = l$include[i];
      final lOther$include$entry = lOther$include[i];
      if (l$include$entry != lOther$include$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$exclude = exclude;
    final l$include = include;
    return Object.hashAll([
      Object.hashAll(l$exclude.map((v) => v)),
      Object.hashAll(l$include.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$RefNameConditionTargetInput<TRes> {
  factory CopyWith$Input$RefNameConditionTargetInput(
    Input$RefNameConditionTargetInput instance,
    TRes Function(Input$RefNameConditionTargetInput) then,
  ) = _CopyWithImpl$Input$RefNameConditionTargetInput;

  factory CopyWith$Input$RefNameConditionTargetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RefNameConditionTargetInput;

  TRes call({
    List<String>? exclude,
    List<String>? include,
  });
}

class _CopyWithImpl$Input$RefNameConditionTargetInput<TRes>
    implements CopyWith$Input$RefNameConditionTargetInput<TRes> {
  _CopyWithImpl$Input$RefNameConditionTargetInput(
    this._instance,
    this._then,
  );

  final Input$RefNameConditionTargetInput _instance;

  final TRes Function(Input$RefNameConditionTargetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? exclude = _undefined,
    Object? include = _undefined,
  }) =>
      _then(Input$RefNameConditionTargetInput._({
        ..._instance._$data,
        if (exclude != _undefined && exclude != null)
          'exclude': (exclude as List<String>),
        if (include != _undefined && include != null)
          'include': (include as List<String>),
      }));
}

class _CopyWithStubImpl$Input$RefNameConditionTargetInput<TRes>
    implements CopyWith$Input$RefNameConditionTargetInput<TRes> {
  _CopyWithStubImpl$Input$RefNameConditionTargetInput(this._res);

  TRes _res;

  call({
    List<String>? exclude,
    List<String>? include,
  }) =>
      _res;
}

class Input$RefOrder {
  factory Input$RefOrder({
    required Enum$RefOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$RefOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RefOrder._(this._$data);

  factory Input$RefOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$RefOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$RefOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RefOrderField get field => (_$data['field'] as Enum$RefOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RefOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RefOrder<Input$RefOrder> get copyWith =>
      CopyWith$Input$RefOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RefOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RefOrder<TRes> {
  factory CopyWith$Input$RefOrder(
    Input$RefOrder instance,
    TRes Function(Input$RefOrder) then,
  ) = _CopyWithImpl$Input$RefOrder;

  factory CopyWith$Input$RefOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RefOrder;

  TRes call({
    Enum$RefOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RefOrder<TRes>
    implements CopyWith$Input$RefOrder<TRes> {
  _CopyWithImpl$Input$RefOrder(
    this._instance,
    this._then,
  );

  final Input$RefOrder _instance;

  final TRes Function(Input$RefOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RefOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RefOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RefOrder<TRes>
    implements CopyWith$Input$RefOrder<TRes> {
  _CopyWithStubImpl$Input$RefOrder(this._res);

  TRes _res;

  call({
    Enum$RefOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RefUpdate {
  factory Input$RefUpdate({
    required String name,
    required String afterOid,
    String? beforeOid,
    bool? force,
  }) =>
      Input$RefUpdate._({
        r'name': name,
        r'afterOid': afterOid,
        if (beforeOid != null) r'beforeOid': beforeOid,
        if (force != null) r'force': force,
      });

  Input$RefUpdate._(this._$data);

  factory Input$RefUpdate.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$afterOid = data['afterOid'];
    result$data['afterOid'] = (l$afterOid as String);
    if (data.containsKey('beforeOid')) {
      final l$beforeOid = data['beforeOid'];
      result$data['beforeOid'] = (l$beforeOid as String?);
    }
    if (data.containsKey('force')) {
      final l$force = data['force'];
      result$data['force'] = (l$force as bool?);
    }
    return Input$RefUpdate._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);

  String get afterOid => (_$data['afterOid'] as String);

  String? get beforeOid => (_$data['beforeOid'] as String?);

  bool? get force => (_$data['force'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$afterOid = afterOid;
    result$data['afterOid'] = l$afterOid;
    if (_$data.containsKey('beforeOid')) {
      final l$beforeOid = beforeOid;
      result$data['beforeOid'] = l$beforeOid;
    }
    if (_$data.containsKey('force')) {
      final l$force = force;
      result$data['force'] = l$force;
    }
    return result$data;
  }

  CopyWith$Input$RefUpdate<Input$RefUpdate> get copyWith =>
      CopyWith$Input$RefUpdate(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RefUpdate || runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$afterOid = afterOid;
    final lOther$afterOid = other.afterOid;
    if (l$afterOid != lOther$afterOid) {
      return false;
    }
    final l$beforeOid = beforeOid;
    final lOther$beforeOid = other.beforeOid;
    if (_$data.containsKey('beforeOid') !=
        other._$data.containsKey('beforeOid')) {
      return false;
    }
    if (l$beforeOid != lOther$beforeOid) {
      return false;
    }
    final l$force = force;
    final lOther$force = other.force;
    if (_$data.containsKey('force') != other._$data.containsKey('force')) {
      return false;
    }
    if (l$force != lOther$force) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$afterOid = afterOid;
    final l$beforeOid = beforeOid;
    final l$force = force;
    return Object.hashAll([
      l$name,
      l$afterOid,
      _$data.containsKey('beforeOid') ? l$beforeOid : const {},
      _$data.containsKey('force') ? l$force : const {},
    ]);
  }
}

abstract class CopyWith$Input$RefUpdate<TRes> {
  factory CopyWith$Input$RefUpdate(
    Input$RefUpdate instance,
    TRes Function(Input$RefUpdate) then,
  ) = _CopyWithImpl$Input$RefUpdate;

  factory CopyWith$Input$RefUpdate.stub(TRes res) =
      _CopyWithStubImpl$Input$RefUpdate;

  TRes call({
    String? name,
    String? afterOid,
    String? beforeOid,
    bool? force,
  });
}

class _CopyWithImpl$Input$RefUpdate<TRes>
    implements CopyWith$Input$RefUpdate<TRes> {
  _CopyWithImpl$Input$RefUpdate(
    this._instance,
    this._then,
  );

  final Input$RefUpdate _instance;

  final TRes Function(Input$RefUpdate) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? afterOid = _undefined,
    Object? beforeOid = _undefined,
    Object? force = _undefined,
  }) =>
      _then(Input$RefUpdate._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (afterOid != _undefined && afterOid != null)
          'afterOid': (afterOid as String),
        if (beforeOid != _undefined) 'beforeOid': (beforeOid as String?),
        if (force != _undefined) 'force': (force as bool?),
      }));
}

class _CopyWithStubImpl$Input$RefUpdate<TRes>
    implements CopyWith$Input$RefUpdate<TRes> {
  _CopyWithStubImpl$Input$RefUpdate(this._res);

  TRes _res;

  call({
    String? name,
    String? afterOid,
    String? beforeOid,
    bool? force,
  }) =>
      _res;
}

class Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  factory Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput({
    String? clientMutationId,
    required String enterpriseId,
  }) =>
      Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
      });

  Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._(this._$data);

  factory Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    return Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    return result$data;
  }

  CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
          Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput>
      get copyWith =>
          CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
    ]);
  }
}

abstract class CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
    TRes> {
  factory CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
    Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput instance,
    TRes Function(Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput)
        then,
  ) = _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput;

  factory CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
  });
}

class _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
        TRes>
    implements
        CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
            TRes> {
  _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
    this._instance,
    this._then,
  );

  final Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput _instance;

  final TRes Function(
      Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
  }) =>
      _then(Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
      }));
}

class _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
        TRes>
    implements
        CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
            TRes> {
  _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
  }) =>
      _res;
}

class Input$RegenerateVerifiableDomainTokenInput {
  factory Input$RegenerateVerifiableDomainTokenInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$RegenerateVerifiableDomainTokenInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$RegenerateVerifiableDomainTokenInput._(this._$data);

  factory Input$RegenerateVerifiableDomainTokenInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$RegenerateVerifiableDomainTokenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$RegenerateVerifiableDomainTokenInput<
          Input$RegenerateVerifiableDomainTokenInput>
      get copyWith => CopyWith$Input$RegenerateVerifiableDomainTokenInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RegenerateVerifiableDomainTokenInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  factory CopyWith$Input$RegenerateVerifiableDomainTokenInput(
    Input$RegenerateVerifiableDomainTokenInput instance,
    TRes Function(Input$RegenerateVerifiableDomainTokenInput) then,
  ) = _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput;

  factory CopyWith$Input$RegenerateVerifiableDomainTokenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput<TRes>
    implements CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput(
    this._instance,
    this._then,
  );

  final Input$RegenerateVerifiableDomainTokenInput _instance;

  final TRes Function(Input$RegenerateVerifiableDomainTokenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$RegenerateVerifiableDomainTokenInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput<TRes>
    implements CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$RejectDeploymentsInput {
  factory Input$RejectDeploymentsInput({
    String? clientMutationId,
    required String workflowRunId,
    required List<String> environmentIds,
    String? comment,
  }) =>
      Input$RejectDeploymentsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'workflowRunId': workflowRunId,
        r'environmentIds': environmentIds,
        if (comment != null) r'comment': comment,
      });

  Input$RejectDeploymentsInput._(this._$data);

  factory Input$RejectDeploymentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$workflowRunId = data['workflowRunId'];
    result$data['workflowRunId'] = (l$workflowRunId as String);
    final l$environmentIds = data['environmentIds'];
    result$data['environmentIds'] =
        (l$environmentIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    return Input$RejectDeploymentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get workflowRunId => (_$data['workflowRunId'] as String);

  List<String> get environmentIds => (_$data['environmentIds'] as List<String>);

  String? get comment => (_$data['comment'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$workflowRunId = workflowRunId;
    result$data['workflowRunId'] = l$workflowRunId;
    final l$environmentIds = environmentIds;
    result$data['environmentIds'] = l$environmentIds.map((e) => e).toList();
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    return result$data;
  }

  CopyWith$Input$RejectDeploymentsInput<Input$RejectDeploymentsInput>
      get copyWith => CopyWith$Input$RejectDeploymentsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RejectDeploymentsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$workflowRunId = workflowRunId;
    final lOther$workflowRunId = other.workflowRunId;
    if (l$workflowRunId != lOther$workflowRunId) {
      return false;
    }
    final l$environmentIds = environmentIds;
    final lOther$environmentIds = other.environmentIds;
    if (l$environmentIds.length != lOther$environmentIds.length) {
      return false;
    }
    for (int i = 0; i < l$environmentIds.length; i++) {
      final l$environmentIds$entry = l$environmentIds[i];
      final lOther$environmentIds$entry = lOther$environmentIds[i];
      if (l$environmentIds$entry != lOther$environmentIds$entry) {
        return false;
      }
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$workflowRunId = workflowRunId;
    final l$environmentIds = environmentIds;
    final l$comment = comment;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$workflowRunId,
      Object.hashAll(l$environmentIds.map((v) => v)),
      _$data.containsKey('comment') ? l$comment : const {},
    ]);
  }
}

abstract class CopyWith$Input$RejectDeploymentsInput<TRes> {
  factory CopyWith$Input$RejectDeploymentsInput(
    Input$RejectDeploymentsInput instance,
    TRes Function(Input$RejectDeploymentsInput) then,
  ) = _CopyWithImpl$Input$RejectDeploymentsInput;

  factory CopyWith$Input$RejectDeploymentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RejectDeploymentsInput;

  TRes call({
    String? clientMutationId,
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
  });
}

class _CopyWithImpl$Input$RejectDeploymentsInput<TRes>
    implements CopyWith$Input$RejectDeploymentsInput<TRes> {
  _CopyWithImpl$Input$RejectDeploymentsInput(
    this._instance,
    this._then,
  );

  final Input$RejectDeploymentsInput _instance;

  final TRes Function(Input$RejectDeploymentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? workflowRunId = _undefined,
    Object? environmentIds = _undefined,
    Object? comment = _undefined,
  }) =>
      _then(Input$RejectDeploymentsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (workflowRunId != _undefined && workflowRunId != null)
          'workflowRunId': (workflowRunId as String),
        if (environmentIds != _undefined && environmentIds != null)
          'environmentIds': (environmentIds as List<String>),
        if (comment != _undefined) 'comment': (comment as String?),
      }));
}

class _CopyWithStubImpl$Input$RejectDeploymentsInput<TRes>
    implements CopyWith$Input$RejectDeploymentsInput<TRes> {
  _CopyWithStubImpl$Input$RejectDeploymentsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? workflowRunId,
    List<String>? environmentIds,
    String? comment,
  }) =>
      _res;
}

class Input$ReleaseOrder {
  factory Input$ReleaseOrder({
    required Enum$ReleaseOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$ReleaseOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$ReleaseOrder._(this._$data);

  factory Input$ReleaseOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$ReleaseOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ReleaseOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReleaseOrderField get field =>
      (_$data['field'] as Enum$ReleaseOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$ReleaseOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ReleaseOrder<Input$ReleaseOrder> get copyWith =>
      CopyWith$Input$ReleaseOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReleaseOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$ReleaseOrder<TRes> {
  factory CopyWith$Input$ReleaseOrder(
    Input$ReleaseOrder instance,
    TRes Function(Input$ReleaseOrder) then,
  ) = _CopyWithImpl$Input$ReleaseOrder;

  factory CopyWith$Input$ReleaseOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseOrder;

  TRes call({
    Enum$ReleaseOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$ReleaseOrder<TRes>
    implements CopyWith$Input$ReleaseOrder<TRes> {
  _CopyWithImpl$Input$ReleaseOrder(
    this._instance,
    this._then,
  );

  final Input$ReleaseOrder _instance;

  final TRes Function(Input$ReleaseOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$ReleaseOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$ReleaseOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ReleaseOrder<TRes>
    implements CopyWith$Input$ReleaseOrder<TRes> {
  _CopyWithStubImpl$Input$ReleaseOrder(this._res);

  TRes _res;

  call({
    Enum$ReleaseOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RemoveAssigneesFromAssignableInput {
  factory Input$RemoveAssigneesFromAssignableInput({
    String? clientMutationId,
    required String assignableId,
    required List<String> assigneeIds,
  }) =>
      Input$RemoveAssigneesFromAssignableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'assignableId': assignableId,
        r'assigneeIds': assigneeIds,
      });

  Input$RemoveAssigneesFromAssignableInput._(this._$data);

  factory Input$RemoveAssigneesFromAssignableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$assignableId = data['assignableId'];
    result$data['assignableId'] = (l$assignableId as String);
    final l$assigneeIds = data['assigneeIds'];
    result$data['assigneeIds'] =
        (l$assigneeIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$RemoveAssigneesFromAssignableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get assignableId => (_$data['assignableId'] as String);

  List<String> get assigneeIds => (_$data['assigneeIds'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$assignableId = assignableId;
    result$data['assignableId'] = l$assignableId;
    final l$assigneeIds = assigneeIds;
    result$data['assigneeIds'] = l$assigneeIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$RemoveAssigneesFromAssignableInput<
          Input$RemoveAssigneesFromAssignableInput>
      get copyWith => CopyWith$Input$RemoveAssigneesFromAssignableInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveAssigneesFromAssignableInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$assignableId = assignableId;
    final lOther$assignableId = other.assignableId;
    if (l$assignableId != lOther$assignableId) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (l$assigneeIds.length != lOther$assigneeIds.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeIds.length; i++) {
      final l$assigneeIds$entry = l$assigneeIds[i];
      final lOther$assigneeIds$entry = lOther$assigneeIds[i];
      if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$assignableId = assignableId;
    final l$assigneeIds = assigneeIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$assignableId,
      Object.hashAll(l$assigneeIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  factory CopyWith$Input$RemoveAssigneesFromAssignableInput(
    Input$RemoveAssigneesFromAssignableInput instance,
    TRes Function(Input$RemoveAssigneesFromAssignableInput) then,
  ) = _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput;

  factory CopyWith$Input$RemoveAssigneesFromAssignableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput;

  TRes call({
    String? clientMutationId,
    String? assignableId,
    List<String>? assigneeIds,
  });
}

class _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput<TRes>
    implements CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput(
    this._instance,
    this._then,
  );

  final Input$RemoveAssigneesFromAssignableInput _instance;

  final TRes Function(Input$RemoveAssigneesFromAssignableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? assignableId = _undefined,
    Object? assigneeIds = _undefined,
  }) =>
      _then(Input$RemoveAssigneesFromAssignableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (assignableId != _undefined && assignableId != null)
          'assignableId': (assignableId as String),
        if (assigneeIds != _undefined && assigneeIds != null)
          'assigneeIds': (assigneeIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput<TRes>
    implements CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? assignableId,
    List<String>? assigneeIds,
  }) =>
      _res;
}

class Input$RemoveBlockedByInput {
  factory Input$RemoveBlockedByInput({
    String? clientMutationId,
    required String issueId,
    required String blockingIssueId,
  }) =>
      Input$RemoveBlockedByInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        r'blockingIssueId': blockingIssueId,
      });

  Input$RemoveBlockedByInput._(this._$data);

  factory Input$RemoveBlockedByInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$blockingIssueId = data['blockingIssueId'];
    result$data['blockingIssueId'] = (l$blockingIssueId as String);
    return Input$RemoveBlockedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  String get blockingIssueId => (_$data['blockingIssueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$blockingIssueId = blockingIssueId;
    result$data['blockingIssueId'] = l$blockingIssueId;
    return result$data;
  }

  CopyWith$Input$RemoveBlockedByInput<Input$RemoveBlockedByInput>
      get copyWith => CopyWith$Input$RemoveBlockedByInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveBlockedByInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$blockingIssueId = blockingIssueId;
    final lOther$blockingIssueId = other.blockingIssueId;
    if (l$blockingIssueId != lOther$blockingIssueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$blockingIssueId = blockingIssueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      l$blockingIssueId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveBlockedByInput<TRes> {
  factory CopyWith$Input$RemoveBlockedByInput(
    Input$RemoveBlockedByInput instance,
    TRes Function(Input$RemoveBlockedByInput) then,
  ) = _CopyWithImpl$Input$RemoveBlockedByInput;

  factory CopyWith$Input$RemoveBlockedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveBlockedByInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? blockingIssueId,
  });
}

class _CopyWithImpl$Input$RemoveBlockedByInput<TRes>
    implements CopyWith$Input$RemoveBlockedByInput<TRes> {
  _CopyWithImpl$Input$RemoveBlockedByInput(
    this._instance,
    this._then,
  );

  final Input$RemoveBlockedByInput _instance;

  final TRes Function(Input$RemoveBlockedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? blockingIssueId = _undefined,
  }) =>
      _then(Input$RemoveBlockedByInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (blockingIssueId != _undefined && blockingIssueId != null)
          'blockingIssueId': (blockingIssueId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveBlockedByInput<TRes>
    implements CopyWith$Input$RemoveBlockedByInput<TRes> {
  _CopyWithStubImpl$Input$RemoveBlockedByInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? blockingIssueId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseAdminInput {
  factory Input$RemoveEnterpriseAdminInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$RemoveEnterpriseAdminInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$RemoveEnterpriseAdminInput._(this._$data);

  factory Input$RemoveEnterpriseAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$RemoveEnterpriseAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get login => (_$data['login'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseAdminInput<Input$RemoveEnterpriseAdminInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseAdminInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveEnterpriseAdminInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseAdminInput(
    Input$RemoveEnterpriseAdminInput instance,
    TRes Function(Input$RemoveEnterpriseAdminInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseAdminInput;

  factory CopyWith$Input$RemoveEnterpriseAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseAdminInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseAdminInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseAdminInput _instance;

  final TRes Function(Input$RemoveEnterpriseAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseAdminInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$RemoveEnterpriseIdentityProviderInput {
  factory Input$RemoveEnterpriseIdentityProviderInput({
    String? clientMutationId,
    required String enterpriseId,
  }) =>
      Input$RemoveEnterpriseIdentityProviderInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
      });

  Input$RemoveEnterpriseIdentityProviderInput._(this._$data);

  factory Input$RemoveEnterpriseIdentityProviderInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    return Input$RemoveEnterpriseIdentityProviderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseIdentityProviderInput<
          Input$RemoveEnterpriseIdentityProviderInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseIdentityProviderInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveEnterpriseIdentityProviderInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseIdentityProviderInput(
    Input$RemoveEnterpriseIdentityProviderInput instance,
    TRes Function(Input$RemoveEnterpriseIdentityProviderInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput;

  factory CopyWith$Input$RemoveEnterpriseIdentityProviderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseIdentityProviderInput _instance;

  final TRes Function(Input$RemoveEnterpriseIdentityProviderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseIdentityProviderInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseMemberInput {
  factory Input$RemoveEnterpriseMemberInput({
    String? clientMutationId,
    required String enterpriseId,
    required String userId,
  }) =>
      Input$RemoveEnterpriseMemberInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'userId': userId,
      });

  Input$RemoveEnterpriseMemberInput._(this._$data);

  factory Input$RemoveEnterpriseMemberInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$RemoveEnterpriseMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get userId => (_$data['userId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseMemberInput<Input$RemoveEnterpriseMemberInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseMemberInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveEnterpriseMemberInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseMemberInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseMemberInput(
    Input$RemoveEnterpriseMemberInput instance,
    TRes Function(Input$RemoveEnterpriseMemberInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseMemberInput;

  factory CopyWith$Input$RemoveEnterpriseMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseMemberInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? userId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseMemberInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseMemberInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseMemberInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseMemberInput _instance;

  final TRes Function(Input$RemoveEnterpriseMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseMemberInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseMemberInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseMemberInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseMemberInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? userId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseOrganizationInput {
  factory Input$RemoveEnterpriseOrganizationInput({
    String? clientMutationId,
    required String enterpriseId,
    required String organizationId,
  }) =>
      Input$RemoveEnterpriseOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
      });

  Input$RemoveEnterpriseOrganizationInput._(this._$data);

  factory Input$RemoveEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$RemoveEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get organizationId => (_$data['organizationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseOrganizationInput<
          Input$RemoveEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseOrganizationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveEnterpriseOrganizationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseOrganizationInput(
    Input$RemoveEnterpriseOrganizationInput instance,
    TRes Function(Input$RemoveEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput;

  factory CopyWith$Input$RemoveEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseOrganizationInput _instance;

  final TRes Function(Input$RemoveEnterpriseOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseSupportEntitlementInput {
  factory Input$RemoveEnterpriseSupportEntitlementInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$RemoveEnterpriseSupportEntitlementInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$RemoveEnterpriseSupportEntitlementInput._(this._$data);

  factory Input$RemoveEnterpriseSupportEntitlementInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$RemoveEnterpriseSupportEntitlementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get login => (_$data['login'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<
          Input$RemoveEnterpriseSupportEntitlementInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseSupportEntitlementInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveEnterpriseSupportEntitlementInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseSupportEntitlementInput(
    Input$RemoveEnterpriseSupportEntitlementInput instance,
    TRes Function(Input$RemoveEnterpriseSupportEntitlementInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput;

  factory CopyWith$Input$RemoveEnterpriseSupportEntitlementInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseSupportEntitlementInput _instance;

  final TRes Function(Input$RemoveEnterpriseSupportEntitlementInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseSupportEntitlementInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$RemoveLabelsFromLabelableInput {
  factory Input$RemoveLabelsFromLabelableInput({
    String? clientMutationId,
    required String labelableId,
    required List<String> labelIds,
  }) =>
      Input$RemoveLabelsFromLabelableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'labelableId': labelableId,
        r'labelIds': labelIds,
      });

  Input$RemoveLabelsFromLabelableInput._(this._$data);

  factory Input$RemoveLabelsFromLabelableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    final l$labelIds = data['labelIds'];
    result$data['labelIds'] =
        (l$labelIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$RemoveLabelsFromLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get labelableId => (_$data['labelableId'] as String);

  List<String> get labelIds => (_$data['labelIds'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    final l$labelIds = labelIds;
    result$data['labelIds'] = l$labelIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$RemoveLabelsFromLabelableInput<
          Input$RemoveLabelsFromLabelableInput>
      get copyWith => CopyWith$Input$RemoveLabelsFromLabelableInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveLabelsFromLabelableInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (l$labelIds.length != lOther$labelIds.length) {
      return false;
    }
    for (int i = 0; i < l$labelIds.length; i++) {
      final l$labelIds$entry = l$labelIds[i];
      final lOther$labelIds$entry = lOther$labelIds[i];
      if (l$labelIds$entry != lOther$labelIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$labelableId = labelableId;
    final l$labelIds = labelIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$labelableId,
      Object.hashAll(l$labelIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  factory CopyWith$Input$RemoveLabelsFromLabelableInput(
    Input$RemoveLabelsFromLabelableInput instance,
    TRes Function(Input$RemoveLabelsFromLabelableInput) then,
  ) = _CopyWithImpl$Input$RemoveLabelsFromLabelableInput;

  factory CopyWith$Input$RemoveLabelsFromLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput;

  TRes call({
    String? clientMutationId,
    String? labelableId,
    List<String>? labelIds,
  });
}

class _CopyWithImpl$Input$RemoveLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  _CopyWithImpl$Input$RemoveLabelsFromLabelableInput(
    this._instance,
    this._then,
  );

  final Input$RemoveLabelsFromLabelableInput _instance;

  final TRes Function(Input$RemoveLabelsFromLabelableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? labelableId = _undefined,
    Object? labelIds = _undefined,
  }) =>
      _then(Input$RemoveLabelsFromLabelableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
        if (labelIds != _undefined && labelIds != null)
          'labelIds': (labelIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? labelableId,
    List<String>? labelIds,
  }) =>
      _res;
}

class Input$RemoveOutsideCollaboratorInput {
  factory Input$RemoveOutsideCollaboratorInput({
    String? clientMutationId,
    required String userId,
    required String organizationId,
  }) =>
      Input$RemoveOutsideCollaboratorInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'userId': userId,
        r'organizationId': organizationId,
      });

  Input$RemoveOutsideCollaboratorInput._(this._$data);

  factory Input$RemoveOutsideCollaboratorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$RemoveOutsideCollaboratorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get userId => (_$data['userId'] as String);

  String get organizationId => (_$data['organizationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$RemoveOutsideCollaboratorInput<
          Input$RemoveOutsideCollaboratorInput>
      get copyWith => CopyWith$Input$RemoveOutsideCollaboratorInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveOutsideCollaboratorInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$userId = userId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$userId,
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  factory CopyWith$Input$RemoveOutsideCollaboratorInput(
    Input$RemoveOutsideCollaboratorInput instance,
    TRes Function(Input$RemoveOutsideCollaboratorInput) then,
  ) = _CopyWithImpl$Input$RemoveOutsideCollaboratorInput;

  factory CopyWith$Input$RemoveOutsideCollaboratorInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput;

  TRes call({
    String? clientMutationId,
    String? userId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$RemoveOutsideCollaboratorInput<TRes>
    implements CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  _CopyWithImpl$Input$RemoveOutsideCollaboratorInput(
    this._instance,
    this._then,
  );

  final Input$RemoveOutsideCollaboratorInput _instance;

  final TRes Function(Input$RemoveOutsideCollaboratorInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? userId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$RemoveOutsideCollaboratorInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput<TRes>
    implements CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? userId,
    String? organizationId,
  }) =>
      _res;
}

class Input$RemoveReactionInput {
  factory Input$RemoveReactionInput({
    String? clientMutationId,
    required String subjectId,
    required Enum$ReactionContent content,
  }) =>
      Input$RemoveReactionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
        r'content': content,
      });

  Input$RemoveReactionInput._(this._$data);

  factory Input$RemoveReactionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    final l$content = data['content'];
    result$data['content'] =
        fromJson$Enum$ReactionContent((l$content as String));
    return Input$RemoveReactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subjectId => (_$data['subjectId'] as String);

  Enum$ReactionContent get content =>
      (_$data['content'] as Enum$ReactionContent);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    final l$content = content;
    result$data['content'] = toJson$Enum$ReactionContent(l$content);
    return result$data;
  }

  CopyWith$Input$RemoveReactionInput<Input$RemoveReactionInput> get copyWith =>
      CopyWith$Input$RemoveReactionInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveReactionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    final l$content = content;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
      l$content,
    ]);
  }
}

abstract class CopyWith$Input$RemoveReactionInput<TRes> {
  factory CopyWith$Input$RemoveReactionInput(
    Input$RemoveReactionInput instance,
    TRes Function(Input$RemoveReactionInput) then,
  ) = _CopyWithImpl$Input$RemoveReactionInput;

  factory CopyWith$Input$RemoveReactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveReactionInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
    Enum$ReactionContent? content,
  });
}

class _CopyWithImpl$Input$RemoveReactionInput<TRes>
    implements CopyWith$Input$RemoveReactionInput<TRes> {
  _CopyWithImpl$Input$RemoveReactionInput(
    this._instance,
    this._then,
  );

  final Input$RemoveReactionInput _instance;

  final TRes Function(Input$RemoveReactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
    Object? content = _undefined,
  }) =>
      _then(Input$RemoveReactionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
        if (content != _undefined && content != null)
          'content': (content as Enum$ReactionContent),
      }));
}

class _CopyWithStubImpl$Input$RemoveReactionInput<TRes>
    implements CopyWith$Input$RemoveReactionInput<TRes> {
  _CopyWithStubImpl$Input$RemoveReactionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
    Enum$ReactionContent? content,
  }) =>
      _res;
}

class Input$RemoveStarInput {
  factory Input$RemoveStarInput({
    String? clientMutationId,
    required String starrableId,
  }) =>
      Input$RemoveStarInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'starrableId': starrableId,
      });

  Input$RemoveStarInput._(this._$data);

  factory Input$RemoveStarInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$starrableId = data['starrableId'];
    result$data['starrableId'] = (l$starrableId as String);
    return Input$RemoveStarInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get starrableId => (_$data['starrableId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$starrableId = starrableId;
    result$data['starrableId'] = l$starrableId;
    return result$data;
  }

  CopyWith$Input$RemoveStarInput<Input$RemoveStarInput> get copyWith =>
      CopyWith$Input$RemoveStarInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveStarInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$starrableId = starrableId;
    final lOther$starrableId = other.starrableId;
    if (l$starrableId != lOther$starrableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$starrableId = starrableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$starrableId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveStarInput<TRes> {
  factory CopyWith$Input$RemoveStarInput(
    Input$RemoveStarInput instance,
    TRes Function(Input$RemoveStarInput) then,
  ) = _CopyWithImpl$Input$RemoveStarInput;

  factory CopyWith$Input$RemoveStarInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveStarInput;

  TRes call({
    String? clientMutationId,
    String? starrableId,
  });
}

class _CopyWithImpl$Input$RemoveStarInput<TRes>
    implements CopyWith$Input$RemoveStarInput<TRes> {
  _CopyWithImpl$Input$RemoveStarInput(
    this._instance,
    this._then,
  );

  final Input$RemoveStarInput _instance;

  final TRes Function(Input$RemoveStarInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? starrableId = _undefined,
  }) =>
      _then(Input$RemoveStarInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (starrableId != _undefined && starrableId != null)
          'starrableId': (starrableId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveStarInput<TRes>
    implements CopyWith$Input$RemoveStarInput<TRes> {
  _CopyWithStubImpl$Input$RemoveStarInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? starrableId,
  }) =>
      _res;
}

class Input$RemoveSubIssueInput {
  factory Input$RemoveSubIssueInput({
    String? clientMutationId,
    required String issueId,
    required String subIssueId,
  }) =>
      Input$RemoveSubIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        r'subIssueId': subIssueId,
      });

  Input$RemoveSubIssueInput._(this._$data);

  factory Input$RemoveSubIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$subIssueId = data['subIssueId'];
    result$data['subIssueId'] = (l$subIssueId as String);
    return Input$RemoveSubIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  String get subIssueId => (_$data['subIssueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$subIssueId = subIssueId;
    result$data['subIssueId'] = l$subIssueId;
    return result$data;
  }

  CopyWith$Input$RemoveSubIssueInput<Input$RemoveSubIssueInput> get copyWith =>
      CopyWith$Input$RemoveSubIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveSubIssueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$subIssueId = subIssueId;
    final lOther$subIssueId = other.subIssueId;
    if (l$subIssueId != lOther$subIssueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$subIssueId = subIssueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      l$subIssueId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveSubIssueInput<TRes> {
  factory CopyWith$Input$RemoveSubIssueInput(
    Input$RemoveSubIssueInput instance,
    TRes Function(Input$RemoveSubIssueInput) then,
  ) = _CopyWithImpl$Input$RemoveSubIssueInput;

  factory CopyWith$Input$RemoveSubIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveSubIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? subIssueId,
  });
}

class _CopyWithImpl$Input$RemoveSubIssueInput<TRes>
    implements CopyWith$Input$RemoveSubIssueInput<TRes> {
  _CopyWithImpl$Input$RemoveSubIssueInput(
    this._instance,
    this._then,
  );

  final Input$RemoveSubIssueInput _instance;

  final TRes Function(Input$RemoveSubIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? subIssueId = _undefined,
  }) =>
      _then(Input$RemoveSubIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (subIssueId != _undefined && subIssueId != null)
          'subIssueId': (subIssueId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveSubIssueInput<TRes>
    implements CopyWith$Input$RemoveSubIssueInput<TRes> {
  _CopyWithStubImpl$Input$RemoveSubIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? subIssueId,
  }) =>
      _res;
}

class Input$RemoveUpvoteInput {
  factory Input$RemoveUpvoteInput({
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$RemoveUpvoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$RemoveUpvoteInput._(this._$data);

  factory Input$RemoveUpvoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$RemoveUpvoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subjectId => (_$data['subjectId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$RemoveUpvoteInput<Input$RemoveUpvoteInput> get copyWith =>
      CopyWith$Input$RemoveUpvoteInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RemoveUpvoteInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveUpvoteInput<TRes> {
  factory CopyWith$Input$RemoveUpvoteInput(
    Input$RemoveUpvoteInput instance,
    TRes Function(Input$RemoveUpvoteInput) then,
  ) = _CopyWithImpl$Input$RemoveUpvoteInput;

  factory CopyWith$Input$RemoveUpvoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveUpvoteInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$RemoveUpvoteInput<TRes>
    implements CopyWith$Input$RemoveUpvoteInput<TRes> {
  _CopyWithImpl$Input$RemoveUpvoteInput(
    this._instance,
    this._then,
  );

  final Input$RemoveUpvoteInput _instance;

  final TRes Function(Input$RemoveUpvoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$RemoveUpvoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveUpvoteInput<TRes>
    implements CopyWith$Input$RemoveUpvoteInput<TRes> {
  _CopyWithStubImpl$Input$RemoveUpvoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$ReopenDiscussionInput {
  factory Input$ReopenDiscussionInput({
    String? clientMutationId,
    required String discussionId,
  }) =>
      Input$ReopenDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
      });

  Input$ReopenDiscussionInput._(this._$data);

  factory Input$ReopenDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    return Input$ReopenDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get discussionId => (_$data['discussionId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    return result$data;
  }

  CopyWith$Input$ReopenDiscussionInput<Input$ReopenDiscussionInput>
      get copyWith => CopyWith$Input$ReopenDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReopenDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
    ]);
  }
}

abstract class CopyWith$Input$ReopenDiscussionInput<TRes> {
  factory CopyWith$Input$ReopenDiscussionInput(
    Input$ReopenDiscussionInput instance,
    TRes Function(Input$ReopenDiscussionInput) then,
  ) = _CopyWithImpl$Input$ReopenDiscussionInput;

  factory CopyWith$Input$ReopenDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? discussionId,
  });
}

class _CopyWithImpl$Input$ReopenDiscussionInput<TRes>
    implements CopyWith$Input$ReopenDiscussionInput<TRes> {
  _CopyWithImpl$Input$ReopenDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$ReopenDiscussionInput _instance;

  final TRes Function(Input$ReopenDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
  }) =>
      _then(Input$ReopenDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
      }));
}

class _CopyWithStubImpl$Input$ReopenDiscussionInput<TRes>
    implements CopyWith$Input$ReopenDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$ReopenDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? discussionId,
  }) =>
      _res;
}

class Input$ReopenIssueInput {
  factory Input$ReopenIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$ReopenIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$ReopenIssueInput._(this._$data);

  factory Input$ReopenIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$ReopenIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$ReopenIssueInput<Input$ReopenIssueInput> get copyWith =>
      CopyWith$Input$ReopenIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReopenIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$ReopenIssueInput<TRes> {
  factory CopyWith$Input$ReopenIssueInput(
    Input$ReopenIssueInput instance,
    TRes Function(Input$ReopenIssueInput) then,
  ) = _CopyWithImpl$Input$ReopenIssueInput;

  factory CopyWith$Input$ReopenIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$ReopenIssueInput<TRes>
    implements CopyWith$Input$ReopenIssueInput<TRes> {
  _CopyWithImpl$Input$ReopenIssueInput(
    this._instance,
    this._then,
  );

  final Input$ReopenIssueInput _instance;

  final TRes Function(Input$ReopenIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$ReopenIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$ReopenIssueInput<TRes>
    implements CopyWith$Input$ReopenIssueInput<TRes> {
  _CopyWithStubImpl$Input$ReopenIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$ReopenPullRequestInput {
  factory Input$ReopenPullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$ReopenPullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$ReopenPullRequestInput._(this._$data);

  factory Input$ReopenPullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$ReopenPullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$ReopenPullRequestInput<Input$ReopenPullRequestInput>
      get copyWith => CopyWith$Input$ReopenPullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReopenPullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$ReopenPullRequestInput<TRes> {
  factory CopyWith$Input$ReopenPullRequestInput(
    Input$ReopenPullRequestInput instance,
    TRes Function(Input$ReopenPullRequestInput) then,
  ) = _CopyWithImpl$Input$ReopenPullRequestInput;

  factory CopyWith$Input$ReopenPullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenPullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$ReopenPullRequestInput<TRes>
    implements CopyWith$Input$ReopenPullRequestInput<TRes> {
  _CopyWithImpl$Input$ReopenPullRequestInput(
    this._instance,
    this._then,
  );

  final Input$ReopenPullRequestInput _instance;

  final TRes Function(Input$ReopenPullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$ReopenPullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$ReopenPullRequestInput<TRes>
    implements CopyWith$Input$ReopenPullRequestInput<TRes> {
  _CopyWithStubImpl$Input$ReopenPullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$ReorderEnvironmentInput {
  factory Input$ReorderEnvironmentInput({
    String? clientMutationId,
    required String environmentId,
    required int position,
  }) =>
      Input$ReorderEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'environmentId': environmentId,
        r'position': position,
      });

  Input$ReorderEnvironmentInput._(this._$data);

  factory Input$ReorderEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$environmentId = data['environmentId'];
    result$data['environmentId'] = (l$environmentId as String);
    final l$position = data['position'];
    result$data['position'] = (l$position as int);
    return Input$ReorderEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get environmentId => (_$data['environmentId'] as String);

  int get position => (_$data['position'] as int);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$environmentId = environmentId;
    result$data['environmentId'] = l$environmentId;
    final l$position = position;
    result$data['position'] = l$position;
    return result$data;
  }

  CopyWith$Input$ReorderEnvironmentInput<Input$ReorderEnvironmentInput>
      get copyWith => CopyWith$Input$ReorderEnvironmentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReorderEnvironmentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$environmentId = environmentId;
    final lOther$environmentId = other.environmentId;
    if (l$environmentId != lOther$environmentId) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$environmentId = environmentId;
    final l$position = position;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$environmentId,
      l$position,
    ]);
  }
}

abstract class CopyWith$Input$ReorderEnvironmentInput<TRes> {
  factory CopyWith$Input$ReorderEnvironmentInput(
    Input$ReorderEnvironmentInput instance,
    TRes Function(Input$ReorderEnvironmentInput) then,
  ) = _CopyWithImpl$Input$ReorderEnvironmentInput;

  factory CopyWith$Input$ReorderEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReorderEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? environmentId,
    int? position,
  });
}

class _CopyWithImpl$Input$ReorderEnvironmentInput<TRes>
    implements CopyWith$Input$ReorderEnvironmentInput<TRes> {
  _CopyWithImpl$Input$ReorderEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$ReorderEnvironmentInput _instance;

  final TRes Function(Input$ReorderEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? environmentId = _undefined,
    Object? position = _undefined,
  }) =>
      _then(Input$ReorderEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (environmentId != _undefined && environmentId != null)
          'environmentId': (environmentId as String),
        if (position != _undefined && position != null)
          'position': (position as int),
      }));
}

class _CopyWithStubImpl$Input$ReorderEnvironmentInput<TRes>
    implements CopyWith$Input$ReorderEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$ReorderEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? environmentId,
    int? position,
  }) =>
      _res;
}

class Input$ReplaceActorsForAssignableInput {
  factory Input$ReplaceActorsForAssignableInput({
    String? clientMutationId,
    required String assignableId,
    required List<String> actorIds,
  }) =>
      Input$ReplaceActorsForAssignableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'assignableId': assignableId,
        r'actorIds': actorIds,
      });

  Input$ReplaceActorsForAssignableInput._(this._$data);

  factory Input$ReplaceActorsForAssignableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$assignableId = data['assignableId'];
    result$data['assignableId'] = (l$assignableId as String);
    final l$actorIds = data['actorIds'];
    result$data['actorIds'] =
        (l$actorIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$ReplaceActorsForAssignableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get assignableId => (_$data['assignableId'] as String);

  List<String> get actorIds => (_$data['actorIds'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$assignableId = assignableId;
    result$data['assignableId'] = l$assignableId;
    final l$actorIds = actorIds;
    result$data['actorIds'] = l$actorIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$ReplaceActorsForAssignableInput<
          Input$ReplaceActorsForAssignableInput>
      get copyWith => CopyWith$Input$ReplaceActorsForAssignableInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReplaceActorsForAssignableInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$assignableId = assignableId;
    final lOther$assignableId = other.assignableId;
    if (l$assignableId != lOther$assignableId) {
      return false;
    }
    final l$actorIds = actorIds;
    final lOther$actorIds = other.actorIds;
    if (l$actorIds.length != lOther$actorIds.length) {
      return false;
    }
    for (int i = 0; i < l$actorIds.length; i++) {
      final l$actorIds$entry = l$actorIds[i];
      final lOther$actorIds$entry = lOther$actorIds[i];
      if (l$actorIds$entry != lOther$actorIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$assignableId = assignableId;
    final l$actorIds = actorIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$assignableId,
      Object.hashAll(l$actorIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$ReplaceActorsForAssignableInput<TRes> {
  factory CopyWith$Input$ReplaceActorsForAssignableInput(
    Input$ReplaceActorsForAssignableInput instance,
    TRes Function(Input$ReplaceActorsForAssignableInput) then,
  ) = _CopyWithImpl$Input$ReplaceActorsForAssignableInput;

  factory CopyWith$Input$ReplaceActorsForAssignableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReplaceActorsForAssignableInput;

  TRes call({
    String? clientMutationId,
    String? assignableId,
    List<String>? actorIds,
  });
}

class _CopyWithImpl$Input$ReplaceActorsForAssignableInput<TRes>
    implements CopyWith$Input$ReplaceActorsForAssignableInput<TRes> {
  _CopyWithImpl$Input$ReplaceActorsForAssignableInput(
    this._instance,
    this._then,
  );

  final Input$ReplaceActorsForAssignableInput _instance;

  final TRes Function(Input$ReplaceActorsForAssignableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? assignableId = _undefined,
    Object? actorIds = _undefined,
  }) =>
      _then(Input$ReplaceActorsForAssignableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (assignableId != _undefined && assignableId != null)
          'assignableId': (assignableId as String),
        if (actorIds != _undefined && actorIds != null)
          'actorIds': (actorIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$ReplaceActorsForAssignableInput<TRes>
    implements CopyWith$Input$ReplaceActorsForAssignableInput<TRes> {
  _CopyWithStubImpl$Input$ReplaceActorsForAssignableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? assignableId,
    List<String>? actorIds,
  }) =>
      _res;
}

class Input$RepositoryIdConditionTargetInput {
  factory Input$RepositoryIdConditionTargetInput(
          {required List<String> repositoryIds}) =>
      Input$RepositoryIdConditionTargetInput._({
        r'repositoryIds': repositoryIds,
      });

  Input$RepositoryIdConditionTargetInput._(this._$data);

  factory Input$RepositoryIdConditionTargetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$repositoryIds = data['repositoryIds'];
    result$data['repositoryIds'] =
        (l$repositoryIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$RepositoryIdConditionTargetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get repositoryIds => (_$data['repositoryIds'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$repositoryIds = repositoryIds;
    result$data['repositoryIds'] = l$repositoryIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$RepositoryIdConditionTargetInput<
          Input$RepositoryIdConditionTargetInput>
      get copyWith => CopyWith$Input$RepositoryIdConditionTargetInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryIdConditionTargetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$repositoryIds = repositoryIds;
    final lOther$repositoryIds = other.repositoryIds;
    if (l$repositoryIds.length != lOther$repositoryIds.length) {
      return false;
    }
    for (int i = 0; i < l$repositoryIds.length; i++) {
      final l$repositoryIds$entry = l$repositoryIds[i];
      final lOther$repositoryIds$entry = lOther$repositoryIds[i];
      if (l$repositoryIds$entry != lOther$repositoryIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$repositoryIds = repositoryIds;
    return Object.hashAll([Object.hashAll(l$repositoryIds.map((v) => v))]);
  }
}

abstract class CopyWith$Input$RepositoryIdConditionTargetInput<TRes> {
  factory CopyWith$Input$RepositoryIdConditionTargetInput(
    Input$RepositoryIdConditionTargetInput instance,
    TRes Function(Input$RepositoryIdConditionTargetInput) then,
  ) = _CopyWithImpl$Input$RepositoryIdConditionTargetInput;

  factory CopyWith$Input$RepositoryIdConditionTargetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryIdConditionTargetInput;

  TRes call({List<String>? repositoryIds});
}

class _CopyWithImpl$Input$RepositoryIdConditionTargetInput<TRes>
    implements CopyWith$Input$RepositoryIdConditionTargetInput<TRes> {
  _CopyWithImpl$Input$RepositoryIdConditionTargetInput(
    this._instance,
    this._then,
  );

  final Input$RepositoryIdConditionTargetInput _instance;

  final TRes Function(Input$RepositoryIdConditionTargetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? repositoryIds = _undefined}) =>
      _then(Input$RepositoryIdConditionTargetInput._({
        ..._instance._$data,
        if (repositoryIds != _undefined && repositoryIds != null)
          'repositoryIds': (repositoryIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$RepositoryIdConditionTargetInput<TRes>
    implements CopyWith$Input$RepositoryIdConditionTargetInput<TRes> {
  _CopyWithStubImpl$Input$RepositoryIdConditionTargetInput(this._res);

  TRes _res;

  call({List<String>? repositoryIds}) => _res;
}

class Input$RepositoryInvitationOrder {
  factory Input$RepositoryInvitationOrder({
    required Enum$RepositoryInvitationOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$RepositoryInvitationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RepositoryInvitationOrder._(this._$data);

  factory Input$RepositoryInvitationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryInvitationOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$RepositoryInvitationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryInvitationOrderField get field =>
      (_$data['field'] as Enum$RepositoryInvitationOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryInvitationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RepositoryInvitationOrder<Input$RepositoryInvitationOrder>
      get copyWith => CopyWith$Input$RepositoryInvitationOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryInvitationOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryInvitationOrder<TRes> {
  factory CopyWith$Input$RepositoryInvitationOrder(
    Input$RepositoryInvitationOrder instance,
    TRes Function(Input$RepositoryInvitationOrder) then,
  ) = _CopyWithImpl$Input$RepositoryInvitationOrder;

  factory CopyWith$Input$RepositoryInvitationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryInvitationOrder;

  TRes call({
    Enum$RepositoryInvitationOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RepositoryInvitationOrder<TRes>
    implements CopyWith$Input$RepositoryInvitationOrder<TRes> {
  _CopyWithImpl$Input$RepositoryInvitationOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryInvitationOrder _instance;

  final TRes Function(Input$RepositoryInvitationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RepositoryInvitationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryInvitationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RepositoryInvitationOrder<TRes>
    implements CopyWith$Input$RepositoryInvitationOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryInvitationOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryInvitationOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RepositoryMigrationOrder {
  factory Input$RepositoryMigrationOrder({
    required Enum$RepositoryMigrationOrderField field,
    required Enum$RepositoryMigrationOrderDirection direction,
  }) =>
      Input$RepositoryMigrationOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RepositoryMigrationOrder._(this._$data);

  factory Input$RepositoryMigrationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryMigrationOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] = fromJson$Enum$RepositoryMigrationOrderDirection(
        (l$direction as String));
    return Input$RepositoryMigrationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryMigrationOrderField get field =>
      (_$data['field'] as Enum$RepositoryMigrationOrderField);

  Enum$RepositoryMigrationOrderDirection get direction =>
      (_$data['direction'] as Enum$RepositoryMigrationOrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryMigrationOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] =
        toJson$Enum$RepositoryMigrationOrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RepositoryMigrationOrder<Input$RepositoryMigrationOrder>
      get copyWith => CopyWith$Input$RepositoryMigrationOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryMigrationOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryMigrationOrder<TRes> {
  factory CopyWith$Input$RepositoryMigrationOrder(
    Input$RepositoryMigrationOrder instance,
    TRes Function(Input$RepositoryMigrationOrder) then,
  ) = _CopyWithImpl$Input$RepositoryMigrationOrder;

  factory CopyWith$Input$RepositoryMigrationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryMigrationOrder;

  TRes call({
    Enum$RepositoryMigrationOrderField? field,
    Enum$RepositoryMigrationOrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RepositoryMigrationOrder<TRes>
    implements CopyWith$Input$RepositoryMigrationOrder<TRes> {
  _CopyWithImpl$Input$RepositoryMigrationOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryMigrationOrder _instance;

  final TRes Function(Input$RepositoryMigrationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RepositoryMigrationOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryMigrationOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$RepositoryMigrationOrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RepositoryMigrationOrder<TRes>
    implements CopyWith$Input$RepositoryMigrationOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryMigrationOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryMigrationOrderField? field,
    Enum$RepositoryMigrationOrderDirection? direction,
  }) =>
      _res;
}

class Input$RepositoryNameConditionTargetInput {
  factory Input$RepositoryNameConditionTargetInput({
    required List<String> exclude,
    required List<String> include,
    bool? protected,
  }) =>
      Input$RepositoryNameConditionTargetInput._({
        r'exclude': exclude,
        r'include': include,
        if (protected != null) r'protected': protected,
      });

  Input$RepositoryNameConditionTargetInput._(this._$data);

  factory Input$RepositoryNameConditionTargetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$exclude = data['exclude'];
    result$data['exclude'] =
        (l$exclude as List<dynamic>).map((e) => (e as String)).toList();
    final l$include = data['include'];
    result$data['include'] =
        (l$include as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('protected')) {
      final l$protected = data['protected'];
      result$data['protected'] = (l$protected as bool?);
    }
    return Input$RepositoryNameConditionTargetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get exclude => (_$data['exclude'] as List<String>);

  List<String> get include => (_$data['include'] as List<String>);

  bool? get protected => (_$data['protected'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$exclude = exclude;
    result$data['exclude'] = l$exclude.map((e) => e).toList();
    final l$include = include;
    result$data['include'] = l$include.map((e) => e).toList();
    if (_$data.containsKey('protected')) {
      final l$protected = protected;
      result$data['protected'] = l$protected;
    }
    return result$data;
  }

  CopyWith$Input$RepositoryNameConditionTargetInput<
          Input$RepositoryNameConditionTargetInput>
      get copyWith => CopyWith$Input$RepositoryNameConditionTargetInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryNameConditionTargetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$exclude = exclude;
    final lOther$exclude = other.exclude;
    if (l$exclude.length != lOther$exclude.length) {
      return false;
    }
    for (int i = 0; i < l$exclude.length; i++) {
      final l$exclude$entry = l$exclude[i];
      final lOther$exclude$entry = lOther$exclude[i];
      if (l$exclude$entry != lOther$exclude$entry) {
        return false;
      }
    }
    final l$include = include;
    final lOther$include = other.include;
    if (l$include.length != lOther$include.length) {
      return false;
    }
    for (int i = 0; i < l$include.length; i++) {
      final l$include$entry = l$include[i];
      final lOther$include$entry = lOther$include[i];
      if (l$include$entry != lOther$include$entry) {
        return false;
      }
    }
    final l$protected = protected;
    final lOther$protected = other.protected;
    if (_$data.containsKey('protected') !=
        other._$data.containsKey('protected')) {
      return false;
    }
    if (l$protected != lOther$protected) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$exclude = exclude;
    final l$include = include;
    final l$protected = protected;
    return Object.hashAll([
      Object.hashAll(l$exclude.map((v) => v)),
      Object.hashAll(l$include.map((v) => v)),
      _$data.containsKey('protected') ? l$protected : const {},
    ]);
  }
}

abstract class CopyWith$Input$RepositoryNameConditionTargetInput<TRes> {
  factory CopyWith$Input$RepositoryNameConditionTargetInput(
    Input$RepositoryNameConditionTargetInput instance,
    TRes Function(Input$RepositoryNameConditionTargetInput) then,
  ) = _CopyWithImpl$Input$RepositoryNameConditionTargetInput;

  factory CopyWith$Input$RepositoryNameConditionTargetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryNameConditionTargetInput;

  TRes call({
    List<String>? exclude,
    List<String>? include,
    bool? protected,
  });
}

class _CopyWithImpl$Input$RepositoryNameConditionTargetInput<TRes>
    implements CopyWith$Input$RepositoryNameConditionTargetInput<TRes> {
  _CopyWithImpl$Input$RepositoryNameConditionTargetInput(
    this._instance,
    this._then,
  );

  final Input$RepositoryNameConditionTargetInput _instance;

  final TRes Function(Input$RepositoryNameConditionTargetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? exclude = _undefined,
    Object? include = _undefined,
    Object? protected = _undefined,
  }) =>
      _then(Input$RepositoryNameConditionTargetInput._({
        ..._instance._$data,
        if (exclude != _undefined && exclude != null)
          'exclude': (exclude as List<String>),
        if (include != _undefined && include != null)
          'include': (include as List<String>),
        if (protected != _undefined) 'protected': (protected as bool?),
      }));
}

class _CopyWithStubImpl$Input$RepositoryNameConditionTargetInput<TRes>
    implements CopyWith$Input$RepositoryNameConditionTargetInput<TRes> {
  _CopyWithStubImpl$Input$RepositoryNameConditionTargetInput(this._res);

  TRes _res;

  call({
    List<String>? exclude,
    List<String>? include,
    bool? protected,
  }) =>
      _res;
}

class Input$RepositoryOrder {
  factory Input$RepositoryOrder({
    required Enum$RepositoryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$RepositoryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RepositoryOrder._(this._$data);

  factory Input$RepositoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$RepositoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryOrderField get field =>
      (_$data['field'] as Enum$RepositoryOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RepositoryOrder<Input$RepositoryOrder> get copyWith =>
      CopyWith$Input$RepositoryOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryOrder<TRes> {
  factory CopyWith$Input$RepositoryOrder(
    Input$RepositoryOrder instance,
    TRes Function(Input$RepositoryOrder) then,
  ) = _CopyWithImpl$Input$RepositoryOrder;

  factory CopyWith$Input$RepositoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryOrder;

  TRes call({
    Enum$RepositoryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RepositoryOrder<TRes>
    implements CopyWith$Input$RepositoryOrder<TRes> {
  _CopyWithImpl$Input$RepositoryOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryOrder _instance;

  final TRes Function(Input$RepositoryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RepositoryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RepositoryOrder<TRes>
    implements CopyWith$Input$RepositoryOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RepositoryPropertyConditionTargetInput {
  factory Input$RepositoryPropertyConditionTargetInput({
    required List<Input$PropertyTargetDefinitionInput> exclude,
    required List<Input$PropertyTargetDefinitionInput> include,
  }) =>
      Input$RepositoryPropertyConditionTargetInput._({
        r'exclude': exclude,
        r'include': include,
      });

  Input$RepositoryPropertyConditionTargetInput._(this._$data);

  factory Input$RepositoryPropertyConditionTargetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$exclude = data['exclude'];
    result$data['exclude'] = (l$exclude as List<dynamic>)
        .map((e) => Input$PropertyTargetDefinitionInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    final l$include = data['include'];
    result$data['include'] = (l$include as List<dynamic>)
        .map((e) => Input$PropertyTargetDefinitionInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    return Input$RepositoryPropertyConditionTargetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PropertyTargetDefinitionInput> get exclude =>
      (_$data['exclude'] as List<Input$PropertyTargetDefinitionInput>);

  List<Input$PropertyTargetDefinitionInput> get include =>
      (_$data['include'] as List<Input$PropertyTargetDefinitionInput>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$exclude = exclude;
    result$data['exclude'] = l$exclude.map((e) => e.toJson()).toList();
    final l$include = include;
    result$data['include'] = l$include.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$RepositoryPropertyConditionTargetInput<
          Input$RepositoryPropertyConditionTargetInput>
      get copyWith => CopyWith$Input$RepositoryPropertyConditionTargetInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryPropertyConditionTargetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$exclude = exclude;
    final lOther$exclude = other.exclude;
    if (l$exclude.length != lOther$exclude.length) {
      return false;
    }
    for (int i = 0; i < l$exclude.length; i++) {
      final l$exclude$entry = l$exclude[i];
      final lOther$exclude$entry = lOther$exclude[i];
      if (l$exclude$entry != lOther$exclude$entry) {
        return false;
      }
    }
    final l$include = include;
    final lOther$include = other.include;
    if (l$include.length != lOther$include.length) {
      return false;
    }
    for (int i = 0; i < l$include.length; i++) {
      final l$include$entry = l$include[i];
      final lOther$include$entry = lOther$include[i];
      if (l$include$entry != lOther$include$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$exclude = exclude;
    final l$include = include;
    return Object.hashAll([
      Object.hashAll(l$exclude.map((v) => v)),
      Object.hashAll(l$include.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$RepositoryPropertyConditionTargetInput<TRes> {
  factory CopyWith$Input$RepositoryPropertyConditionTargetInput(
    Input$RepositoryPropertyConditionTargetInput instance,
    TRes Function(Input$RepositoryPropertyConditionTargetInput) then,
  ) = _CopyWithImpl$Input$RepositoryPropertyConditionTargetInput;

  factory CopyWith$Input$RepositoryPropertyConditionTargetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryPropertyConditionTargetInput;

  TRes call({
    List<Input$PropertyTargetDefinitionInput>? exclude,
    List<Input$PropertyTargetDefinitionInput>? include,
  });
  TRes exclude(
      Iterable<Input$PropertyTargetDefinitionInput> Function(
              Iterable<
                  CopyWith$Input$PropertyTargetDefinitionInput<
                      Input$PropertyTargetDefinitionInput>>)
          _fn);
  TRes include(
      Iterable<Input$PropertyTargetDefinitionInput> Function(
              Iterable<
                  CopyWith$Input$PropertyTargetDefinitionInput<
                      Input$PropertyTargetDefinitionInput>>)
          _fn);
}

class _CopyWithImpl$Input$RepositoryPropertyConditionTargetInput<TRes>
    implements CopyWith$Input$RepositoryPropertyConditionTargetInput<TRes> {
  _CopyWithImpl$Input$RepositoryPropertyConditionTargetInput(
    this._instance,
    this._then,
  );

  final Input$RepositoryPropertyConditionTargetInput _instance;

  final TRes Function(Input$RepositoryPropertyConditionTargetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? exclude = _undefined,
    Object? include = _undefined,
  }) =>
      _then(Input$RepositoryPropertyConditionTargetInput._({
        ..._instance._$data,
        if (exclude != _undefined && exclude != null)
          'exclude': (exclude as List<Input$PropertyTargetDefinitionInput>),
        if (include != _undefined && include != null)
          'include': (include as List<Input$PropertyTargetDefinitionInput>),
      }));

  TRes exclude(
          Iterable<Input$PropertyTargetDefinitionInput> Function(
                  Iterable<
                      CopyWith$Input$PropertyTargetDefinitionInput<
                          Input$PropertyTargetDefinitionInput>>)
              _fn) =>
      call(
          exclude: _fn(_instance.exclude
              .map((e) => CopyWith$Input$PropertyTargetDefinitionInput(
                    e,
                    (i) => i,
                  ))).toList());

  TRes include(
          Iterable<Input$PropertyTargetDefinitionInput> Function(
                  Iterable<
                      CopyWith$Input$PropertyTargetDefinitionInput<
                          Input$PropertyTargetDefinitionInput>>)
              _fn) =>
      call(
          include: _fn(_instance.include
              .map((e) => CopyWith$Input$PropertyTargetDefinitionInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$RepositoryPropertyConditionTargetInput<TRes>
    implements CopyWith$Input$RepositoryPropertyConditionTargetInput<TRes> {
  _CopyWithStubImpl$Input$RepositoryPropertyConditionTargetInput(this._res);

  TRes _res;

  call({
    List<Input$PropertyTargetDefinitionInput>? exclude,
    List<Input$PropertyTargetDefinitionInput>? include,
  }) =>
      _res;

  exclude(_fn) => _res;

  include(_fn) => _res;
}

class Input$RepositoryRuleConditionsInput {
  factory Input$RepositoryRuleConditionsInput({
    Input$RefNameConditionTargetInput? refName,
    Input$RepositoryNameConditionTargetInput? repositoryName,
    Input$RepositoryIdConditionTargetInput? repositoryId,
    Input$RepositoryPropertyConditionTargetInput? repositoryProperty,
  }) =>
      Input$RepositoryRuleConditionsInput._({
        if (refName != null) r'refName': refName,
        if (repositoryName != null) r'repositoryName': repositoryName,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (repositoryProperty != null)
          r'repositoryProperty': repositoryProperty,
      });

  Input$RepositoryRuleConditionsInput._(this._$data);

  factory Input$RepositoryRuleConditionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('refName')) {
      final l$refName = data['refName'];
      result$data['refName'] = l$refName == null
          ? null
          : Input$RefNameConditionTargetInput.fromJson(
              (l$refName as Map<String, dynamic>));
    }
    if (data.containsKey('repositoryName')) {
      final l$repositoryName = data['repositoryName'];
      result$data['repositoryName'] = l$repositoryName == null
          ? null
          : Input$RepositoryNameConditionTargetInput.fromJson(
              (l$repositoryName as Map<String, dynamic>));
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = l$repositoryId == null
          ? null
          : Input$RepositoryIdConditionTargetInput.fromJson(
              (l$repositoryId as Map<String, dynamic>));
    }
    if (data.containsKey('repositoryProperty')) {
      final l$repositoryProperty = data['repositoryProperty'];
      result$data['repositoryProperty'] = l$repositoryProperty == null
          ? null
          : Input$RepositoryPropertyConditionTargetInput.fromJson(
              (l$repositoryProperty as Map<String, dynamic>));
    }
    return Input$RepositoryRuleConditionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$RefNameConditionTargetInput? get refName =>
      (_$data['refName'] as Input$RefNameConditionTargetInput?);

  Input$RepositoryNameConditionTargetInput? get repositoryName =>
      (_$data['repositoryName'] as Input$RepositoryNameConditionTargetInput?);

  Input$RepositoryIdConditionTargetInput? get repositoryId =>
      (_$data['repositoryId'] as Input$RepositoryIdConditionTargetInput?);

  Input$RepositoryPropertyConditionTargetInput? get repositoryProperty =>
      (_$data['repositoryProperty']
          as Input$RepositoryPropertyConditionTargetInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('refName')) {
      final l$refName = refName;
      result$data['refName'] = l$refName?.toJson();
    }
    if (_$data.containsKey('repositoryName')) {
      final l$repositoryName = repositoryName;
      result$data['repositoryName'] = l$repositoryName?.toJson();
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId?.toJson();
    }
    if (_$data.containsKey('repositoryProperty')) {
      final l$repositoryProperty = repositoryProperty;
      result$data['repositoryProperty'] = l$repositoryProperty?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RepositoryRuleConditionsInput<
          Input$RepositoryRuleConditionsInput>
      get copyWith => CopyWith$Input$RepositoryRuleConditionsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryRuleConditionsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refName = refName;
    final lOther$refName = other.refName;
    if (_$data.containsKey('refName') != other._$data.containsKey('refName')) {
      return false;
    }
    if (l$refName != lOther$refName) {
      return false;
    }
    final l$repositoryName = repositoryName;
    final lOther$repositoryName = other.repositoryName;
    if (_$data.containsKey('repositoryName') !=
        other._$data.containsKey('repositoryName')) {
      return false;
    }
    if (l$repositoryName != lOther$repositoryName) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$repositoryProperty = repositoryProperty;
    final lOther$repositoryProperty = other.repositoryProperty;
    if (_$data.containsKey('repositoryProperty') !=
        other._$data.containsKey('repositoryProperty')) {
      return false;
    }
    if (l$repositoryProperty != lOther$repositoryProperty) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refName = refName;
    final l$repositoryName = repositoryName;
    final l$repositoryId = repositoryId;
    final l$repositoryProperty = repositoryProperty;
    return Object.hashAll([
      _$data.containsKey('refName') ? l$refName : const {},
      _$data.containsKey('repositoryName') ? l$repositoryName : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('repositoryProperty')
          ? l$repositoryProperty
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RepositoryRuleConditionsInput<TRes> {
  factory CopyWith$Input$RepositoryRuleConditionsInput(
    Input$RepositoryRuleConditionsInput instance,
    TRes Function(Input$RepositoryRuleConditionsInput) then,
  ) = _CopyWithImpl$Input$RepositoryRuleConditionsInput;

  factory CopyWith$Input$RepositoryRuleConditionsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryRuleConditionsInput;

  TRes call({
    Input$RefNameConditionTargetInput? refName,
    Input$RepositoryNameConditionTargetInput? repositoryName,
    Input$RepositoryIdConditionTargetInput? repositoryId,
    Input$RepositoryPropertyConditionTargetInput? repositoryProperty,
  });
  CopyWith$Input$RefNameConditionTargetInput<TRes> get refName;
  CopyWith$Input$RepositoryNameConditionTargetInput<TRes> get repositoryName;
  CopyWith$Input$RepositoryIdConditionTargetInput<TRes> get repositoryId;
  CopyWith$Input$RepositoryPropertyConditionTargetInput<TRes>
      get repositoryProperty;
}

class _CopyWithImpl$Input$RepositoryRuleConditionsInput<TRes>
    implements CopyWith$Input$RepositoryRuleConditionsInput<TRes> {
  _CopyWithImpl$Input$RepositoryRuleConditionsInput(
    this._instance,
    this._then,
  );

  final Input$RepositoryRuleConditionsInput _instance;

  final TRes Function(Input$RepositoryRuleConditionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? refName = _undefined,
    Object? repositoryName = _undefined,
    Object? repositoryId = _undefined,
    Object? repositoryProperty = _undefined,
  }) =>
      _then(Input$RepositoryRuleConditionsInput._({
        ..._instance._$data,
        if (refName != _undefined)
          'refName': (refName as Input$RefNameConditionTargetInput?),
        if (repositoryName != _undefined)
          'repositoryName':
              (repositoryName as Input$RepositoryNameConditionTargetInput?),
        if (repositoryId != _undefined)
          'repositoryId':
              (repositoryId as Input$RepositoryIdConditionTargetInput?),
        if (repositoryProperty != _undefined)
          'repositoryProperty': (repositoryProperty
              as Input$RepositoryPropertyConditionTargetInput?),
      }));

  CopyWith$Input$RefNameConditionTargetInput<TRes> get refName {
    final local$refName = _instance.refName;
    return local$refName == null
        ? CopyWith$Input$RefNameConditionTargetInput.stub(_then(_instance))
        : CopyWith$Input$RefNameConditionTargetInput(
            local$refName, (e) => call(refName: e));
  }

  CopyWith$Input$RepositoryNameConditionTargetInput<TRes> get repositoryName {
    final local$repositoryName = _instance.repositoryName;
    return local$repositoryName == null
        ? CopyWith$Input$RepositoryNameConditionTargetInput.stub(
            _then(_instance))
        : CopyWith$Input$RepositoryNameConditionTargetInput(
            local$repositoryName, (e) => call(repositoryName: e));
  }

  CopyWith$Input$RepositoryIdConditionTargetInput<TRes> get repositoryId {
    final local$repositoryId = _instance.repositoryId;
    return local$repositoryId == null
        ? CopyWith$Input$RepositoryIdConditionTargetInput.stub(_then(_instance))
        : CopyWith$Input$RepositoryIdConditionTargetInput(
            local$repositoryId, (e) => call(repositoryId: e));
  }

  CopyWith$Input$RepositoryPropertyConditionTargetInput<TRes>
      get repositoryProperty {
    final local$repositoryProperty = _instance.repositoryProperty;
    return local$repositoryProperty == null
        ? CopyWith$Input$RepositoryPropertyConditionTargetInput.stub(
            _then(_instance))
        : CopyWith$Input$RepositoryPropertyConditionTargetInput(
            local$repositoryProperty, (e) => call(repositoryProperty: e));
  }
}

class _CopyWithStubImpl$Input$RepositoryRuleConditionsInput<TRes>
    implements CopyWith$Input$RepositoryRuleConditionsInput<TRes> {
  _CopyWithStubImpl$Input$RepositoryRuleConditionsInput(this._res);

  TRes _res;

  call({
    Input$RefNameConditionTargetInput? refName,
    Input$RepositoryNameConditionTargetInput? repositoryName,
    Input$RepositoryIdConditionTargetInput? repositoryId,
    Input$RepositoryPropertyConditionTargetInput? repositoryProperty,
  }) =>
      _res;

  CopyWith$Input$RefNameConditionTargetInput<TRes> get refName =>
      CopyWith$Input$RefNameConditionTargetInput.stub(_res);

  CopyWith$Input$RepositoryNameConditionTargetInput<TRes> get repositoryName =>
      CopyWith$Input$RepositoryNameConditionTargetInput.stub(_res);

  CopyWith$Input$RepositoryIdConditionTargetInput<TRes> get repositoryId =>
      CopyWith$Input$RepositoryIdConditionTargetInput.stub(_res);

  CopyWith$Input$RepositoryPropertyConditionTargetInput<TRes>
      get repositoryProperty =>
          CopyWith$Input$RepositoryPropertyConditionTargetInput.stub(_res);
}

class Input$RepositoryRuleInput {
  factory Input$RepositoryRuleInput({
    String? id,
    required Enum$RepositoryRuleType type,
    Input$RuleParametersInput? parameters,
  }) =>
      Input$RepositoryRuleInput._({
        if (id != null) r'id': id,
        r'type': type,
        if (parameters != null) r'parameters': parameters,
      });

  Input$RepositoryRuleInput._(this._$data);

  factory Input$RepositoryRuleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$RepositoryRuleType((l$type as String));
    if (data.containsKey('parameters')) {
      final l$parameters = data['parameters'];
      result$data['parameters'] = l$parameters == null
          ? null
          : Input$RuleParametersInput.fromJson(
              (l$parameters as Map<String, dynamic>));
    }
    return Input$RepositoryRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);

  Enum$RepositoryRuleType get type =>
      (_$data['type'] as Enum$RepositoryRuleType);

  Input$RuleParametersInput? get parameters =>
      (_$data['parameters'] as Input$RuleParametersInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$type = type;
    result$data['type'] = toJson$Enum$RepositoryRuleType(l$type);
    if (_$data.containsKey('parameters')) {
      final l$parameters = parameters;
      result$data['parameters'] = l$parameters?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RepositoryRuleInput<Input$RepositoryRuleInput> get copyWith =>
      CopyWith$Input$RepositoryRuleInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryRuleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$parameters = parameters;
    final lOther$parameters = other.parameters;
    if (_$data.containsKey('parameters') !=
        other._$data.containsKey('parameters')) {
      return false;
    }
    if (l$parameters != lOther$parameters) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$type = type;
    final l$parameters = parameters;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$type,
      _$data.containsKey('parameters') ? l$parameters : const {},
    ]);
  }
}

abstract class CopyWith$Input$RepositoryRuleInput<TRes> {
  factory CopyWith$Input$RepositoryRuleInput(
    Input$RepositoryRuleInput instance,
    TRes Function(Input$RepositoryRuleInput) then,
  ) = _CopyWithImpl$Input$RepositoryRuleInput;

  factory CopyWith$Input$RepositoryRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryRuleInput;

  TRes call({
    String? id,
    Enum$RepositoryRuleType? type,
    Input$RuleParametersInput? parameters,
  });
  CopyWith$Input$RuleParametersInput<TRes> get parameters;
}

class _CopyWithImpl$Input$RepositoryRuleInput<TRes>
    implements CopyWith$Input$RepositoryRuleInput<TRes> {
  _CopyWithImpl$Input$RepositoryRuleInput(
    this._instance,
    this._then,
  );

  final Input$RepositoryRuleInput _instance;

  final TRes Function(Input$RepositoryRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? type = _undefined,
    Object? parameters = _undefined,
  }) =>
      _then(Input$RepositoryRuleInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (type != _undefined && type != null)
          'type': (type as Enum$RepositoryRuleType),
        if (parameters != _undefined)
          'parameters': (parameters as Input$RuleParametersInput?),
      }));

  CopyWith$Input$RuleParametersInput<TRes> get parameters {
    final local$parameters = _instance.parameters;
    return local$parameters == null
        ? CopyWith$Input$RuleParametersInput.stub(_then(_instance))
        : CopyWith$Input$RuleParametersInput(
            local$parameters, (e) => call(parameters: e));
  }
}

class _CopyWithStubImpl$Input$RepositoryRuleInput<TRes>
    implements CopyWith$Input$RepositoryRuleInput<TRes> {
  _CopyWithStubImpl$Input$RepositoryRuleInput(this._res);

  TRes _res;

  call({
    String? id,
    Enum$RepositoryRuleType? type,
    Input$RuleParametersInput? parameters,
  }) =>
      _res;

  CopyWith$Input$RuleParametersInput<TRes> get parameters =>
      CopyWith$Input$RuleParametersInput.stub(_res);
}

class Input$RepositoryRuleOrder {
  factory Input$RepositoryRuleOrder({
    required Enum$RepositoryRuleOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$RepositoryRuleOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$RepositoryRuleOrder._(this._$data);

  factory Input$RepositoryRuleOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryRuleOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$RepositoryRuleOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryRuleOrderField get field =>
      (_$data['field'] as Enum$RepositoryRuleOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryRuleOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$RepositoryRuleOrder<Input$RepositoryRuleOrder> get copyWith =>
      CopyWith$Input$RepositoryRuleOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryRuleOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryRuleOrder<TRes> {
  factory CopyWith$Input$RepositoryRuleOrder(
    Input$RepositoryRuleOrder instance,
    TRes Function(Input$RepositoryRuleOrder) then,
  ) = _CopyWithImpl$Input$RepositoryRuleOrder;

  factory CopyWith$Input$RepositoryRuleOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryRuleOrder;

  TRes call({
    Enum$RepositoryRuleOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$RepositoryRuleOrder<TRes>
    implements CopyWith$Input$RepositoryRuleOrder<TRes> {
  _CopyWithImpl$Input$RepositoryRuleOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryRuleOrder _instance;

  final TRes Function(Input$RepositoryRuleOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$RepositoryRuleOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryRuleOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$RepositoryRuleOrder<TRes>
    implements CopyWith$Input$RepositoryRuleOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryRuleOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryRuleOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$RepositoryRulesetBypassActorInput {
  factory Input$RepositoryRulesetBypassActorInput({
    String? actorId,
    int? repositoryRoleDatabaseId,
    bool? organizationAdmin,
    bool? enterpriseOwner,
    bool? deployKey,
    required Enum$RepositoryRulesetBypassActorBypassMode bypassMode,
  }) =>
      Input$RepositoryRulesetBypassActorInput._({
        if (actorId != null) r'actorId': actorId,
        if (repositoryRoleDatabaseId != null)
          r'repositoryRoleDatabaseId': repositoryRoleDatabaseId,
        if (organizationAdmin != null) r'organizationAdmin': organizationAdmin,
        if (enterpriseOwner != null) r'enterpriseOwner': enterpriseOwner,
        if (deployKey != null) r'deployKey': deployKey,
        r'bypassMode': bypassMode,
      });

  Input$RepositoryRulesetBypassActorInput._(this._$data);

  factory Input$RepositoryRulesetBypassActorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('actorId')) {
      final l$actorId = data['actorId'];
      result$data['actorId'] = (l$actorId as String?);
    }
    if (data.containsKey('repositoryRoleDatabaseId')) {
      final l$repositoryRoleDatabaseId = data['repositoryRoleDatabaseId'];
      result$data['repositoryRoleDatabaseId'] =
          (l$repositoryRoleDatabaseId as int?);
    }
    if (data.containsKey('organizationAdmin')) {
      final l$organizationAdmin = data['organizationAdmin'];
      result$data['organizationAdmin'] = (l$organizationAdmin as bool?);
    }
    if (data.containsKey('enterpriseOwner')) {
      final l$enterpriseOwner = data['enterpriseOwner'];
      result$data['enterpriseOwner'] = (l$enterpriseOwner as bool?);
    }
    if (data.containsKey('deployKey')) {
      final l$deployKey = data['deployKey'];
      result$data['deployKey'] = (l$deployKey as bool?);
    }
    final l$bypassMode = data['bypassMode'];
    result$data['bypassMode'] =
        fromJson$Enum$RepositoryRulesetBypassActorBypassMode(
            (l$bypassMode as String));
    return Input$RepositoryRulesetBypassActorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get actorId => (_$data['actorId'] as String?);

  int? get repositoryRoleDatabaseId =>
      (_$data['repositoryRoleDatabaseId'] as int?);

  bool? get organizationAdmin => (_$data['organizationAdmin'] as bool?);

  bool? get enterpriseOwner => (_$data['enterpriseOwner'] as bool?);

  bool? get deployKey => (_$data['deployKey'] as bool?);

  Enum$RepositoryRulesetBypassActorBypassMode get bypassMode =>
      (_$data['bypassMode'] as Enum$RepositoryRulesetBypassActorBypassMode);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('actorId')) {
      final l$actorId = actorId;
      result$data['actorId'] = l$actorId;
    }
    if (_$data.containsKey('repositoryRoleDatabaseId')) {
      final l$repositoryRoleDatabaseId = repositoryRoleDatabaseId;
      result$data['repositoryRoleDatabaseId'] = l$repositoryRoleDatabaseId;
    }
    if (_$data.containsKey('organizationAdmin')) {
      final l$organizationAdmin = organizationAdmin;
      result$data['organizationAdmin'] = l$organizationAdmin;
    }
    if (_$data.containsKey('enterpriseOwner')) {
      final l$enterpriseOwner = enterpriseOwner;
      result$data['enterpriseOwner'] = l$enterpriseOwner;
    }
    if (_$data.containsKey('deployKey')) {
      final l$deployKey = deployKey;
      result$data['deployKey'] = l$deployKey;
    }
    final l$bypassMode = bypassMode;
    result$data['bypassMode'] =
        toJson$Enum$RepositoryRulesetBypassActorBypassMode(l$bypassMode);
    return result$data;
  }

  CopyWith$Input$RepositoryRulesetBypassActorInput<
          Input$RepositoryRulesetBypassActorInput>
      get copyWith => CopyWith$Input$RepositoryRulesetBypassActorInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RepositoryRulesetBypassActorInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$actorId = actorId;
    final lOther$actorId = other.actorId;
    if (_$data.containsKey('actorId') != other._$data.containsKey('actorId')) {
      return false;
    }
    if (l$actorId != lOther$actorId) {
      return false;
    }
    final l$repositoryRoleDatabaseId = repositoryRoleDatabaseId;
    final lOther$repositoryRoleDatabaseId = other.repositoryRoleDatabaseId;
    if (_$data.containsKey('repositoryRoleDatabaseId') !=
        other._$data.containsKey('repositoryRoleDatabaseId')) {
      return false;
    }
    if (l$repositoryRoleDatabaseId != lOther$repositoryRoleDatabaseId) {
      return false;
    }
    final l$organizationAdmin = organizationAdmin;
    final lOther$organizationAdmin = other.organizationAdmin;
    if (_$data.containsKey('organizationAdmin') !=
        other._$data.containsKey('organizationAdmin')) {
      return false;
    }
    if (l$organizationAdmin != lOther$organizationAdmin) {
      return false;
    }
    final l$enterpriseOwner = enterpriseOwner;
    final lOther$enterpriseOwner = other.enterpriseOwner;
    if (_$data.containsKey('enterpriseOwner') !=
        other._$data.containsKey('enterpriseOwner')) {
      return false;
    }
    if (l$enterpriseOwner != lOther$enterpriseOwner) {
      return false;
    }
    final l$deployKey = deployKey;
    final lOther$deployKey = other.deployKey;
    if (_$data.containsKey('deployKey') !=
        other._$data.containsKey('deployKey')) {
      return false;
    }
    if (l$deployKey != lOther$deployKey) {
      return false;
    }
    final l$bypassMode = bypassMode;
    final lOther$bypassMode = other.bypassMode;
    if (l$bypassMode != lOther$bypassMode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$actorId = actorId;
    final l$repositoryRoleDatabaseId = repositoryRoleDatabaseId;
    final l$organizationAdmin = organizationAdmin;
    final l$enterpriseOwner = enterpriseOwner;
    final l$deployKey = deployKey;
    final l$bypassMode = bypassMode;
    return Object.hashAll([
      _$data.containsKey('actorId') ? l$actorId : const {},
      _$data.containsKey('repositoryRoleDatabaseId')
          ? l$repositoryRoleDatabaseId
          : const {},
      _$data.containsKey('organizationAdmin') ? l$organizationAdmin : const {},
      _$data.containsKey('enterpriseOwner') ? l$enterpriseOwner : const {},
      _$data.containsKey('deployKey') ? l$deployKey : const {},
      l$bypassMode,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryRulesetBypassActorInput<TRes> {
  factory CopyWith$Input$RepositoryRulesetBypassActorInput(
    Input$RepositoryRulesetBypassActorInput instance,
    TRes Function(Input$RepositoryRulesetBypassActorInput) then,
  ) = _CopyWithImpl$Input$RepositoryRulesetBypassActorInput;

  factory CopyWith$Input$RepositoryRulesetBypassActorInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryRulesetBypassActorInput;

  TRes call({
    String? actorId,
    int? repositoryRoleDatabaseId,
    bool? organizationAdmin,
    bool? enterpriseOwner,
    bool? deployKey,
    Enum$RepositoryRulesetBypassActorBypassMode? bypassMode,
  });
}

class _CopyWithImpl$Input$RepositoryRulesetBypassActorInput<TRes>
    implements CopyWith$Input$RepositoryRulesetBypassActorInput<TRes> {
  _CopyWithImpl$Input$RepositoryRulesetBypassActorInput(
    this._instance,
    this._then,
  );

  final Input$RepositoryRulesetBypassActorInput _instance;

  final TRes Function(Input$RepositoryRulesetBypassActorInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? actorId = _undefined,
    Object? repositoryRoleDatabaseId = _undefined,
    Object? organizationAdmin = _undefined,
    Object? enterpriseOwner = _undefined,
    Object? deployKey = _undefined,
    Object? bypassMode = _undefined,
  }) =>
      _then(Input$RepositoryRulesetBypassActorInput._({
        ..._instance._$data,
        if (actorId != _undefined) 'actorId': (actorId as String?),
        if (repositoryRoleDatabaseId != _undefined)
          'repositoryRoleDatabaseId': (repositoryRoleDatabaseId as int?),
        if (organizationAdmin != _undefined)
          'organizationAdmin': (organizationAdmin as bool?),
        if (enterpriseOwner != _undefined)
          'enterpriseOwner': (enterpriseOwner as bool?),
        if (deployKey != _undefined) 'deployKey': (deployKey as bool?),
        if (bypassMode != _undefined && bypassMode != null)
          'bypassMode':
              (bypassMode as Enum$RepositoryRulesetBypassActorBypassMode),
      }));
}

class _CopyWithStubImpl$Input$RepositoryRulesetBypassActorInput<TRes>
    implements CopyWith$Input$RepositoryRulesetBypassActorInput<TRes> {
  _CopyWithStubImpl$Input$RepositoryRulesetBypassActorInput(this._res);

  TRes _res;

  call({
    String? actorId,
    int? repositoryRoleDatabaseId,
    bool? organizationAdmin,
    bool? enterpriseOwner,
    bool? deployKey,
    Enum$RepositoryRulesetBypassActorBypassMode? bypassMode,
  }) =>
      _res;
}

class Input$ReprioritizeSubIssueInput {
  factory Input$ReprioritizeSubIssueInput({
    String? clientMutationId,
    required String issueId,
    required String subIssueId,
    String? afterId,
    String? beforeId,
  }) =>
      Input$ReprioritizeSubIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        r'subIssueId': subIssueId,
        if (afterId != null) r'afterId': afterId,
        if (beforeId != null) r'beforeId': beforeId,
      });

  Input$ReprioritizeSubIssueInput._(this._$data);

  factory Input$ReprioritizeSubIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$subIssueId = data['subIssueId'];
    result$data['subIssueId'] = (l$subIssueId as String);
    if (data.containsKey('afterId')) {
      final l$afterId = data['afterId'];
      result$data['afterId'] = (l$afterId as String?);
    }
    if (data.containsKey('beforeId')) {
      final l$beforeId = data['beforeId'];
      result$data['beforeId'] = (l$beforeId as String?);
    }
    return Input$ReprioritizeSubIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  String get subIssueId => (_$data['subIssueId'] as String);

  String? get afterId => (_$data['afterId'] as String?);

  String? get beforeId => (_$data['beforeId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$subIssueId = subIssueId;
    result$data['subIssueId'] = l$subIssueId;
    if (_$data.containsKey('afterId')) {
      final l$afterId = afterId;
      result$data['afterId'] = l$afterId;
    }
    if (_$data.containsKey('beforeId')) {
      final l$beforeId = beforeId;
      result$data['beforeId'] = l$beforeId;
    }
    return result$data;
  }

  CopyWith$Input$ReprioritizeSubIssueInput<Input$ReprioritizeSubIssueInput>
      get copyWith => CopyWith$Input$ReprioritizeSubIssueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ReprioritizeSubIssueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$subIssueId = subIssueId;
    final lOther$subIssueId = other.subIssueId;
    if (l$subIssueId != lOther$subIssueId) {
      return false;
    }
    final l$afterId = afterId;
    final lOther$afterId = other.afterId;
    if (_$data.containsKey('afterId') != other._$data.containsKey('afterId')) {
      return false;
    }
    if (l$afterId != lOther$afterId) {
      return false;
    }
    final l$beforeId = beforeId;
    final lOther$beforeId = other.beforeId;
    if (_$data.containsKey('beforeId') !=
        other._$data.containsKey('beforeId')) {
      return false;
    }
    if (l$beforeId != lOther$beforeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$subIssueId = subIssueId;
    final l$afterId = afterId;
    final l$beforeId = beforeId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      l$subIssueId,
      _$data.containsKey('afterId') ? l$afterId : const {},
      _$data.containsKey('beforeId') ? l$beforeId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ReprioritizeSubIssueInput<TRes> {
  factory CopyWith$Input$ReprioritizeSubIssueInput(
    Input$ReprioritizeSubIssueInput instance,
    TRes Function(Input$ReprioritizeSubIssueInput) then,
  ) = _CopyWithImpl$Input$ReprioritizeSubIssueInput;

  factory CopyWith$Input$ReprioritizeSubIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReprioritizeSubIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? subIssueId,
    String? afterId,
    String? beforeId,
  });
}

class _CopyWithImpl$Input$ReprioritizeSubIssueInput<TRes>
    implements CopyWith$Input$ReprioritizeSubIssueInput<TRes> {
  _CopyWithImpl$Input$ReprioritizeSubIssueInput(
    this._instance,
    this._then,
  );

  final Input$ReprioritizeSubIssueInput _instance;

  final TRes Function(Input$ReprioritizeSubIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? subIssueId = _undefined,
    Object? afterId = _undefined,
    Object? beforeId = _undefined,
  }) =>
      _then(Input$ReprioritizeSubIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (subIssueId != _undefined && subIssueId != null)
          'subIssueId': (subIssueId as String),
        if (afterId != _undefined) 'afterId': (afterId as String?),
        if (beforeId != _undefined) 'beforeId': (beforeId as String?),
      }));
}

class _CopyWithStubImpl$Input$ReprioritizeSubIssueInput<TRes>
    implements CopyWith$Input$ReprioritizeSubIssueInput<TRes> {
  _CopyWithStubImpl$Input$ReprioritizeSubIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? subIssueId,
    String? afterId,
    String? beforeId,
  }) =>
      _res;
}

class Input$RequestReviewsInput {
  factory Input$RequestReviewsInput({
    String? clientMutationId,
    required String pullRequestId,
    List<String>? userIds,
    List<String>? botIds,
    List<String>? teamIds,
    bool? union,
  }) =>
      Input$RequestReviewsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (userIds != null) r'userIds': userIds,
        if (botIds != null) r'botIds': botIds,
        if (teamIds != null) r'teamIds': teamIds,
        if (union != null) r'union': union,
      });

  Input$RequestReviewsInput._(this._$data);

  factory Input$RequestReviewsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('userIds')) {
      final l$userIds = data['userIds'];
      result$data['userIds'] =
          (l$userIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('botIds')) {
      final l$botIds = data['botIds'];
      result$data['botIds'] =
          (l$botIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('teamIds')) {
      final l$teamIds = data['teamIds'];
      result$data['teamIds'] =
          (l$teamIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('union')) {
      final l$union = data['union'];
      result$data['union'] = (l$union as bool?);
    }
    return Input$RequestReviewsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  List<String>? get userIds => (_$data['userIds'] as List<String>?);

  List<String>? get botIds => (_$data['botIds'] as List<String>?);

  List<String>? get teamIds => (_$data['teamIds'] as List<String>?);

  bool? get union => (_$data['union'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('userIds')) {
      final l$userIds = userIds;
      result$data['userIds'] = l$userIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('botIds')) {
      final l$botIds = botIds;
      result$data['botIds'] = l$botIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('teamIds')) {
      final l$teamIds = teamIds;
      result$data['teamIds'] = l$teamIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('union')) {
      final l$union = union;
      result$data['union'] = l$union;
    }
    return result$data;
  }

  CopyWith$Input$RequestReviewsInput<Input$RequestReviewsInput> get copyWith =>
      CopyWith$Input$RequestReviewsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequestReviewsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$userIds = userIds;
    final lOther$userIds = other.userIds;
    if (_$data.containsKey('userIds') != other._$data.containsKey('userIds')) {
      return false;
    }
    if (l$userIds != null && lOther$userIds != null) {
      if (l$userIds.length != lOther$userIds.length) {
        return false;
      }
      for (int i = 0; i < l$userIds.length; i++) {
        final l$userIds$entry = l$userIds[i];
        final lOther$userIds$entry = lOther$userIds[i];
        if (l$userIds$entry != lOther$userIds$entry) {
          return false;
        }
      }
    } else if (l$userIds != lOther$userIds) {
      return false;
    }
    final l$botIds = botIds;
    final lOther$botIds = other.botIds;
    if (_$data.containsKey('botIds') != other._$data.containsKey('botIds')) {
      return false;
    }
    if (l$botIds != null && lOther$botIds != null) {
      if (l$botIds.length != lOther$botIds.length) {
        return false;
      }
      for (int i = 0; i < l$botIds.length; i++) {
        final l$botIds$entry = l$botIds[i];
        final lOther$botIds$entry = lOther$botIds[i];
        if (l$botIds$entry != lOther$botIds$entry) {
          return false;
        }
      }
    } else if (l$botIds != lOther$botIds) {
      return false;
    }
    final l$teamIds = teamIds;
    final lOther$teamIds = other.teamIds;
    if (_$data.containsKey('teamIds') != other._$data.containsKey('teamIds')) {
      return false;
    }
    if (l$teamIds != null && lOther$teamIds != null) {
      if (l$teamIds.length != lOther$teamIds.length) {
        return false;
      }
      for (int i = 0; i < l$teamIds.length; i++) {
        final l$teamIds$entry = l$teamIds[i];
        final lOther$teamIds$entry = lOther$teamIds[i];
        if (l$teamIds$entry != lOther$teamIds$entry) {
          return false;
        }
      }
    } else if (l$teamIds != lOther$teamIds) {
      return false;
    }
    final l$union = union;
    final lOther$union = other.union;
    if (_$data.containsKey('union') != other._$data.containsKey('union')) {
      return false;
    }
    if (l$union != lOther$union) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$userIds = userIds;
    final l$botIds = botIds;
    final l$teamIds = teamIds;
    final l$union = union;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('userIds')
          ? l$userIds == null
              ? null
              : Object.hashAll(l$userIds.map((v) => v))
          : const {},
      _$data.containsKey('botIds')
          ? l$botIds == null
              ? null
              : Object.hashAll(l$botIds.map((v) => v))
          : const {},
      _$data.containsKey('teamIds')
          ? l$teamIds == null
              ? null
              : Object.hashAll(l$teamIds.map((v) => v))
          : const {},
      _$data.containsKey('union') ? l$union : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestReviewsInput<TRes> {
  factory CopyWith$Input$RequestReviewsInput(
    Input$RequestReviewsInput instance,
    TRes Function(Input$RequestReviewsInput) then,
  ) = _CopyWithImpl$Input$RequestReviewsInput;

  factory CopyWith$Input$RequestReviewsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestReviewsInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    List<String>? userIds,
    List<String>? botIds,
    List<String>? teamIds,
    bool? union,
  });
}

class _CopyWithImpl$Input$RequestReviewsInput<TRes>
    implements CopyWith$Input$RequestReviewsInput<TRes> {
  _CopyWithImpl$Input$RequestReviewsInput(
    this._instance,
    this._then,
  );

  final Input$RequestReviewsInput _instance;

  final TRes Function(Input$RequestReviewsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? userIds = _undefined,
    Object? botIds = _undefined,
    Object? teamIds = _undefined,
    Object? union = _undefined,
  }) =>
      _then(Input$RequestReviewsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (userIds != _undefined) 'userIds': (userIds as List<String>?),
        if (botIds != _undefined) 'botIds': (botIds as List<String>?),
        if (teamIds != _undefined) 'teamIds': (teamIds as List<String>?),
        if (union != _undefined) 'union': (union as bool?),
      }));
}

class _CopyWithStubImpl$Input$RequestReviewsInput<TRes>
    implements CopyWith$Input$RequestReviewsInput<TRes> {
  _CopyWithStubImpl$Input$RequestReviewsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    List<String>? userIds,
    List<String>? botIds,
    List<String>? teamIds,
    bool? union,
  }) =>
      _res;
}

class Input$RequiredDeploymentsParametersInput {
  factory Input$RequiredDeploymentsParametersInput(
          {required List<String> requiredDeploymentEnvironments}) =>
      Input$RequiredDeploymentsParametersInput._({
        r'requiredDeploymentEnvironments': requiredDeploymentEnvironments,
      });

  Input$RequiredDeploymentsParametersInput._(this._$data);

  factory Input$RequiredDeploymentsParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$requiredDeploymentEnvironments =
        data['requiredDeploymentEnvironments'];
    result$data['requiredDeploymentEnvironments'] =
        (l$requiredDeploymentEnvironments as List<dynamic>)
            .map((e) => (e as String))
            .toList();
    return Input$RequiredDeploymentsParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get requiredDeploymentEnvironments =>
      (_$data['requiredDeploymentEnvironments'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    result$data['requiredDeploymentEnvironments'] =
        l$requiredDeploymentEnvironments.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$RequiredDeploymentsParametersInput<
          Input$RequiredDeploymentsParametersInput>
      get copyWith => CopyWith$Input$RequiredDeploymentsParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequiredDeploymentsParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final lOther$requiredDeploymentEnvironments =
        other.requiredDeploymentEnvironments;
    if (l$requiredDeploymentEnvironments.length !=
        lOther$requiredDeploymentEnvironments.length) {
      return false;
    }
    for (int i = 0; i < l$requiredDeploymentEnvironments.length; i++) {
      final l$requiredDeploymentEnvironments$entry =
          l$requiredDeploymentEnvironments[i];
      final lOther$requiredDeploymentEnvironments$entry =
          lOther$requiredDeploymentEnvironments[i];
      if (l$requiredDeploymentEnvironments$entry !=
          lOther$requiredDeploymentEnvironments$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    return Object.hashAll(
        [Object.hashAll(l$requiredDeploymentEnvironments.map((v) => v))]);
  }
}

abstract class CopyWith$Input$RequiredDeploymentsParametersInput<TRes> {
  factory CopyWith$Input$RequiredDeploymentsParametersInput(
    Input$RequiredDeploymentsParametersInput instance,
    TRes Function(Input$RequiredDeploymentsParametersInput) then,
  ) = _CopyWithImpl$Input$RequiredDeploymentsParametersInput;

  factory CopyWith$Input$RequiredDeploymentsParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequiredDeploymentsParametersInput;

  TRes call({List<String>? requiredDeploymentEnvironments});
}

class _CopyWithImpl$Input$RequiredDeploymentsParametersInput<TRes>
    implements CopyWith$Input$RequiredDeploymentsParametersInput<TRes> {
  _CopyWithImpl$Input$RequiredDeploymentsParametersInput(
    this._instance,
    this._then,
  );

  final Input$RequiredDeploymentsParametersInput _instance;

  final TRes Function(Input$RequiredDeploymentsParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? requiredDeploymentEnvironments = _undefined}) =>
      _then(Input$RequiredDeploymentsParametersInput._({
        ..._instance._$data,
        if (requiredDeploymentEnvironments != _undefined &&
            requiredDeploymentEnvironments != null)
          'requiredDeploymentEnvironments':
              (requiredDeploymentEnvironments as List<String>),
      }));
}

class _CopyWithStubImpl$Input$RequiredDeploymentsParametersInput<TRes>
    implements CopyWith$Input$RequiredDeploymentsParametersInput<TRes> {
  _CopyWithStubImpl$Input$RequiredDeploymentsParametersInput(this._res);

  TRes _res;

  call({List<String>? requiredDeploymentEnvironments}) => _res;
}

class Input$RequiredStatusCheckInput {
  factory Input$RequiredStatusCheckInput({
    required String context,
    String? appId,
  }) =>
      Input$RequiredStatusCheckInput._({
        r'context': context,
        if (appId != null) r'appId': appId,
      });

  Input$RequiredStatusCheckInput._(this._$data);

  factory Input$RequiredStatusCheckInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$context = data['context'];
    result$data['context'] = (l$context as String);
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as String?);
    }
    return Input$RequiredStatusCheckInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get context => (_$data['context'] as String);

  String? get appId => (_$data['appId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$context = context;
    result$data['context'] = l$context;
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    return result$data;
  }

  CopyWith$Input$RequiredStatusCheckInput<Input$RequiredStatusCheckInput>
      get copyWith => CopyWith$Input$RequiredStatusCheckInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequiredStatusCheckInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$context = context;
    final l$appId = appId;
    return Object.hashAll([
      l$context,
      _$data.containsKey('appId') ? l$appId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequiredStatusCheckInput<TRes> {
  factory CopyWith$Input$RequiredStatusCheckInput(
    Input$RequiredStatusCheckInput instance,
    TRes Function(Input$RequiredStatusCheckInput) then,
  ) = _CopyWithImpl$Input$RequiredStatusCheckInput;

  factory CopyWith$Input$RequiredStatusCheckInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequiredStatusCheckInput;

  TRes call({
    String? context,
    String? appId,
  });
}

class _CopyWithImpl$Input$RequiredStatusCheckInput<TRes>
    implements CopyWith$Input$RequiredStatusCheckInput<TRes> {
  _CopyWithImpl$Input$RequiredStatusCheckInput(
    this._instance,
    this._then,
  );

  final Input$RequiredStatusCheckInput _instance;

  final TRes Function(Input$RequiredStatusCheckInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? context = _undefined,
    Object? appId = _undefined,
  }) =>
      _then(Input$RequiredStatusCheckInput._({
        ..._instance._$data,
        if (context != _undefined && context != null)
          'context': (context as String),
        if (appId != _undefined) 'appId': (appId as String?),
      }));
}

class _CopyWithStubImpl$Input$RequiredStatusCheckInput<TRes>
    implements CopyWith$Input$RequiredStatusCheckInput<TRes> {
  _CopyWithStubImpl$Input$RequiredStatusCheckInput(this._res);

  TRes _res;

  call({
    String? context,
    String? appId,
  }) =>
      _res;
}

class Input$RequiredStatusChecksParametersInput {
  factory Input$RequiredStatusChecksParametersInput({
    bool? doNotEnforceOnCreate,
    required List<Input$StatusCheckConfigurationInput> requiredStatusChecks,
    required bool strictRequiredStatusChecksPolicy,
  }) =>
      Input$RequiredStatusChecksParametersInput._({
        if (doNotEnforceOnCreate != null)
          r'doNotEnforceOnCreate': doNotEnforceOnCreate,
        r'requiredStatusChecks': requiredStatusChecks,
        r'strictRequiredStatusChecksPolicy': strictRequiredStatusChecksPolicy,
      });

  Input$RequiredStatusChecksParametersInput._(this._$data);

  factory Input$RequiredStatusChecksParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('doNotEnforceOnCreate')) {
      final l$doNotEnforceOnCreate = data['doNotEnforceOnCreate'];
      result$data['doNotEnforceOnCreate'] = (l$doNotEnforceOnCreate as bool?);
    }
    final l$requiredStatusChecks = data['requiredStatusChecks'];
    result$data['requiredStatusChecks'] =
        (l$requiredStatusChecks as List<dynamic>)
            .map((e) => Input$StatusCheckConfigurationInput.fromJson(
                (e as Map<String, dynamic>)))
            .toList();
    final l$strictRequiredStatusChecksPolicy =
        data['strictRequiredStatusChecksPolicy'];
    result$data['strictRequiredStatusChecksPolicy'] =
        (l$strictRequiredStatusChecksPolicy as bool);
    return Input$RequiredStatusChecksParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get doNotEnforceOnCreate => (_$data['doNotEnforceOnCreate'] as bool?);

  List<Input$StatusCheckConfigurationInput> get requiredStatusChecks =>
      (_$data['requiredStatusChecks']
          as List<Input$StatusCheckConfigurationInput>);

  bool get strictRequiredStatusChecksPolicy =>
      (_$data['strictRequiredStatusChecksPolicy'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('doNotEnforceOnCreate')) {
      final l$doNotEnforceOnCreate = doNotEnforceOnCreate;
      result$data['doNotEnforceOnCreate'] = l$doNotEnforceOnCreate;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    result$data['requiredStatusChecks'] =
        l$requiredStatusChecks.map((e) => e.toJson()).toList();
    final l$strictRequiredStatusChecksPolicy = strictRequiredStatusChecksPolicy;
    result$data['strictRequiredStatusChecksPolicy'] =
        l$strictRequiredStatusChecksPolicy;
    return result$data;
  }

  CopyWith$Input$RequiredStatusChecksParametersInput<
          Input$RequiredStatusChecksParametersInput>
      get copyWith => CopyWith$Input$RequiredStatusChecksParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RequiredStatusChecksParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$doNotEnforceOnCreate = doNotEnforceOnCreate;
    final lOther$doNotEnforceOnCreate = other.doNotEnforceOnCreate;
    if (_$data.containsKey('doNotEnforceOnCreate') !=
        other._$data.containsKey('doNotEnforceOnCreate')) {
      return false;
    }
    if (l$doNotEnforceOnCreate != lOther$doNotEnforceOnCreate) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (l$requiredStatusChecks.length != lOther$requiredStatusChecks.length) {
      return false;
    }
    for (int i = 0; i < l$requiredStatusChecks.length; i++) {
      final l$requiredStatusChecks$entry = l$requiredStatusChecks[i];
      final lOther$requiredStatusChecks$entry = lOther$requiredStatusChecks[i];
      if (l$requiredStatusChecks$entry != lOther$requiredStatusChecks$entry) {
        return false;
      }
    }
    final l$strictRequiredStatusChecksPolicy = strictRequiredStatusChecksPolicy;
    final lOther$strictRequiredStatusChecksPolicy =
        other.strictRequiredStatusChecksPolicy;
    if (l$strictRequiredStatusChecksPolicy !=
        lOther$strictRequiredStatusChecksPolicy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$doNotEnforceOnCreate = doNotEnforceOnCreate;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$strictRequiredStatusChecksPolicy = strictRequiredStatusChecksPolicy;
    return Object.hashAll([
      _$data.containsKey('doNotEnforceOnCreate')
          ? l$doNotEnforceOnCreate
          : const {},
      Object.hashAll(l$requiredStatusChecks.map((v) => v)),
      l$strictRequiredStatusChecksPolicy,
    ]);
  }
}

abstract class CopyWith$Input$RequiredStatusChecksParametersInput<TRes> {
  factory CopyWith$Input$RequiredStatusChecksParametersInput(
    Input$RequiredStatusChecksParametersInput instance,
    TRes Function(Input$RequiredStatusChecksParametersInput) then,
  ) = _CopyWithImpl$Input$RequiredStatusChecksParametersInput;

  factory CopyWith$Input$RequiredStatusChecksParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequiredStatusChecksParametersInput;

  TRes call({
    bool? doNotEnforceOnCreate,
    List<Input$StatusCheckConfigurationInput>? requiredStatusChecks,
    bool? strictRequiredStatusChecksPolicy,
  });
  TRes requiredStatusChecks(
      Iterable<Input$StatusCheckConfigurationInput> Function(
              Iterable<
                  CopyWith$Input$StatusCheckConfigurationInput<
                      Input$StatusCheckConfigurationInput>>)
          _fn);
}

class _CopyWithImpl$Input$RequiredStatusChecksParametersInput<TRes>
    implements CopyWith$Input$RequiredStatusChecksParametersInput<TRes> {
  _CopyWithImpl$Input$RequiredStatusChecksParametersInput(
    this._instance,
    this._then,
  );

  final Input$RequiredStatusChecksParametersInput _instance;

  final TRes Function(Input$RequiredStatusChecksParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? doNotEnforceOnCreate = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? strictRequiredStatusChecksPolicy = _undefined,
  }) =>
      _then(Input$RequiredStatusChecksParametersInput._({
        ..._instance._$data,
        if (doNotEnforceOnCreate != _undefined)
          'doNotEnforceOnCreate': (doNotEnforceOnCreate as bool?),
        if (requiredStatusChecks != _undefined && requiredStatusChecks != null)
          'requiredStatusChecks': (requiredStatusChecks
              as List<Input$StatusCheckConfigurationInput>),
        if (strictRequiredStatusChecksPolicy != _undefined &&
            strictRequiredStatusChecksPolicy != null)
          'strictRequiredStatusChecksPolicy':
              (strictRequiredStatusChecksPolicy as bool),
      }));

  TRes requiredStatusChecks(
          Iterable<Input$StatusCheckConfigurationInput> Function(
                  Iterable<
                      CopyWith$Input$StatusCheckConfigurationInput<
                          Input$StatusCheckConfigurationInput>>)
              _fn) =>
      call(
          requiredStatusChecks: _fn(_instance.requiredStatusChecks
              .map((e) => CopyWith$Input$StatusCheckConfigurationInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$RequiredStatusChecksParametersInput<TRes>
    implements CopyWith$Input$RequiredStatusChecksParametersInput<TRes> {
  _CopyWithStubImpl$Input$RequiredStatusChecksParametersInput(this._res);

  TRes _res;

  call({
    bool? doNotEnforceOnCreate,
    List<Input$StatusCheckConfigurationInput>? requiredStatusChecks,
    bool? strictRequiredStatusChecksPolicy,
  }) =>
      _res;

  requiredStatusChecks(_fn) => _res;
}

class Input$RerequestCheckSuiteInput {
  factory Input$RerequestCheckSuiteInput({
    String? clientMutationId,
    required String repositoryId,
    required String checkSuiteId,
  }) =>
      Input$RerequestCheckSuiteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'checkSuiteId': checkSuiteId,
      });

  Input$RerequestCheckSuiteInput._(this._$data);

  factory Input$RerequestCheckSuiteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$checkSuiteId = data['checkSuiteId'];
    result$data['checkSuiteId'] = (l$checkSuiteId as String);
    return Input$RerequestCheckSuiteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get checkSuiteId => (_$data['checkSuiteId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$checkSuiteId = checkSuiteId;
    result$data['checkSuiteId'] = l$checkSuiteId;
    return result$data;
  }

  CopyWith$Input$RerequestCheckSuiteInput<Input$RerequestCheckSuiteInput>
      get copyWith => CopyWith$Input$RerequestCheckSuiteInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RerequestCheckSuiteInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$checkSuiteId = checkSuiteId;
    final lOther$checkSuiteId = other.checkSuiteId;
    if (l$checkSuiteId != lOther$checkSuiteId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$checkSuiteId = checkSuiteId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$checkSuiteId,
    ]);
  }
}

abstract class CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  factory CopyWith$Input$RerequestCheckSuiteInput(
    Input$RerequestCheckSuiteInput instance,
    TRes Function(Input$RerequestCheckSuiteInput) then,
  ) = _CopyWithImpl$Input$RerequestCheckSuiteInput;

  factory CopyWith$Input$RerequestCheckSuiteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RerequestCheckSuiteInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? checkSuiteId,
  });
}

class _CopyWithImpl$Input$RerequestCheckSuiteInput<TRes>
    implements CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  _CopyWithImpl$Input$RerequestCheckSuiteInput(
    this._instance,
    this._then,
  );

  final Input$RerequestCheckSuiteInput _instance;

  final TRes Function(Input$RerequestCheckSuiteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? checkSuiteId = _undefined,
  }) =>
      _then(Input$RerequestCheckSuiteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (checkSuiteId != _undefined && checkSuiteId != null)
          'checkSuiteId': (checkSuiteId as String),
      }));
}

class _CopyWithStubImpl$Input$RerequestCheckSuiteInput<TRes>
    implements CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  _CopyWithStubImpl$Input$RerequestCheckSuiteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? checkSuiteId,
  }) =>
      _res;
}

class Input$ResolveReviewThreadInput {
  factory Input$ResolveReviewThreadInput({
    String? clientMutationId,
    required String threadId,
  }) =>
      Input$ResolveReviewThreadInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'threadId': threadId,
      });

  Input$ResolveReviewThreadInput._(this._$data);

  factory Input$ResolveReviewThreadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$threadId = data['threadId'];
    result$data['threadId'] = (l$threadId as String);
    return Input$ResolveReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get threadId => (_$data['threadId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$threadId = threadId;
    result$data['threadId'] = l$threadId;
    return result$data;
  }

  CopyWith$Input$ResolveReviewThreadInput<Input$ResolveReviewThreadInput>
      get copyWith => CopyWith$Input$ResolveReviewThreadInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$ResolveReviewThreadInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$threadId = threadId;
    final lOther$threadId = other.threadId;
    if (l$threadId != lOther$threadId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$threadId = threadId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$threadId,
    ]);
  }
}

abstract class CopyWith$Input$ResolveReviewThreadInput<TRes> {
  factory CopyWith$Input$ResolveReviewThreadInput(
    Input$ResolveReviewThreadInput instance,
    TRes Function(Input$ResolveReviewThreadInput) then,
  ) = _CopyWithImpl$Input$ResolveReviewThreadInput;

  factory CopyWith$Input$ResolveReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ResolveReviewThreadInput;

  TRes call({
    String? clientMutationId,
    String? threadId,
  });
}

class _CopyWithImpl$Input$ResolveReviewThreadInput<TRes>
    implements CopyWith$Input$ResolveReviewThreadInput<TRes> {
  _CopyWithImpl$Input$ResolveReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$ResolveReviewThreadInput _instance;

  final TRes Function(Input$ResolveReviewThreadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? threadId = _undefined,
  }) =>
      _then(Input$ResolveReviewThreadInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (threadId != _undefined && threadId != null)
          'threadId': (threadId as String),
      }));
}

class _CopyWithStubImpl$Input$ResolveReviewThreadInput<TRes>
    implements CopyWith$Input$ResolveReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$ResolveReviewThreadInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? threadId,
  }) =>
      _res;
}

class Input$RetireSponsorsTierInput {
  factory Input$RetireSponsorsTierInput({
    String? clientMutationId,
    required String tierId,
  }) =>
      Input$RetireSponsorsTierInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'tierId': tierId,
      });

  Input$RetireSponsorsTierInput._(this._$data);

  factory Input$RetireSponsorsTierInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$tierId = data['tierId'];
    result$data['tierId'] = (l$tierId as String);
    return Input$RetireSponsorsTierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get tierId => (_$data['tierId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$tierId = tierId;
    result$data['tierId'] = l$tierId;
    return result$data;
  }

  CopyWith$Input$RetireSponsorsTierInput<Input$RetireSponsorsTierInput>
      get copyWith => CopyWith$Input$RetireSponsorsTierInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RetireSponsorsTierInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$tierId = tierId;
    final lOther$tierId = other.tierId;
    if (l$tierId != lOther$tierId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$tierId = tierId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$tierId,
    ]);
  }
}

abstract class CopyWith$Input$RetireSponsorsTierInput<TRes> {
  factory CopyWith$Input$RetireSponsorsTierInput(
    Input$RetireSponsorsTierInput instance,
    TRes Function(Input$RetireSponsorsTierInput) then,
  ) = _CopyWithImpl$Input$RetireSponsorsTierInput;

  factory CopyWith$Input$RetireSponsorsTierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RetireSponsorsTierInput;

  TRes call({
    String? clientMutationId,
    String? tierId,
  });
}

class _CopyWithImpl$Input$RetireSponsorsTierInput<TRes>
    implements CopyWith$Input$RetireSponsorsTierInput<TRes> {
  _CopyWithImpl$Input$RetireSponsorsTierInput(
    this._instance,
    this._then,
  );

  final Input$RetireSponsorsTierInput _instance;

  final TRes Function(Input$RetireSponsorsTierInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? tierId = _undefined,
  }) =>
      _then(Input$RetireSponsorsTierInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (tierId != _undefined && tierId != null)
          'tierId': (tierId as String),
      }));
}

class _CopyWithStubImpl$Input$RetireSponsorsTierInput<TRes>
    implements CopyWith$Input$RetireSponsorsTierInput<TRes> {
  _CopyWithStubImpl$Input$RetireSponsorsTierInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? tierId,
  }) =>
      _res;
}

class Input$RevertPullRequestInput {
  factory Input$RevertPullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
    String? title,
    String? body,
    bool? draft,
  }) =>
      Input$RevertPullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (draft != null) r'draft': draft,
      });

  Input$RevertPullRequestInput._(this._$data);

  factory Input$RevertPullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('draft')) {
      final l$draft = data['draft'];
      result$data['draft'] = (l$draft as bool?);
    }
    return Input$RevertPullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  bool? get draft => (_$data['draft'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('draft')) {
      final l$draft = draft;
      result$data['draft'] = l$draft;
    }
    return result$data;
  }

  CopyWith$Input$RevertPullRequestInput<Input$RevertPullRequestInput>
      get copyWith => CopyWith$Input$RevertPullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RevertPullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$draft = draft;
    final lOther$draft = other.draft;
    if (_$data.containsKey('draft') != other._$data.containsKey('draft')) {
      return false;
    }
    if (l$draft != lOther$draft) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$title = title;
    final l$body = body;
    final l$draft = draft;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('draft') ? l$draft : const {},
    ]);
  }
}

abstract class CopyWith$Input$RevertPullRequestInput<TRes> {
  factory CopyWith$Input$RevertPullRequestInput(
    Input$RevertPullRequestInput instance,
    TRes Function(Input$RevertPullRequestInput) then,
  ) = _CopyWithImpl$Input$RevertPullRequestInput;

  factory CopyWith$Input$RevertPullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RevertPullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? title,
    String? body,
    bool? draft,
  });
}

class _CopyWithImpl$Input$RevertPullRequestInput<TRes>
    implements CopyWith$Input$RevertPullRequestInput<TRes> {
  _CopyWithImpl$Input$RevertPullRequestInput(
    this._instance,
    this._then,
  );

  final Input$RevertPullRequestInput _instance;

  final TRes Function(Input$RevertPullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? draft = _undefined,
  }) =>
      _then(Input$RevertPullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (draft != _undefined) 'draft': (draft as bool?),
      }));
}

class _CopyWithStubImpl$Input$RevertPullRequestInput<TRes>
    implements CopyWith$Input$RevertPullRequestInput<TRes> {
  _CopyWithStubImpl$Input$RevertPullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? title,
    String? body,
    bool? draft,
  }) =>
      _res;
}

class Input$RevokeEnterpriseOrganizationsMigratorRoleInput {
  factory Input$RevokeEnterpriseOrganizationsMigratorRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$RevokeEnterpriseOrganizationsMigratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$RevokeEnterpriseOrganizationsMigratorRoleInput._(this._$data);

  factory Input$RevokeEnterpriseOrganizationsMigratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$RevokeEnterpriseOrganizationsMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get login => (_$data['login'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
          Input$RevokeEnterpriseOrganizationsMigratorRoleInput>
      get copyWith =>
          CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RevokeEnterpriseOrganizationsMigratorRoleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
    TRes> {
  factory CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
    Input$RevokeEnterpriseOrganizationsMigratorRoleInput instance,
    TRes Function(Input$RevokeEnterpriseOrganizationsMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput;

  factory CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes>
    implements
        CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$RevokeEnterpriseOrganizationsMigratorRoleInput _instance;

  final TRes Function(Input$RevokeEnterpriseOrganizationsMigratorRoleInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$RevokeEnterpriseOrganizationsMigratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
        TRes>
    implements
        CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$RevokeMigratorRoleInput {
  factory Input$RevokeMigratorRoleInput({
    String? clientMutationId,
    required String organizationId,
    required String actor,
    required Enum$ActorType actorType,
  }) =>
      Input$RevokeMigratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'actor': actor,
        r'actorType': actorType,
      });

  Input$RevokeMigratorRoleInput._(this._$data);

  factory Input$RevokeMigratorRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$actor = data['actor'];
    result$data['actor'] = (l$actor as String);
    final l$actorType = data['actorType'];
    result$data['actorType'] = fromJson$Enum$ActorType((l$actorType as String));
    return Input$RevokeMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  String get actor => (_$data['actor'] as String);

  Enum$ActorType get actorType => (_$data['actorType'] as Enum$ActorType);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$actor = actor;
    result$data['actor'] = l$actor;
    final l$actorType = actorType;
    result$data['actorType'] = toJson$Enum$ActorType(l$actorType);
    return result$data;
  }

  CopyWith$Input$RevokeMigratorRoleInput<Input$RevokeMigratorRoleInput>
      get copyWith => CopyWith$Input$RevokeMigratorRoleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RevokeMigratorRoleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$actor = actor;
    final lOther$actor = other.actor;
    if (l$actor != lOther$actor) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (l$actorType != lOther$actorType) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$actor = actor;
    final l$actorType = actorType;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$actor,
      l$actorType,
    ]);
  }
}

abstract class CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  factory CopyWith$Input$RevokeMigratorRoleInput(
    Input$RevokeMigratorRoleInput instance,
    TRes Function(Input$RevokeMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$RevokeMigratorRoleInput;

  factory CopyWith$Input$RevokeMigratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RevokeMigratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
  });
}

class _CopyWithImpl$Input$RevokeMigratorRoleInput<TRes>
    implements CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$RevokeMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$RevokeMigratorRoleInput _instance;

  final TRes Function(Input$RevokeMigratorRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? actor = _undefined,
    Object? actorType = _undefined,
  }) =>
      _then(Input$RevokeMigratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (actor != _undefined && actor != null) 'actor': (actor as String),
        if (actorType != _undefined && actorType != null)
          'actorType': (actorType as Enum$ActorType),
      }));
}

class _CopyWithStubImpl$Input$RevokeMigratorRoleInput<TRes>
    implements CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$RevokeMigratorRoleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    String? actor,
    Enum$ActorType? actorType,
  }) =>
      _res;
}

class Input$RuleParametersInput {
  factory Input$RuleParametersInput({
    Input$UpdateParametersInput? update,
    Input$MergeQueueParametersInput? mergeQueue,
    Input$RequiredDeploymentsParametersInput? requiredDeployments,
    Input$PullRequestParametersInput? pullRequest,
    Input$RequiredStatusChecksParametersInput? requiredStatusChecks,
    Input$CommitMessagePatternParametersInput? commitMessagePattern,
    Input$CommitAuthorEmailPatternParametersInput? commitAuthorEmailPattern,
    Input$CommitterEmailPatternParametersInput? committerEmailPattern,
    Input$BranchNamePatternParametersInput? branchNamePattern,
    Input$TagNamePatternParametersInput? tagNamePattern,
    Input$FilePathRestrictionParametersInput? filePathRestriction,
    Input$MaxFilePathLengthParametersInput? maxFilePathLength,
    Input$FileExtensionRestrictionParametersInput? fileExtensionRestriction,
    Input$MaxFileSizeParametersInput? maxFileSize,
    Input$WorkflowsParametersInput? workflows,
    Input$CodeScanningParametersInput? codeScanning,
    Input$CopilotCodeReviewParametersInput? copilotCodeReview,
  }) =>
      Input$RuleParametersInput._({
        if (update != null) r'update': update,
        if (mergeQueue != null) r'mergeQueue': mergeQueue,
        if (requiredDeployments != null)
          r'requiredDeployments': requiredDeployments,
        if (pullRequest != null) r'pullRequest': pullRequest,
        if (requiredStatusChecks != null)
          r'requiredStatusChecks': requiredStatusChecks,
        if (commitMessagePattern != null)
          r'commitMessagePattern': commitMessagePattern,
        if (commitAuthorEmailPattern != null)
          r'commitAuthorEmailPattern': commitAuthorEmailPattern,
        if (committerEmailPattern != null)
          r'committerEmailPattern': committerEmailPattern,
        if (branchNamePattern != null) r'branchNamePattern': branchNamePattern,
        if (tagNamePattern != null) r'tagNamePattern': tagNamePattern,
        if (filePathRestriction != null)
          r'filePathRestriction': filePathRestriction,
        if (maxFilePathLength != null) r'maxFilePathLength': maxFilePathLength,
        if (fileExtensionRestriction != null)
          r'fileExtensionRestriction': fileExtensionRestriction,
        if (maxFileSize != null) r'maxFileSize': maxFileSize,
        if (workflows != null) r'workflows': workflows,
        if (codeScanning != null) r'codeScanning': codeScanning,
        if (copilotCodeReview != null) r'copilotCodeReview': copilotCodeReview,
      });

  Input$RuleParametersInput._(this._$data);

  factory Input$RuleParametersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$UpdateParametersInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    if (data.containsKey('mergeQueue')) {
      final l$mergeQueue = data['mergeQueue'];
      result$data['mergeQueue'] = l$mergeQueue == null
          ? null
          : Input$MergeQueueParametersInput.fromJson(
              (l$mergeQueue as Map<String, dynamic>));
    }
    if (data.containsKey('requiredDeployments')) {
      final l$requiredDeployments = data['requiredDeployments'];
      result$data['requiredDeployments'] = l$requiredDeployments == null
          ? null
          : Input$RequiredDeploymentsParametersInput.fromJson(
              (l$requiredDeployments as Map<String, dynamic>));
    }
    if (data.containsKey('pullRequest')) {
      final l$pullRequest = data['pullRequest'];
      result$data['pullRequest'] = l$pullRequest == null
          ? null
          : Input$PullRequestParametersInput.fromJson(
              (l$pullRequest as Map<String, dynamic>));
    }
    if (data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = data['requiredStatusChecks'];
      result$data['requiredStatusChecks'] = l$requiredStatusChecks == null
          ? null
          : Input$RequiredStatusChecksParametersInput.fromJson(
              (l$requiredStatusChecks as Map<String, dynamic>));
    }
    if (data.containsKey('commitMessagePattern')) {
      final l$commitMessagePattern = data['commitMessagePattern'];
      result$data['commitMessagePattern'] = l$commitMessagePattern == null
          ? null
          : Input$CommitMessagePatternParametersInput.fromJson(
              (l$commitMessagePattern as Map<String, dynamic>));
    }
    if (data.containsKey('commitAuthorEmailPattern')) {
      final l$commitAuthorEmailPattern = data['commitAuthorEmailPattern'];
      result$data['commitAuthorEmailPattern'] =
          l$commitAuthorEmailPattern == null
              ? null
              : Input$CommitAuthorEmailPatternParametersInput.fromJson(
                  (l$commitAuthorEmailPattern as Map<String, dynamic>));
    }
    if (data.containsKey('committerEmailPattern')) {
      final l$committerEmailPattern = data['committerEmailPattern'];
      result$data['committerEmailPattern'] = l$committerEmailPattern == null
          ? null
          : Input$CommitterEmailPatternParametersInput.fromJson(
              (l$committerEmailPattern as Map<String, dynamic>));
    }
    if (data.containsKey('branchNamePattern')) {
      final l$branchNamePattern = data['branchNamePattern'];
      result$data['branchNamePattern'] = l$branchNamePattern == null
          ? null
          : Input$BranchNamePatternParametersInput.fromJson(
              (l$branchNamePattern as Map<String, dynamic>));
    }
    if (data.containsKey('tagNamePattern')) {
      final l$tagNamePattern = data['tagNamePattern'];
      result$data['tagNamePattern'] = l$tagNamePattern == null
          ? null
          : Input$TagNamePatternParametersInput.fromJson(
              (l$tagNamePattern as Map<String, dynamic>));
    }
    if (data.containsKey('filePathRestriction')) {
      final l$filePathRestriction = data['filePathRestriction'];
      result$data['filePathRestriction'] = l$filePathRestriction == null
          ? null
          : Input$FilePathRestrictionParametersInput.fromJson(
              (l$filePathRestriction as Map<String, dynamic>));
    }
    if (data.containsKey('maxFilePathLength')) {
      final l$maxFilePathLength = data['maxFilePathLength'];
      result$data['maxFilePathLength'] = l$maxFilePathLength == null
          ? null
          : Input$MaxFilePathLengthParametersInput.fromJson(
              (l$maxFilePathLength as Map<String, dynamic>));
    }
    if (data.containsKey('fileExtensionRestriction')) {
      final l$fileExtensionRestriction = data['fileExtensionRestriction'];
      result$data['fileExtensionRestriction'] =
          l$fileExtensionRestriction == null
              ? null
              : Input$FileExtensionRestrictionParametersInput.fromJson(
                  (l$fileExtensionRestriction as Map<String, dynamic>));
    }
    if (data.containsKey('maxFileSize')) {
      final l$maxFileSize = data['maxFileSize'];
      result$data['maxFileSize'] = l$maxFileSize == null
          ? null
          : Input$MaxFileSizeParametersInput.fromJson(
              (l$maxFileSize as Map<String, dynamic>));
    }
    if (data.containsKey('workflows')) {
      final l$workflows = data['workflows'];
      result$data['workflows'] = l$workflows == null
          ? null
          : Input$WorkflowsParametersInput.fromJson(
              (l$workflows as Map<String, dynamic>));
    }
    if (data.containsKey('codeScanning')) {
      final l$codeScanning = data['codeScanning'];
      result$data['codeScanning'] = l$codeScanning == null
          ? null
          : Input$CodeScanningParametersInput.fromJson(
              (l$codeScanning as Map<String, dynamic>));
    }
    if (data.containsKey('copilotCodeReview')) {
      final l$copilotCodeReview = data['copilotCodeReview'];
      result$data['copilotCodeReview'] = l$copilotCodeReview == null
          ? null
          : Input$CopilotCodeReviewParametersInput.fromJson(
              (l$copilotCodeReview as Map<String, dynamic>));
    }
    return Input$RuleParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UpdateParametersInput? get update =>
      (_$data['update'] as Input$UpdateParametersInput?);

  Input$MergeQueueParametersInput? get mergeQueue =>
      (_$data['mergeQueue'] as Input$MergeQueueParametersInput?);

  Input$RequiredDeploymentsParametersInput? get requiredDeployments =>
      (_$data['requiredDeployments']
          as Input$RequiredDeploymentsParametersInput?);

  Input$PullRequestParametersInput? get pullRequest =>
      (_$data['pullRequest'] as Input$PullRequestParametersInput?);

  Input$RequiredStatusChecksParametersInput? get requiredStatusChecks =>
      (_$data['requiredStatusChecks']
          as Input$RequiredStatusChecksParametersInput?);

  Input$CommitMessagePatternParametersInput? get commitMessagePattern =>
      (_$data['commitMessagePattern']
          as Input$CommitMessagePatternParametersInput?);

  Input$CommitAuthorEmailPatternParametersInput? get commitAuthorEmailPattern =>
      (_$data['commitAuthorEmailPattern']
          as Input$CommitAuthorEmailPatternParametersInput?);

  Input$CommitterEmailPatternParametersInput? get committerEmailPattern =>
      (_$data['committerEmailPattern']
          as Input$CommitterEmailPatternParametersInput?);

  Input$BranchNamePatternParametersInput? get branchNamePattern =>
      (_$data['branchNamePattern'] as Input$BranchNamePatternParametersInput?);

  Input$TagNamePatternParametersInput? get tagNamePattern =>
      (_$data['tagNamePattern'] as Input$TagNamePatternParametersInput?);

  Input$FilePathRestrictionParametersInput? get filePathRestriction =>
      (_$data['filePathRestriction']
          as Input$FilePathRestrictionParametersInput?);

  Input$MaxFilePathLengthParametersInput? get maxFilePathLength =>
      (_$data['maxFilePathLength'] as Input$MaxFilePathLengthParametersInput?);

  Input$FileExtensionRestrictionParametersInput? get fileExtensionRestriction =>
      (_$data['fileExtensionRestriction']
          as Input$FileExtensionRestrictionParametersInput?);

  Input$MaxFileSizeParametersInput? get maxFileSize =>
      (_$data['maxFileSize'] as Input$MaxFileSizeParametersInput?);

  Input$WorkflowsParametersInput? get workflows =>
      (_$data['workflows'] as Input$WorkflowsParametersInput?);

  Input$CodeScanningParametersInput? get codeScanning =>
      (_$data['codeScanning'] as Input$CodeScanningParametersInput?);

  Input$CopilotCodeReviewParametersInput? get copilotCodeReview =>
      (_$data['copilotCodeReview'] as Input$CopilotCodeReviewParametersInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    if (_$data.containsKey('mergeQueue')) {
      final l$mergeQueue = mergeQueue;
      result$data['mergeQueue'] = l$mergeQueue?.toJson();
    }
    if (_$data.containsKey('requiredDeployments')) {
      final l$requiredDeployments = requiredDeployments;
      result$data['requiredDeployments'] = l$requiredDeployments?.toJson();
    }
    if (_$data.containsKey('pullRequest')) {
      final l$pullRequest = pullRequest;
      result$data['pullRequest'] = l$pullRequest?.toJson();
    }
    if (_$data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = requiredStatusChecks;
      result$data['requiredStatusChecks'] = l$requiredStatusChecks?.toJson();
    }
    if (_$data.containsKey('commitMessagePattern')) {
      final l$commitMessagePattern = commitMessagePattern;
      result$data['commitMessagePattern'] = l$commitMessagePattern?.toJson();
    }
    if (_$data.containsKey('commitAuthorEmailPattern')) {
      final l$commitAuthorEmailPattern = commitAuthorEmailPattern;
      result$data['commitAuthorEmailPattern'] =
          l$commitAuthorEmailPattern?.toJson();
    }
    if (_$data.containsKey('committerEmailPattern')) {
      final l$committerEmailPattern = committerEmailPattern;
      result$data['committerEmailPattern'] = l$committerEmailPattern?.toJson();
    }
    if (_$data.containsKey('branchNamePattern')) {
      final l$branchNamePattern = branchNamePattern;
      result$data['branchNamePattern'] = l$branchNamePattern?.toJson();
    }
    if (_$data.containsKey('tagNamePattern')) {
      final l$tagNamePattern = tagNamePattern;
      result$data['tagNamePattern'] = l$tagNamePattern?.toJson();
    }
    if (_$data.containsKey('filePathRestriction')) {
      final l$filePathRestriction = filePathRestriction;
      result$data['filePathRestriction'] = l$filePathRestriction?.toJson();
    }
    if (_$data.containsKey('maxFilePathLength')) {
      final l$maxFilePathLength = maxFilePathLength;
      result$data['maxFilePathLength'] = l$maxFilePathLength?.toJson();
    }
    if (_$data.containsKey('fileExtensionRestriction')) {
      final l$fileExtensionRestriction = fileExtensionRestriction;
      result$data['fileExtensionRestriction'] =
          l$fileExtensionRestriction?.toJson();
    }
    if (_$data.containsKey('maxFileSize')) {
      final l$maxFileSize = maxFileSize;
      result$data['maxFileSize'] = l$maxFileSize?.toJson();
    }
    if (_$data.containsKey('workflows')) {
      final l$workflows = workflows;
      result$data['workflows'] = l$workflows?.toJson();
    }
    if (_$data.containsKey('codeScanning')) {
      final l$codeScanning = codeScanning;
      result$data['codeScanning'] = l$codeScanning?.toJson();
    }
    if (_$data.containsKey('copilotCodeReview')) {
      final l$copilotCodeReview = copilotCodeReview;
      result$data['copilotCodeReview'] = l$copilotCodeReview?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$RuleParametersInput<Input$RuleParametersInput> get copyWith =>
      CopyWith$Input$RuleParametersInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$RuleParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    final l$mergeQueue = mergeQueue;
    final lOther$mergeQueue = other.mergeQueue;
    if (_$data.containsKey('mergeQueue') !=
        other._$data.containsKey('mergeQueue')) {
      return false;
    }
    if (l$mergeQueue != lOther$mergeQueue) {
      return false;
    }
    final l$requiredDeployments = requiredDeployments;
    final lOther$requiredDeployments = other.requiredDeployments;
    if (_$data.containsKey('requiredDeployments') !=
        other._$data.containsKey('requiredDeployments')) {
      return false;
    }
    if (l$requiredDeployments != lOther$requiredDeployments) {
      return false;
    }
    final l$pullRequest = pullRequest;
    final lOther$pullRequest = other.pullRequest;
    if (_$data.containsKey('pullRequest') !=
        other._$data.containsKey('pullRequest')) {
      return false;
    }
    if (l$pullRequest != lOther$pullRequest) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (_$data.containsKey('requiredStatusChecks') !=
        other._$data.containsKey('requiredStatusChecks')) {
      return false;
    }
    if (l$requiredStatusChecks != lOther$requiredStatusChecks) {
      return false;
    }
    final l$commitMessagePattern = commitMessagePattern;
    final lOther$commitMessagePattern = other.commitMessagePattern;
    if (_$data.containsKey('commitMessagePattern') !=
        other._$data.containsKey('commitMessagePattern')) {
      return false;
    }
    if (l$commitMessagePattern != lOther$commitMessagePattern) {
      return false;
    }
    final l$commitAuthorEmailPattern = commitAuthorEmailPattern;
    final lOther$commitAuthorEmailPattern = other.commitAuthorEmailPattern;
    if (_$data.containsKey('commitAuthorEmailPattern') !=
        other._$data.containsKey('commitAuthorEmailPattern')) {
      return false;
    }
    if (l$commitAuthorEmailPattern != lOther$commitAuthorEmailPattern) {
      return false;
    }
    final l$committerEmailPattern = committerEmailPattern;
    final lOther$committerEmailPattern = other.committerEmailPattern;
    if (_$data.containsKey('committerEmailPattern') !=
        other._$data.containsKey('committerEmailPattern')) {
      return false;
    }
    if (l$committerEmailPattern != lOther$committerEmailPattern) {
      return false;
    }
    final l$branchNamePattern = branchNamePattern;
    final lOther$branchNamePattern = other.branchNamePattern;
    if (_$data.containsKey('branchNamePattern') !=
        other._$data.containsKey('branchNamePattern')) {
      return false;
    }
    if (l$branchNamePattern != lOther$branchNamePattern) {
      return false;
    }
    final l$tagNamePattern = tagNamePattern;
    final lOther$tagNamePattern = other.tagNamePattern;
    if (_$data.containsKey('tagNamePattern') !=
        other._$data.containsKey('tagNamePattern')) {
      return false;
    }
    if (l$tagNamePattern != lOther$tagNamePattern) {
      return false;
    }
    final l$filePathRestriction = filePathRestriction;
    final lOther$filePathRestriction = other.filePathRestriction;
    if (_$data.containsKey('filePathRestriction') !=
        other._$data.containsKey('filePathRestriction')) {
      return false;
    }
    if (l$filePathRestriction != lOther$filePathRestriction) {
      return false;
    }
    final l$maxFilePathLength = maxFilePathLength;
    final lOther$maxFilePathLength = other.maxFilePathLength;
    if (_$data.containsKey('maxFilePathLength') !=
        other._$data.containsKey('maxFilePathLength')) {
      return false;
    }
    if (l$maxFilePathLength != lOther$maxFilePathLength) {
      return false;
    }
    final l$fileExtensionRestriction = fileExtensionRestriction;
    final lOther$fileExtensionRestriction = other.fileExtensionRestriction;
    if (_$data.containsKey('fileExtensionRestriction') !=
        other._$data.containsKey('fileExtensionRestriction')) {
      return false;
    }
    if (l$fileExtensionRestriction != lOther$fileExtensionRestriction) {
      return false;
    }
    final l$maxFileSize = maxFileSize;
    final lOther$maxFileSize = other.maxFileSize;
    if (_$data.containsKey('maxFileSize') !=
        other._$data.containsKey('maxFileSize')) {
      return false;
    }
    if (l$maxFileSize != lOther$maxFileSize) {
      return false;
    }
    final l$workflows = workflows;
    final lOther$workflows = other.workflows;
    if (_$data.containsKey('workflows') !=
        other._$data.containsKey('workflows')) {
      return false;
    }
    if (l$workflows != lOther$workflows) {
      return false;
    }
    final l$codeScanning = codeScanning;
    final lOther$codeScanning = other.codeScanning;
    if (_$data.containsKey('codeScanning') !=
        other._$data.containsKey('codeScanning')) {
      return false;
    }
    if (l$codeScanning != lOther$codeScanning) {
      return false;
    }
    final l$copilotCodeReview = copilotCodeReview;
    final lOther$copilotCodeReview = other.copilotCodeReview;
    if (_$data.containsKey('copilotCodeReview') !=
        other._$data.containsKey('copilotCodeReview')) {
      return false;
    }
    if (l$copilotCodeReview != lOther$copilotCodeReview) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$mergeQueue = mergeQueue;
    final l$requiredDeployments = requiredDeployments;
    final l$pullRequest = pullRequest;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$commitMessagePattern = commitMessagePattern;
    final l$commitAuthorEmailPattern = commitAuthorEmailPattern;
    final l$committerEmailPattern = committerEmailPattern;
    final l$branchNamePattern = branchNamePattern;
    final l$tagNamePattern = tagNamePattern;
    final l$filePathRestriction = filePathRestriction;
    final l$maxFilePathLength = maxFilePathLength;
    final l$fileExtensionRestriction = fileExtensionRestriction;
    final l$maxFileSize = maxFileSize;
    final l$workflows = workflows;
    final l$codeScanning = codeScanning;
    final l$copilotCodeReview = copilotCodeReview;
    return Object.hashAll([
      _$data.containsKey('update') ? l$update : const {},
      _$data.containsKey('mergeQueue') ? l$mergeQueue : const {},
      _$data.containsKey('requiredDeployments')
          ? l$requiredDeployments
          : const {},
      _$data.containsKey('pullRequest') ? l$pullRequest : const {},
      _$data.containsKey('requiredStatusChecks')
          ? l$requiredStatusChecks
          : const {},
      _$data.containsKey('commitMessagePattern')
          ? l$commitMessagePattern
          : const {},
      _$data.containsKey('commitAuthorEmailPattern')
          ? l$commitAuthorEmailPattern
          : const {},
      _$data.containsKey('committerEmailPattern')
          ? l$committerEmailPattern
          : const {},
      _$data.containsKey('branchNamePattern') ? l$branchNamePattern : const {},
      _$data.containsKey('tagNamePattern') ? l$tagNamePattern : const {},
      _$data.containsKey('filePathRestriction')
          ? l$filePathRestriction
          : const {},
      _$data.containsKey('maxFilePathLength') ? l$maxFilePathLength : const {},
      _$data.containsKey('fileExtensionRestriction')
          ? l$fileExtensionRestriction
          : const {},
      _$data.containsKey('maxFileSize') ? l$maxFileSize : const {},
      _$data.containsKey('workflows') ? l$workflows : const {},
      _$data.containsKey('codeScanning') ? l$codeScanning : const {},
      _$data.containsKey('copilotCodeReview') ? l$copilotCodeReview : const {},
    ]);
  }
}

abstract class CopyWith$Input$RuleParametersInput<TRes> {
  factory CopyWith$Input$RuleParametersInput(
    Input$RuleParametersInput instance,
    TRes Function(Input$RuleParametersInput) then,
  ) = _CopyWithImpl$Input$RuleParametersInput;

  factory CopyWith$Input$RuleParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RuleParametersInput;

  TRes call({
    Input$UpdateParametersInput? update,
    Input$MergeQueueParametersInput? mergeQueue,
    Input$RequiredDeploymentsParametersInput? requiredDeployments,
    Input$PullRequestParametersInput? pullRequest,
    Input$RequiredStatusChecksParametersInput? requiredStatusChecks,
    Input$CommitMessagePatternParametersInput? commitMessagePattern,
    Input$CommitAuthorEmailPatternParametersInput? commitAuthorEmailPattern,
    Input$CommitterEmailPatternParametersInput? committerEmailPattern,
    Input$BranchNamePatternParametersInput? branchNamePattern,
    Input$TagNamePatternParametersInput? tagNamePattern,
    Input$FilePathRestrictionParametersInput? filePathRestriction,
    Input$MaxFilePathLengthParametersInput? maxFilePathLength,
    Input$FileExtensionRestrictionParametersInput? fileExtensionRestriction,
    Input$MaxFileSizeParametersInput? maxFileSize,
    Input$WorkflowsParametersInput? workflows,
    Input$CodeScanningParametersInput? codeScanning,
    Input$CopilotCodeReviewParametersInput? copilotCodeReview,
  });
  CopyWith$Input$UpdateParametersInput<TRes> get update;
  CopyWith$Input$MergeQueueParametersInput<TRes> get mergeQueue;
  CopyWith$Input$RequiredDeploymentsParametersInput<TRes>
      get requiredDeployments;
  CopyWith$Input$PullRequestParametersInput<TRes> get pullRequest;
  CopyWith$Input$RequiredStatusChecksParametersInput<TRes>
      get requiredStatusChecks;
  CopyWith$Input$CommitMessagePatternParametersInput<TRes>
      get commitMessagePattern;
  CopyWith$Input$CommitAuthorEmailPatternParametersInput<TRes>
      get commitAuthorEmailPattern;
  CopyWith$Input$CommitterEmailPatternParametersInput<TRes>
      get committerEmailPattern;
  CopyWith$Input$BranchNamePatternParametersInput<TRes> get branchNamePattern;
  CopyWith$Input$TagNamePatternParametersInput<TRes> get tagNamePattern;
  CopyWith$Input$FilePathRestrictionParametersInput<TRes>
      get filePathRestriction;
  CopyWith$Input$MaxFilePathLengthParametersInput<TRes> get maxFilePathLength;
  CopyWith$Input$FileExtensionRestrictionParametersInput<TRes>
      get fileExtensionRestriction;
  CopyWith$Input$MaxFileSizeParametersInput<TRes> get maxFileSize;
  CopyWith$Input$WorkflowsParametersInput<TRes> get workflows;
  CopyWith$Input$CodeScanningParametersInput<TRes> get codeScanning;
  CopyWith$Input$CopilotCodeReviewParametersInput<TRes> get copilotCodeReview;
}

class _CopyWithImpl$Input$RuleParametersInput<TRes>
    implements CopyWith$Input$RuleParametersInput<TRes> {
  _CopyWithImpl$Input$RuleParametersInput(
    this._instance,
    this._then,
  );

  final Input$RuleParametersInput _instance;

  final TRes Function(Input$RuleParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? mergeQueue = _undefined,
    Object? requiredDeployments = _undefined,
    Object? pullRequest = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? commitMessagePattern = _undefined,
    Object? commitAuthorEmailPattern = _undefined,
    Object? committerEmailPattern = _undefined,
    Object? branchNamePattern = _undefined,
    Object? tagNamePattern = _undefined,
    Object? filePathRestriction = _undefined,
    Object? maxFilePathLength = _undefined,
    Object? fileExtensionRestriction = _undefined,
    Object? maxFileSize = _undefined,
    Object? workflows = _undefined,
    Object? codeScanning = _undefined,
    Object? copilotCodeReview = _undefined,
  }) =>
      _then(Input$RuleParametersInput._({
        ..._instance._$data,
        if (update != _undefined)
          'update': (update as Input$UpdateParametersInput?),
        if (mergeQueue != _undefined)
          'mergeQueue': (mergeQueue as Input$MergeQueueParametersInput?),
        if (requiredDeployments != _undefined)
          'requiredDeployments': (requiredDeployments
              as Input$RequiredDeploymentsParametersInput?),
        if (pullRequest != _undefined)
          'pullRequest': (pullRequest as Input$PullRequestParametersInput?),
        if (requiredStatusChecks != _undefined)
          'requiredStatusChecks': (requiredStatusChecks
              as Input$RequiredStatusChecksParametersInput?),
        if (commitMessagePattern != _undefined)
          'commitMessagePattern': (commitMessagePattern
              as Input$CommitMessagePatternParametersInput?),
        if (commitAuthorEmailPattern != _undefined)
          'commitAuthorEmailPattern': (commitAuthorEmailPattern
              as Input$CommitAuthorEmailPatternParametersInput?),
        if (committerEmailPattern != _undefined)
          'committerEmailPattern': (committerEmailPattern
              as Input$CommitterEmailPatternParametersInput?),
        if (branchNamePattern != _undefined)
          'branchNamePattern':
              (branchNamePattern as Input$BranchNamePatternParametersInput?),
        if (tagNamePattern != _undefined)
          'tagNamePattern':
              (tagNamePattern as Input$TagNamePatternParametersInput?),
        if (filePathRestriction != _undefined)
          'filePathRestriction': (filePathRestriction
              as Input$FilePathRestrictionParametersInput?),
        if (maxFilePathLength != _undefined)
          'maxFilePathLength':
              (maxFilePathLength as Input$MaxFilePathLengthParametersInput?),
        if (fileExtensionRestriction != _undefined)
          'fileExtensionRestriction': (fileExtensionRestriction
              as Input$FileExtensionRestrictionParametersInput?),
        if (maxFileSize != _undefined)
          'maxFileSize': (maxFileSize as Input$MaxFileSizeParametersInput?),
        if (workflows != _undefined)
          'workflows': (workflows as Input$WorkflowsParametersInput?),
        if (codeScanning != _undefined)
          'codeScanning': (codeScanning as Input$CodeScanningParametersInput?),
        if (copilotCodeReview != _undefined)
          'copilotCodeReview':
              (copilotCodeReview as Input$CopilotCodeReviewParametersInput?),
      }));

  CopyWith$Input$UpdateParametersInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$UpdateParametersInput.stub(_then(_instance))
        : CopyWith$Input$UpdateParametersInput(
            local$update, (e) => call(update: e));
  }

  CopyWith$Input$MergeQueueParametersInput<TRes> get mergeQueue {
    final local$mergeQueue = _instance.mergeQueue;
    return local$mergeQueue == null
        ? CopyWith$Input$MergeQueueParametersInput.stub(_then(_instance))
        : CopyWith$Input$MergeQueueParametersInput(
            local$mergeQueue, (e) => call(mergeQueue: e));
  }

  CopyWith$Input$RequiredDeploymentsParametersInput<TRes>
      get requiredDeployments {
    final local$requiredDeployments = _instance.requiredDeployments;
    return local$requiredDeployments == null
        ? CopyWith$Input$RequiredDeploymentsParametersInput.stub(
            _then(_instance))
        : CopyWith$Input$RequiredDeploymentsParametersInput(
            local$requiredDeployments, (e) => call(requiredDeployments: e));
  }

  CopyWith$Input$PullRequestParametersInput<TRes> get pullRequest {
    final local$pullRequest = _instance.pullRequest;
    return local$pullRequest == null
        ? CopyWith$Input$PullRequestParametersInput.stub(_then(_instance))
        : CopyWith$Input$PullRequestParametersInput(
            local$pullRequest, (e) => call(pullRequest: e));
  }

  CopyWith$Input$RequiredStatusChecksParametersInput<TRes>
      get requiredStatusChecks {
    final local$requiredStatusChecks = _instance.requiredStatusChecks;
    return local$requiredStatusChecks == null
        ? CopyWith$Input$RequiredStatusChecksParametersInput.stub(
            _then(_instance))
        : CopyWith$Input$RequiredStatusChecksParametersInput(
            local$requiredStatusChecks, (e) => call(requiredStatusChecks: e));
  }

  CopyWith$Input$CommitMessagePatternParametersInput<TRes>
      get commitMessagePattern {
    final local$commitMessagePattern = _instance.commitMessagePattern;
    return local$commitMessagePattern == null
        ? CopyWith$Input$CommitMessagePatternParametersInput.stub(
            _then(_instance))
        : CopyWith$Input$CommitMessagePatternParametersInput(
            local$commitMessagePattern, (e) => call(commitMessagePattern: e));
  }

  CopyWith$Input$CommitAuthorEmailPatternParametersInput<TRes>
      get commitAuthorEmailPattern {
    final local$commitAuthorEmailPattern = _instance.commitAuthorEmailPattern;
    return local$commitAuthorEmailPattern == null
        ? CopyWith$Input$CommitAuthorEmailPatternParametersInput.stub(
            _then(_instance))
        : CopyWith$Input$CommitAuthorEmailPatternParametersInput(
            local$commitAuthorEmailPattern,
            (e) => call(commitAuthorEmailPattern: e));
  }

  CopyWith$Input$CommitterEmailPatternParametersInput<TRes>
      get committerEmailPattern {
    final local$committerEmailPattern = _instance.committerEmailPattern;
    return local$committerEmailPattern == null
        ? CopyWith$Input$CommitterEmailPatternParametersInput.stub(
            _then(_instance))
        : CopyWith$Input$CommitterEmailPatternParametersInput(
            local$committerEmailPattern, (e) => call(committerEmailPattern: e));
  }

  CopyWith$Input$BranchNamePatternParametersInput<TRes> get branchNamePattern {
    final local$branchNamePattern = _instance.branchNamePattern;
    return local$branchNamePattern == null
        ? CopyWith$Input$BranchNamePatternParametersInput.stub(_then(_instance))
        : CopyWith$Input$BranchNamePatternParametersInput(
            local$branchNamePattern, (e) => call(branchNamePattern: e));
  }

  CopyWith$Input$TagNamePatternParametersInput<TRes> get tagNamePattern {
    final local$tagNamePattern = _instance.tagNamePattern;
    return local$tagNamePattern == null
        ? CopyWith$Input$TagNamePatternParametersInput.stub(_then(_instance))
        : CopyWith$Input$TagNamePatternParametersInput(
            local$tagNamePattern, (e) => call(tagNamePattern: e));
  }

  CopyWith$Input$FilePathRestrictionParametersInput<TRes>
      get filePathRestriction {
    final local$filePathRestriction = _instance.filePathRestriction;
    return local$filePathRestriction == null
        ? CopyWith$Input$FilePathRestrictionParametersInput.stub(
            _then(_instance))
        : CopyWith$Input$FilePathRestrictionParametersInput(
            local$filePathRestriction, (e) => call(filePathRestriction: e));
  }

  CopyWith$Input$MaxFilePathLengthParametersInput<TRes> get maxFilePathLength {
    final local$maxFilePathLength = _instance.maxFilePathLength;
    return local$maxFilePathLength == null
        ? CopyWith$Input$MaxFilePathLengthParametersInput.stub(_then(_instance))
        : CopyWith$Input$MaxFilePathLengthParametersInput(
            local$maxFilePathLength, (e) => call(maxFilePathLength: e));
  }

  CopyWith$Input$FileExtensionRestrictionParametersInput<TRes>
      get fileExtensionRestriction {
    final local$fileExtensionRestriction = _instance.fileExtensionRestriction;
    return local$fileExtensionRestriction == null
        ? CopyWith$Input$FileExtensionRestrictionParametersInput.stub(
            _then(_instance))
        : CopyWith$Input$FileExtensionRestrictionParametersInput(
            local$fileExtensionRestriction,
            (e) => call(fileExtensionRestriction: e));
  }

  CopyWith$Input$MaxFileSizeParametersInput<TRes> get maxFileSize {
    final local$maxFileSize = _instance.maxFileSize;
    return local$maxFileSize == null
        ? CopyWith$Input$MaxFileSizeParametersInput.stub(_then(_instance))
        : CopyWith$Input$MaxFileSizeParametersInput(
            local$maxFileSize, (e) => call(maxFileSize: e));
  }

  CopyWith$Input$WorkflowsParametersInput<TRes> get workflows {
    final local$workflows = _instance.workflows;
    return local$workflows == null
        ? CopyWith$Input$WorkflowsParametersInput.stub(_then(_instance))
        : CopyWith$Input$WorkflowsParametersInput(
            local$workflows, (e) => call(workflows: e));
  }

  CopyWith$Input$CodeScanningParametersInput<TRes> get codeScanning {
    final local$codeScanning = _instance.codeScanning;
    return local$codeScanning == null
        ? CopyWith$Input$CodeScanningParametersInput.stub(_then(_instance))
        : CopyWith$Input$CodeScanningParametersInput(
            local$codeScanning, (e) => call(codeScanning: e));
  }

  CopyWith$Input$CopilotCodeReviewParametersInput<TRes> get copilotCodeReview {
    final local$copilotCodeReview = _instance.copilotCodeReview;
    return local$copilotCodeReview == null
        ? CopyWith$Input$CopilotCodeReviewParametersInput.stub(_then(_instance))
        : CopyWith$Input$CopilotCodeReviewParametersInput(
            local$copilotCodeReview, (e) => call(copilotCodeReview: e));
  }
}

class _CopyWithStubImpl$Input$RuleParametersInput<TRes>
    implements CopyWith$Input$RuleParametersInput<TRes> {
  _CopyWithStubImpl$Input$RuleParametersInput(this._res);

  TRes _res;

  call({
    Input$UpdateParametersInput? update,
    Input$MergeQueueParametersInput? mergeQueue,
    Input$RequiredDeploymentsParametersInput? requiredDeployments,
    Input$PullRequestParametersInput? pullRequest,
    Input$RequiredStatusChecksParametersInput? requiredStatusChecks,
    Input$CommitMessagePatternParametersInput? commitMessagePattern,
    Input$CommitAuthorEmailPatternParametersInput? commitAuthorEmailPattern,
    Input$CommitterEmailPatternParametersInput? committerEmailPattern,
    Input$BranchNamePatternParametersInput? branchNamePattern,
    Input$TagNamePatternParametersInput? tagNamePattern,
    Input$FilePathRestrictionParametersInput? filePathRestriction,
    Input$MaxFilePathLengthParametersInput? maxFilePathLength,
    Input$FileExtensionRestrictionParametersInput? fileExtensionRestriction,
    Input$MaxFileSizeParametersInput? maxFileSize,
    Input$WorkflowsParametersInput? workflows,
    Input$CodeScanningParametersInput? codeScanning,
    Input$CopilotCodeReviewParametersInput? copilotCodeReview,
  }) =>
      _res;

  CopyWith$Input$UpdateParametersInput<TRes> get update =>
      CopyWith$Input$UpdateParametersInput.stub(_res);

  CopyWith$Input$MergeQueueParametersInput<TRes> get mergeQueue =>
      CopyWith$Input$MergeQueueParametersInput.stub(_res);

  CopyWith$Input$RequiredDeploymentsParametersInput<TRes>
      get requiredDeployments =>
          CopyWith$Input$RequiredDeploymentsParametersInput.stub(_res);

  CopyWith$Input$PullRequestParametersInput<TRes> get pullRequest =>
      CopyWith$Input$PullRequestParametersInput.stub(_res);

  CopyWith$Input$RequiredStatusChecksParametersInput<TRes>
      get requiredStatusChecks =>
          CopyWith$Input$RequiredStatusChecksParametersInput.stub(_res);

  CopyWith$Input$CommitMessagePatternParametersInput<TRes>
      get commitMessagePattern =>
          CopyWith$Input$CommitMessagePatternParametersInput.stub(_res);

  CopyWith$Input$CommitAuthorEmailPatternParametersInput<TRes>
      get commitAuthorEmailPattern =>
          CopyWith$Input$CommitAuthorEmailPatternParametersInput.stub(_res);

  CopyWith$Input$CommitterEmailPatternParametersInput<TRes>
      get committerEmailPattern =>
          CopyWith$Input$CommitterEmailPatternParametersInput.stub(_res);

  CopyWith$Input$BranchNamePatternParametersInput<TRes> get branchNamePattern =>
      CopyWith$Input$BranchNamePatternParametersInput.stub(_res);

  CopyWith$Input$TagNamePatternParametersInput<TRes> get tagNamePattern =>
      CopyWith$Input$TagNamePatternParametersInput.stub(_res);

  CopyWith$Input$FilePathRestrictionParametersInput<TRes>
      get filePathRestriction =>
          CopyWith$Input$FilePathRestrictionParametersInput.stub(_res);

  CopyWith$Input$MaxFilePathLengthParametersInput<TRes> get maxFilePathLength =>
      CopyWith$Input$MaxFilePathLengthParametersInput.stub(_res);

  CopyWith$Input$FileExtensionRestrictionParametersInput<TRes>
      get fileExtensionRestriction =>
          CopyWith$Input$FileExtensionRestrictionParametersInput.stub(_res);

  CopyWith$Input$MaxFileSizeParametersInput<TRes> get maxFileSize =>
      CopyWith$Input$MaxFileSizeParametersInput.stub(_res);

  CopyWith$Input$WorkflowsParametersInput<TRes> get workflows =>
      CopyWith$Input$WorkflowsParametersInput.stub(_res);

  CopyWith$Input$CodeScanningParametersInput<TRes> get codeScanning =>
      CopyWith$Input$CodeScanningParametersInput.stub(_res);

  CopyWith$Input$CopilotCodeReviewParametersInput<TRes> get copilotCodeReview =>
      CopyWith$Input$CopilotCodeReviewParametersInput.stub(_res);
}

class Input$SavedReplyOrder {
  factory Input$SavedReplyOrder({
    required Enum$SavedReplyOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SavedReplyOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SavedReplyOrder._(this._$data);

  factory Input$SavedReplyOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SavedReplyOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SavedReplyOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SavedReplyOrderField get field =>
      (_$data['field'] as Enum$SavedReplyOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SavedReplyOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SavedReplyOrder<Input$SavedReplyOrder> get copyWith =>
      CopyWith$Input$SavedReplyOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SavedReplyOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SavedReplyOrder<TRes> {
  factory CopyWith$Input$SavedReplyOrder(
    Input$SavedReplyOrder instance,
    TRes Function(Input$SavedReplyOrder) then,
  ) = _CopyWithImpl$Input$SavedReplyOrder;

  factory CopyWith$Input$SavedReplyOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SavedReplyOrder;

  TRes call({
    Enum$SavedReplyOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SavedReplyOrder<TRes>
    implements CopyWith$Input$SavedReplyOrder<TRes> {
  _CopyWithImpl$Input$SavedReplyOrder(
    this._instance,
    this._then,
  );

  final Input$SavedReplyOrder _instance;

  final TRes Function(Input$SavedReplyOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SavedReplyOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SavedReplyOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SavedReplyOrder<TRes>
    implements CopyWith$Input$SavedReplyOrder<TRes> {
  _CopyWithStubImpl$Input$SavedReplyOrder(this._res);

  TRes _res;

  call({
    Enum$SavedReplyOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SecurityAdvisoryIdentifierFilter {
  factory Input$SecurityAdvisoryIdentifierFilter({
    required Enum$SecurityAdvisoryIdentifierType type,
    required String value,
  }) =>
      Input$SecurityAdvisoryIdentifierFilter._({
        r'type': type,
        r'value': value,
      });

  Input$SecurityAdvisoryIdentifierFilter._(this._$data);

  factory Input$SecurityAdvisoryIdentifierFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$type = data['type'];
    result$data['type'] =
        fromJson$Enum$SecurityAdvisoryIdentifierType((l$type as String));
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$SecurityAdvisoryIdentifierFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SecurityAdvisoryIdentifierType get type =>
      (_$data['type'] as Enum$SecurityAdvisoryIdentifierType);

  String get value => (_$data['value'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$type = type;
    result$data['type'] = toJson$Enum$SecurityAdvisoryIdentifierType(l$type);
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$SecurityAdvisoryIdentifierFilter<
          Input$SecurityAdvisoryIdentifierFilter>
      get copyWith => CopyWith$Input$SecurityAdvisoryIdentifierFilter(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SecurityAdvisoryIdentifierFilter ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$value = value;
    return Object.hashAll([
      l$type,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  factory CopyWith$Input$SecurityAdvisoryIdentifierFilter(
    Input$SecurityAdvisoryIdentifierFilter instance,
    TRes Function(Input$SecurityAdvisoryIdentifierFilter) then,
  ) = _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter;

  factory CopyWith$Input$SecurityAdvisoryIdentifierFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter;

  TRes call({
    Enum$SecurityAdvisoryIdentifierType? type,
    String? value,
  });
}

class _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter<TRes>
    implements CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter(
    this._instance,
    this._then,
  );

  final Input$SecurityAdvisoryIdentifierFilter _instance;

  final TRes Function(Input$SecurityAdvisoryIdentifierFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$SecurityAdvisoryIdentifierFilter._({
        ..._instance._$data,
        if (type != _undefined && type != null)
          'type': (type as Enum$SecurityAdvisoryIdentifierType),
        if (value != _undefined && value != null) 'value': (value as String),
      }));
}

class _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter<TRes>
    implements CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter(this._res);

  TRes _res;

  call({
    Enum$SecurityAdvisoryIdentifierType? type,
    String? value,
  }) =>
      _res;
}

class Input$SecurityAdvisoryOrder {
  factory Input$SecurityAdvisoryOrder({
    required Enum$SecurityAdvisoryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SecurityAdvisoryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SecurityAdvisoryOrder._(this._$data);

  factory Input$SecurityAdvisoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SecurityAdvisoryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SecurityAdvisoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SecurityAdvisoryOrderField get field =>
      (_$data['field'] as Enum$SecurityAdvisoryOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SecurityAdvisoryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SecurityAdvisoryOrder<Input$SecurityAdvisoryOrder>
      get copyWith => CopyWith$Input$SecurityAdvisoryOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SecurityAdvisoryOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  factory CopyWith$Input$SecurityAdvisoryOrder(
    Input$SecurityAdvisoryOrder instance,
    TRes Function(Input$SecurityAdvisoryOrder) then,
  ) = _CopyWithImpl$Input$SecurityAdvisoryOrder;

  factory CopyWith$Input$SecurityAdvisoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityAdvisoryOrder;

  TRes call({
    Enum$SecurityAdvisoryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SecurityAdvisoryOrder<TRes>
    implements CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  _CopyWithImpl$Input$SecurityAdvisoryOrder(
    this._instance,
    this._then,
  );

  final Input$SecurityAdvisoryOrder _instance;

  final TRes Function(Input$SecurityAdvisoryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SecurityAdvisoryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SecurityAdvisoryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SecurityAdvisoryOrder<TRes>
    implements CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  _CopyWithStubImpl$Input$SecurityAdvisoryOrder(this._res);

  TRes _res;

  call({
    Enum$SecurityAdvisoryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SecurityVulnerabilityOrder {
  factory Input$SecurityVulnerabilityOrder({
    required Enum$SecurityVulnerabilityOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SecurityVulnerabilityOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SecurityVulnerabilityOrder._(this._$data);

  factory Input$SecurityVulnerabilityOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SecurityVulnerabilityOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SecurityVulnerabilityOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SecurityVulnerabilityOrderField get field =>
      (_$data['field'] as Enum$SecurityVulnerabilityOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SecurityVulnerabilityOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SecurityVulnerabilityOrder<Input$SecurityVulnerabilityOrder>
      get copyWith => CopyWith$Input$SecurityVulnerabilityOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SecurityVulnerabilityOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  factory CopyWith$Input$SecurityVulnerabilityOrder(
    Input$SecurityVulnerabilityOrder instance,
    TRes Function(Input$SecurityVulnerabilityOrder) then,
  ) = _CopyWithImpl$Input$SecurityVulnerabilityOrder;

  factory CopyWith$Input$SecurityVulnerabilityOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityVulnerabilityOrder;

  TRes call({
    Enum$SecurityVulnerabilityOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SecurityVulnerabilityOrder<TRes>
    implements CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  _CopyWithImpl$Input$SecurityVulnerabilityOrder(
    this._instance,
    this._then,
  );

  final Input$SecurityVulnerabilityOrder _instance;

  final TRes Function(Input$SecurityVulnerabilityOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SecurityVulnerabilityOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SecurityVulnerabilityOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SecurityVulnerabilityOrder<TRes>
    implements CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  _CopyWithStubImpl$Input$SecurityVulnerabilityOrder(this._res);

  TRes _res;

  call({
    Enum$SecurityVulnerabilityOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SetEnterpriseIdentityProviderInput {
  factory Input$SetEnterpriseIdentityProviderInput({
    String? clientMutationId,
    required String enterpriseId,
    required String ssoUrl,
    String? issuer,
    required String idpCertificate,
    required Enum$SamlSignatureAlgorithm signatureMethod,
    required Enum$SamlDigestAlgorithm digestMethod,
  }) =>
      Input$SetEnterpriseIdentityProviderInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'ssoUrl': ssoUrl,
        if (issuer != null) r'issuer': issuer,
        r'idpCertificate': idpCertificate,
        r'signatureMethod': signatureMethod,
        r'digestMethod': digestMethod,
      });

  Input$SetEnterpriseIdentityProviderInput._(this._$data);

  factory Input$SetEnterpriseIdentityProviderInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$ssoUrl = data['ssoUrl'];
    result$data['ssoUrl'] = (l$ssoUrl as String);
    if (data.containsKey('issuer')) {
      final l$issuer = data['issuer'];
      result$data['issuer'] = (l$issuer as String?);
    }
    final l$idpCertificate = data['idpCertificate'];
    result$data['idpCertificate'] = (l$idpCertificate as String);
    final l$signatureMethod = data['signatureMethod'];
    result$data['signatureMethod'] =
        fromJson$Enum$SamlSignatureAlgorithm((l$signatureMethod as String));
    final l$digestMethod = data['digestMethod'];
    result$data['digestMethod'] =
        fromJson$Enum$SamlDigestAlgorithm((l$digestMethod as String));
    return Input$SetEnterpriseIdentityProviderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get ssoUrl => (_$data['ssoUrl'] as String);

  String? get issuer => (_$data['issuer'] as String?);

  String get idpCertificate => (_$data['idpCertificate'] as String);

  Enum$SamlSignatureAlgorithm get signatureMethod =>
      (_$data['signatureMethod'] as Enum$SamlSignatureAlgorithm);

  Enum$SamlDigestAlgorithm get digestMethod =>
      (_$data['digestMethod'] as Enum$SamlDigestAlgorithm);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$ssoUrl = ssoUrl;
    result$data['ssoUrl'] = l$ssoUrl;
    if (_$data.containsKey('issuer')) {
      final l$issuer = issuer;
      result$data['issuer'] = l$issuer;
    }
    final l$idpCertificate = idpCertificate;
    result$data['idpCertificate'] = l$idpCertificate;
    final l$signatureMethod = signatureMethod;
    result$data['signatureMethod'] =
        toJson$Enum$SamlSignatureAlgorithm(l$signatureMethod);
    final l$digestMethod = digestMethod;
    result$data['digestMethod'] =
        toJson$Enum$SamlDigestAlgorithm(l$digestMethod);
    return result$data;
  }

  CopyWith$Input$SetEnterpriseIdentityProviderInput<
          Input$SetEnterpriseIdentityProviderInput>
      get copyWith => CopyWith$Input$SetEnterpriseIdentityProviderInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SetEnterpriseIdentityProviderInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$ssoUrl = ssoUrl;
    final lOther$ssoUrl = other.ssoUrl;
    if (l$ssoUrl != lOther$ssoUrl) {
      return false;
    }
    final l$issuer = issuer;
    final lOther$issuer = other.issuer;
    if (_$data.containsKey('issuer') != other._$data.containsKey('issuer')) {
      return false;
    }
    if (l$issuer != lOther$issuer) {
      return false;
    }
    final l$idpCertificate = idpCertificate;
    final lOther$idpCertificate = other.idpCertificate;
    if (l$idpCertificate != lOther$idpCertificate) {
      return false;
    }
    final l$signatureMethod = signatureMethod;
    final lOther$signatureMethod = other.signatureMethod;
    if (l$signatureMethod != lOther$signatureMethod) {
      return false;
    }
    final l$digestMethod = digestMethod;
    final lOther$digestMethod = other.digestMethod;
    if (l$digestMethod != lOther$digestMethod) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$ssoUrl = ssoUrl;
    final l$issuer = issuer;
    final l$idpCertificate = idpCertificate;
    final l$signatureMethod = signatureMethod;
    final l$digestMethod = digestMethod;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$ssoUrl,
      _$data.containsKey('issuer') ? l$issuer : const {},
      l$idpCertificate,
      l$signatureMethod,
      l$digestMethod,
    ]);
  }
}

abstract class CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  factory CopyWith$Input$SetEnterpriseIdentityProviderInput(
    Input$SetEnterpriseIdentityProviderInput instance,
    TRes Function(Input$SetEnterpriseIdentityProviderInput) then,
  ) = _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput;

  factory CopyWith$Input$SetEnterpriseIdentityProviderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? ssoUrl,
    String? issuer,
    String? idpCertificate,
    Enum$SamlSignatureAlgorithm? signatureMethod,
    Enum$SamlDigestAlgorithm? digestMethod,
  });
}

class _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput(
    this._instance,
    this._then,
  );

  final Input$SetEnterpriseIdentityProviderInput _instance;

  final TRes Function(Input$SetEnterpriseIdentityProviderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? ssoUrl = _undefined,
    Object? issuer = _undefined,
    Object? idpCertificate = _undefined,
    Object? signatureMethod = _undefined,
    Object? digestMethod = _undefined,
  }) =>
      _then(Input$SetEnterpriseIdentityProviderInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (ssoUrl != _undefined && ssoUrl != null)
          'ssoUrl': (ssoUrl as String),
        if (issuer != _undefined) 'issuer': (issuer as String?),
        if (idpCertificate != _undefined && idpCertificate != null)
          'idpCertificate': (idpCertificate as String),
        if (signatureMethod != _undefined && signatureMethod != null)
          'signatureMethod': (signatureMethod as Enum$SamlSignatureAlgorithm),
        if (digestMethod != _undefined && digestMethod != null)
          'digestMethod': (digestMethod as Enum$SamlDigestAlgorithm),
      }));
}

class _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? ssoUrl,
    String? issuer,
    String? idpCertificate,
    Enum$SamlSignatureAlgorithm? signatureMethod,
    Enum$SamlDigestAlgorithm? digestMethod,
  }) =>
      _res;
}

class Input$SetOrganizationInteractionLimitInput {
  factory Input$SetOrganizationInteractionLimitInput({
    String? clientMutationId,
    required String organizationId,
    required Enum$RepositoryInteractionLimit limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  }) =>
      Input$SetOrganizationInteractionLimitInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'limit': limit,
        if (expiry != null) r'expiry': expiry,
      });

  Input$SetOrganizationInteractionLimitInput._(this._$data);

  factory Input$SetOrganizationInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    return Input$SetOrganizationInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);

  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    return result$data;
  }

  CopyWith$Input$SetOrganizationInteractionLimitInput<
          Input$SetOrganizationInteractionLimitInput>
      get copyWith => CopyWith$Input$SetOrganizationInteractionLimitInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SetOrganizationInteractionLimitInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$limit = limit;
    final l$expiry = expiry;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$limit,
      _$data.containsKey('expiry') ? l$expiry : const {},
    ]);
  }
}

abstract class CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetOrganizationInteractionLimitInput(
    Input$SetOrganizationInteractionLimitInput instance,
    TRes Function(Input$SetOrganizationInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetOrganizationInteractionLimitInput;

  factory CopyWith$Input$SetOrganizationInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  });
}

class _CopyWithImpl$Input$SetOrganizationInteractionLimitInput<TRes>
    implements CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetOrganizationInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetOrganizationInteractionLimitInput _instance;

  final TRes Function(Input$SetOrganizationInteractionLimitInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? limit = _undefined,
    Object? expiry = _undefined,
  }) =>
      _then(Input$SetOrganizationInteractionLimitInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
      }));
}

class _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput<TRes>
    implements CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  }) =>
      _res;
}

class Input$SetRepositoryInteractionLimitInput {
  factory Input$SetRepositoryInteractionLimitInput({
    String? clientMutationId,
    required String repositoryId,
    required Enum$RepositoryInteractionLimit limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  }) =>
      Input$SetRepositoryInteractionLimitInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'limit': limit,
        if (expiry != null) r'expiry': expiry,
      });

  Input$SetRepositoryInteractionLimitInput._(this._$data);

  factory Input$SetRepositoryInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    return Input$SetRepositoryInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);

  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    return result$data;
  }

  CopyWith$Input$SetRepositoryInteractionLimitInput<
          Input$SetRepositoryInteractionLimitInput>
      get copyWith => CopyWith$Input$SetRepositoryInteractionLimitInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SetRepositoryInteractionLimitInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$limit = limit;
    final l$expiry = expiry;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$limit,
      _$data.containsKey('expiry') ? l$expiry : const {},
    ]);
  }
}

abstract class CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetRepositoryInteractionLimitInput(
    Input$SetRepositoryInteractionLimitInput instance,
    TRes Function(Input$SetRepositoryInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetRepositoryInteractionLimitInput;

  factory CopyWith$Input$SetRepositoryInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  });
}

class _CopyWithImpl$Input$SetRepositoryInteractionLimitInput<TRes>
    implements CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetRepositoryInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetRepositoryInteractionLimitInput _instance;

  final TRes Function(Input$SetRepositoryInteractionLimitInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? limit = _undefined,
    Object? expiry = _undefined,
  }) =>
      _then(Input$SetRepositoryInteractionLimitInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
      }));
}

class _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput<TRes>
    implements CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  }) =>
      _res;
}

class Input$SetUserInteractionLimitInput {
  factory Input$SetUserInteractionLimitInput({
    String? clientMutationId,
    required String userId,
    required Enum$RepositoryInteractionLimit limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  }) =>
      Input$SetUserInteractionLimitInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'userId': userId,
        r'limit': limit,
        if (expiry != null) r'expiry': expiry,
      });

  Input$SetUserInteractionLimitInput._(this._$data);

  factory Input$SetUserInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    return Input$SetUserInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get userId => (_$data['userId'] as String);

  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);

  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$userId = userId;
    result$data['userId'] = l$userId;
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    return result$data;
  }

  CopyWith$Input$SetUserInteractionLimitInput<
          Input$SetUserInteractionLimitInput>
      get copyWith => CopyWith$Input$SetUserInteractionLimitInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SetUserInteractionLimitInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$userId = userId;
    final l$limit = limit;
    final l$expiry = expiry;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$userId,
      l$limit,
      _$data.containsKey('expiry') ? l$expiry : const {},
    ]);
  }
}

abstract class CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetUserInteractionLimitInput(
    Input$SetUserInteractionLimitInput instance,
    TRes Function(Input$SetUserInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetUserInteractionLimitInput;

  factory CopyWith$Input$SetUserInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetUserInteractionLimitInput;

  TRes call({
    String? clientMutationId,
    String? userId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  });
}

class _CopyWithImpl$Input$SetUserInteractionLimitInput<TRes>
    implements CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetUserInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetUserInteractionLimitInput _instance;

  final TRes Function(Input$SetUserInteractionLimitInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? userId = _undefined,
    Object? limit = _undefined,
    Object? expiry = _undefined,
  }) =>
      _then(Input$SetUserInteractionLimitInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
      }));
}

class _CopyWithStubImpl$Input$SetUserInteractionLimitInput<TRes>
    implements CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetUserInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? userId,
    Enum$RepositoryInteractionLimit? limit,
    Enum$RepositoryInteractionLimitExpiry? expiry,
  }) =>
      _res;
}

class Input$SponsorableOrder {
  factory Input$SponsorableOrder({
    required Enum$SponsorableOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorableOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorableOrder._(this._$data);

  factory Input$SponsorableOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorableOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorableOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorableOrderField get field =>
      (_$data['field'] as Enum$SponsorableOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorableOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorableOrder<Input$SponsorableOrder> get copyWith =>
      CopyWith$Input$SponsorableOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SponsorableOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorableOrder<TRes> {
  factory CopyWith$Input$SponsorableOrder(
    Input$SponsorableOrder instance,
    TRes Function(Input$SponsorableOrder) then,
  ) = _CopyWithImpl$Input$SponsorableOrder;

  factory CopyWith$Input$SponsorableOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorableOrder;

  TRes call({
    Enum$SponsorableOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorableOrder<TRes>
    implements CopyWith$Input$SponsorableOrder<TRes> {
  _CopyWithImpl$Input$SponsorableOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorableOrder _instance;

  final TRes Function(Input$SponsorableOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorableOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorableOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorableOrder<TRes>
    implements CopyWith$Input$SponsorableOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorableOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorableOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorAndLifetimeValueOrder {
  factory Input$SponsorAndLifetimeValueOrder({
    required Enum$SponsorAndLifetimeValueOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorAndLifetimeValueOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorAndLifetimeValueOrder._(this._$data);

  factory Input$SponsorAndLifetimeValueOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorAndLifetimeValueOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorAndLifetimeValueOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorAndLifetimeValueOrderField get field =>
      (_$data['field'] as Enum$SponsorAndLifetimeValueOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] =
        toJson$Enum$SponsorAndLifetimeValueOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorAndLifetimeValueOrder<
          Input$SponsorAndLifetimeValueOrder>
      get copyWith => CopyWith$Input$SponsorAndLifetimeValueOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SponsorAndLifetimeValueOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorAndLifetimeValueOrder<TRes> {
  factory CopyWith$Input$SponsorAndLifetimeValueOrder(
    Input$SponsorAndLifetimeValueOrder instance,
    TRes Function(Input$SponsorAndLifetimeValueOrder) then,
  ) = _CopyWithImpl$Input$SponsorAndLifetimeValueOrder;

  factory CopyWith$Input$SponsorAndLifetimeValueOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorAndLifetimeValueOrder;

  TRes call({
    Enum$SponsorAndLifetimeValueOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorAndLifetimeValueOrder<TRes>
    implements CopyWith$Input$SponsorAndLifetimeValueOrder<TRes> {
  _CopyWithImpl$Input$SponsorAndLifetimeValueOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorAndLifetimeValueOrder _instance;

  final TRes Function(Input$SponsorAndLifetimeValueOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorAndLifetimeValueOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorAndLifetimeValueOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorAndLifetimeValueOrder<TRes>
    implements CopyWith$Input$SponsorAndLifetimeValueOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorAndLifetimeValueOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorAndLifetimeValueOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorOrder {
  factory Input$SponsorOrder({
    required Enum$SponsorOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorOrder._(this._$data);

  factory Input$SponsorOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$SponsorOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorOrderField get field =>
      (_$data['field'] as Enum$SponsorOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorOrder<Input$SponsorOrder> get copyWith =>
      CopyWith$Input$SponsorOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SponsorOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorOrder<TRes> {
  factory CopyWith$Input$SponsorOrder(
    Input$SponsorOrder instance,
    TRes Function(Input$SponsorOrder) then,
  ) = _CopyWithImpl$Input$SponsorOrder;

  factory CopyWith$Input$SponsorOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorOrder;

  TRes call({
    Enum$SponsorOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorOrder<TRes>
    implements CopyWith$Input$SponsorOrder<TRes> {
  _CopyWithImpl$Input$SponsorOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorOrder _instance;

  final TRes Function(Input$SponsorOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorOrder<TRes>
    implements CopyWith$Input$SponsorOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorsActivityOrder {
  factory Input$SponsorsActivityOrder({
    required Enum$SponsorsActivityOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorsActivityOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorsActivityOrder._(this._$data);

  factory Input$SponsorsActivityOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorsActivityOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorsActivityOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorsActivityOrderField get field =>
      (_$data['field'] as Enum$SponsorsActivityOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorsActivityOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorsActivityOrder<Input$SponsorsActivityOrder>
      get copyWith => CopyWith$Input$SponsorsActivityOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SponsorsActivityOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorsActivityOrder<TRes> {
  factory CopyWith$Input$SponsorsActivityOrder(
    Input$SponsorsActivityOrder instance,
    TRes Function(Input$SponsorsActivityOrder) then,
  ) = _CopyWithImpl$Input$SponsorsActivityOrder;

  factory CopyWith$Input$SponsorsActivityOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorsActivityOrder;

  TRes call({
    Enum$SponsorsActivityOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorsActivityOrder<TRes>
    implements CopyWith$Input$SponsorsActivityOrder<TRes> {
  _CopyWithImpl$Input$SponsorsActivityOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorsActivityOrder _instance;

  final TRes Function(Input$SponsorsActivityOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorsActivityOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorsActivityOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorsActivityOrder<TRes>
    implements CopyWith$Input$SponsorsActivityOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorsActivityOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorsActivityOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorshipNewsletterOrder {
  factory Input$SponsorshipNewsletterOrder({
    required Enum$SponsorshipNewsletterOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorshipNewsletterOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorshipNewsletterOrder._(this._$data);

  factory Input$SponsorshipNewsletterOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorshipNewsletterOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorshipNewsletterOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorshipNewsletterOrderField get field =>
      (_$data['field'] as Enum$SponsorshipNewsletterOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorshipNewsletterOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorshipNewsletterOrder<Input$SponsorshipNewsletterOrder>
      get copyWith => CopyWith$Input$SponsorshipNewsletterOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SponsorshipNewsletterOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  factory CopyWith$Input$SponsorshipNewsletterOrder(
    Input$SponsorshipNewsletterOrder instance,
    TRes Function(Input$SponsorshipNewsletterOrder) then,
  ) = _CopyWithImpl$Input$SponsorshipNewsletterOrder;

  factory CopyWith$Input$SponsorshipNewsletterOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorshipNewsletterOrder;

  TRes call({
    Enum$SponsorshipNewsletterOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorshipNewsletterOrder<TRes>
    implements CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  _CopyWithImpl$Input$SponsorshipNewsletterOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorshipNewsletterOrder _instance;

  final TRes Function(Input$SponsorshipNewsletterOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorshipNewsletterOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorshipNewsletterOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorshipNewsletterOrder<TRes>
    implements CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorshipNewsletterOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorshipNewsletterOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorshipOrder {
  factory Input$SponsorshipOrder({
    required Enum$SponsorshipOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorshipOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorshipOrder._(this._$data);

  factory Input$SponsorshipOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorshipOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorshipOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorshipOrderField get field =>
      (_$data['field'] as Enum$SponsorshipOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorshipOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorshipOrder<Input$SponsorshipOrder> get copyWith =>
      CopyWith$Input$SponsorshipOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SponsorshipOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorshipOrder<TRes> {
  factory CopyWith$Input$SponsorshipOrder(
    Input$SponsorshipOrder instance,
    TRes Function(Input$SponsorshipOrder) then,
  ) = _CopyWithImpl$Input$SponsorshipOrder;

  factory CopyWith$Input$SponsorshipOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorshipOrder;

  TRes call({
    Enum$SponsorshipOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorshipOrder<TRes>
    implements CopyWith$Input$SponsorshipOrder<TRes> {
  _CopyWithImpl$Input$SponsorshipOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorshipOrder _instance;

  final TRes Function(Input$SponsorshipOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorshipOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorshipOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorshipOrder<TRes>
    implements CopyWith$Input$SponsorshipOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorshipOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorshipOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$SponsorsTierOrder {
  factory Input$SponsorsTierOrder({
    required Enum$SponsorsTierOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$SponsorsTierOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$SponsorsTierOrder._(this._$data);

  factory Input$SponsorsTierOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorsTierOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$SponsorsTierOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorsTierOrderField get field =>
      (_$data['field'] as Enum$SponsorsTierOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorsTierOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$SponsorsTierOrder<Input$SponsorsTierOrder> get copyWith =>
      CopyWith$Input$SponsorsTierOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SponsorsTierOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$SponsorsTierOrder<TRes> {
  factory CopyWith$Input$SponsorsTierOrder(
    Input$SponsorsTierOrder instance,
    TRes Function(Input$SponsorsTierOrder) then,
  ) = _CopyWithImpl$Input$SponsorsTierOrder;

  factory CopyWith$Input$SponsorsTierOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorsTierOrder;

  TRes call({
    Enum$SponsorsTierOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$SponsorsTierOrder<TRes>
    implements CopyWith$Input$SponsorsTierOrder<TRes> {
  _CopyWithImpl$Input$SponsorsTierOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorsTierOrder _instance;

  final TRes Function(Input$SponsorsTierOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$SponsorsTierOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorsTierOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$SponsorsTierOrder<TRes>
    implements CopyWith$Input$SponsorsTierOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorsTierOrder(this._res);

  TRes _res;

  call({
    Enum$SponsorsTierOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$StarOrder {
  factory Input$StarOrder({
    required Enum$StarOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$StarOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$StarOrder._(this._$data);

  factory Input$StarOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$StarOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$StarOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$StarOrderField get field => (_$data['field'] as Enum$StarOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$StarOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$StarOrder<Input$StarOrder> get copyWith =>
      CopyWith$Input$StarOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StarOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$StarOrder<TRes> {
  factory CopyWith$Input$StarOrder(
    Input$StarOrder instance,
    TRes Function(Input$StarOrder) then,
  ) = _CopyWithImpl$Input$StarOrder;

  factory CopyWith$Input$StarOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$StarOrder;

  TRes call({
    Enum$StarOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$StarOrder<TRes>
    implements CopyWith$Input$StarOrder<TRes> {
  _CopyWithImpl$Input$StarOrder(
    this._instance,
    this._then,
  );

  final Input$StarOrder _instance;

  final TRes Function(Input$StarOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$StarOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$StarOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$StarOrder<TRes>
    implements CopyWith$Input$StarOrder<TRes> {
  _CopyWithStubImpl$Input$StarOrder(this._res);

  TRes _res;

  call({
    Enum$StarOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$StartOrganizationMigrationInput {
  factory Input$StartOrganizationMigrationInput({
    String? clientMutationId,
    required String sourceOrgUrl,
    required String targetOrgName,
    required String targetEnterpriseId,
    required String sourceAccessToken,
  }) =>
      Input$StartOrganizationMigrationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'sourceOrgUrl': sourceOrgUrl,
        r'targetOrgName': targetOrgName,
        r'targetEnterpriseId': targetEnterpriseId,
        r'sourceAccessToken': sourceAccessToken,
      });

  Input$StartOrganizationMigrationInput._(this._$data);

  factory Input$StartOrganizationMigrationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$sourceOrgUrl = data['sourceOrgUrl'];
    result$data['sourceOrgUrl'] = (l$sourceOrgUrl as String);
    final l$targetOrgName = data['targetOrgName'];
    result$data['targetOrgName'] = (l$targetOrgName as String);
    final l$targetEnterpriseId = data['targetEnterpriseId'];
    result$data['targetEnterpriseId'] = (l$targetEnterpriseId as String);
    final l$sourceAccessToken = data['sourceAccessToken'];
    result$data['sourceAccessToken'] = (l$sourceAccessToken as String);
    return Input$StartOrganizationMigrationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get sourceOrgUrl => (_$data['sourceOrgUrl'] as String);

  String get targetOrgName => (_$data['targetOrgName'] as String);

  String get targetEnterpriseId => (_$data['targetEnterpriseId'] as String);

  String get sourceAccessToken => (_$data['sourceAccessToken'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$sourceOrgUrl = sourceOrgUrl;
    result$data['sourceOrgUrl'] = l$sourceOrgUrl;
    final l$targetOrgName = targetOrgName;
    result$data['targetOrgName'] = l$targetOrgName;
    final l$targetEnterpriseId = targetEnterpriseId;
    result$data['targetEnterpriseId'] = l$targetEnterpriseId;
    final l$sourceAccessToken = sourceAccessToken;
    result$data['sourceAccessToken'] = l$sourceAccessToken;
    return result$data;
  }

  CopyWith$Input$StartOrganizationMigrationInput<
          Input$StartOrganizationMigrationInput>
      get copyWith => CopyWith$Input$StartOrganizationMigrationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StartOrganizationMigrationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sourceOrgUrl = sourceOrgUrl;
    final lOther$sourceOrgUrl = other.sourceOrgUrl;
    if (l$sourceOrgUrl != lOther$sourceOrgUrl) {
      return false;
    }
    final l$targetOrgName = targetOrgName;
    final lOther$targetOrgName = other.targetOrgName;
    if (l$targetOrgName != lOther$targetOrgName) {
      return false;
    }
    final l$targetEnterpriseId = targetEnterpriseId;
    final lOther$targetEnterpriseId = other.targetEnterpriseId;
    if (l$targetEnterpriseId != lOther$targetEnterpriseId) {
      return false;
    }
    final l$sourceAccessToken = sourceAccessToken;
    final lOther$sourceAccessToken = other.sourceAccessToken;
    if (l$sourceAccessToken != lOther$sourceAccessToken) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sourceOrgUrl = sourceOrgUrl;
    final l$targetOrgName = targetOrgName;
    final l$targetEnterpriseId = targetEnterpriseId;
    final l$sourceAccessToken = sourceAccessToken;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$sourceOrgUrl,
      l$targetOrgName,
      l$targetEnterpriseId,
      l$sourceAccessToken,
    ]);
  }
}

abstract class CopyWith$Input$StartOrganizationMigrationInput<TRes> {
  factory CopyWith$Input$StartOrganizationMigrationInput(
    Input$StartOrganizationMigrationInput instance,
    TRes Function(Input$StartOrganizationMigrationInput) then,
  ) = _CopyWithImpl$Input$StartOrganizationMigrationInput;

  factory CopyWith$Input$StartOrganizationMigrationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StartOrganizationMigrationInput;

  TRes call({
    String? clientMutationId,
    String? sourceOrgUrl,
    String? targetOrgName,
    String? targetEnterpriseId,
    String? sourceAccessToken,
  });
}

class _CopyWithImpl$Input$StartOrganizationMigrationInput<TRes>
    implements CopyWith$Input$StartOrganizationMigrationInput<TRes> {
  _CopyWithImpl$Input$StartOrganizationMigrationInput(
    this._instance,
    this._then,
  );

  final Input$StartOrganizationMigrationInput _instance;

  final TRes Function(Input$StartOrganizationMigrationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sourceOrgUrl = _undefined,
    Object? targetOrgName = _undefined,
    Object? targetEnterpriseId = _undefined,
    Object? sourceAccessToken = _undefined,
  }) =>
      _then(Input$StartOrganizationMigrationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sourceOrgUrl != _undefined && sourceOrgUrl != null)
          'sourceOrgUrl': (sourceOrgUrl as String),
        if (targetOrgName != _undefined && targetOrgName != null)
          'targetOrgName': (targetOrgName as String),
        if (targetEnterpriseId != _undefined && targetEnterpriseId != null)
          'targetEnterpriseId': (targetEnterpriseId as String),
        if (sourceAccessToken != _undefined && sourceAccessToken != null)
          'sourceAccessToken': (sourceAccessToken as String),
      }));
}

class _CopyWithStubImpl$Input$StartOrganizationMigrationInput<TRes>
    implements CopyWith$Input$StartOrganizationMigrationInput<TRes> {
  _CopyWithStubImpl$Input$StartOrganizationMigrationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sourceOrgUrl,
    String? targetOrgName,
    String? targetEnterpriseId,
    String? sourceAccessToken,
  }) =>
      _res;
}

class Input$StartRepositoryMigrationInput {
  factory Input$StartRepositoryMigrationInput({
    String? clientMutationId,
    required String sourceId,
    required String ownerId,
    required String sourceRepositoryUrl,
    required String repositoryName,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? metadataArchiveUrl,
    String? accessToken,
    String? githubPat,
    bool? skipReleases,
    String? targetRepoVisibility,
    bool? lockSource,
  }) =>
      Input$StartRepositoryMigrationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'sourceId': sourceId,
        r'ownerId': ownerId,
        r'sourceRepositoryUrl': sourceRepositoryUrl,
        r'repositoryName': repositoryName,
        if (continueOnError != null) r'continueOnError': continueOnError,
        if (gitArchiveUrl != null) r'gitArchiveUrl': gitArchiveUrl,
        if (metadataArchiveUrl != null)
          r'metadataArchiveUrl': metadataArchiveUrl,
        if (accessToken != null) r'accessToken': accessToken,
        if (githubPat != null) r'githubPat': githubPat,
        if (skipReleases != null) r'skipReleases': skipReleases,
        if (targetRepoVisibility != null)
          r'targetRepoVisibility': targetRepoVisibility,
        if (lockSource != null) r'lockSource': lockSource,
      });

  Input$StartRepositoryMigrationInput._(this._$data);

  factory Input$StartRepositoryMigrationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$sourceRepositoryUrl = data['sourceRepositoryUrl'];
    result$data['sourceRepositoryUrl'] = (l$sourceRepositoryUrl as String);
    final l$repositoryName = data['repositoryName'];
    result$data['repositoryName'] = (l$repositoryName as String);
    if (data.containsKey('continueOnError')) {
      final l$continueOnError = data['continueOnError'];
      result$data['continueOnError'] = (l$continueOnError as bool?);
    }
    if (data.containsKey('gitArchiveUrl')) {
      final l$gitArchiveUrl = data['gitArchiveUrl'];
      result$data['gitArchiveUrl'] = (l$gitArchiveUrl as String?);
    }
    if (data.containsKey('metadataArchiveUrl')) {
      final l$metadataArchiveUrl = data['metadataArchiveUrl'];
      result$data['metadataArchiveUrl'] = (l$metadataArchiveUrl as String?);
    }
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    if (data.containsKey('githubPat')) {
      final l$githubPat = data['githubPat'];
      result$data['githubPat'] = (l$githubPat as String?);
    }
    if (data.containsKey('skipReleases')) {
      final l$skipReleases = data['skipReleases'];
      result$data['skipReleases'] = (l$skipReleases as bool?);
    }
    if (data.containsKey('targetRepoVisibility')) {
      final l$targetRepoVisibility = data['targetRepoVisibility'];
      result$data['targetRepoVisibility'] = (l$targetRepoVisibility as String?);
    }
    if (data.containsKey('lockSource')) {
      final l$lockSource = data['lockSource'];
      result$data['lockSource'] = (l$lockSource as bool?);
    }
    return Input$StartRepositoryMigrationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get sourceId => (_$data['sourceId'] as String);

  String get ownerId => (_$data['ownerId'] as String);

  String get sourceRepositoryUrl => (_$data['sourceRepositoryUrl'] as String);

  String get repositoryName => (_$data['repositoryName'] as String);

  bool? get continueOnError => (_$data['continueOnError'] as bool?);

  String? get gitArchiveUrl => (_$data['gitArchiveUrl'] as String?);

  String? get metadataArchiveUrl => (_$data['metadataArchiveUrl'] as String?);

  String? get accessToken => (_$data['accessToken'] as String?);

  String? get githubPat => (_$data['githubPat'] as String?);

  bool? get skipReleases => (_$data['skipReleases'] as bool?);

  String? get targetRepoVisibility =>
      (_$data['targetRepoVisibility'] as String?);

  bool? get lockSource => (_$data['lockSource'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    result$data['sourceRepositoryUrl'] = l$sourceRepositoryUrl;
    final l$repositoryName = repositoryName;
    result$data['repositoryName'] = l$repositoryName;
    if (_$data.containsKey('continueOnError')) {
      final l$continueOnError = continueOnError;
      result$data['continueOnError'] = l$continueOnError;
    }
    if (_$data.containsKey('gitArchiveUrl')) {
      final l$gitArchiveUrl = gitArchiveUrl;
      result$data['gitArchiveUrl'] = l$gitArchiveUrl;
    }
    if (_$data.containsKey('metadataArchiveUrl')) {
      final l$metadataArchiveUrl = metadataArchiveUrl;
      result$data['metadataArchiveUrl'] = l$metadataArchiveUrl;
    }
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    if (_$data.containsKey('githubPat')) {
      final l$githubPat = githubPat;
      result$data['githubPat'] = l$githubPat;
    }
    if (_$data.containsKey('skipReleases')) {
      final l$skipReleases = skipReleases;
      result$data['skipReleases'] = l$skipReleases;
    }
    if (_$data.containsKey('targetRepoVisibility')) {
      final l$targetRepoVisibility = targetRepoVisibility;
      result$data['targetRepoVisibility'] = l$targetRepoVisibility;
    }
    if (_$data.containsKey('lockSource')) {
      final l$lockSource = lockSource;
      result$data['lockSource'] = l$lockSource;
    }
    return result$data;
  }

  CopyWith$Input$StartRepositoryMigrationInput<
          Input$StartRepositoryMigrationInput>
      get copyWith => CopyWith$Input$StartRepositoryMigrationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StartRepositoryMigrationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    final lOther$sourceRepositoryUrl = other.sourceRepositoryUrl;
    if (l$sourceRepositoryUrl != lOther$sourceRepositoryUrl) {
      return false;
    }
    final l$repositoryName = repositoryName;
    final lOther$repositoryName = other.repositoryName;
    if (l$repositoryName != lOther$repositoryName) {
      return false;
    }
    final l$continueOnError = continueOnError;
    final lOther$continueOnError = other.continueOnError;
    if (_$data.containsKey('continueOnError') !=
        other._$data.containsKey('continueOnError')) {
      return false;
    }
    if (l$continueOnError != lOther$continueOnError) {
      return false;
    }
    final l$gitArchiveUrl = gitArchiveUrl;
    final lOther$gitArchiveUrl = other.gitArchiveUrl;
    if (_$data.containsKey('gitArchiveUrl') !=
        other._$data.containsKey('gitArchiveUrl')) {
      return false;
    }
    if (l$gitArchiveUrl != lOther$gitArchiveUrl) {
      return false;
    }
    final l$metadataArchiveUrl = metadataArchiveUrl;
    final lOther$metadataArchiveUrl = other.metadataArchiveUrl;
    if (_$data.containsKey('metadataArchiveUrl') !=
        other._$data.containsKey('metadataArchiveUrl')) {
      return false;
    }
    if (l$metadataArchiveUrl != lOther$metadataArchiveUrl) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$githubPat = githubPat;
    final lOther$githubPat = other.githubPat;
    if (_$data.containsKey('githubPat') !=
        other._$data.containsKey('githubPat')) {
      return false;
    }
    if (l$githubPat != lOther$githubPat) {
      return false;
    }
    final l$skipReleases = skipReleases;
    final lOther$skipReleases = other.skipReleases;
    if (_$data.containsKey('skipReleases') !=
        other._$data.containsKey('skipReleases')) {
      return false;
    }
    if (l$skipReleases != lOther$skipReleases) {
      return false;
    }
    final l$targetRepoVisibility = targetRepoVisibility;
    final lOther$targetRepoVisibility = other.targetRepoVisibility;
    if (_$data.containsKey('targetRepoVisibility') !=
        other._$data.containsKey('targetRepoVisibility')) {
      return false;
    }
    if (l$targetRepoVisibility != lOther$targetRepoVisibility) {
      return false;
    }
    final l$lockSource = lockSource;
    final lOther$lockSource = other.lockSource;
    if (_$data.containsKey('lockSource') !=
        other._$data.containsKey('lockSource')) {
      return false;
    }
    if (l$lockSource != lOther$lockSource) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sourceId = sourceId;
    final l$ownerId = ownerId;
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    final l$repositoryName = repositoryName;
    final l$continueOnError = continueOnError;
    final l$gitArchiveUrl = gitArchiveUrl;
    final l$metadataArchiveUrl = metadataArchiveUrl;
    final l$accessToken = accessToken;
    final l$githubPat = githubPat;
    final l$skipReleases = skipReleases;
    final l$targetRepoVisibility = targetRepoVisibility;
    final l$lockSource = lockSource;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$sourceId,
      l$ownerId,
      l$sourceRepositoryUrl,
      l$repositoryName,
      _$data.containsKey('continueOnError') ? l$continueOnError : const {},
      _$data.containsKey('gitArchiveUrl') ? l$gitArchiveUrl : const {},
      _$data.containsKey('metadataArchiveUrl')
          ? l$metadataArchiveUrl
          : const {},
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('githubPat') ? l$githubPat : const {},
      _$data.containsKey('skipReleases') ? l$skipReleases : const {},
      _$data.containsKey('targetRepoVisibility')
          ? l$targetRepoVisibility
          : const {},
      _$data.containsKey('lockSource') ? l$lockSource : const {},
    ]);
  }
}

abstract class CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  factory CopyWith$Input$StartRepositoryMigrationInput(
    Input$StartRepositoryMigrationInput instance,
    TRes Function(Input$StartRepositoryMigrationInput) then,
  ) = _CopyWithImpl$Input$StartRepositoryMigrationInput;

  factory CopyWith$Input$StartRepositoryMigrationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StartRepositoryMigrationInput;

  TRes call({
    String? clientMutationId,
    String? sourceId,
    String? ownerId,
    String? sourceRepositoryUrl,
    String? repositoryName,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? metadataArchiveUrl,
    String? accessToken,
    String? githubPat,
    bool? skipReleases,
    String? targetRepoVisibility,
    bool? lockSource,
  });
}

class _CopyWithImpl$Input$StartRepositoryMigrationInput<TRes>
    implements CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  _CopyWithImpl$Input$StartRepositoryMigrationInput(
    this._instance,
    this._then,
  );

  final Input$StartRepositoryMigrationInput _instance;

  final TRes Function(Input$StartRepositoryMigrationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sourceId = _undefined,
    Object? ownerId = _undefined,
    Object? sourceRepositoryUrl = _undefined,
    Object? repositoryName = _undefined,
    Object? continueOnError = _undefined,
    Object? gitArchiveUrl = _undefined,
    Object? metadataArchiveUrl = _undefined,
    Object? accessToken = _undefined,
    Object? githubPat = _undefined,
    Object? skipReleases = _undefined,
    Object? targetRepoVisibility = _undefined,
    Object? lockSource = _undefined,
  }) =>
      _then(Input$StartRepositoryMigrationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (sourceRepositoryUrl != _undefined && sourceRepositoryUrl != null)
          'sourceRepositoryUrl': (sourceRepositoryUrl as String),
        if (repositoryName != _undefined && repositoryName != null)
          'repositoryName': (repositoryName as String),
        if (continueOnError != _undefined)
          'continueOnError': (continueOnError as bool?),
        if (gitArchiveUrl != _undefined)
          'gitArchiveUrl': (gitArchiveUrl as String?),
        if (metadataArchiveUrl != _undefined)
          'metadataArchiveUrl': (metadataArchiveUrl as String?),
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (githubPat != _undefined) 'githubPat': (githubPat as String?),
        if (skipReleases != _undefined) 'skipReleases': (skipReleases as bool?),
        if (targetRepoVisibility != _undefined)
          'targetRepoVisibility': (targetRepoVisibility as String?),
        if (lockSource != _undefined) 'lockSource': (lockSource as bool?),
      }));
}

class _CopyWithStubImpl$Input$StartRepositoryMigrationInput<TRes>
    implements CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  _CopyWithStubImpl$Input$StartRepositoryMigrationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sourceId,
    String? ownerId,
    String? sourceRepositoryUrl,
    String? repositoryName,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? metadataArchiveUrl,
    String? accessToken,
    String? githubPat,
    bool? skipReleases,
    String? targetRepoVisibility,
    bool? lockSource,
  }) =>
      _res;
}

class Input$StatusCheckConfigurationInput {
  factory Input$StatusCheckConfigurationInput({
    required String context,
    int? integrationId,
  }) =>
      Input$StatusCheckConfigurationInput._({
        r'context': context,
        if (integrationId != null) r'integrationId': integrationId,
      });

  Input$StatusCheckConfigurationInput._(this._$data);

  factory Input$StatusCheckConfigurationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$context = data['context'];
    result$data['context'] = (l$context as String);
    if (data.containsKey('integrationId')) {
      final l$integrationId = data['integrationId'];
      result$data['integrationId'] = (l$integrationId as int?);
    }
    return Input$StatusCheckConfigurationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get context => (_$data['context'] as String);

  int? get integrationId => (_$data['integrationId'] as int?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$context = context;
    result$data['context'] = l$context;
    if (_$data.containsKey('integrationId')) {
      final l$integrationId = integrationId;
      result$data['integrationId'] = l$integrationId;
    }
    return result$data;
  }

  CopyWith$Input$StatusCheckConfigurationInput<
          Input$StatusCheckConfigurationInput>
      get copyWith => CopyWith$Input$StatusCheckConfigurationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$StatusCheckConfigurationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) {
      return false;
    }
    final l$integrationId = integrationId;
    final lOther$integrationId = other.integrationId;
    if (_$data.containsKey('integrationId') !=
        other._$data.containsKey('integrationId')) {
      return false;
    }
    if (l$integrationId != lOther$integrationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$context = context;
    final l$integrationId = integrationId;
    return Object.hashAll([
      l$context,
      _$data.containsKey('integrationId') ? l$integrationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$StatusCheckConfigurationInput<TRes> {
  factory CopyWith$Input$StatusCheckConfigurationInput(
    Input$StatusCheckConfigurationInput instance,
    TRes Function(Input$StatusCheckConfigurationInput) then,
  ) = _CopyWithImpl$Input$StatusCheckConfigurationInput;

  factory CopyWith$Input$StatusCheckConfigurationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StatusCheckConfigurationInput;

  TRes call({
    String? context,
    int? integrationId,
  });
}

class _CopyWithImpl$Input$StatusCheckConfigurationInput<TRes>
    implements CopyWith$Input$StatusCheckConfigurationInput<TRes> {
  _CopyWithImpl$Input$StatusCheckConfigurationInput(
    this._instance,
    this._then,
  );

  final Input$StatusCheckConfigurationInput _instance;

  final TRes Function(Input$StatusCheckConfigurationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? context = _undefined,
    Object? integrationId = _undefined,
  }) =>
      _then(Input$StatusCheckConfigurationInput._({
        ..._instance._$data,
        if (context != _undefined && context != null)
          'context': (context as String),
        if (integrationId != _undefined)
          'integrationId': (integrationId as int?),
      }));
}

class _CopyWithStubImpl$Input$StatusCheckConfigurationInput<TRes>
    implements CopyWith$Input$StatusCheckConfigurationInput<TRes> {
  _CopyWithStubImpl$Input$StatusCheckConfigurationInput(this._res);

  TRes _res;

  call({
    String? context,
    int? integrationId,
  }) =>
      _res;
}

class Input$SubmitPullRequestReviewInput {
  factory Input$SubmitPullRequestReviewInput({
    String? clientMutationId,
    String? pullRequestId,
    String? pullRequestReviewId,
    required Enum$PullRequestReviewEvent event,
    String? body,
  }) =>
      Input$SubmitPullRequestReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        r'event': event,
        if (body != null) r'body': body,
      });

  Input$SubmitPullRequestReviewInput._(this._$data);

  factory Input$SubmitPullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    final l$event = data['event'];
    result$data['event'] =
        fromJson$Enum$PullRequestReviewEvent((l$event as String));
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$SubmitPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get pullRequestId => (_$data['pullRequestId'] as String?);

  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);

  Enum$PullRequestReviewEvent get event =>
      (_$data['event'] as Enum$PullRequestReviewEvent);

  String? get body => (_$data['body'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    final l$event = event;
    result$data['event'] = toJson$Enum$PullRequestReviewEvent(l$event);
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$SubmitPullRequestReviewInput<
          Input$SubmitPullRequestReviewInput>
      get copyWith => CopyWith$Input$SubmitPullRequestReviewInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$SubmitPullRequestReviewInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (l$event != lOther$event) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$event = event;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      l$event,
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  factory CopyWith$Input$SubmitPullRequestReviewInput(
    Input$SubmitPullRequestReviewInput instance,
    TRes Function(Input$SubmitPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$SubmitPullRequestReviewInput;

  factory CopyWith$Input$SubmitPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubmitPullRequestReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? pullRequestReviewId,
    Enum$PullRequestReviewEvent? event,
    String? body,
  });
}

class _CopyWithImpl$Input$SubmitPullRequestReviewInput<TRes>
    implements CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$SubmitPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$SubmitPullRequestReviewInput _instance;

  final TRes Function(Input$SubmitPullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? event = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$SubmitPullRequestReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (event != _undefined && event != null)
          'event': (event as Enum$PullRequestReviewEvent),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$SubmitPullRequestReviewInput<TRes>
    implements CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$SubmitPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? pullRequestReviewId,
    Enum$PullRequestReviewEvent? event,
    String? body,
  }) =>
      _res;
}

class Input$TagNamePatternParametersInput {
  factory Input$TagNamePatternParametersInput({
    String? name,
    bool? negate,
    required String $operator,
    required String pattern,
  }) =>
      Input$TagNamePatternParametersInput._({
        if (name != null) r'name': name,
        if (negate != null) r'negate': negate,
        r'operator': $operator,
        r'pattern': pattern,
      });

  Input$TagNamePatternParametersInput._(this._$data);

  factory Input$TagNamePatternParametersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('negate')) {
      final l$negate = data['negate'];
      result$data['negate'] = (l$negate as bool?);
    }
    final l$$operator = data['operator'];
    result$data['operator'] = (l$$operator as String);
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    return Input$TagNamePatternParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get name => (_$data['name'] as String?);

  bool? get negate => (_$data['negate'] as bool?);

  String get $operator => (_$data['operator'] as String);

  String get pattern => (_$data['pattern'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('negate')) {
      final l$negate = negate;
      result$data['negate'] = l$negate;
    }
    final l$$operator = $operator;
    result$data['operator'] = l$$operator;
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    return result$data;
  }

  CopyWith$Input$TagNamePatternParametersInput<
          Input$TagNamePatternParametersInput>
      get copyWith => CopyWith$Input$TagNamePatternParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TagNamePatternParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$negate = negate;
    final lOther$negate = other.negate;
    if (_$data.containsKey('negate') != other._$data.containsKey('negate')) {
      return false;
    }
    if (l$negate != lOther$negate) {
      return false;
    }
    final l$$operator = $operator;
    final lOther$$operator = other.$operator;
    if (l$$operator != lOther$$operator) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$negate = negate;
    final l$$operator = $operator;
    final l$pattern = pattern;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('negate') ? l$negate : const {},
      l$$operator,
      l$pattern,
    ]);
  }
}

abstract class CopyWith$Input$TagNamePatternParametersInput<TRes> {
  factory CopyWith$Input$TagNamePatternParametersInput(
    Input$TagNamePatternParametersInput instance,
    TRes Function(Input$TagNamePatternParametersInput) then,
  ) = _CopyWithImpl$Input$TagNamePatternParametersInput;

  factory CopyWith$Input$TagNamePatternParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TagNamePatternParametersInput;

  TRes call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  });
}

class _CopyWithImpl$Input$TagNamePatternParametersInput<TRes>
    implements CopyWith$Input$TagNamePatternParametersInput<TRes> {
  _CopyWithImpl$Input$TagNamePatternParametersInput(
    this._instance,
    this._then,
  );

  final Input$TagNamePatternParametersInput _instance;

  final TRes Function(Input$TagNamePatternParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? negate = _undefined,
    Object? $operator = _undefined,
    Object? pattern = _undefined,
  }) =>
      _then(Input$TagNamePatternParametersInput._({
        ..._instance._$data,
        if (name != _undefined) 'name': (name as String?),
        if (negate != _undefined) 'negate': (negate as bool?),
        if ($operator != _undefined && $operator != null)
          'operator': ($operator as String),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
      }));
}

class _CopyWithStubImpl$Input$TagNamePatternParametersInput<TRes>
    implements CopyWith$Input$TagNamePatternParametersInput<TRes> {
  _CopyWithStubImpl$Input$TagNamePatternParametersInput(this._res);

  TRes _res;

  call({
    String? name,
    bool? negate,
    String? $operator,
    String? pattern,
  }) =>
      _res;
}

class Input$TeamDiscussionCommentOrder {
  factory Input$TeamDiscussionCommentOrder({
    required Enum$TeamDiscussionCommentOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamDiscussionCommentOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamDiscussionCommentOrder._(this._$data);

  factory Input$TeamDiscussionCommentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamDiscussionCommentOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamDiscussionCommentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamDiscussionCommentOrderField get field =>
      (_$data['field'] as Enum$TeamDiscussionCommentOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamDiscussionCommentOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamDiscussionCommentOrder<Input$TeamDiscussionCommentOrder>
      get copyWith => CopyWith$Input$TeamDiscussionCommentOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TeamDiscussionCommentOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  factory CopyWith$Input$TeamDiscussionCommentOrder(
    Input$TeamDiscussionCommentOrder instance,
    TRes Function(Input$TeamDiscussionCommentOrder) then,
  ) = _CopyWithImpl$Input$TeamDiscussionCommentOrder;

  factory CopyWith$Input$TeamDiscussionCommentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamDiscussionCommentOrder;

  TRes call({
    Enum$TeamDiscussionCommentOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamDiscussionCommentOrder<TRes>
    implements CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  _CopyWithImpl$Input$TeamDiscussionCommentOrder(
    this._instance,
    this._then,
  );

  final Input$TeamDiscussionCommentOrder _instance;

  final TRes Function(Input$TeamDiscussionCommentOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamDiscussionCommentOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamDiscussionCommentOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamDiscussionCommentOrder<TRes>
    implements CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  _CopyWithStubImpl$Input$TeamDiscussionCommentOrder(this._res);

  TRes _res;

  call({
    Enum$TeamDiscussionCommentOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamDiscussionOrder {
  factory Input$TeamDiscussionOrder({
    required Enum$TeamDiscussionOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamDiscussionOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamDiscussionOrder._(this._$data);

  factory Input$TeamDiscussionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamDiscussionOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamDiscussionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamDiscussionOrderField get field =>
      (_$data['field'] as Enum$TeamDiscussionOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamDiscussionOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamDiscussionOrder<Input$TeamDiscussionOrder> get copyWith =>
      CopyWith$Input$TeamDiscussionOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TeamDiscussionOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamDiscussionOrder<TRes> {
  factory CopyWith$Input$TeamDiscussionOrder(
    Input$TeamDiscussionOrder instance,
    TRes Function(Input$TeamDiscussionOrder) then,
  ) = _CopyWithImpl$Input$TeamDiscussionOrder;

  factory CopyWith$Input$TeamDiscussionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamDiscussionOrder;

  TRes call({
    Enum$TeamDiscussionOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamDiscussionOrder<TRes>
    implements CopyWith$Input$TeamDiscussionOrder<TRes> {
  _CopyWithImpl$Input$TeamDiscussionOrder(
    this._instance,
    this._then,
  );

  final Input$TeamDiscussionOrder _instance;

  final TRes Function(Input$TeamDiscussionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamDiscussionOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamDiscussionOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamDiscussionOrder<TRes>
    implements CopyWith$Input$TeamDiscussionOrder<TRes> {
  _CopyWithStubImpl$Input$TeamDiscussionOrder(this._res);

  TRes _res;

  call({
    Enum$TeamDiscussionOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamMemberOrder {
  factory Input$TeamMemberOrder({
    required Enum$TeamMemberOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamMemberOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamMemberOrder._(this._$data);

  factory Input$TeamMemberOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamMemberOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamMemberOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamMemberOrderField get field =>
      (_$data['field'] as Enum$TeamMemberOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamMemberOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamMemberOrder<Input$TeamMemberOrder> get copyWith =>
      CopyWith$Input$TeamMemberOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TeamMemberOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamMemberOrder<TRes> {
  factory CopyWith$Input$TeamMemberOrder(
    Input$TeamMemberOrder instance,
    TRes Function(Input$TeamMemberOrder) then,
  ) = _CopyWithImpl$Input$TeamMemberOrder;

  factory CopyWith$Input$TeamMemberOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamMemberOrder;

  TRes call({
    Enum$TeamMemberOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamMemberOrder<TRes>
    implements CopyWith$Input$TeamMemberOrder<TRes> {
  _CopyWithImpl$Input$TeamMemberOrder(
    this._instance,
    this._then,
  );

  final Input$TeamMemberOrder _instance;

  final TRes Function(Input$TeamMemberOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamMemberOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamMemberOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamMemberOrder<TRes>
    implements CopyWith$Input$TeamMemberOrder<TRes> {
  _CopyWithStubImpl$Input$TeamMemberOrder(this._res);

  TRes _res;

  call({
    Enum$TeamMemberOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamOrder {
  factory Input$TeamOrder({
    required Enum$TeamOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamOrder._(this._$data);

  factory Input$TeamOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$TeamOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamOrderField get field => (_$data['field'] as Enum$TeamOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamOrder<Input$TeamOrder> get copyWith =>
      CopyWith$Input$TeamOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TeamOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamOrder<TRes> {
  factory CopyWith$Input$TeamOrder(
    Input$TeamOrder instance,
    TRes Function(Input$TeamOrder) then,
  ) = _CopyWithImpl$Input$TeamOrder;

  factory CopyWith$Input$TeamOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamOrder;

  TRes call({
    Enum$TeamOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamOrder<TRes>
    implements CopyWith$Input$TeamOrder<TRes> {
  _CopyWithImpl$Input$TeamOrder(
    this._instance,
    this._then,
  );

  final Input$TeamOrder _instance;

  final TRes Function(Input$TeamOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamOrder<TRes>
    implements CopyWith$Input$TeamOrder<TRes> {
  _CopyWithStubImpl$Input$TeamOrder(this._res);

  TRes _res;

  call({
    Enum$TeamOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TeamRepositoryOrder {
  factory Input$TeamRepositoryOrder({
    required Enum$TeamRepositoryOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$TeamRepositoryOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$TeamRepositoryOrder._(this._$data);

  factory Input$TeamRepositoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamRepositoryOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$TeamRepositoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamRepositoryOrderField get field =>
      (_$data['field'] as Enum$TeamRepositoryOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamRepositoryOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$TeamRepositoryOrder<Input$TeamRepositoryOrder> get copyWith =>
      CopyWith$Input$TeamRepositoryOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TeamRepositoryOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$TeamRepositoryOrder<TRes> {
  factory CopyWith$Input$TeamRepositoryOrder(
    Input$TeamRepositoryOrder instance,
    TRes Function(Input$TeamRepositoryOrder) then,
  ) = _CopyWithImpl$Input$TeamRepositoryOrder;

  factory CopyWith$Input$TeamRepositoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamRepositoryOrder;

  TRes call({
    Enum$TeamRepositoryOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$TeamRepositoryOrder<TRes>
    implements CopyWith$Input$TeamRepositoryOrder<TRes> {
  _CopyWithImpl$Input$TeamRepositoryOrder(
    this._instance,
    this._then,
  );

  final Input$TeamRepositoryOrder _instance;

  final TRes Function(Input$TeamRepositoryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$TeamRepositoryOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamRepositoryOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$TeamRepositoryOrder<TRes>
    implements CopyWith$Input$TeamRepositoryOrder<TRes> {
  _CopyWithStubImpl$Input$TeamRepositoryOrder(this._res);

  TRes _res;

  call({
    Enum$TeamRepositoryOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$TransferEnterpriseOrganizationInput {
  factory Input$TransferEnterpriseOrganizationInput({
    String? clientMutationId,
    required String organizationId,
    required String destinationEnterpriseId,
  }) =>
      Input$TransferEnterpriseOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'destinationEnterpriseId': destinationEnterpriseId,
      });

  Input$TransferEnterpriseOrganizationInput._(this._$data);

  factory Input$TransferEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$destinationEnterpriseId = data['destinationEnterpriseId'];
    result$data['destinationEnterpriseId'] =
        (l$destinationEnterpriseId as String);
    return Input$TransferEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  String get destinationEnterpriseId =>
      (_$data['destinationEnterpriseId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$destinationEnterpriseId = destinationEnterpriseId;
    result$data['destinationEnterpriseId'] = l$destinationEnterpriseId;
    return result$data;
  }

  CopyWith$Input$TransferEnterpriseOrganizationInput<
          Input$TransferEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$TransferEnterpriseOrganizationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TransferEnterpriseOrganizationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$destinationEnterpriseId = destinationEnterpriseId;
    final lOther$destinationEnterpriseId = other.destinationEnterpriseId;
    if (l$destinationEnterpriseId != lOther$destinationEnterpriseId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$destinationEnterpriseId = destinationEnterpriseId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$destinationEnterpriseId,
    ]);
  }
}

abstract class CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$TransferEnterpriseOrganizationInput(
    Input$TransferEnterpriseOrganizationInput instance,
    TRes Function(Input$TransferEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$TransferEnterpriseOrganizationInput;

  factory CopyWith$Input$TransferEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    String? destinationEnterpriseId,
  });
}

class _CopyWithImpl$Input$TransferEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$TransferEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$TransferEnterpriseOrganizationInput _instance;

  final TRes Function(Input$TransferEnterpriseOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? destinationEnterpriseId = _undefined,
  }) =>
      _then(Input$TransferEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (destinationEnterpriseId != _undefined &&
            destinationEnterpriseId != null)
          'destinationEnterpriseId': (destinationEnterpriseId as String),
      }));
}

class _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    String? destinationEnterpriseId,
  }) =>
      _res;
}

class Input$TransferIssueInput {
  factory Input$TransferIssueInput({
    String? clientMutationId,
    required String issueId,
    required String repositoryId,
    bool? createLabelsIfMissing,
  }) =>
      Input$TransferIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        r'repositoryId': repositoryId,
        if (createLabelsIfMissing != null)
          r'createLabelsIfMissing': createLabelsIfMissing,
      });

  Input$TransferIssueInput._(this._$data);

  factory Input$TransferIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('createLabelsIfMissing')) {
      final l$createLabelsIfMissing = data['createLabelsIfMissing'];
      result$data['createLabelsIfMissing'] = (l$createLabelsIfMissing as bool?);
    }
    return Input$TransferIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  bool? get createLabelsIfMissing => (_$data['createLabelsIfMissing'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('createLabelsIfMissing')) {
      final l$createLabelsIfMissing = createLabelsIfMissing;
      result$data['createLabelsIfMissing'] = l$createLabelsIfMissing;
    }
    return result$data;
  }

  CopyWith$Input$TransferIssueInput<Input$TransferIssueInput> get copyWith =>
      CopyWith$Input$TransferIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$TransferIssueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$createLabelsIfMissing = createLabelsIfMissing;
    final lOther$createLabelsIfMissing = other.createLabelsIfMissing;
    if (_$data.containsKey('createLabelsIfMissing') !=
        other._$data.containsKey('createLabelsIfMissing')) {
      return false;
    }
    if (l$createLabelsIfMissing != lOther$createLabelsIfMissing) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$repositoryId = repositoryId;
    final l$createLabelsIfMissing = createLabelsIfMissing;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      l$repositoryId,
      _$data.containsKey('createLabelsIfMissing')
          ? l$createLabelsIfMissing
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransferIssueInput<TRes> {
  factory CopyWith$Input$TransferIssueInput(
    Input$TransferIssueInput instance,
    TRes Function(Input$TransferIssueInput) then,
  ) = _CopyWithImpl$Input$TransferIssueInput;

  factory CopyWith$Input$TransferIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? repositoryId,
    bool? createLabelsIfMissing,
  });
}

class _CopyWithImpl$Input$TransferIssueInput<TRes>
    implements CopyWith$Input$TransferIssueInput<TRes> {
  _CopyWithImpl$Input$TransferIssueInput(
    this._instance,
    this._then,
  );

  final Input$TransferIssueInput _instance;

  final TRes Function(Input$TransferIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? repositoryId = _undefined,
    Object? createLabelsIfMissing = _undefined,
  }) =>
      _then(Input$TransferIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (createLabelsIfMissing != _undefined)
          'createLabelsIfMissing': (createLabelsIfMissing as bool?),
      }));
}

class _CopyWithStubImpl$Input$TransferIssueInput<TRes>
    implements CopyWith$Input$TransferIssueInput<TRes> {
  _CopyWithStubImpl$Input$TransferIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? repositoryId,
    bool? createLabelsIfMissing,
  }) =>
      _res;
}

class Input$UnarchiveProjectV2ItemInput {
  factory Input$UnarchiveProjectV2ItemInput({
    String? clientMutationId,
    required String projectId,
    required String itemId,
  }) =>
      Input$UnarchiveProjectV2ItemInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'itemId': itemId,
      });

  Input$UnarchiveProjectV2ItemInput._(this._$data);

  factory Input$UnarchiveProjectV2ItemInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    return Input$UnarchiveProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get itemId => (_$data['itemId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    return result$data;
  }

  CopyWith$Input$UnarchiveProjectV2ItemInput<Input$UnarchiveProjectV2ItemInput>
      get copyWith => CopyWith$Input$UnarchiveProjectV2ItemInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnarchiveProjectV2ItemInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$itemId = itemId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$itemId,
    ]);
  }
}

abstract class CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  factory CopyWith$Input$UnarchiveProjectV2ItemInput(
    Input$UnarchiveProjectV2ItemInput instance,
    TRes Function(Input$UnarchiveProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$UnarchiveProjectV2ItemInput;

  factory CopyWith$Input$UnarchiveProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
  });
}

class _CopyWithImpl$Input$UnarchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$UnarchiveProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$UnarchiveProjectV2ItemInput _instance;

  final TRes Function(Input$UnarchiveProjectV2ItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? itemId = _undefined,
  }) =>
      _then(Input$UnarchiveProjectV2ItemInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
      }));
}

class _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
  }) =>
      _res;
}

class Input$UnarchiveRepositoryInput {
  factory Input$UnarchiveRepositoryInput({
    String? clientMutationId,
    required String repositoryId,
  }) =>
      Input$UnarchiveRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
      });

  Input$UnarchiveRepositoryInput._(this._$data);

  factory Input$UnarchiveRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UnarchiveRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UnarchiveRepositoryInput<Input$UnarchiveRepositoryInput>
      get copyWith => CopyWith$Input$UnarchiveRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnarchiveRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  factory CopyWith$Input$UnarchiveRepositoryInput(
    Input$UnarchiveRepositoryInput instance,
    TRes Function(Input$UnarchiveRepositoryInput) then,
  ) = _CopyWithImpl$Input$UnarchiveRepositoryInput;

  factory CopyWith$Input$UnarchiveRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnarchiveRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$UnarchiveRepositoryInput<TRes>
    implements CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  _CopyWithImpl$Input$UnarchiveRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UnarchiveRepositoryInput _instance;

  final TRes Function(Input$UnarchiveRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UnarchiveRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$UnarchiveRepositoryInput<TRes>
    implements CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UnarchiveRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$UnfollowOrganizationInput {
  factory Input$UnfollowOrganizationInput({
    String? clientMutationId,
    required String organizationId,
  }) =>
      Input$UnfollowOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
      });

  Input$UnfollowOrganizationInput._(this._$data);

  factory Input$UnfollowOrganizationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$UnfollowOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$UnfollowOrganizationInput<Input$UnfollowOrganizationInput>
      get copyWith => CopyWith$Input$UnfollowOrganizationInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnfollowOrganizationInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$UnfollowOrganizationInput<TRes> {
  factory CopyWith$Input$UnfollowOrganizationInput(
    Input$UnfollowOrganizationInput instance,
    TRes Function(Input$UnfollowOrganizationInput) then,
  ) = _CopyWithImpl$Input$UnfollowOrganizationInput;

  factory CopyWith$Input$UnfollowOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnfollowOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$UnfollowOrganizationInput<TRes>
    implements CopyWith$Input$UnfollowOrganizationInput<TRes> {
  _CopyWithImpl$Input$UnfollowOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$UnfollowOrganizationInput _instance;

  final TRes Function(Input$UnfollowOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$UnfollowOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$UnfollowOrganizationInput<TRes>
    implements CopyWith$Input$UnfollowOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$UnfollowOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
  }) =>
      _res;
}

class Input$UnfollowUserInput {
  factory Input$UnfollowUserInput({
    String? clientMutationId,
    required String userId,
  }) =>
      Input$UnfollowUserInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'userId': userId,
      });

  Input$UnfollowUserInput._(this._$data);

  factory Input$UnfollowUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$UnfollowUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get userId => (_$data['userId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$UnfollowUserInput<Input$UnfollowUserInput> get copyWith =>
      CopyWith$Input$UnfollowUserInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnfollowUserInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$UnfollowUserInput<TRes> {
  factory CopyWith$Input$UnfollowUserInput(
    Input$UnfollowUserInput instance,
    TRes Function(Input$UnfollowUserInput) then,
  ) = _CopyWithImpl$Input$UnfollowUserInput;

  factory CopyWith$Input$UnfollowUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnfollowUserInput;

  TRes call({
    String? clientMutationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$UnfollowUserInput<TRes>
    implements CopyWith$Input$UnfollowUserInput<TRes> {
  _CopyWithImpl$Input$UnfollowUserInput(
    this._instance,
    this._then,
  );

  final Input$UnfollowUserInput _instance;

  final TRes Function(Input$UnfollowUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$UnfollowUserInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$UnfollowUserInput<TRes>
    implements CopyWith$Input$UnfollowUserInput<TRes> {
  _CopyWithStubImpl$Input$UnfollowUserInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? userId,
  }) =>
      _res;
}

class Input$UnlinkProjectV2FromRepositoryInput {
  factory Input$UnlinkProjectV2FromRepositoryInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$UnlinkProjectV2FromRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$UnlinkProjectV2FromRepositoryInput._(this._$data);

  factory Input$UnlinkProjectV2FromRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UnlinkProjectV2FromRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UnlinkProjectV2FromRepositoryInput<
          Input$UnlinkProjectV2FromRepositoryInput>
      get copyWith => CopyWith$Input$UnlinkProjectV2FromRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnlinkProjectV2FromRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  factory CopyWith$Input$UnlinkProjectV2FromRepositoryInput(
    Input$UnlinkProjectV2FromRepositoryInput instance,
    TRes Function(Input$UnlinkProjectV2FromRepositoryInput) then,
  ) = _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput;

  factory CopyWith$Input$UnlinkProjectV2FromRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkProjectV2FromRepositoryInput _instance;

  final TRes Function(Input$UnlinkProjectV2FromRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UnlinkProjectV2FromRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$UnlinkProjectV2FromTeamInput {
  factory Input$UnlinkProjectV2FromTeamInput({
    String? clientMutationId,
    required String projectId,
    required String teamId,
  }) =>
      Input$UnlinkProjectV2FromTeamInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'teamId': teamId,
      });

  Input$UnlinkProjectV2FromTeamInput._(this._$data);

  factory Input$UnlinkProjectV2FromTeamInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    return Input$UnlinkProjectV2FromTeamInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get teamId => (_$data['teamId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    return result$data;
  }

  CopyWith$Input$UnlinkProjectV2FromTeamInput<
          Input$UnlinkProjectV2FromTeamInput>
      get copyWith => CopyWith$Input$UnlinkProjectV2FromTeamInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnlinkProjectV2FromTeamInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$teamId = teamId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$teamId,
    ]);
  }
}

abstract class CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  factory CopyWith$Input$UnlinkProjectV2FromTeamInput(
    Input$UnlinkProjectV2FromTeamInput instance,
    TRes Function(Input$UnlinkProjectV2FromTeamInput) then,
  ) = _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput;

  factory CopyWith$Input$UnlinkProjectV2FromTeamInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  });
}

class _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkProjectV2FromTeamInput _instance;

  final TRes Function(Input$UnlinkProjectV2FromTeamInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? teamId = _undefined,
  }) =>
      _then(Input$UnlinkProjectV2FromTeamInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  }) =>
      _res;
}

class Input$UnlinkRepositoryFromProjectInput {
  factory Input$UnlinkRepositoryFromProjectInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$UnlinkRepositoryFromProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$UnlinkRepositoryFromProjectInput._(this._$data);

  factory Input$UnlinkRepositoryFromProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UnlinkRepositoryFromProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get repositoryId => (_$data['repositoryId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UnlinkRepositoryFromProjectInput<
          Input$UnlinkRepositoryFromProjectInput>
      get copyWith => CopyWith$Input$UnlinkRepositoryFromProjectInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnlinkRepositoryFromProjectInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  factory CopyWith$Input$UnlinkRepositoryFromProjectInput(
    Input$UnlinkRepositoryFromProjectInput instance,
    TRes Function(Input$UnlinkRepositoryFromProjectInput) then,
  ) = _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput;

  factory CopyWith$Input$UnlinkRepositoryFromProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput<TRes>
    implements CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkRepositoryFromProjectInput _instance;

  final TRes Function(Input$UnlinkRepositoryFromProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UnlinkRepositoryFromProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput<TRes>
    implements CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$UnlockLockableInput {
  factory Input$UnlockLockableInput({
    String? clientMutationId,
    required String lockableId,
  }) =>
      Input$UnlockLockableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'lockableId': lockableId,
      });

  Input$UnlockLockableInput._(this._$data);

  factory Input$UnlockLockableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$lockableId = data['lockableId'];
    result$data['lockableId'] = (l$lockableId as String);
    return Input$UnlockLockableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get lockableId => (_$data['lockableId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$lockableId = lockableId;
    result$data['lockableId'] = l$lockableId;
    return result$data;
  }

  CopyWith$Input$UnlockLockableInput<Input$UnlockLockableInput> get copyWith =>
      CopyWith$Input$UnlockLockableInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnlockLockableInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$lockableId = lockableId;
    final lOther$lockableId = other.lockableId;
    if (l$lockableId != lOther$lockableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$lockableId = lockableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$lockableId,
    ]);
  }
}

abstract class CopyWith$Input$UnlockLockableInput<TRes> {
  factory CopyWith$Input$UnlockLockableInput(
    Input$UnlockLockableInput instance,
    TRes Function(Input$UnlockLockableInput) then,
  ) = _CopyWithImpl$Input$UnlockLockableInput;

  factory CopyWith$Input$UnlockLockableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlockLockableInput;

  TRes call({
    String? clientMutationId,
    String? lockableId,
  });
}

class _CopyWithImpl$Input$UnlockLockableInput<TRes>
    implements CopyWith$Input$UnlockLockableInput<TRes> {
  _CopyWithImpl$Input$UnlockLockableInput(
    this._instance,
    this._then,
  );

  final Input$UnlockLockableInput _instance;

  final TRes Function(Input$UnlockLockableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? lockableId = _undefined,
  }) =>
      _then(Input$UnlockLockableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (lockableId != _undefined && lockableId != null)
          'lockableId': (lockableId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlockLockableInput<TRes>
    implements CopyWith$Input$UnlockLockableInput<TRes> {
  _CopyWithStubImpl$Input$UnlockLockableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? lockableId,
  }) =>
      _res;
}

class Input$UnmarkDiscussionCommentAsAnswerInput {
  factory Input$UnmarkDiscussionCommentAsAnswerInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$UnmarkDiscussionCommentAsAnswerInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$UnmarkDiscussionCommentAsAnswerInput._(this._$data);

  factory Input$UnmarkDiscussionCommentAsAnswerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$UnmarkDiscussionCommentAsAnswerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<
          Input$UnmarkDiscussionCommentAsAnswerInput>
      get copyWith => CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnmarkDiscussionCommentAsAnswerInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  factory CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput(
    Input$UnmarkDiscussionCommentAsAnswerInput instance,
    TRes Function(Input$UnmarkDiscussionCommentAsAnswerInput) then,
  ) = _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput;

  factory CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkDiscussionCommentAsAnswerInput _instance;

  final TRes Function(Input$UnmarkDiscussionCommentAsAnswerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$UnmarkDiscussionCommentAsAnswerInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$UnmarkFileAsViewedInput {
  factory Input$UnmarkFileAsViewedInput({
    String? clientMutationId,
    required String pullRequestId,
    required String path,
  }) =>
      Input$UnmarkFileAsViewedInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        r'path': path,
      });

  Input$UnmarkFileAsViewedInput._(this._$data);

  factory Input$UnmarkFileAsViewedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    return Input$UnmarkFileAsViewedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String get path => (_$data['path'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    final l$path = path;
    result$data['path'] = l$path;
    return result$data;
  }

  CopyWith$Input$UnmarkFileAsViewedInput<Input$UnmarkFileAsViewedInput>
      get copyWith => CopyWith$Input$UnmarkFileAsViewedInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnmarkFileAsViewedInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$path = path;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      l$path,
    ]);
  }
}

abstract class CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  factory CopyWith$Input$UnmarkFileAsViewedInput(
    Input$UnmarkFileAsViewedInput instance,
    TRes Function(Input$UnmarkFileAsViewedInput) then,
  ) = _CopyWithImpl$Input$UnmarkFileAsViewedInput;

  factory CopyWith$Input$UnmarkFileAsViewedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkFileAsViewedInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? path,
  });
}

class _CopyWithImpl$Input$UnmarkFileAsViewedInput<TRes>
    implements CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  _CopyWithImpl$Input$UnmarkFileAsViewedInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkFileAsViewedInput _instance;

  final TRes Function(Input$UnmarkFileAsViewedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? path = _undefined,
  }) =>
      _then(Input$UnmarkFileAsViewedInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (path != _undefined && path != null) 'path': (path as String),
      }));
}

class _CopyWithStubImpl$Input$UnmarkFileAsViewedInput<TRes>
    implements CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkFileAsViewedInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? path,
  }) =>
      _res;
}

class Input$UnmarkIssueAsDuplicateInput {
  factory Input$UnmarkIssueAsDuplicateInput({
    String? clientMutationId,
    required String duplicateId,
    required String canonicalId,
  }) =>
      Input$UnmarkIssueAsDuplicateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'duplicateId': duplicateId,
        r'canonicalId': canonicalId,
      });

  Input$UnmarkIssueAsDuplicateInput._(this._$data);

  factory Input$UnmarkIssueAsDuplicateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$duplicateId = data['duplicateId'];
    result$data['duplicateId'] = (l$duplicateId as String);
    final l$canonicalId = data['canonicalId'];
    result$data['canonicalId'] = (l$canonicalId as String);
    return Input$UnmarkIssueAsDuplicateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get duplicateId => (_$data['duplicateId'] as String);

  String get canonicalId => (_$data['canonicalId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$duplicateId = duplicateId;
    result$data['duplicateId'] = l$duplicateId;
    final l$canonicalId = canonicalId;
    result$data['canonicalId'] = l$canonicalId;
    return result$data;
  }

  CopyWith$Input$UnmarkIssueAsDuplicateInput<Input$UnmarkIssueAsDuplicateInput>
      get copyWith => CopyWith$Input$UnmarkIssueAsDuplicateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnmarkIssueAsDuplicateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$duplicateId = duplicateId;
    final lOther$duplicateId = other.duplicateId;
    if (l$duplicateId != lOther$duplicateId) {
      return false;
    }
    final l$canonicalId = canonicalId;
    final lOther$canonicalId = other.canonicalId;
    if (l$canonicalId != lOther$canonicalId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$duplicateId = duplicateId;
    final l$canonicalId = canonicalId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$duplicateId,
      l$canonicalId,
    ]);
  }
}

abstract class CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  factory CopyWith$Input$UnmarkIssueAsDuplicateInput(
    Input$UnmarkIssueAsDuplicateInput instance,
    TRes Function(Input$UnmarkIssueAsDuplicateInput) then,
  ) = _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput;

  factory CopyWith$Input$UnmarkIssueAsDuplicateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput;

  TRes call({
    String? clientMutationId,
    String? duplicateId,
    String? canonicalId,
  });
}

class _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput<TRes>
    implements CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkIssueAsDuplicateInput _instance;

  final TRes Function(Input$UnmarkIssueAsDuplicateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? duplicateId = _undefined,
    Object? canonicalId = _undefined,
  }) =>
      _then(Input$UnmarkIssueAsDuplicateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (duplicateId != _undefined && duplicateId != null)
          'duplicateId': (duplicateId as String),
        if (canonicalId != _undefined && canonicalId != null)
          'canonicalId': (canonicalId as String),
      }));
}

class _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput<TRes>
    implements CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? duplicateId,
    String? canonicalId,
  }) =>
      _res;
}

class Input$UnmarkProjectV2AsTemplateInput {
  factory Input$UnmarkProjectV2AsTemplateInput({
    String? clientMutationId,
    required String projectId,
  }) =>
      Input$UnmarkProjectV2AsTemplateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
      });

  Input$UnmarkProjectV2AsTemplateInput._(this._$data);

  factory Input$UnmarkProjectV2AsTemplateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$UnmarkProjectV2AsTemplateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$UnmarkProjectV2AsTemplateInput<
          Input$UnmarkProjectV2AsTemplateInput>
      get copyWith => CopyWith$Input$UnmarkProjectV2AsTemplateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnmarkProjectV2AsTemplateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$UnmarkProjectV2AsTemplateInput<TRes> {
  factory CopyWith$Input$UnmarkProjectV2AsTemplateInput(
    Input$UnmarkProjectV2AsTemplateInput instance,
    TRes Function(Input$UnmarkProjectV2AsTemplateInput) then,
  ) = _CopyWithImpl$Input$UnmarkProjectV2AsTemplateInput;

  factory CopyWith$Input$UnmarkProjectV2AsTemplateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkProjectV2AsTemplateInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$UnmarkProjectV2AsTemplateInput<TRes>
    implements CopyWith$Input$UnmarkProjectV2AsTemplateInput<TRes> {
  _CopyWithImpl$Input$UnmarkProjectV2AsTemplateInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkProjectV2AsTemplateInput _instance;

  final TRes Function(Input$UnmarkProjectV2AsTemplateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$UnmarkProjectV2AsTemplateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$UnmarkProjectV2AsTemplateInput<TRes>
    implements CopyWith$Input$UnmarkProjectV2AsTemplateInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkProjectV2AsTemplateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
  }) =>
      _res;
}

class Input$UnminimizeCommentInput {
  factory Input$UnminimizeCommentInput({
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$UnminimizeCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$UnminimizeCommentInput._(this._$data);

  factory Input$UnminimizeCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$UnminimizeCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subjectId => (_$data['subjectId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$UnminimizeCommentInput<Input$UnminimizeCommentInput>
      get copyWith => CopyWith$Input$UnminimizeCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnminimizeCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$UnminimizeCommentInput<TRes> {
  factory CopyWith$Input$UnminimizeCommentInput(
    Input$UnminimizeCommentInput instance,
    TRes Function(Input$UnminimizeCommentInput) then,
  ) = _CopyWithImpl$Input$UnminimizeCommentInput;

  factory CopyWith$Input$UnminimizeCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnminimizeCommentInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$UnminimizeCommentInput<TRes>
    implements CopyWith$Input$UnminimizeCommentInput<TRes> {
  _CopyWithImpl$Input$UnminimizeCommentInput(
    this._instance,
    this._then,
  );

  final Input$UnminimizeCommentInput _instance;

  final TRes Function(Input$UnminimizeCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$UnminimizeCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$UnminimizeCommentInput<TRes>
    implements CopyWith$Input$UnminimizeCommentInput<TRes> {
  _CopyWithStubImpl$Input$UnminimizeCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$UnpinIssueInput {
  factory Input$UnpinIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$UnpinIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$UnpinIssueInput._(this._$data);

  factory Input$UnpinIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$UnpinIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$UnpinIssueInput<Input$UnpinIssueInput> get copyWith =>
      CopyWith$Input$UnpinIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnpinIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$UnpinIssueInput<TRes> {
  factory CopyWith$Input$UnpinIssueInput(
    Input$UnpinIssueInput instance,
    TRes Function(Input$UnpinIssueInput) then,
  ) = _CopyWithImpl$Input$UnpinIssueInput;

  factory CopyWith$Input$UnpinIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnpinIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$UnpinIssueInput<TRes>
    implements CopyWith$Input$UnpinIssueInput<TRes> {
  _CopyWithImpl$Input$UnpinIssueInput(
    this._instance,
    this._then,
  );

  final Input$UnpinIssueInput _instance;

  final TRes Function(Input$UnpinIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$UnpinIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$UnpinIssueInput<TRes>
    implements CopyWith$Input$UnpinIssueInput<TRes> {
  _CopyWithStubImpl$Input$UnpinIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$UnresolveReviewThreadInput {
  factory Input$UnresolveReviewThreadInput({
    String? clientMutationId,
    required String threadId,
  }) =>
      Input$UnresolveReviewThreadInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'threadId': threadId,
      });

  Input$UnresolveReviewThreadInput._(this._$data);

  factory Input$UnresolveReviewThreadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$threadId = data['threadId'];
    result$data['threadId'] = (l$threadId as String);
    return Input$UnresolveReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get threadId => (_$data['threadId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$threadId = threadId;
    result$data['threadId'] = l$threadId;
    return result$data;
  }

  CopyWith$Input$UnresolveReviewThreadInput<Input$UnresolveReviewThreadInput>
      get copyWith => CopyWith$Input$UnresolveReviewThreadInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UnresolveReviewThreadInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$threadId = threadId;
    final lOther$threadId = other.threadId;
    if (l$threadId != lOther$threadId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$threadId = threadId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$threadId,
    ]);
  }
}

abstract class CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  factory CopyWith$Input$UnresolveReviewThreadInput(
    Input$UnresolveReviewThreadInput instance,
    TRes Function(Input$UnresolveReviewThreadInput) then,
  ) = _CopyWithImpl$Input$UnresolveReviewThreadInput;

  factory CopyWith$Input$UnresolveReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnresolveReviewThreadInput;

  TRes call({
    String? clientMutationId,
    String? threadId,
  });
}

class _CopyWithImpl$Input$UnresolveReviewThreadInput<TRes>
    implements CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  _CopyWithImpl$Input$UnresolveReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$UnresolveReviewThreadInput _instance;

  final TRes Function(Input$UnresolveReviewThreadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? threadId = _undefined,
  }) =>
      _then(Input$UnresolveReviewThreadInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (threadId != _undefined && threadId != null)
          'threadId': (threadId as String),
      }));
}

class _CopyWithStubImpl$Input$UnresolveReviewThreadInput<TRes>
    implements CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$UnresolveReviewThreadInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? threadId,
  }) =>
      _res;
}

class Input$UpdateBranchProtectionRuleInput {
  factory Input$UpdateBranchProtectionRuleInput({
    String? clientMutationId,
    required String branchProtectionRuleId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresDeployments,
    List<String>? requiredDeploymentEnvironments,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
  }) =>
      Input$UpdateBranchProtectionRuleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'branchProtectionRuleId': branchProtectionRuleId,
        if (pattern != null) r'pattern': pattern,
        if (requiresApprovingReviews != null)
          r'requiresApprovingReviews': requiresApprovingReviews,
        if (requiredApprovingReviewCount != null)
          r'requiredApprovingReviewCount': requiredApprovingReviewCount,
        if (requiresCommitSignatures != null)
          r'requiresCommitSignatures': requiresCommitSignatures,
        if (requiresLinearHistory != null)
          r'requiresLinearHistory': requiresLinearHistory,
        if (blocksCreations != null) r'blocksCreations': blocksCreations,
        if (allowsForcePushes != null) r'allowsForcePushes': allowsForcePushes,
        if (allowsDeletions != null) r'allowsDeletions': allowsDeletions,
        if (isAdminEnforced != null) r'isAdminEnforced': isAdminEnforced,
        if (requiresStatusChecks != null)
          r'requiresStatusChecks': requiresStatusChecks,
        if (requiresStrictStatusChecks != null)
          r'requiresStrictStatusChecks': requiresStrictStatusChecks,
        if (requiresCodeOwnerReviews != null)
          r'requiresCodeOwnerReviews': requiresCodeOwnerReviews,
        if (dismissesStaleReviews != null)
          r'dismissesStaleReviews': dismissesStaleReviews,
        if (restrictsReviewDismissals != null)
          r'restrictsReviewDismissals': restrictsReviewDismissals,
        if (reviewDismissalActorIds != null)
          r'reviewDismissalActorIds': reviewDismissalActorIds,
        if (bypassPullRequestActorIds != null)
          r'bypassPullRequestActorIds': bypassPullRequestActorIds,
        if (bypassForcePushActorIds != null)
          r'bypassForcePushActorIds': bypassForcePushActorIds,
        if (restrictsPushes != null) r'restrictsPushes': restrictsPushes,
        if (pushActorIds != null) r'pushActorIds': pushActorIds,
        if (requiredStatusCheckContexts != null)
          r'requiredStatusCheckContexts': requiredStatusCheckContexts,
        if (requiredStatusChecks != null)
          r'requiredStatusChecks': requiredStatusChecks,
        if (requiresDeployments != null)
          r'requiresDeployments': requiresDeployments,
        if (requiredDeploymentEnvironments != null)
          r'requiredDeploymentEnvironments': requiredDeploymentEnvironments,
        if (requiresConversationResolution != null)
          r'requiresConversationResolution': requiresConversationResolution,
        if (requireLastPushApproval != null)
          r'requireLastPushApproval': requireLastPushApproval,
        if (lockBranch != null) r'lockBranch': lockBranch,
        if (lockAllowsFetchAndMerge != null)
          r'lockAllowsFetchAndMerge': lockAllowsFetchAndMerge,
      });

  Input$UpdateBranchProtectionRuleInput._(this._$data);

  factory Input$UpdateBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$branchProtectionRuleId = data['branchProtectionRuleId'];
    result$data['branchProtectionRuleId'] =
        (l$branchProtectionRuleId as String);
    if (data.containsKey('pattern')) {
      final l$pattern = data['pattern'];
      result$data['pattern'] = (l$pattern as String?);
    }
    if (data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = data['requiresApprovingReviews'];
      result$data['requiresApprovingReviews'] =
          (l$requiresApprovingReviews as bool?);
    }
    if (data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount =
          data['requiredApprovingReviewCount'];
      result$data['requiredApprovingReviewCount'] =
          (l$requiredApprovingReviewCount as int?);
    }
    if (data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = data['requiresCommitSignatures'];
      result$data['requiresCommitSignatures'] =
          (l$requiresCommitSignatures as bool?);
    }
    if (data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = data['requiresLinearHistory'];
      result$data['requiresLinearHistory'] = (l$requiresLinearHistory as bool?);
    }
    if (data.containsKey('blocksCreations')) {
      final l$blocksCreations = data['blocksCreations'];
      result$data['blocksCreations'] = (l$blocksCreations as bool?);
    }
    if (data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = data['allowsForcePushes'];
      result$data['allowsForcePushes'] = (l$allowsForcePushes as bool?);
    }
    if (data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = data['allowsDeletions'];
      result$data['allowsDeletions'] = (l$allowsDeletions as bool?);
    }
    if (data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = data['isAdminEnforced'];
      result$data['isAdminEnforced'] = (l$isAdminEnforced as bool?);
    }
    if (data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = data['requiresStatusChecks'];
      result$data['requiresStatusChecks'] = (l$requiresStatusChecks as bool?);
    }
    if (data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = data['requiresStrictStatusChecks'];
      result$data['requiresStrictStatusChecks'] =
          (l$requiresStrictStatusChecks as bool?);
    }
    if (data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = data['requiresCodeOwnerReviews'];
      result$data['requiresCodeOwnerReviews'] =
          (l$requiresCodeOwnerReviews as bool?);
    }
    if (data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = data['dismissesStaleReviews'];
      result$data['dismissesStaleReviews'] = (l$dismissesStaleReviews as bool?);
    }
    if (data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = data['restrictsReviewDismissals'];
      result$data['restrictsReviewDismissals'] =
          (l$restrictsReviewDismissals as bool?);
    }
    if (data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = data['reviewDismissalActorIds'];
      result$data['reviewDismissalActorIds'] =
          (l$reviewDismissalActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = data['bypassPullRequestActorIds'];
      result$data['bypassPullRequestActorIds'] =
          (l$bypassPullRequestActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = data['bypassForcePushActorIds'];
      result$data['bypassForcePushActorIds'] =
          (l$bypassForcePushActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = data['restrictsPushes'];
      result$data['restrictsPushes'] = (l$restrictsPushes as bool?);
    }
    if (data.containsKey('pushActorIds')) {
      final l$pushActorIds = data['pushActorIds'];
      result$data['pushActorIds'] = (l$pushActorIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = data['requiredStatusCheckContexts'];
      result$data['requiredStatusCheckContexts'] =
          (l$requiredStatusCheckContexts as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = data['requiredStatusChecks'];
      result$data['requiredStatusChecks'] =
          (l$requiredStatusChecks as List<dynamic>?)
              ?.map((e) => Input$RequiredStatusCheckInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = data['requiresDeployments'];
      result$data['requiresDeployments'] = (l$requiresDeployments as bool?);
    }
    if (data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments =
          data['requiredDeploymentEnvironments'];
      result$data['requiredDeploymentEnvironments'] =
          (l$requiredDeploymentEnvironments as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution =
          data['requiresConversationResolution'];
      result$data['requiresConversationResolution'] =
          (l$requiresConversationResolution as bool?);
    }
    if (data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = data['requireLastPushApproval'];
      result$data['requireLastPushApproval'] =
          (l$requireLastPushApproval as bool?);
    }
    if (data.containsKey('lockBranch')) {
      final l$lockBranch = data['lockBranch'];
      result$data['lockBranch'] = (l$lockBranch as bool?);
    }
    if (data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = data['lockAllowsFetchAndMerge'];
      result$data['lockAllowsFetchAndMerge'] =
          (l$lockAllowsFetchAndMerge as bool?);
    }
    return Input$UpdateBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get branchProtectionRuleId =>
      (_$data['branchProtectionRuleId'] as String);

  String? get pattern => (_$data['pattern'] as String?);

  bool? get requiresApprovingReviews =>
      (_$data['requiresApprovingReviews'] as bool?);

  int? get requiredApprovingReviewCount =>
      (_$data['requiredApprovingReviewCount'] as int?);

  bool? get requiresCommitSignatures =>
      (_$data['requiresCommitSignatures'] as bool?);

  bool? get requiresLinearHistory => (_$data['requiresLinearHistory'] as bool?);

  bool? get blocksCreations => (_$data['blocksCreations'] as bool?);

  bool? get allowsForcePushes => (_$data['allowsForcePushes'] as bool?);

  bool? get allowsDeletions => (_$data['allowsDeletions'] as bool?);

  bool? get isAdminEnforced => (_$data['isAdminEnforced'] as bool?);

  bool? get requiresStatusChecks => (_$data['requiresStatusChecks'] as bool?);

  bool? get requiresStrictStatusChecks =>
      (_$data['requiresStrictStatusChecks'] as bool?);

  bool? get requiresCodeOwnerReviews =>
      (_$data['requiresCodeOwnerReviews'] as bool?);

  bool? get dismissesStaleReviews => (_$data['dismissesStaleReviews'] as bool?);

  bool? get restrictsReviewDismissals =>
      (_$data['restrictsReviewDismissals'] as bool?);

  List<String>? get reviewDismissalActorIds =>
      (_$data['reviewDismissalActorIds'] as List<String>?);

  List<String>? get bypassPullRequestActorIds =>
      (_$data['bypassPullRequestActorIds'] as List<String>?);

  List<String>? get bypassForcePushActorIds =>
      (_$data['bypassForcePushActorIds'] as List<String>?);

  bool? get restrictsPushes => (_$data['restrictsPushes'] as bool?);

  List<String>? get pushActorIds => (_$data['pushActorIds'] as List<String>?);

  List<String>? get requiredStatusCheckContexts =>
      (_$data['requiredStatusCheckContexts'] as List<String>?);

  List<Input$RequiredStatusCheckInput>? get requiredStatusChecks =>
      (_$data['requiredStatusChecks'] as List<Input$RequiredStatusCheckInput>?);

  bool? get requiresDeployments => (_$data['requiresDeployments'] as bool?);

  List<String>? get requiredDeploymentEnvironments =>
      (_$data['requiredDeploymentEnvironments'] as List<String>?);

  bool? get requiresConversationResolution =>
      (_$data['requiresConversationResolution'] as bool?);

  bool? get requireLastPushApproval =>
      (_$data['requireLastPushApproval'] as bool?);

  bool? get lockBranch => (_$data['lockBranch'] as bool?);

  bool? get lockAllowsFetchAndMerge =>
      (_$data['lockAllowsFetchAndMerge'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    result$data['branchProtectionRuleId'] = l$branchProtectionRuleId;
    if (_$data.containsKey('pattern')) {
      final l$pattern = pattern;
      result$data['pattern'] = l$pattern;
    }
    if (_$data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = requiresApprovingReviews;
      result$data['requiresApprovingReviews'] = l$requiresApprovingReviews;
    }
    if (_$data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
      result$data['requiredApprovingReviewCount'] =
          l$requiredApprovingReviewCount;
    }
    if (_$data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = requiresCommitSignatures;
      result$data['requiresCommitSignatures'] = l$requiresCommitSignatures;
    }
    if (_$data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = requiresLinearHistory;
      result$data['requiresLinearHistory'] = l$requiresLinearHistory;
    }
    if (_$data.containsKey('blocksCreations')) {
      final l$blocksCreations = blocksCreations;
      result$data['blocksCreations'] = l$blocksCreations;
    }
    if (_$data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = allowsForcePushes;
      result$data['allowsForcePushes'] = l$allowsForcePushes;
    }
    if (_$data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = allowsDeletions;
      result$data['allowsDeletions'] = l$allowsDeletions;
    }
    if (_$data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = isAdminEnforced;
      result$data['isAdminEnforced'] = l$isAdminEnforced;
    }
    if (_$data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = requiresStatusChecks;
      result$data['requiresStatusChecks'] = l$requiresStatusChecks;
    }
    if (_$data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
      result$data['requiresStrictStatusChecks'] = l$requiresStrictStatusChecks;
    }
    if (_$data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
      result$data['requiresCodeOwnerReviews'] = l$requiresCodeOwnerReviews;
    }
    if (_$data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = dismissesStaleReviews;
      result$data['dismissesStaleReviews'] = l$dismissesStaleReviews;
    }
    if (_$data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = restrictsReviewDismissals;
      result$data['restrictsReviewDismissals'] = l$restrictsReviewDismissals;
    }
    if (_$data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = reviewDismissalActorIds;
      result$data['reviewDismissalActorIds'] =
          l$reviewDismissalActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
      result$data['bypassPullRequestActorIds'] =
          l$bypassPullRequestActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = bypassForcePushActorIds;
      result$data['bypassForcePushActorIds'] =
          l$bypassForcePushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = restrictsPushes;
      result$data['restrictsPushes'] = l$restrictsPushes;
    }
    if (_$data.containsKey('pushActorIds')) {
      final l$pushActorIds = pushActorIds;
      result$data['pushActorIds'] = l$pushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
      result$data['requiredStatusCheckContexts'] =
          l$requiredStatusCheckContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = requiredStatusChecks;
      result$data['requiredStatusChecks'] =
          l$requiredStatusChecks?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = requiresDeployments;
      result$data['requiresDeployments'] = l$requiresDeployments;
    }
    if (_$data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
      result$data['requiredDeploymentEnvironments'] =
          l$requiredDeploymentEnvironments?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution = requiresConversationResolution;
      result$data['requiresConversationResolution'] =
          l$requiresConversationResolution;
    }
    if (_$data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = requireLastPushApproval;
      result$data['requireLastPushApproval'] = l$requireLastPushApproval;
    }
    if (_$data.containsKey('lockBranch')) {
      final l$lockBranch = lockBranch;
      result$data['lockBranch'] = l$lockBranch;
    }
    if (_$data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
      result$data['lockAllowsFetchAndMerge'] = l$lockAllowsFetchAndMerge;
    }
    return result$data;
  }

  CopyWith$Input$UpdateBranchProtectionRuleInput<
          Input$UpdateBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$UpdateBranchProtectionRuleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateBranchProtectionRuleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final lOther$branchProtectionRuleId = other.branchProtectionRuleId;
    if (l$branchProtectionRuleId != lOther$branchProtectionRuleId) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (_$data.containsKey('pattern') != other._$data.containsKey('pattern')) {
      return false;
    }
    if (l$pattern != lOther$pattern) {
      return false;
    }
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final lOther$requiresApprovingReviews = other.requiresApprovingReviews;
    if (_$data.containsKey('requiresApprovingReviews') !=
        other._$data.containsKey('requiresApprovingReviews')) {
      return false;
    }
    if (l$requiresApprovingReviews != lOther$requiresApprovingReviews) {
      return false;
    }
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final lOther$requiredApprovingReviewCount =
        other.requiredApprovingReviewCount;
    if (_$data.containsKey('requiredApprovingReviewCount') !=
        other._$data.containsKey('requiredApprovingReviewCount')) {
      return false;
    }
    if (l$requiredApprovingReviewCount != lOther$requiredApprovingReviewCount) {
      return false;
    }
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final lOther$requiresCommitSignatures = other.requiresCommitSignatures;
    if (_$data.containsKey('requiresCommitSignatures') !=
        other._$data.containsKey('requiresCommitSignatures')) {
      return false;
    }
    if (l$requiresCommitSignatures != lOther$requiresCommitSignatures) {
      return false;
    }
    final l$requiresLinearHistory = requiresLinearHistory;
    final lOther$requiresLinearHistory = other.requiresLinearHistory;
    if (_$data.containsKey('requiresLinearHistory') !=
        other._$data.containsKey('requiresLinearHistory')) {
      return false;
    }
    if (l$requiresLinearHistory != lOther$requiresLinearHistory) {
      return false;
    }
    final l$blocksCreations = blocksCreations;
    final lOther$blocksCreations = other.blocksCreations;
    if (_$data.containsKey('blocksCreations') !=
        other._$data.containsKey('blocksCreations')) {
      return false;
    }
    if (l$blocksCreations != lOther$blocksCreations) {
      return false;
    }
    final l$allowsForcePushes = allowsForcePushes;
    final lOther$allowsForcePushes = other.allowsForcePushes;
    if (_$data.containsKey('allowsForcePushes') !=
        other._$data.containsKey('allowsForcePushes')) {
      return false;
    }
    if (l$allowsForcePushes != lOther$allowsForcePushes) {
      return false;
    }
    final l$allowsDeletions = allowsDeletions;
    final lOther$allowsDeletions = other.allowsDeletions;
    if (_$data.containsKey('allowsDeletions') !=
        other._$data.containsKey('allowsDeletions')) {
      return false;
    }
    if (l$allowsDeletions != lOther$allowsDeletions) {
      return false;
    }
    final l$isAdminEnforced = isAdminEnforced;
    final lOther$isAdminEnforced = other.isAdminEnforced;
    if (_$data.containsKey('isAdminEnforced') !=
        other._$data.containsKey('isAdminEnforced')) {
      return false;
    }
    if (l$isAdminEnforced != lOther$isAdminEnforced) {
      return false;
    }
    final l$requiresStatusChecks = requiresStatusChecks;
    final lOther$requiresStatusChecks = other.requiresStatusChecks;
    if (_$data.containsKey('requiresStatusChecks') !=
        other._$data.containsKey('requiresStatusChecks')) {
      return false;
    }
    if (l$requiresStatusChecks != lOther$requiresStatusChecks) {
      return false;
    }
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final lOther$requiresStrictStatusChecks = other.requiresStrictStatusChecks;
    if (_$data.containsKey('requiresStrictStatusChecks') !=
        other._$data.containsKey('requiresStrictStatusChecks')) {
      return false;
    }
    if (l$requiresStrictStatusChecks != lOther$requiresStrictStatusChecks) {
      return false;
    }
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final lOther$requiresCodeOwnerReviews = other.requiresCodeOwnerReviews;
    if (_$data.containsKey('requiresCodeOwnerReviews') !=
        other._$data.containsKey('requiresCodeOwnerReviews')) {
      return false;
    }
    if (l$requiresCodeOwnerReviews != lOther$requiresCodeOwnerReviews) {
      return false;
    }
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final lOther$dismissesStaleReviews = other.dismissesStaleReviews;
    if (_$data.containsKey('dismissesStaleReviews') !=
        other._$data.containsKey('dismissesStaleReviews')) {
      return false;
    }
    if (l$dismissesStaleReviews != lOther$dismissesStaleReviews) {
      return false;
    }
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final lOther$restrictsReviewDismissals = other.restrictsReviewDismissals;
    if (_$data.containsKey('restrictsReviewDismissals') !=
        other._$data.containsKey('restrictsReviewDismissals')) {
      return false;
    }
    if (l$restrictsReviewDismissals != lOther$restrictsReviewDismissals) {
      return false;
    }
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final lOther$reviewDismissalActorIds = other.reviewDismissalActorIds;
    if (_$data.containsKey('reviewDismissalActorIds') !=
        other._$data.containsKey('reviewDismissalActorIds')) {
      return false;
    }
    if (l$reviewDismissalActorIds != null &&
        lOther$reviewDismissalActorIds != null) {
      if (l$reviewDismissalActorIds.length !=
          lOther$reviewDismissalActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$reviewDismissalActorIds.length; i++) {
        final l$reviewDismissalActorIds$entry = l$reviewDismissalActorIds[i];
        final lOther$reviewDismissalActorIds$entry =
            lOther$reviewDismissalActorIds[i];
        if (l$reviewDismissalActorIds$entry !=
            lOther$reviewDismissalActorIds$entry) {
          return false;
        }
      }
    } else if (l$reviewDismissalActorIds != lOther$reviewDismissalActorIds) {
      return false;
    }
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final lOther$bypassPullRequestActorIds = other.bypassPullRequestActorIds;
    if (_$data.containsKey('bypassPullRequestActorIds') !=
        other._$data.containsKey('bypassPullRequestActorIds')) {
      return false;
    }
    if (l$bypassPullRequestActorIds != null &&
        lOther$bypassPullRequestActorIds != null) {
      if (l$bypassPullRequestActorIds.length !=
          lOther$bypassPullRequestActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassPullRequestActorIds.length; i++) {
        final l$bypassPullRequestActorIds$entry =
            l$bypassPullRequestActorIds[i];
        final lOther$bypassPullRequestActorIds$entry =
            lOther$bypassPullRequestActorIds[i];
        if (l$bypassPullRequestActorIds$entry !=
            lOther$bypassPullRequestActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassPullRequestActorIds !=
        lOther$bypassPullRequestActorIds) {
      return false;
    }
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final lOther$bypassForcePushActorIds = other.bypassForcePushActorIds;
    if (_$data.containsKey('bypassForcePushActorIds') !=
        other._$data.containsKey('bypassForcePushActorIds')) {
      return false;
    }
    if (l$bypassForcePushActorIds != null &&
        lOther$bypassForcePushActorIds != null) {
      if (l$bypassForcePushActorIds.length !=
          lOther$bypassForcePushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassForcePushActorIds.length; i++) {
        final l$bypassForcePushActorIds$entry = l$bypassForcePushActorIds[i];
        final lOther$bypassForcePushActorIds$entry =
            lOther$bypassForcePushActorIds[i];
        if (l$bypassForcePushActorIds$entry !=
            lOther$bypassForcePushActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassForcePushActorIds != lOther$bypassForcePushActorIds) {
      return false;
    }
    final l$restrictsPushes = restrictsPushes;
    final lOther$restrictsPushes = other.restrictsPushes;
    if (_$data.containsKey('restrictsPushes') !=
        other._$data.containsKey('restrictsPushes')) {
      return false;
    }
    if (l$restrictsPushes != lOther$restrictsPushes) {
      return false;
    }
    final l$pushActorIds = pushActorIds;
    final lOther$pushActorIds = other.pushActorIds;
    if (_$data.containsKey('pushActorIds') !=
        other._$data.containsKey('pushActorIds')) {
      return false;
    }
    if (l$pushActorIds != null && lOther$pushActorIds != null) {
      if (l$pushActorIds.length != lOther$pushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$pushActorIds.length; i++) {
        final l$pushActorIds$entry = l$pushActorIds[i];
        final lOther$pushActorIds$entry = lOther$pushActorIds[i];
        if (l$pushActorIds$entry != lOther$pushActorIds$entry) {
          return false;
        }
      }
    } else if (l$pushActorIds != lOther$pushActorIds) {
      return false;
    }
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final lOther$requiredStatusCheckContexts =
        other.requiredStatusCheckContexts;
    if (_$data.containsKey('requiredStatusCheckContexts') !=
        other._$data.containsKey('requiredStatusCheckContexts')) {
      return false;
    }
    if (l$requiredStatusCheckContexts != null &&
        lOther$requiredStatusCheckContexts != null) {
      if (l$requiredStatusCheckContexts.length !=
          lOther$requiredStatusCheckContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusCheckContexts.length; i++) {
        final l$requiredStatusCheckContexts$entry =
            l$requiredStatusCheckContexts[i];
        final lOther$requiredStatusCheckContexts$entry =
            lOther$requiredStatusCheckContexts[i];
        if (l$requiredStatusCheckContexts$entry !=
            lOther$requiredStatusCheckContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusCheckContexts !=
        lOther$requiredStatusCheckContexts) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (_$data.containsKey('requiredStatusChecks') !=
        other._$data.containsKey('requiredStatusChecks')) {
      return false;
    }
    if (l$requiredStatusChecks != null && lOther$requiredStatusChecks != null) {
      if (l$requiredStatusChecks.length != lOther$requiredStatusChecks.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusChecks.length; i++) {
        final l$requiredStatusChecks$entry = l$requiredStatusChecks[i];
        final lOther$requiredStatusChecks$entry =
            lOther$requiredStatusChecks[i];
        if (l$requiredStatusChecks$entry != lOther$requiredStatusChecks$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusChecks != lOther$requiredStatusChecks) {
      return false;
    }
    final l$requiresDeployments = requiresDeployments;
    final lOther$requiresDeployments = other.requiresDeployments;
    if (_$data.containsKey('requiresDeployments') !=
        other._$data.containsKey('requiresDeployments')) {
      return false;
    }
    if (l$requiresDeployments != lOther$requiresDeployments) {
      return false;
    }
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final lOther$requiredDeploymentEnvironments =
        other.requiredDeploymentEnvironments;
    if (_$data.containsKey('requiredDeploymentEnvironments') !=
        other._$data.containsKey('requiredDeploymentEnvironments')) {
      return false;
    }
    if (l$requiredDeploymentEnvironments != null &&
        lOther$requiredDeploymentEnvironments != null) {
      if (l$requiredDeploymentEnvironments.length !=
          lOther$requiredDeploymentEnvironments.length) {
        return false;
      }
      for (int i = 0; i < l$requiredDeploymentEnvironments.length; i++) {
        final l$requiredDeploymentEnvironments$entry =
            l$requiredDeploymentEnvironments[i];
        final lOther$requiredDeploymentEnvironments$entry =
            lOther$requiredDeploymentEnvironments[i];
        if (l$requiredDeploymentEnvironments$entry !=
            lOther$requiredDeploymentEnvironments$entry) {
          return false;
        }
      }
    } else if (l$requiredDeploymentEnvironments !=
        lOther$requiredDeploymentEnvironments) {
      return false;
    }
    final l$requiresConversationResolution = requiresConversationResolution;
    final lOther$requiresConversationResolution =
        other.requiresConversationResolution;
    if (_$data.containsKey('requiresConversationResolution') !=
        other._$data.containsKey('requiresConversationResolution')) {
      return false;
    }
    if (l$requiresConversationResolution !=
        lOther$requiresConversationResolution) {
      return false;
    }
    final l$requireLastPushApproval = requireLastPushApproval;
    final lOther$requireLastPushApproval = other.requireLastPushApproval;
    if (_$data.containsKey('requireLastPushApproval') !=
        other._$data.containsKey('requireLastPushApproval')) {
      return false;
    }
    if (l$requireLastPushApproval != lOther$requireLastPushApproval) {
      return false;
    }
    final l$lockBranch = lockBranch;
    final lOther$lockBranch = other.lockBranch;
    if (_$data.containsKey('lockBranch') !=
        other._$data.containsKey('lockBranch')) {
      return false;
    }
    if (l$lockBranch != lOther$lockBranch) {
      return false;
    }
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final lOther$lockAllowsFetchAndMerge = other.lockAllowsFetchAndMerge;
    if (_$data.containsKey('lockAllowsFetchAndMerge') !=
        other._$data.containsKey('lockAllowsFetchAndMerge')) {
      return false;
    }
    if (l$lockAllowsFetchAndMerge != lOther$lockAllowsFetchAndMerge) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final l$pattern = pattern;
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final l$requiresLinearHistory = requiresLinearHistory;
    final l$blocksCreations = blocksCreations;
    final l$allowsForcePushes = allowsForcePushes;
    final l$allowsDeletions = allowsDeletions;
    final l$isAdminEnforced = isAdminEnforced;
    final l$requiresStatusChecks = requiresStatusChecks;
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final l$restrictsPushes = restrictsPushes;
    final l$pushActorIds = pushActorIds;
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$requiresDeployments = requiresDeployments;
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final l$requiresConversationResolution = requiresConversationResolution;
    final l$requireLastPushApproval = requireLastPushApproval;
    final l$lockBranch = lockBranch;
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$branchProtectionRuleId,
      _$data.containsKey('pattern') ? l$pattern : const {},
      _$data.containsKey('requiresApprovingReviews')
          ? l$requiresApprovingReviews
          : const {},
      _$data.containsKey('requiredApprovingReviewCount')
          ? l$requiredApprovingReviewCount
          : const {},
      _$data.containsKey('requiresCommitSignatures')
          ? l$requiresCommitSignatures
          : const {},
      _$data.containsKey('requiresLinearHistory')
          ? l$requiresLinearHistory
          : const {},
      _$data.containsKey('blocksCreations') ? l$blocksCreations : const {},
      _$data.containsKey('allowsForcePushes') ? l$allowsForcePushes : const {},
      _$data.containsKey('allowsDeletions') ? l$allowsDeletions : const {},
      _$data.containsKey('isAdminEnforced') ? l$isAdminEnforced : const {},
      _$data.containsKey('requiresStatusChecks')
          ? l$requiresStatusChecks
          : const {},
      _$data.containsKey('requiresStrictStatusChecks')
          ? l$requiresStrictStatusChecks
          : const {},
      _$data.containsKey('requiresCodeOwnerReviews')
          ? l$requiresCodeOwnerReviews
          : const {},
      _$data.containsKey('dismissesStaleReviews')
          ? l$dismissesStaleReviews
          : const {},
      _$data.containsKey('restrictsReviewDismissals')
          ? l$restrictsReviewDismissals
          : const {},
      _$data.containsKey('reviewDismissalActorIds')
          ? l$reviewDismissalActorIds == null
              ? null
              : Object.hashAll(l$reviewDismissalActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassPullRequestActorIds')
          ? l$bypassPullRequestActorIds == null
              ? null
              : Object.hashAll(l$bypassPullRequestActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassForcePushActorIds')
          ? l$bypassForcePushActorIds == null
              ? null
              : Object.hashAll(l$bypassForcePushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('restrictsPushes') ? l$restrictsPushes : const {},
      _$data.containsKey('pushActorIds')
          ? l$pushActorIds == null
              ? null
              : Object.hashAll(l$pushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusCheckContexts')
          ? l$requiredStatusCheckContexts == null
              ? null
              : Object.hashAll(l$requiredStatusCheckContexts.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusChecks')
          ? l$requiredStatusChecks == null
              ? null
              : Object.hashAll(l$requiredStatusChecks.map((v) => v))
          : const {},
      _$data.containsKey('requiresDeployments')
          ? l$requiresDeployments
          : const {},
      _$data.containsKey('requiredDeploymentEnvironments')
          ? l$requiredDeploymentEnvironments == null
              ? null
              : Object.hashAll(l$requiredDeploymentEnvironments.map((v) => v))
          : const {},
      _$data.containsKey('requiresConversationResolution')
          ? l$requiresConversationResolution
          : const {},
      _$data.containsKey('requireLastPushApproval')
          ? l$requireLastPushApproval
          : const {},
      _$data.containsKey('lockBranch') ? l$lockBranch : const {},
      _$data.containsKey('lockAllowsFetchAndMerge')
          ? l$lockAllowsFetchAndMerge
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$UpdateBranchProtectionRuleInput(
    Input$UpdateBranchProtectionRuleInput instance,
    TRes Function(Input$UpdateBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$UpdateBranchProtectionRuleInput;

  factory CopyWith$Input$UpdateBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput;

  TRes call({
    String? clientMutationId,
    String? branchProtectionRuleId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresDeployments,
    List<String>? requiredDeploymentEnvironments,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
  });
  TRes requiredStatusChecks(
      Iterable<Input$RequiredStatusCheckInput>? Function(
              Iterable<
                  CopyWith$Input$RequiredStatusCheckInput<
                      Input$RequiredStatusCheckInput>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$UpdateBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBranchProtectionRuleInput _instance;

  final TRes Function(Input$UpdateBranchProtectionRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? branchProtectionRuleId = _undefined,
    Object? pattern = _undefined,
    Object? requiresApprovingReviews = _undefined,
    Object? requiredApprovingReviewCount = _undefined,
    Object? requiresCommitSignatures = _undefined,
    Object? requiresLinearHistory = _undefined,
    Object? blocksCreations = _undefined,
    Object? allowsForcePushes = _undefined,
    Object? allowsDeletions = _undefined,
    Object? isAdminEnforced = _undefined,
    Object? requiresStatusChecks = _undefined,
    Object? requiresStrictStatusChecks = _undefined,
    Object? requiresCodeOwnerReviews = _undefined,
    Object? dismissesStaleReviews = _undefined,
    Object? restrictsReviewDismissals = _undefined,
    Object? reviewDismissalActorIds = _undefined,
    Object? bypassPullRequestActorIds = _undefined,
    Object? bypassForcePushActorIds = _undefined,
    Object? restrictsPushes = _undefined,
    Object? pushActorIds = _undefined,
    Object? requiredStatusCheckContexts = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? requiresDeployments = _undefined,
    Object? requiredDeploymentEnvironments = _undefined,
    Object? requiresConversationResolution = _undefined,
    Object? requireLastPushApproval = _undefined,
    Object? lockBranch = _undefined,
    Object? lockAllowsFetchAndMerge = _undefined,
  }) =>
      _then(Input$UpdateBranchProtectionRuleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (branchProtectionRuleId != _undefined &&
            branchProtectionRuleId != null)
          'branchProtectionRuleId': (branchProtectionRuleId as String),
        if (pattern != _undefined) 'pattern': (pattern as String?),
        if (requiresApprovingReviews != _undefined)
          'requiresApprovingReviews': (requiresApprovingReviews as bool?),
        if (requiredApprovingReviewCount != _undefined)
          'requiredApprovingReviewCount':
              (requiredApprovingReviewCount as int?),
        if (requiresCommitSignatures != _undefined)
          'requiresCommitSignatures': (requiresCommitSignatures as bool?),
        if (requiresLinearHistory != _undefined)
          'requiresLinearHistory': (requiresLinearHistory as bool?),
        if (blocksCreations != _undefined)
          'blocksCreations': (blocksCreations as bool?),
        if (allowsForcePushes != _undefined)
          'allowsForcePushes': (allowsForcePushes as bool?),
        if (allowsDeletions != _undefined)
          'allowsDeletions': (allowsDeletions as bool?),
        if (isAdminEnforced != _undefined)
          'isAdminEnforced': (isAdminEnforced as bool?),
        if (requiresStatusChecks != _undefined)
          'requiresStatusChecks': (requiresStatusChecks as bool?),
        if (requiresStrictStatusChecks != _undefined)
          'requiresStrictStatusChecks': (requiresStrictStatusChecks as bool?),
        if (requiresCodeOwnerReviews != _undefined)
          'requiresCodeOwnerReviews': (requiresCodeOwnerReviews as bool?),
        if (dismissesStaleReviews != _undefined)
          'dismissesStaleReviews': (dismissesStaleReviews as bool?),
        if (restrictsReviewDismissals != _undefined)
          'restrictsReviewDismissals': (restrictsReviewDismissals as bool?),
        if (reviewDismissalActorIds != _undefined)
          'reviewDismissalActorIds': (reviewDismissalActorIds as List<String>?),
        if (bypassPullRequestActorIds != _undefined)
          'bypassPullRequestActorIds':
              (bypassPullRequestActorIds as List<String>?),
        if (bypassForcePushActorIds != _undefined)
          'bypassForcePushActorIds': (bypassForcePushActorIds as List<String>?),
        if (restrictsPushes != _undefined)
          'restrictsPushes': (restrictsPushes as bool?),
        if (pushActorIds != _undefined)
          'pushActorIds': (pushActorIds as List<String>?),
        if (requiredStatusCheckContexts != _undefined)
          'requiredStatusCheckContexts':
              (requiredStatusCheckContexts as List<String>?),
        if (requiredStatusChecks != _undefined)
          'requiredStatusChecks':
              (requiredStatusChecks as List<Input$RequiredStatusCheckInput>?),
        if (requiresDeployments != _undefined)
          'requiresDeployments': (requiresDeployments as bool?),
        if (requiredDeploymentEnvironments != _undefined)
          'requiredDeploymentEnvironments':
              (requiredDeploymentEnvironments as List<String>?),
        if (requiresConversationResolution != _undefined)
          'requiresConversationResolution':
              (requiresConversationResolution as bool?),
        if (requireLastPushApproval != _undefined)
          'requireLastPushApproval': (requireLastPushApproval as bool?),
        if (lockBranch != _undefined) 'lockBranch': (lockBranch as bool?),
        if (lockAllowsFetchAndMerge != _undefined)
          'lockAllowsFetchAndMerge': (lockAllowsFetchAndMerge as bool?),
      }));

  TRes requiredStatusChecks(
          Iterable<Input$RequiredStatusCheckInput>? Function(
                  Iterable<
                      CopyWith$Input$RequiredStatusCheckInput<
                          Input$RequiredStatusCheckInput>>?)
              _fn) =>
      call(
          requiredStatusChecks: _fn(_instance.requiredStatusChecks
              ?.map((e) => CopyWith$Input$RequiredStatusCheckInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? branchProtectionRuleId,
    String? pattern,
    bool? requiresApprovingReviews,
    int? requiredApprovingReviewCount,
    bool? requiresCommitSignatures,
    bool? requiresLinearHistory,
    bool? blocksCreations,
    bool? allowsForcePushes,
    bool? allowsDeletions,
    bool? isAdminEnforced,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? requiresCodeOwnerReviews,
    bool? dismissesStaleReviews,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
    List<String>? bypassPullRequestActorIds,
    List<String>? bypassForcePushActorIds,
    bool? restrictsPushes,
    List<String>? pushActorIds,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresDeployments,
    List<String>? requiredDeploymentEnvironments,
    bool? requiresConversationResolution,
    bool? requireLastPushApproval,
    bool? lockBranch,
    bool? lockAllowsFetchAndMerge,
  }) =>
      _res;

  requiredStatusChecks(_fn) => _res;
}

class Input$UpdateCheckRunInput {
  factory Input$UpdateCheckRunInput({
    String? clientMutationId,
    required String repositoryId,
    required String checkRunId,
    String? name,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
  }) =>
      Input$UpdateCheckRunInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'checkRunId': checkRunId,
        if (name != null) r'name': name,
        if (detailsUrl != null) r'detailsUrl': detailsUrl,
        if (externalId != null) r'externalId': externalId,
        if (status != null) r'status': status,
        if (startedAt != null) r'startedAt': startedAt,
        if (conclusion != null) r'conclusion': conclusion,
        if (completedAt != null) r'completedAt': completedAt,
        if (output != null) r'output': output,
        if (actions != null) r'actions': actions,
      });

  Input$UpdateCheckRunInput._(this._$data);

  factory Input$UpdateCheckRunInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$checkRunId = data['checkRunId'];
    result$data['checkRunId'] = (l$checkRunId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('detailsUrl')) {
      final l$detailsUrl = data['detailsUrl'];
      result$data['detailsUrl'] = (l$detailsUrl as String?);
    }
    if (data.containsKey('externalId')) {
      final l$externalId = data['externalId'];
      result$data['externalId'] = (l$externalId as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$RequestableCheckStatusState((l$status as String));
    }
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] = (l$startedAt as String?);
    }
    if (data.containsKey('conclusion')) {
      final l$conclusion = data['conclusion'];
      result$data['conclusion'] = l$conclusion == null
          ? null
          : fromJson$Enum$CheckConclusionState((l$conclusion as String));
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = (l$completedAt as String?);
    }
    if (data.containsKey('output')) {
      final l$output = data['output'];
      result$data['output'] = l$output == null
          ? null
          : Input$CheckRunOutput.fromJson((l$output as Map<String, dynamic>));
    }
    if (data.containsKey('actions')) {
      final l$actions = data['actions'];
      result$data['actions'] = (l$actions as List<dynamic>?)
          ?.map(
              (e) => Input$CheckRunAction.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$UpdateCheckRunInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String get checkRunId => (_$data['checkRunId'] as String);

  String? get name => (_$data['name'] as String?);

  String? get detailsUrl => (_$data['detailsUrl'] as String?);

  String? get externalId => (_$data['externalId'] as String?);

  Enum$RequestableCheckStatusState? get status =>
      (_$data['status'] as Enum$RequestableCheckStatusState?);

  String? get startedAt => (_$data['startedAt'] as String?);

  Enum$CheckConclusionState? get conclusion =>
      (_$data['conclusion'] as Enum$CheckConclusionState?);

  String? get completedAt => (_$data['completedAt'] as String?);

  Input$CheckRunOutput? get output =>
      (_$data['output'] as Input$CheckRunOutput?);

  List<Input$CheckRunAction>? get actions =>
      (_$data['actions'] as List<Input$CheckRunAction>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$checkRunId = checkRunId;
    result$data['checkRunId'] = l$checkRunId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('detailsUrl')) {
      final l$detailsUrl = detailsUrl;
      result$data['detailsUrl'] = l$detailsUrl;
    }
    if (_$data.containsKey('externalId')) {
      final l$externalId = externalId;
      result$data['externalId'] = l$externalId;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$RequestableCheckStatusState(l$status);
    }
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt;
    }
    if (_$data.containsKey('conclusion')) {
      final l$conclusion = conclusion;
      result$data['conclusion'] = l$conclusion == null
          ? null
          : toJson$Enum$CheckConclusionState(l$conclusion);
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt;
    }
    if (_$data.containsKey('output')) {
      final l$output = output;
      result$data['output'] = l$output?.toJson();
    }
    if (_$data.containsKey('actions')) {
      final l$actions = actions;
      result$data['actions'] = l$actions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateCheckRunInput<Input$UpdateCheckRunInput> get copyWith =>
      CopyWith$Input$UpdateCheckRunInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateCheckRunInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$checkRunId = checkRunId;
    final lOther$checkRunId = other.checkRunId;
    if (l$checkRunId != lOther$checkRunId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$detailsUrl = detailsUrl;
    final lOther$detailsUrl = other.detailsUrl;
    if (_$data.containsKey('detailsUrl') !=
        other._$data.containsKey('detailsUrl')) {
      return false;
    }
    if (l$detailsUrl != lOther$detailsUrl) {
      return false;
    }
    final l$externalId = externalId;
    final lOther$externalId = other.externalId;
    if (_$data.containsKey('externalId') !=
        other._$data.containsKey('externalId')) {
      return false;
    }
    if (l$externalId != lOther$externalId) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$conclusion = conclusion;
    final lOther$conclusion = other.conclusion;
    if (_$data.containsKey('conclusion') !=
        other._$data.containsKey('conclusion')) {
      return false;
    }
    if (l$conclusion != lOther$conclusion) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$output = output;
    final lOther$output = other.output;
    if (_$data.containsKey('output') != other._$data.containsKey('output')) {
      return false;
    }
    if (l$output != lOther$output) {
      return false;
    }
    final l$actions = actions;
    final lOther$actions = other.actions;
    if (_$data.containsKey('actions') != other._$data.containsKey('actions')) {
      return false;
    }
    if (l$actions != null && lOther$actions != null) {
      if (l$actions.length != lOther$actions.length) {
        return false;
      }
      for (int i = 0; i < l$actions.length; i++) {
        final l$actions$entry = l$actions[i];
        final lOther$actions$entry = lOther$actions[i];
        if (l$actions$entry != lOther$actions$entry) {
          return false;
        }
      }
    } else if (l$actions != lOther$actions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$checkRunId = checkRunId;
    final l$name = name;
    final l$detailsUrl = detailsUrl;
    final l$externalId = externalId;
    final l$status = status;
    final l$startedAt = startedAt;
    final l$conclusion = conclusion;
    final l$completedAt = completedAt;
    final l$output = output;
    final l$actions = actions;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$checkRunId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('detailsUrl') ? l$detailsUrl : const {},
      _$data.containsKey('externalId') ? l$externalId : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('conclusion') ? l$conclusion : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('output') ? l$output : const {},
      _$data.containsKey('actions')
          ? l$actions == null
              ? null
              : Object.hashAll(l$actions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateCheckRunInput<TRes> {
  factory CopyWith$Input$UpdateCheckRunInput(
    Input$UpdateCheckRunInput instance,
    TRes Function(Input$UpdateCheckRunInput) then,
  ) = _CopyWithImpl$Input$UpdateCheckRunInput;

  factory CopyWith$Input$UpdateCheckRunInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCheckRunInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? checkRunId,
    String? name,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
  });
  CopyWith$Input$CheckRunOutput<TRes> get output;
  TRes actions(
      Iterable<Input$CheckRunAction>? Function(
              Iterable<CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateCheckRunInput<TRes>
    implements CopyWith$Input$UpdateCheckRunInput<TRes> {
  _CopyWithImpl$Input$UpdateCheckRunInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCheckRunInput _instance;

  final TRes Function(Input$UpdateCheckRunInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? checkRunId = _undefined,
    Object? name = _undefined,
    Object? detailsUrl = _undefined,
    Object? externalId = _undefined,
    Object? status = _undefined,
    Object? startedAt = _undefined,
    Object? conclusion = _undefined,
    Object? completedAt = _undefined,
    Object? output = _undefined,
    Object? actions = _undefined,
  }) =>
      _then(Input$UpdateCheckRunInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (checkRunId != _undefined && checkRunId != null)
          'checkRunId': (checkRunId as String),
        if (name != _undefined) 'name': (name as String?),
        if (detailsUrl != _undefined) 'detailsUrl': (detailsUrl as String?),
        if (externalId != _undefined) 'externalId': (externalId as String?),
        if (status != _undefined)
          'status': (status as Enum$RequestableCheckStatusState?),
        if (startedAt != _undefined) 'startedAt': (startedAt as String?),
        if (conclusion != _undefined)
          'conclusion': (conclusion as Enum$CheckConclusionState?),
        if (completedAt != _undefined) 'completedAt': (completedAt as String?),
        if (output != _undefined) 'output': (output as Input$CheckRunOutput?),
        if (actions != _undefined)
          'actions': (actions as List<Input$CheckRunAction>?),
      }));

  CopyWith$Input$CheckRunOutput<TRes> get output {
    final local$output = _instance.output;
    return local$output == null
        ? CopyWith$Input$CheckRunOutput.stub(_then(_instance))
        : CopyWith$Input$CheckRunOutput(local$output, (e) => call(output: e));
  }

  TRes actions(
          Iterable<Input$CheckRunAction>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
              _fn) =>
      call(
          actions:
              _fn(_instance.actions?.map((e) => CopyWith$Input$CheckRunAction(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateCheckRunInput<TRes>
    implements CopyWith$Input$UpdateCheckRunInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCheckRunInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? checkRunId,
    String? name,
    String? detailsUrl,
    String? externalId,
    Enum$RequestableCheckStatusState? status,
    String? startedAt,
    Enum$CheckConclusionState? conclusion,
    String? completedAt,
    Input$CheckRunOutput? output,
    List<Input$CheckRunAction>? actions,
  }) =>
      _res;

  CopyWith$Input$CheckRunOutput<TRes> get output =>
      CopyWith$Input$CheckRunOutput.stub(_res);

  actions(_fn) => _res;
}

class Input$UpdateCheckSuitePreferencesInput {
  factory Input$UpdateCheckSuitePreferencesInput({
    String? clientMutationId,
    required String repositoryId,
    required List<Input$CheckSuiteAutoTriggerPreference> autoTriggerPreferences,
  }) =>
      Input$UpdateCheckSuitePreferencesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'autoTriggerPreferences': autoTriggerPreferences,
      });

  Input$UpdateCheckSuitePreferencesInput._(this._$data);

  factory Input$UpdateCheckSuitePreferencesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$autoTriggerPreferences = data['autoTriggerPreferences'];
    result$data['autoTriggerPreferences'] =
        (l$autoTriggerPreferences as List<dynamic>)
            .map((e) => Input$CheckSuiteAutoTriggerPreference.fromJson(
                (e as Map<String, dynamic>)))
            .toList();
    return Input$UpdateCheckSuitePreferencesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  List<Input$CheckSuiteAutoTriggerPreference> get autoTriggerPreferences =>
      (_$data['autoTriggerPreferences']
          as List<Input$CheckSuiteAutoTriggerPreference>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$autoTriggerPreferences = autoTriggerPreferences;
    result$data['autoTriggerPreferences'] =
        l$autoTriggerPreferences.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$UpdateCheckSuitePreferencesInput<
          Input$UpdateCheckSuitePreferencesInput>
      get copyWith => CopyWith$Input$UpdateCheckSuitePreferencesInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateCheckSuitePreferencesInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$autoTriggerPreferences = autoTriggerPreferences;
    final lOther$autoTriggerPreferences = other.autoTriggerPreferences;
    if (l$autoTriggerPreferences.length !=
        lOther$autoTriggerPreferences.length) {
      return false;
    }
    for (int i = 0; i < l$autoTriggerPreferences.length; i++) {
      final l$autoTriggerPreferences$entry = l$autoTriggerPreferences[i];
      final lOther$autoTriggerPreferences$entry =
          lOther$autoTriggerPreferences[i];
      if (l$autoTriggerPreferences$entry !=
          lOther$autoTriggerPreferences$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$autoTriggerPreferences = autoTriggerPreferences;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      Object.hashAll(l$autoTriggerPreferences.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  factory CopyWith$Input$UpdateCheckSuitePreferencesInput(
    Input$UpdateCheckSuitePreferencesInput instance,
    TRes Function(Input$UpdateCheckSuitePreferencesInput) then,
  ) = _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput;

  factory CopyWith$Input$UpdateCheckSuitePreferencesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    List<Input$CheckSuiteAutoTriggerPreference>? autoTriggerPreferences,
  });
  TRes autoTriggerPreferences(
      Iterable<Input$CheckSuiteAutoTriggerPreference> Function(
              Iterable<
                  CopyWith$Input$CheckSuiteAutoTriggerPreference<
                      Input$CheckSuiteAutoTriggerPreference>>)
          _fn);
}

class _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput<TRes>
    implements CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCheckSuitePreferencesInput _instance;

  final TRes Function(Input$UpdateCheckSuitePreferencesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? autoTriggerPreferences = _undefined,
  }) =>
      _then(Input$UpdateCheckSuitePreferencesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (autoTriggerPreferences != _undefined &&
            autoTriggerPreferences != null)
          'autoTriggerPreferences': (autoTriggerPreferences
              as List<Input$CheckSuiteAutoTriggerPreference>),
      }));

  TRes autoTriggerPreferences(
          Iterable<Input$CheckSuiteAutoTriggerPreference> Function(
                  Iterable<
                      CopyWith$Input$CheckSuiteAutoTriggerPreference<
                          Input$CheckSuiteAutoTriggerPreference>>)
              _fn) =>
      call(
          autoTriggerPreferences: _fn(_instance.autoTriggerPreferences
              .map((e) => CopyWith$Input$CheckSuiteAutoTriggerPreference(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput<TRes>
    implements CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    List<Input$CheckSuiteAutoTriggerPreference>? autoTriggerPreferences,
  }) =>
      _res;

  autoTriggerPreferences(_fn) => _res;
}

class Input$UpdateDiscussionCommentInput {
  factory Input$UpdateDiscussionCommentInput({
    String? clientMutationId,
    required String commentId,
    required String body,
  }) =>
      Input$UpdateDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'commentId': commentId,
        r'body': body,
      });

  Input$UpdateDiscussionCommentInput._(this._$data);

  factory Input$UpdateDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$commentId = data['commentId'];
    result$data['commentId'] = (l$commentId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$UpdateDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get commentId => (_$data['commentId'] as String);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$commentId = commentId;
    result$data['commentId'] = l$commentId;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$UpdateDiscussionCommentInput<
          Input$UpdateDiscussionCommentInput>
      get copyWith => CopyWith$Input$UpdateDiscussionCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateDiscussionCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$commentId = commentId;
    final lOther$commentId = other.commentId;
    if (l$commentId != lOther$commentId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$commentId = commentId;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$commentId,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  factory CopyWith$Input$UpdateDiscussionCommentInput(
    Input$UpdateDiscussionCommentInput instance,
    TRes Function(Input$UpdateDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateDiscussionCommentInput;

  factory CopyWith$Input$UpdateDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? commentId,
    String? body,
  });
}

class _CopyWithImpl$Input$UpdateDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDiscussionCommentInput _instance;

  final TRes Function(Input$UpdateDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? commentId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$UpdateDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (commentId != _undefined && commentId != null)
          'commentId': (commentId as String),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? commentId,
    String? body,
  }) =>
      _res;
}

class Input$UpdateDiscussionInput {
  factory Input$UpdateDiscussionInput({
    String? clientMutationId,
    required String discussionId,
    String? title,
    String? body,
    String? categoryId,
  }) =>
      Input$UpdateDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (categoryId != null) r'categoryId': categoryId,
      });

  Input$UpdateDiscussionInput._(this._$data);

  factory Input$UpdateDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('categoryId')) {
      final l$categoryId = data['categoryId'];
      result$data['categoryId'] = (l$categoryId as String?);
    }
    return Input$UpdateDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get discussionId => (_$data['discussionId'] as String);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  String? get categoryId => (_$data['categoryId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('categoryId')) {
      final l$categoryId = categoryId;
      result$data['categoryId'] = l$categoryId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateDiscussionInput<Input$UpdateDiscussionInput>
      get copyWith => CopyWith$Input$UpdateDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$categoryId = categoryId;
    final lOther$categoryId = other.categoryId;
    if (_$data.containsKey('categoryId') !=
        other._$data.containsKey('categoryId')) {
      return false;
    }
    if (l$categoryId != lOther$categoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$title = title;
    final l$body = body;
    final l$categoryId = categoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('categoryId') ? l$categoryId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateDiscussionInput<TRes> {
  factory CopyWith$Input$UpdateDiscussionInput(
    Input$UpdateDiscussionInput instance,
    TRes Function(Input$UpdateDiscussionInput) then,
  ) = _CopyWithImpl$Input$UpdateDiscussionInput;

  factory CopyWith$Input$UpdateDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? discussionId,
    String? title,
    String? body,
    String? categoryId,
  });
}

class _CopyWithImpl$Input$UpdateDiscussionInput<TRes>
    implements CopyWith$Input$UpdateDiscussionInput<TRes> {
  _CopyWithImpl$Input$UpdateDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDiscussionInput _instance;

  final TRes Function(Input$UpdateDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? categoryId = _undefined,
  }) =>
      _then(Input$UpdateDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (categoryId != _undefined) 'categoryId': (categoryId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateDiscussionInput<TRes>
    implements CopyWith$Input$UpdateDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? discussionId,
    String? title,
    String? body,
    String? categoryId,
  }) =>
      _res;
}

class Input$UpdateEnterpriseAdministratorRoleInput {
  factory Input$UpdateEnterpriseAdministratorRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
    required Enum$EnterpriseAdministratorRole role,
  }) =>
      Input$UpdateEnterpriseAdministratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
        r'role': role,
      });

  Input$UpdateEnterpriseAdministratorRoleInput._(this._$data);

  factory Input$UpdateEnterpriseAdministratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    final l$role = data['role'];
    result$data['role'] =
        fromJson$Enum$EnterpriseAdministratorRole((l$role as String));
    return Input$UpdateEnterpriseAdministratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get login => (_$data['login'] as String);

  Enum$EnterpriseAdministratorRole get role =>
      (_$data['role'] as Enum$EnterpriseAdministratorRole);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    final l$role = role;
    result$data['role'] = toJson$Enum$EnterpriseAdministratorRole(l$role);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<
          Input$UpdateEnterpriseAdministratorRoleInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseAdministratorRoleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseAdministratorRoleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
      l$role,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseAdministratorRoleInput(
    Input$UpdateEnterpriseAdministratorRoleInput instance,
    TRes Function(Input$UpdateEnterpriseAdministratorRoleInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput;

  factory CopyWith$Input$UpdateEnterpriseAdministratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    Enum$EnterpriseAdministratorRole? role,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseAdministratorRoleInput _instance;

  final TRes Function(Input$UpdateEnterpriseAdministratorRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseAdministratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (role != _undefined && role != null)
          'role': (role as Enum$EnterpriseAdministratorRole),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    Enum$EnterpriseAdministratorRole? role,
  }) =>
      _res;
}

class Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  factory Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
  }) =>
      Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
        if (policyValue != null) r'policyValue': policyValue,
      });

  Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    if (data.containsKey('policyValue')) {
      final l$policyValue = data['policyValue'];
      result$data['policyValue'] = l$policyValue == null
          ? null
          : fromJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
              (l$policyValue as String));
    }
    return Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? get policyValue =>
      (_$data['policyValue']
          as Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    if (_$data.containsKey('policyValue')) {
      final l$policyValue = policyValue;
      result$data['policyValue'] = l$policyValue == null
          ? null
          : toJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
              l$policyValue);
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
          Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$policyValue = policyValue;
    final lOther$policyValue = other.policyValue;
    if (_$data.containsKey('policyValue') !=
        other._$data.containsKey('policyValue')) {
      return false;
    }
    if (l$policyValue != lOther$policyValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$policyValue = policyValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
      _$data.containsKey('policyValue') ? l$policyValue : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
    Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;

  factory CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? policyValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
        if (policyValue != _undefined)
          'policyValue': (policyValue
              as Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  factory Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseDefaultRepositoryPermissionSettingValue
        settingValue,
  }) =>
      Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._(this._$data);

  factory Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseDefaultRepositoryPermissionSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseDefaultRepositoryPermissionSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
            l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
          Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
    Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput instance,
    TRes Function(Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput;

  factory CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput _instance;

  final TRes Function(
      Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$EnterpriseDefaultRepositoryPermissionSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseDeployKeySettingInput {
  factory Input$UpdateEnterpriseDeployKeySettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseDeployKeySettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseDeployKeySettingInput._(this._$data);

  factory Input$UpdateEnterpriseDeployKeySettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseDeployKeySettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseDeployKeySettingInput<
          Input$UpdateEnterpriseDeployKeySettingInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseDeployKeySettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseDeployKeySettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseDeployKeySettingInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseDeployKeySettingInput(
    Input$UpdateEnterpriseDeployKeySettingInput instance,
    TRes Function(Input$UpdateEnterpriseDeployKeySettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseDeployKeySettingInput;

  factory CopyWith$Input$UpdateEnterpriseDeployKeySettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseDeployKeySettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseDeployKeySettingInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseDeployKeySettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseDeployKeySettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseDeployKeySettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseDeployKeySettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseDeployKeySettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseDeployKeySettingInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseDeployKeySettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseDeployKeySettingInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  factory Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
    Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
        instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
      _instance;

  final TRes Function(
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
              ._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  factory Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreateInternalRepositories,
  }) =>
      Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        if (settingValue != null) r'settingValue': settingValue,
        if (membersCanCreateRepositoriesPolicyEnabled != null)
          r'membersCanCreateRepositoriesPolicyEnabled':
              membersCanCreateRepositoriesPolicyEnabled,
        if (membersCanCreatePublicRepositories != null)
          r'membersCanCreatePublicRepositories':
              membersCanCreatePublicRepositories,
        if (membersCanCreatePrivateRepositories != null)
          r'membersCanCreatePrivateRepositories':
              membersCanCreatePrivateRepositories,
        if (membersCanCreateInternalRepositories != null)
          r'membersCanCreateInternalRepositories':
              membersCanCreateInternalRepositories,
      });

  Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('settingValue')) {
      final l$settingValue = data['settingValue'];
      result$data['settingValue'] = l$settingValue == null
          ? null
          : fromJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
              (l$settingValue as String));
    }
    if (data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      final l$membersCanCreateRepositoriesPolicyEnabled =
          data['membersCanCreateRepositoriesPolicyEnabled'];
      result$data['membersCanCreateRepositoriesPolicyEnabled'] =
          (l$membersCanCreateRepositoriesPolicyEnabled as bool?);
    }
    if (data.containsKey('membersCanCreatePublicRepositories')) {
      final l$membersCanCreatePublicRepositories =
          data['membersCanCreatePublicRepositories'];
      result$data['membersCanCreatePublicRepositories'] =
          (l$membersCanCreatePublicRepositories as bool?);
    }
    if (data.containsKey('membersCanCreatePrivateRepositories')) {
      final l$membersCanCreatePrivateRepositories =
          data['membersCanCreatePrivateRepositories'];
      result$data['membersCanCreatePrivateRepositories'] =
          (l$membersCanCreatePrivateRepositories as bool?);
    }
    if (data.containsKey('membersCanCreateInternalRepositories')) {
      final l$membersCanCreateInternalRepositories =
          data['membersCanCreateInternalRepositories'];
      result$data['membersCanCreateInternalRepositories'] =
          (l$membersCanCreateInternalRepositories as bool?);
    }
    return Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseMembersCanCreateRepositoriesSettingValue?);

  bool? get membersCanCreateRepositoriesPolicyEnabled =>
      (_$data['membersCanCreateRepositoriesPolicyEnabled'] as bool?);

  bool? get membersCanCreatePublicRepositories =>
      (_$data['membersCanCreatePublicRepositories'] as bool?);

  bool? get membersCanCreatePrivateRepositories =>
      (_$data['membersCanCreatePrivateRepositories'] as bool?);

  bool? get membersCanCreateInternalRepositories =>
      (_$data['membersCanCreateInternalRepositories'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('settingValue')) {
      final l$settingValue = settingValue;
      result$data['settingValue'] = l$settingValue == null
          ? null
          : toJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
              l$settingValue);
    }
    if (_$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      final l$membersCanCreateRepositoriesPolicyEnabled =
          membersCanCreateRepositoriesPolicyEnabled;
      result$data['membersCanCreateRepositoriesPolicyEnabled'] =
          l$membersCanCreateRepositoriesPolicyEnabled;
    }
    if (_$data.containsKey('membersCanCreatePublicRepositories')) {
      final l$membersCanCreatePublicRepositories =
          membersCanCreatePublicRepositories;
      result$data['membersCanCreatePublicRepositories'] =
          l$membersCanCreatePublicRepositories;
    }
    if (_$data.containsKey('membersCanCreatePrivateRepositories')) {
      final l$membersCanCreatePrivateRepositories =
          membersCanCreatePrivateRepositories;
      result$data['membersCanCreatePrivateRepositories'] =
          l$membersCanCreatePrivateRepositories;
    }
    if (_$data.containsKey('membersCanCreateInternalRepositories')) {
      final l$membersCanCreateInternalRepositories =
          membersCanCreateInternalRepositories;
      result$data['membersCanCreateInternalRepositories'] =
          l$membersCanCreateInternalRepositories;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
          Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (_$data.containsKey('settingValue') !=
        other._$data.containsKey('settingValue')) {
      return false;
    }
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    final l$membersCanCreateRepositoriesPolicyEnabled =
        membersCanCreateRepositoriesPolicyEnabled;
    final lOther$membersCanCreateRepositoriesPolicyEnabled =
        other.membersCanCreateRepositoriesPolicyEnabled;
    if (_$data.containsKey('membersCanCreateRepositoriesPolicyEnabled') !=
        other._$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      return false;
    }
    if (l$membersCanCreateRepositoriesPolicyEnabled !=
        lOther$membersCanCreateRepositoriesPolicyEnabled) {
      return false;
    }
    final l$membersCanCreatePublicRepositories =
        membersCanCreatePublicRepositories;
    final lOther$membersCanCreatePublicRepositories =
        other.membersCanCreatePublicRepositories;
    if (_$data.containsKey('membersCanCreatePublicRepositories') !=
        other._$data.containsKey('membersCanCreatePublicRepositories')) {
      return false;
    }
    if (l$membersCanCreatePublicRepositories !=
        lOther$membersCanCreatePublicRepositories) {
      return false;
    }
    final l$membersCanCreatePrivateRepositories =
        membersCanCreatePrivateRepositories;
    final lOther$membersCanCreatePrivateRepositories =
        other.membersCanCreatePrivateRepositories;
    if (_$data.containsKey('membersCanCreatePrivateRepositories') !=
        other._$data.containsKey('membersCanCreatePrivateRepositories')) {
      return false;
    }
    if (l$membersCanCreatePrivateRepositories !=
        lOther$membersCanCreatePrivateRepositories) {
      return false;
    }
    final l$membersCanCreateInternalRepositories =
        membersCanCreateInternalRepositories;
    final lOther$membersCanCreateInternalRepositories =
        other.membersCanCreateInternalRepositories;
    if (_$data.containsKey('membersCanCreateInternalRepositories') !=
        other._$data.containsKey('membersCanCreateInternalRepositories')) {
      return false;
    }
    if (l$membersCanCreateInternalRepositories !=
        lOther$membersCanCreateInternalRepositories) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    final l$membersCanCreateRepositoriesPolicyEnabled =
        membersCanCreateRepositoriesPolicyEnabled;
    final l$membersCanCreatePublicRepositories =
        membersCanCreatePublicRepositories;
    final l$membersCanCreatePrivateRepositories =
        membersCanCreatePrivateRepositories;
    final l$membersCanCreateInternalRepositories =
        membersCanCreateInternalRepositories;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      _$data.containsKey('settingValue') ? l$settingValue : const {},
      _$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')
          ? l$membersCanCreateRepositoriesPolicyEnabled
          : const {},
      _$data.containsKey('membersCanCreatePublicRepositories')
          ? l$membersCanCreatePublicRepositories
          : const {},
      _$data.containsKey('membersCanCreatePrivateRepositories')
          ? l$membersCanCreatePrivateRepositories
          : const {},
      _$data.containsKey('membersCanCreateInternalRepositories')
          ? l$membersCanCreateInternalRepositories
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
    Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreateInternalRepositories,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
    Object? membersCanCreateRepositoriesPolicyEnabled = _undefined,
    Object? membersCanCreatePublicRepositories = _undefined,
    Object? membersCanCreatePrivateRepositories = _undefined,
    Object? membersCanCreateInternalRepositories = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined)
          'settingValue': (settingValue
              as Enum$EnterpriseMembersCanCreateRepositoriesSettingValue?),
        if (membersCanCreateRepositoriesPolicyEnabled != _undefined)
          'membersCanCreateRepositoriesPolicyEnabled':
              (membersCanCreateRepositoriesPolicyEnabled as bool?),
        if (membersCanCreatePublicRepositories != _undefined)
          'membersCanCreatePublicRepositories':
              (membersCanCreatePublicRepositories as bool?),
        if (membersCanCreatePrivateRepositories != _undefined)
          'membersCanCreatePrivateRepositories':
              (membersCanCreatePrivateRepositories as bool?),
        if (membersCanCreateInternalRepositories != _undefined)
          'membersCanCreateInternalRepositories':
              (membersCanCreateInternalRepositories as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreateInternalRepositories,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  factory Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
          Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
    Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput instance,
    TRes Function(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  factory Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
          Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
    Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  factory Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
          Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
    Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  factory Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseMembersCanMakePurchasesSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseMembersCanMakePurchasesSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseMembersCanMakePurchasesSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
            l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
          Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
    Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput instance,
    TRes Function(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseMembersCanMakePurchasesSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$EnterpriseMembersCanMakePurchasesSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseMembersCanMakePurchasesSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  factory Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
          Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
    Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
        instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
      _instance;

  final TRes Function(
          Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
          ._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  factory Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
          Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
    Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseOrganizationProjectsSettingInput {
  factory Input$UpdateEnterpriseOrganizationProjectsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseOrganizationProjectsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseOrganizationProjectsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseOrganizationProjectsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseOrganizationProjectsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
          Input$UpdateEnterpriseOrganizationProjectsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseOrganizationProjectsSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
    Input$UpdateEnterpriseOrganizationProjectsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseOrganizationProjectsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseOrganizationProjectsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseOrganizationProjectsSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseOrganizationProjectsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseOwnerOrganizationRoleInput {
  factory Input$UpdateEnterpriseOwnerOrganizationRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String organizationId,
    required Enum$RoleInOrganization organizationRole,
  }) =>
      Input$UpdateEnterpriseOwnerOrganizationRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
        r'organizationRole': organizationRole,
      });

  Input$UpdateEnterpriseOwnerOrganizationRoleInput._(this._$data);

  factory Input$UpdateEnterpriseOwnerOrganizationRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$organizationRole = data['organizationRole'];
    result$data['organizationRole'] =
        fromJson$Enum$RoleInOrganization((l$organizationRole as String));
    return Input$UpdateEnterpriseOwnerOrganizationRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String get organizationId => (_$data['organizationId'] as String);

  Enum$RoleInOrganization get organizationRole =>
      (_$data['organizationRole'] as Enum$RoleInOrganization);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$organizationRole = organizationRole;
    result$data['organizationRole'] =
        toJson$Enum$RoleInOrganization(l$organizationRole);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<
          Input$UpdateEnterpriseOwnerOrganizationRoleInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseOwnerOrganizationRoleInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$organizationRole = organizationRole;
    final lOther$organizationRole = other.organizationRole;
    if (l$organizationRole != lOther$organizationRole) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    final l$organizationRole = organizationRole;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$organizationId,
      l$organizationRole,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
    Input$UpdateEnterpriseOwnerOrganizationRoleInput instance,
    TRes Function(Input$UpdateEnterpriseOwnerOrganizationRoleInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput;

  factory CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    Enum$RoleInOrganization? organizationRole,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseOwnerOrganizationRoleInput _instance;

  final TRes Function(Input$UpdateEnterpriseOwnerOrganizationRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
    Object? organizationRole = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseOwnerOrganizationRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (organizationRole != _undefined && organizationRole != null)
          'organizationRole': (organizationRole as Enum$RoleInOrganization),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    Enum$RoleInOrganization? organizationRole,
  }) =>
      _res;
}

class Input$UpdateEnterpriseProfileInput {
  factory Input$UpdateEnterpriseProfileInput({
    String? clientMutationId,
    required String enterpriseId,
    String? name,
    String? description,
    String? websiteUrl,
    String? location,
    String? securityContactEmail,
  }) =>
      Input$UpdateEnterpriseProfileInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (websiteUrl != null) r'websiteUrl': websiteUrl,
        if (location != null) r'location': location,
        if (securityContactEmail != null)
          r'securityContactEmail': securityContactEmail,
      });

  Input$UpdateEnterpriseProfileInput._(this._$data);

  factory Input$UpdateEnterpriseProfileInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('websiteUrl')) {
      final l$websiteUrl = data['websiteUrl'];
      result$data['websiteUrl'] = (l$websiteUrl as String?);
    }
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('securityContactEmail')) {
      final l$securityContactEmail = data['securityContactEmail'];
      result$data['securityContactEmail'] = (l$securityContactEmail as String?);
    }
    return Input$UpdateEnterpriseProfileInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get websiteUrl => (_$data['websiteUrl'] as String?);

  String? get location => (_$data['location'] as String?);

  String? get securityContactEmail =>
      (_$data['securityContactEmail'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('websiteUrl')) {
      final l$websiteUrl = websiteUrl;
      result$data['websiteUrl'] = l$websiteUrl;
    }
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('securityContactEmail')) {
      final l$securityContactEmail = securityContactEmail;
      result$data['securityContactEmail'] = l$securityContactEmail;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseProfileInput<
          Input$UpdateEnterpriseProfileInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseProfileInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseProfileInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$websiteUrl = websiteUrl;
    final lOther$websiteUrl = other.websiteUrl;
    if (_$data.containsKey('websiteUrl') !=
        other._$data.containsKey('websiteUrl')) {
      return false;
    }
    if (l$websiteUrl != lOther$websiteUrl) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$securityContactEmail = securityContactEmail;
    final lOther$securityContactEmail = other.securityContactEmail;
    if (_$data.containsKey('securityContactEmail') !=
        other._$data.containsKey('securityContactEmail')) {
      return false;
    }
    if (l$securityContactEmail != lOther$securityContactEmail) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$name = name;
    final l$description = description;
    final l$websiteUrl = websiteUrl;
    final l$location = location;
    final l$securityContactEmail = securityContactEmail;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('websiteUrl') ? l$websiteUrl : const {},
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('securityContactEmail')
          ? l$securityContactEmail
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseProfileInput(
    Input$UpdateEnterpriseProfileInput instance,
    TRes Function(Input$UpdateEnterpriseProfileInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseProfileInput;

  factory CopyWith$Input$UpdateEnterpriseProfileInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? name,
    String? description,
    String? websiteUrl,
    String? location,
    String? securityContactEmail,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseProfileInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseProfileInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseProfileInput _instance;

  final TRes Function(Input$UpdateEnterpriseProfileInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? websiteUrl = _undefined,
    Object? location = _undefined,
    Object? securityContactEmail = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseProfileInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (websiteUrl != _undefined) 'websiteUrl': (websiteUrl as String?),
        if (location != _undefined) 'location': (location as String?),
        if (securityContactEmail != _undefined)
          'securityContactEmail': (securityContactEmail as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? name,
    String? description,
    String? websiteUrl,
    String? location,
    String? securityContactEmail,
  }) =>
      _res;
}

class Input$UpdateEnterpriseRepositoryProjectsSettingInput {
  factory Input$UpdateEnterpriseRepositoryProjectsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseRepositoryProjectsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseRepositoryProjectsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseRepositoryProjectsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseRepositoryProjectsSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
          Input$UpdateEnterpriseRepositoryProjectsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseRepositoryProjectsSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
    Input$UpdateEnterpriseRepositoryProjectsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseRepositoryProjectsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseRepositoryProjectsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseRepositoryProjectsSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseRepositoryProjectsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseTeamDiscussionsSettingInput {
  factory Input$UpdateEnterpriseTeamDiscussionsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseTeamDiscussionsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseTeamDiscussionsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseTeamDiscussionsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseTeamDiscussionsSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<
          Input$UpdateEnterpriseTeamDiscussionsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnterpriseTeamDiscussionsSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
    Input$UpdateEnterpriseTeamDiscussionsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseTeamDiscussionsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseTeamDiscussionsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseTeamDiscussionsSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseTeamDiscussionsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput {
  factory Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseDisallowedMethodsSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput
          ._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseDisallowedMethodsSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseDisallowedMethodsSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseDisallowedMethodsSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseDisallowedMethodsSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput<
          Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput(
    Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput
        instance,
    TRes Function(
            Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseDisallowedMethodsSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput
      _instance;

  final TRes Function(
          Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput
              ._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseDisallowedMethodsSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationDisallowedMethodsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseDisallowedMethodsSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  factory Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledSettingValue((l$settingValue as String));
    return Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get enterpriseId => (_$data['enterpriseId'] as String);

  Enum$EnterpriseEnabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
          Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
    Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;

  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue as Enum$EnterpriseEnabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnvironmentInput {
  factory Input$UpdateEnvironmentInput({
    String? clientMutationId,
    required String environmentId,
    int? waitTimer,
    List<String>? reviewers,
    bool? preventSelfReview,
  }) =>
      Input$UpdateEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'environmentId': environmentId,
        if (waitTimer != null) r'waitTimer': waitTimer,
        if (reviewers != null) r'reviewers': reviewers,
        if (preventSelfReview != null) r'preventSelfReview': preventSelfReview,
      });

  Input$UpdateEnvironmentInput._(this._$data);

  factory Input$UpdateEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$environmentId = data['environmentId'];
    result$data['environmentId'] = (l$environmentId as String);
    if (data.containsKey('waitTimer')) {
      final l$waitTimer = data['waitTimer'];
      result$data['waitTimer'] = (l$waitTimer as int?);
    }
    if (data.containsKey('reviewers')) {
      final l$reviewers = data['reviewers'];
      result$data['reviewers'] =
          (l$reviewers as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('preventSelfReview')) {
      final l$preventSelfReview = data['preventSelfReview'];
      result$data['preventSelfReview'] = (l$preventSelfReview as bool?);
    }
    return Input$UpdateEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get environmentId => (_$data['environmentId'] as String);

  int? get waitTimer => (_$data['waitTimer'] as int?);

  List<String>? get reviewers => (_$data['reviewers'] as List<String>?);

  bool? get preventSelfReview => (_$data['preventSelfReview'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$environmentId = environmentId;
    result$data['environmentId'] = l$environmentId;
    if (_$data.containsKey('waitTimer')) {
      final l$waitTimer = waitTimer;
      result$data['waitTimer'] = l$waitTimer;
    }
    if (_$data.containsKey('reviewers')) {
      final l$reviewers = reviewers;
      result$data['reviewers'] = l$reviewers?.map((e) => e).toList();
    }
    if (_$data.containsKey('preventSelfReview')) {
      final l$preventSelfReview = preventSelfReview;
      result$data['preventSelfReview'] = l$preventSelfReview;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnvironmentInput<Input$UpdateEnvironmentInput>
      get copyWith => CopyWith$Input$UpdateEnvironmentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateEnvironmentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$environmentId = environmentId;
    final lOther$environmentId = other.environmentId;
    if (l$environmentId != lOther$environmentId) {
      return false;
    }
    final l$waitTimer = waitTimer;
    final lOther$waitTimer = other.waitTimer;
    if (_$data.containsKey('waitTimer') !=
        other._$data.containsKey('waitTimer')) {
      return false;
    }
    if (l$waitTimer != lOther$waitTimer) {
      return false;
    }
    final l$reviewers = reviewers;
    final lOther$reviewers = other.reviewers;
    if (_$data.containsKey('reviewers') !=
        other._$data.containsKey('reviewers')) {
      return false;
    }
    if (l$reviewers != null && lOther$reviewers != null) {
      if (l$reviewers.length != lOther$reviewers.length) {
        return false;
      }
      for (int i = 0; i < l$reviewers.length; i++) {
        final l$reviewers$entry = l$reviewers[i];
        final lOther$reviewers$entry = lOther$reviewers[i];
        if (l$reviewers$entry != lOther$reviewers$entry) {
          return false;
        }
      }
    } else if (l$reviewers != lOther$reviewers) {
      return false;
    }
    final l$preventSelfReview = preventSelfReview;
    final lOther$preventSelfReview = other.preventSelfReview;
    if (_$data.containsKey('preventSelfReview') !=
        other._$data.containsKey('preventSelfReview')) {
      return false;
    }
    if (l$preventSelfReview != lOther$preventSelfReview) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$environmentId = environmentId;
    final l$waitTimer = waitTimer;
    final l$reviewers = reviewers;
    final l$preventSelfReview = preventSelfReview;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$environmentId,
      _$data.containsKey('waitTimer') ? l$waitTimer : const {},
      _$data.containsKey('reviewers')
          ? l$reviewers == null
              ? null
              : Object.hashAll(l$reviewers.map((v) => v))
          : const {},
      _$data.containsKey('preventSelfReview') ? l$preventSelfReview : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnvironmentInput<TRes> {
  factory CopyWith$Input$UpdateEnvironmentInput(
    Input$UpdateEnvironmentInput instance,
    TRes Function(Input$UpdateEnvironmentInput) then,
  ) = _CopyWithImpl$Input$UpdateEnvironmentInput;

  factory CopyWith$Input$UpdateEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? environmentId,
    int? waitTimer,
    List<String>? reviewers,
    bool? preventSelfReview,
  });
}

class _CopyWithImpl$Input$UpdateEnvironmentInput<TRes>
    implements CopyWith$Input$UpdateEnvironmentInput<TRes> {
  _CopyWithImpl$Input$UpdateEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnvironmentInput _instance;

  final TRes Function(Input$UpdateEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? environmentId = _undefined,
    Object? waitTimer = _undefined,
    Object? reviewers = _undefined,
    Object? preventSelfReview = _undefined,
  }) =>
      _then(Input$UpdateEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (environmentId != _undefined && environmentId != null)
          'environmentId': (environmentId as String),
        if (waitTimer != _undefined) 'waitTimer': (waitTimer as int?),
        if (reviewers != _undefined) 'reviewers': (reviewers as List<String>?),
        if (preventSelfReview != _undefined)
          'preventSelfReview': (preventSelfReview as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnvironmentInput<TRes>
    implements CopyWith$Input$UpdateEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? environmentId,
    int? waitTimer,
    List<String>? reviewers,
    bool? preventSelfReview,
  }) =>
      _res;
}

class Input$UpdateIpAllowListEnabledSettingInput {
  factory Input$UpdateIpAllowListEnabledSettingInput({
    String? clientMutationId,
    required String ownerId,
    required Enum$IpAllowListEnabledSettingValue settingValue,
  }) =>
      Input$UpdateIpAllowListEnabledSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'settingValue': settingValue,
      });

  Input$UpdateIpAllowListEnabledSettingInput._(this._$data);

  factory Input$UpdateIpAllowListEnabledSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] = fromJson$Enum$IpAllowListEnabledSettingValue(
        (l$settingValue as String));
    return Input$UpdateIpAllowListEnabledSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  Enum$IpAllowListEnabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$IpAllowListEnabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$IpAllowListEnabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListEnabledSettingInput<
          Input$UpdateIpAllowListEnabledSettingInput>
      get copyWith => CopyWith$Input$UpdateIpAllowListEnabledSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateIpAllowListEnabledSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  factory CopyWith$Input$UpdateIpAllowListEnabledSettingInput(
    Input$UpdateIpAllowListEnabledSettingInput instance,
    TRes Function(Input$UpdateIpAllowListEnabledSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput;

  factory CopyWith$Input$UpdateIpAllowListEnabledSettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListEnabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListEnabledSettingInput _instance;

  final TRes Function(Input$UpdateIpAllowListEnabledSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListEnabledSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue as Enum$IpAllowListEnabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListEnabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateIpAllowListEntryInput {
  factory Input$UpdateIpAllowListEntryInput({
    String? clientMutationId,
    required String ipAllowListEntryId,
    required String allowListValue,
    String? name,
    required bool isActive,
  }) =>
      Input$UpdateIpAllowListEntryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ipAllowListEntryId': ipAllowListEntryId,
        r'allowListValue': allowListValue,
        if (name != null) r'name': name,
        r'isActive': isActive,
      });

  Input$UpdateIpAllowListEntryInput._(this._$data);

  factory Input$UpdateIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ipAllowListEntryId = data['ipAllowListEntryId'];
    result$data['ipAllowListEntryId'] = (l$ipAllowListEntryId as String);
    final l$allowListValue = data['allowListValue'];
    result$data['allowListValue'] = (l$allowListValue as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    return Input$UpdateIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ipAllowListEntryId => (_$data['ipAllowListEntryId'] as String);

  String get allowListValue => (_$data['allowListValue'] as String);

  String? get name => (_$data['name'] as String?);

  bool get isActive => (_$data['isActive'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    result$data['ipAllowListEntryId'] = l$ipAllowListEntryId;
    final l$allowListValue = allowListValue;
    result$data['allowListValue'] = l$allowListValue;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListEntryInput<Input$UpdateIpAllowListEntryInput>
      get copyWith => CopyWith$Input$UpdateIpAllowListEntryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateIpAllowListEntryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final lOther$ipAllowListEntryId = other.ipAllowListEntryId;
    if (l$ipAllowListEntryId != lOther$ipAllowListEntryId) {
      return false;
    }
    final l$allowListValue = allowListValue;
    final lOther$allowListValue = other.allowListValue;
    if (l$allowListValue != lOther$allowListValue) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final l$allowListValue = allowListValue;
    final l$name = name;
    final l$isActive = isActive;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ipAllowListEntryId,
      l$allowListValue,
      _$data.containsKey('name') ? l$name : const {},
      l$isActive,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$UpdateIpAllowListEntryInput(
    Input$UpdateIpAllowListEntryInput instance,
    TRes Function(Input$UpdateIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListEntryInput;

  factory CopyWith$Input$UpdateIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput;

  TRes call({
    String? clientMutationId,
    String? ipAllowListEntryId,
    String? allowListValue,
    String? name,
    bool? isActive,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListEntryInput _instance;

  final TRes Function(Input$UpdateIpAllowListEntryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ipAllowListEntryId = _undefined,
    Object? allowListValue = _undefined,
    Object? name = _undefined,
    Object? isActive = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListEntryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ipAllowListEntryId != _undefined && ipAllowListEntryId != null)
          'ipAllowListEntryId': (ipAllowListEntryId as String),
        if (allowListValue != _undefined && allowListValue != null)
          'allowListValue': (allowListValue as String),
        if (name != _undefined) 'name': (name as String?),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ipAllowListEntryId,
    String? allowListValue,
    String? name,
    bool? isActive,
  }) =>
      _res;
}

class Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput {
  factory Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput({
    String? clientMutationId,
    required String ownerId,
    required Enum$IpAllowListForInstalledAppsEnabledSettingValue settingValue,
  }) =>
      Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'settingValue': settingValue,
      });

  Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._(this._$data);

  factory Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  Enum$IpAllowListForInstalledAppsEnabledSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$IpAllowListForInstalledAppsEnabledSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
            l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
          Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
    Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput instance,
    TRes Function(Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput;

  factory CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListForInstalledAppsEnabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput _instance;

  final TRes Function(
      Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$IpAllowListForInstalledAppsEnabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListForInstalledAppsEnabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateIssueCommentInput {
  factory Input$UpdateIssueCommentInput({
    String? clientMutationId,
    required String id,
    required String body,
  }) =>
      Input$UpdateIssueCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'body': body,
      });

  Input$UpdateIssueCommentInput._(this._$data);

  factory Input$UpdateIssueCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$UpdateIssueCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$UpdateIssueCommentInput<Input$UpdateIssueCommentInput>
      get copyWith => CopyWith$Input$UpdateIssueCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateIssueCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueCommentInput<TRes> {
  factory CopyWith$Input$UpdateIssueCommentInput(
    Input$UpdateIssueCommentInput instance,
    TRes Function(Input$UpdateIssueCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueCommentInput;

  factory CopyWith$Input$UpdateIssueCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? body,
  });
}

class _CopyWithImpl$Input$UpdateIssueCommentInput<TRes>
    implements CopyWith$Input$UpdateIssueCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueCommentInput _instance;

  final TRes Function(Input$UpdateIssueCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$UpdateIssueCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueCommentInput<TRes>
    implements CopyWith$Input$UpdateIssueCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? body,
  }) =>
      _res;
}

class Input$UpdateIssueInput {
  factory Input$UpdateIssueInput({
    String? clientMutationId,
    required String id,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    Enum$IssueState? state,
    List<String>? projectIds,
    String? issueTypeId,
  }) =>
      Input$UpdateIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (labelIds != null) r'labelIds': labelIds,
        if (state != null) r'state': state,
        if (projectIds != null) r'projectIds': projectIds,
        if (issueTypeId != null) r'issueTypeId': issueTypeId,
      });

  Input$UpdateIssueInput._(this._$data);

  factory Input$UpdateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$IssueState((l$state as String));
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('issueTypeId')) {
      final l$issueTypeId = data['issueTypeId'];
      result$data['issueTypeId'] = (l$issueTypeId as String?);
    }
    return Input$UpdateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);

  String? get milestoneId => (_$data['milestoneId'] as String?);

  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);

  Enum$IssueState? get state => (_$data['state'] as Enum$IssueState?);

  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);

  String? get issueTypeId => (_$data['issueTypeId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$IssueState(l$state);
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('issueTypeId')) {
      final l$issueTypeId = issueTypeId;
      result$data['issueTypeId'] = l$issueTypeId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIssueInput<Input$UpdateIssueInput> get copyWith =>
      CopyWith$Input$UpdateIssueInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateIssueInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$issueTypeId = issueTypeId;
    final lOther$issueTypeId = other.issueTypeId;
    if (_$data.containsKey('issueTypeId') !=
        other._$data.containsKey('issueTypeId')) {
      return false;
    }
    if (l$issueTypeId != lOther$issueTypeId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    final l$milestoneId = milestoneId;
    final l$labelIds = labelIds;
    final l$state = state;
    final l$projectIds = projectIds;
    final l$issueTypeId = issueTypeId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      _$data.containsKey('issueTypeId') ? l$issueTypeId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueInput<TRes> {
  factory CopyWith$Input$UpdateIssueInput(
    Input$UpdateIssueInput instance,
    TRes Function(Input$UpdateIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueInput;

  factory CopyWith$Input$UpdateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    Enum$IssueState? state,
    List<String>? projectIds,
    String? issueTypeId,
  });
}

class _CopyWithImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueInput _instance;

  final TRes Function(Input$UpdateIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
    Object? milestoneId = _undefined,
    Object? labelIds = _undefined,
    Object? state = _undefined,
    Object? projectIds = _undefined,
    Object? issueTypeId = _undefined,
  }) =>
      _then(Input$UpdateIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (state != _undefined) 'state': (state as Enum$IssueState?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (issueTypeId != _undefined) 'issueTypeId': (issueTypeId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? title,
    String? body,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    Enum$IssueState? state,
    List<String>? projectIds,
    String? issueTypeId,
  }) =>
      _res;
}

class Input$UpdateIssueIssueTypeInput {
  factory Input$UpdateIssueIssueTypeInput({
    String? clientMutationId,
    String? issueTypeId,
    required String issueId,
  }) =>
      Input$UpdateIssueIssueTypeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (issueTypeId != null) r'issueTypeId': issueTypeId,
        r'issueId': issueId,
      });

  Input$UpdateIssueIssueTypeInput._(this._$data);

  factory Input$UpdateIssueIssueTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('issueTypeId')) {
      final l$issueTypeId = data['issueTypeId'];
      result$data['issueTypeId'] = (l$issueTypeId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$UpdateIssueIssueTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get issueTypeId => (_$data['issueTypeId'] as String?);

  String get issueId => (_$data['issueId'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('issueTypeId')) {
      final l$issueTypeId = issueTypeId;
      result$data['issueTypeId'] = l$issueTypeId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$UpdateIssueIssueTypeInput<Input$UpdateIssueIssueTypeInput>
      get copyWith => CopyWith$Input$UpdateIssueIssueTypeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateIssueIssueTypeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueTypeId = issueTypeId;
    final lOther$issueTypeId = other.issueTypeId;
    if (_$data.containsKey('issueTypeId') !=
        other._$data.containsKey('issueTypeId')) {
      return false;
    }
    if (l$issueTypeId != lOther$issueTypeId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueTypeId = issueTypeId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('issueTypeId') ? l$issueTypeId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueIssueTypeInput<TRes> {
  factory CopyWith$Input$UpdateIssueIssueTypeInput(
    Input$UpdateIssueIssueTypeInput instance,
    TRes Function(Input$UpdateIssueIssueTypeInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueIssueTypeInput;

  factory CopyWith$Input$UpdateIssueIssueTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueIssueTypeInput;

  TRes call({
    String? clientMutationId,
    String? issueTypeId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$UpdateIssueIssueTypeInput<TRes>
    implements CopyWith$Input$UpdateIssueIssueTypeInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueIssueTypeInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueIssueTypeInput _instance;

  final TRes Function(Input$UpdateIssueIssueTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueTypeId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$UpdateIssueIssueTypeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueTypeId != _undefined) 'issueTypeId': (issueTypeId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueIssueTypeInput<TRes>
    implements CopyWith$Input$UpdateIssueIssueTypeInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueIssueTypeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueTypeId,
    String? issueId,
  }) =>
      _res;
}

class Input$UpdateIssueTypeInput {
  factory Input$UpdateIssueTypeInput({
    String? clientMutationId,
    required String issueTypeId,
    bool? isEnabled,
    String? name,
    String? description,
    Enum$IssueTypeColor? color,
  }) =>
      Input$UpdateIssueTypeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueTypeId': issueTypeId,
        if (isEnabled != null) r'isEnabled': isEnabled,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (color != null) r'color': color,
      });

  Input$UpdateIssueTypeInput._(this._$data);

  factory Input$UpdateIssueTypeInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueTypeId = data['issueTypeId'];
    result$data['issueTypeId'] = (l$issueTypeId as String);
    if (data.containsKey('isEnabled')) {
      final l$isEnabled = data['isEnabled'];
      result$data['isEnabled'] = (l$isEnabled as bool?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : fromJson$Enum$IssueTypeColor((l$color as String));
    }
    return Input$UpdateIssueTypeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get issueTypeId => (_$data['issueTypeId'] as String);

  bool? get isEnabled => (_$data['isEnabled'] as bool?);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  Enum$IssueTypeColor? get color => (_$data['color'] as Enum$IssueTypeColor?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueTypeId = issueTypeId;
    result$data['issueTypeId'] = l$issueTypeId;
    if (_$data.containsKey('isEnabled')) {
      final l$isEnabled = isEnabled;
      result$data['isEnabled'] = l$isEnabled;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] =
          l$color == null ? null : toJson$Enum$IssueTypeColor(l$color);
    }
    return result$data;
  }

  CopyWith$Input$UpdateIssueTypeInput<Input$UpdateIssueTypeInput>
      get copyWith => CopyWith$Input$UpdateIssueTypeInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateIssueTypeInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueTypeId = issueTypeId;
    final lOther$issueTypeId = other.issueTypeId;
    if (l$issueTypeId != lOther$issueTypeId) {
      return false;
    }
    final l$isEnabled = isEnabled;
    final lOther$isEnabled = other.isEnabled;
    if (_$data.containsKey('isEnabled') !=
        other._$data.containsKey('isEnabled')) {
      return false;
    }
    if (l$isEnabled != lOther$isEnabled) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueTypeId = issueTypeId;
    final l$isEnabled = isEnabled;
    final l$name = name;
    final l$description = description;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueTypeId,
      _$data.containsKey('isEnabled') ? l$isEnabled : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueTypeInput<TRes> {
  factory CopyWith$Input$UpdateIssueTypeInput(
    Input$UpdateIssueTypeInput instance,
    TRes Function(Input$UpdateIssueTypeInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueTypeInput;

  factory CopyWith$Input$UpdateIssueTypeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueTypeInput;

  TRes call({
    String? clientMutationId,
    String? issueTypeId,
    bool? isEnabled,
    String? name,
    String? description,
    Enum$IssueTypeColor? color,
  });
}

class _CopyWithImpl$Input$UpdateIssueTypeInput<TRes>
    implements CopyWith$Input$UpdateIssueTypeInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueTypeInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueTypeInput _instance;

  final TRes Function(Input$UpdateIssueTypeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueTypeId = _undefined,
    Object? isEnabled = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$UpdateIssueTypeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueTypeId != _undefined && issueTypeId != null)
          'issueTypeId': (issueTypeId as String),
        if (isEnabled != _undefined) 'isEnabled': (isEnabled as bool?),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (color != _undefined) 'color': (color as Enum$IssueTypeColor?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueTypeInput<TRes>
    implements CopyWith$Input$UpdateIssueTypeInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueTypeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueTypeId,
    bool? isEnabled,
    String? name,
    String? description,
    Enum$IssueTypeColor? color,
  }) =>
      _res;
}

class Input$UpdateLabelInput {
  factory Input$UpdateLabelInput({
    String? clientMutationId,
    required String id,
    String? color,
    String? description,
    String? name,
  }) =>
      Input$UpdateLabelInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (color != null) r'color': color,
        if (description != null) r'description': description,
        if (name != null) r'name': name,
      });

  Input$UpdateLabelInput._(this._$data);

  factory Input$UpdateLabelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = (l$color as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$UpdateLabelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  String? get color => (_$data['color'] as String?);

  String? get description => (_$data['description'] as String?);

  String? get name => (_$data['name'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$UpdateLabelInput<Input$UpdateLabelInput> get copyWith =>
      CopyWith$Input$UpdateLabelInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateLabelInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$color = color;
    final l$description = description;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateLabelInput<TRes> {
  factory CopyWith$Input$UpdateLabelInput(
    Input$UpdateLabelInput instance,
    TRes Function(Input$UpdateLabelInput) then,
  ) = _CopyWithImpl$Input$UpdateLabelInput;

  factory CopyWith$Input$UpdateLabelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateLabelInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? color,
    String? description,
    String? name,
  });
}

class _CopyWithImpl$Input$UpdateLabelInput<TRes>
    implements CopyWith$Input$UpdateLabelInput<TRes> {
  _CopyWithImpl$Input$UpdateLabelInput(
    this._instance,
    this._then,
  );

  final Input$UpdateLabelInput _instance;

  final TRes Function(Input$UpdateLabelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? color = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$UpdateLabelInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (color != _undefined) 'color': (color as String?),
        if (description != _undefined) 'description': (description as String?),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateLabelInput<TRes>
    implements CopyWith$Input$UpdateLabelInput<TRes> {
  _CopyWithStubImpl$Input$UpdateLabelInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? color,
    String? description,
    String? name,
  }) =>
      _res;
}

class Input$UpdateNotificationRestrictionSettingInput {
  factory Input$UpdateNotificationRestrictionSettingInput({
    String? clientMutationId,
    required String ownerId,
    required Enum$NotificationRestrictionSettingValue settingValue,
  }) =>
      Input$UpdateNotificationRestrictionSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'settingValue': settingValue,
      });

  Input$UpdateNotificationRestrictionSettingInput._(this._$data);

  factory Input$UpdateNotificationRestrictionSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$NotificationRestrictionSettingValue(
            (l$settingValue as String));
    return Input$UpdateNotificationRestrictionSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get ownerId => (_$data['ownerId'] as String);

  Enum$NotificationRestrictionSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$NotificationRestrictionSettingValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$NotificationRestrictionSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateNotificationRestrictionSettingInput<
          Input$UpdateNotificationRestrictionSettingInput>
      get copyWith => CopyWith$Input$UpdateNotificationRestrictionSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateNotificationRestrictionSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  factory CopyWith$Input$UpdateNotificationRestrictionSettingInput(
    Input$UpdateNotificationRestrictionSettingInput instance,
    TRes Function(Input$UpdateNotificationRestrictionSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput;

  factory CopyWith$Input$UpdateNotificationRestrictionSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    Enum$NotificationRestrictionSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput<TRes>
    implements CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateNotificationRestrictionSettingInput _instance;

  final TRes Function(Input$UpdateNotificationRestrictionSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateNotificationRestrictionSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$NotificationRestrictionSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput<TRes>
    implements CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    Enum$NotificationRestrictionSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput {
  factory Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput({
    String? clientMutationId,
    required String organizationId,
    required bool forkingEnabled,
  }) =>
      Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'forkingEnabled': forkingEnabled,
      });

  Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._(
      this._$data);

  factory Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$forkingEnabled = data['forkingEnabled'];
    result$data['forkingEnabled'] = (l$forkingEnabled as bool);
    return Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  bool get forkingEnabled => (_$data['forkingEnabled'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$forkingEnabled = forkingEnabled;
    result$data['forkingEnabled'] = l$forkingEnabled;
    return result$data;
  }

  CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
          Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other
            is! Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$forkingEnabled = forkingEnabled;
    final lOther$forkingEnabled = other.forkingEnabled;
    if (l$forkingEnabled != lOther$forkingEnabled) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$forkingEnabled = forkingEnabled;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$forkingEnabled,
    ]);
  }
}

abstract class CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
    Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput instance,
    TRes Function(
            Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;

  factory CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    bool? forkingEnabled,
  });
}

class _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput
      _instance;

  final TRes Function(
      Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? forkingEnabled = _undefined,
  }) =>
      _then(
          Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (forkingEnabled != _undefined && forkingEnabled != null)
          'forkingEnabled': (forkingEnabled as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    bool? forkingEnabled,
  }) =>
      _res;
}

class Input$UpdateOrganizationWebCommitSignoffSettingInput {
  factory Input$UpdateOrganizationWebCommitSignoffSettingInput({
    String? clientMutationId,
    required String organizationId,
    required bool webCommitSignoffRequired,
  }) =>
      Input$UpdateOrganizationWebCommitSignoffSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'webCommitSignoffRequired': webCommitSignoffRequired,
      });

  Input$UpdateOrganizationWebCommitSignoffSettingInput._(this._$data);

  factory Input$UpdateOrganizationWebCommitSignoffSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$webCommitSignoffRequired = data['webCommitSignoffRequired'];
    result$data['webCommitSignoffRequired'] =
        (l$webCommitSignoffRequired as bool);
    return Input$UpdateOrganizationWebCommitSignoffSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get organizationId => (_$data['organizationId'] as String);

  bool get webCommitSignoffRequired =>
      (_$data['webCommitSignoffRequired'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    result$data['webCommitSignoffRequired'] = l$webCommitSignoffRequired;
    return result$data;
  }

  CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<
          Input$UpdateOrganizationWebCommitSignoffSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateOrganizationWebCommitSignoffSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final lOther$webCommitSignoffRequired = other.webCommitSignoffRequired;
    if (l$webCommitSignoffRequired != lOther$webCommitSignoffRequired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$webCommitSignoffRequired,
    ]);
  }
}

abstract class CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput(
    Input$UpdateOrganizationWebCommitSignoffSettingInput instance,
    TRes Function(Input$UpdateOrganizationWebCommitSignoffSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput;

  factory CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    bool? webCommitSignoffRequired,
  });
}

class _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateOrganizationWebCommitSignoffSettingInput _instance;

  final TRes Function(Input$UpdateOrganizationWebCommitSignoffSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? webCommitSignoffRequired = _undefined,
  }) =>
      _then(Input$UpdateOrganizationWebCommitSignoffSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (webCommitSignoffRequired != _undefined &&
            webCommitSignoffRequired != null)
          'webCommitSignoffRequired': (webCommitSignoffRequired as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    bool? webCommitSignoffRequired,
  }) =>
      _res;
}

class Input$UpdateParametersInput {
  factory Input$UpdateParametersInput(
          {required bool updateAllowsFetchAndMerge}) =>
      Input$UpdateParametersInput._({
        r'updateAllowsFetchAndMerge': updateAllowsFetchAndMerge,
      });

  Input$UpdateParametersInput._(this._$data);

  factory Input$UpdateParametersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$updateAllowsFetchAndMerge = data['updateAllowsFetchAndMerge'];
    result$data['updateAllowsFetchAndMerge'] =
        (l$updateAllowsFetchAndMerge as bool);
    return Input$UpdateParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool get updateAllowsFetchAndMerge =>
      (_$data['updateAllowsFetchAndMerge'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$updateAllowsFetchAndMerge = updateAllowsFetchAndMerge;
    result$data['updateAllowsFetchAndMerge'] = l$updateAllowsFetchAndMerge;
    return result$data;
  }

  CopyWith$Input$UpdateParametersInput<Input$UpdateParametersInput>
      get copyWith => CopyWith$Input$UpdateParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$updateAllowsFetchAndMerge = updateAllowsFetchAndMerge;
    final lOther$updateAllowsFetchAndMerge = other.updateAllowsFetchAndMerge;
    if (l$updateAllowsFetchAndMerge != lOther$updateAllowsFetchAndMerge) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$updateAllowsFetchAndMerge = updateAllowsFetchAndMerge;
    return Object.hashAll([l$updateAllowsFetchAndMerge]);
  }
}

abstract class CopyWith$Input$UpdateParametersInput<TRes> {
  factory CopyWith$Input$UpdateParametersInput(
    Input$UpdateParametersInput instance,
    TRes Function(Input$UpdateParametersInput) then,
  ) = _CopyWithImpl$Input$UpdateParametersInput;

  factory CopyWith$Input$UpdateParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateParametersInput;

  TRes call({bool? updateAllowsFetchAndMerge});
}

class _CopyWithImpl$Input$UpdateParametersInput<TRes>
    implements CopyWith$Input$UpdateParametersInput<TRes> {
  _CopyWithImpl$Input$UpdateParametersInput(
    this._instance,
    this._then,
  );

  final Input$UpdateParametersInput _instance;

  final TRes Function(Input$UpdateParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? updateAllowsFetchAndMerge = _undefined}) =>
      _then(Input$UpdateParametersInput._({
        ..._instance._$data,
        if (updateAllowsFetchAndMerge != _undefined &&
            updateAllowsFetchAndMerge != null)
          'updateAllowsFetchAndMerge': (updateAllowsFetchAndMerge as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateParametersInput<TRes>
    implements CopyWith$Input$UpdateParametersInput<TRes> {
  _CopyWithStubImpl$Input$UpdateParametersInput(this._res);

  TRes _res;

  call({bool? updateAllowsFetchAndMerge}) => _res;
}

class Input$UpdatePatreonSponsorabilityInput {
  factory Input$UpdatePatreonSponsorabilityInput({
    String? clientMutationId,
    String? sponsorableLogin,
    required bool enablePatreonSponsorships,
  }) =>
      Input$UpdatePatreonSponsorabilityInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        r'enablePatreonSponsorships': enablePatreonSponsorships,
      });

  Input$UpdatePatreonSponsorabilityInput._(this._$data);

  factory Input$UpdatePatreonSponsorabilityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    final l$enablePatreonSponsorships = data['enablePatreonSponsorships'];
    result$data['enablePatreonSponsorships'] =
        (l$enablePatreonSponsorships as bool);
    return Input$UpdatePatreonSponsorabilityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);

  bool get enablePatreonSponsorships =>
      (_$data['enablePatreonSponsorships'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    final l$enablePatreonSponsorships = enablePatreonSponsorships;
    result$data['enablePatreonSponsorships'] = l$enablePatreonSponsorships;
    return result$data;
  }

  CopyWith$Input$UpdatePatreonSponsorabilityInput<
          Input$UpdatePatreonSponsorabilityInput>
      get copyWith => CopyWith$Input$UpdatePatreonSponsorabilityInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdatePatreonSponsorabilityInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$enablePatreonSponsorships = enablePatreonSponsorships;
    final lOther$enablePatreonSponsorships = other.enablePatreonSponsorships;
    if (l$enablePatreonSponsorships != lOther$enablePatreonSponsorships) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$enablePatreonSponsorships = enablePatreonSponsorships;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      l$enablePatreonSponsorships,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePatreonSponsorabilityInput<TRes> {
  factory CopyWith$Input$UpdatePatreonSponsorabilityInput(
    Input$UpdatePatreonSponsorabilityInput instance,
    TRes Function(Input$UpdatePatreonSponsorabilityInput) then,
  ) = _CopyWithImpl$Input$UpdatePatreonSponsorabilityInput;

  factory CopyWith$Input$UpdatePatreonSponsorabilityInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePatreonSponsorabilityInput;

  TRes call({
    String? clientMutationId,
    String? sponsorableLogin,
    bool? enablePatreonSponsorships,
  });
}

class _CopyWithImpl$Input$UpdatePatreonSponsorabilityInput<TRes>
    implements CopyWith$Input$UpdatePatreonSponsorabilityInput<TRes> {
  _CopyWithImpl$Input$UpdatePatreonSponsorabilityInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePatreonSponsorabilityInput _instance;

  final TRes Function(Input$UpdatePatreonSponsorabilityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? enablePatreonSponsorships = _undefined,
  }) =>
      _then(Input$UpdatePatreonSponsorabilityInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (enablePatreonSponsorships != _undefined &&
            enablePatreonSponsorships != null)
          'enablePatreonSponsorships': (enablePatreonSponsorships as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdatePatreonSponsorabilityInput<TRes>
    implements CopyWith$Input$UpdatePatreonSponsorabilityInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePatreonSponsorabilityInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorableLogin,
    bool? enablePatreonSponsorships,
  }) =>
      _res;
}

class Input$UpdateProjectCardInput {
  factory Input$UpdateProjectCardInput({
    String? clientMutationId,
    required String projectCardId,
    bool? isArchived,
    String? note,
  }) =>
      Input$UpdateProjectCardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectCardId': projectCardId,
        if (isArchived != null) r'isArchived': isArchived,
        if (note != null) r'note': note,
      });

  Input$UpdateProjectCardInput._(this._$data);

  factory Input$UpdateProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectCardId = data['projectCardId'];
    result$data['projectCardId'] = (l$projectCardId as String);
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = (l$isArchived as bool?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    return Input$UpdateProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectCardId => (_$data['projectCardId'] as String);

  bool? get isArchived => (_$data['isArchived'] as bool?);

  String? get note => (_$data['note'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectCardId = projectCardId;
    result$data['projectCardId'] = l$projectCardId;
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectCardInput<Input$UpdateProjectCardInput>
      get copyWith => CopyWith$Input$UpdateProjectCardInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectCardInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectCardId = projectCardId;
    final lOther$projectCardId = other.projectCardId;
    if (l$projectCardId != lOther$projectCardId) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectCardId = projectCardId;
    final l$isArchived = isArchived;
    final l$note = note;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectCardId,
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('note') ? l$note : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectCardInput<TRes> {
  factory CopyWith$Input$UpdateProjectCardInput(
    Input$UpdateProjectCardInput instance,
    TRes Function(Input$UpdateProjectCardInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectCardInput;

  factory CopyWith$Input$UpdateProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectCardInput;

  TRes call({
    String? clientMutationId,
    String? projectCardId,
    bool? isArchived,
    String? note,
  });
}

class _CopyWithImpl$Input$UpdateProjectCardInput<TRes>
    implements CopyWith$Input$UpdateProjectCardInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectCardInput _instance;

  final TRes Function(Input$UpdateProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectCardId = _undefined,
    Object? isArchived = _undefined,
    Object? note = _undefined,
  }) =>
      _then(Input$UpdateProjectCardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectCardId != _undefined && projectCardId != null)
          'projectCardId': (projectCardId as String),
        if (isArchived != _undefined) 'isArchived': (isArchived as bool?),
        if (note != _undefined) 'note': (note as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectCardInput<TRes>
    implements CopyWith$Input$UpdateProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectCardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectCardId,
    bool? isArchived,
    String? note,
  }) =>
      _res;
}

class Input$UpdateProjectColumnInput {
  factory Input$UpdateProjectColumnInput({
    String? clientMutationId,
    required String projectColumnId,
    required String name,
  }) =>
      Input$UpdateProjectColumnInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectColumnId': projectColumnId,
        r'name': name,
      });

  Input$UpdateProjectColumnInput._(this._$data);

  factory Input$UpdateProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectColumnId = data['projectColumnId'];
    result$data['projectColumnId'] = (l$projectColumnId as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$UpdateProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectColumnId => (_$data['projectColumnId'] as String);

  String get name => (_$data['name'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectColumnId = projectColumnId;
    result$data['projectColumnId'] = l$projectColumnId;
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$UpdateProjectColumnInput<Input$UpdateProjectColumnInput>
      get copyWith => CopyWith$Input$UpdateProjectColumnInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectColumnInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectColumnId = projectColumnId;
    final lOther$projectColumnId = other.projectColumnId;
    if (l$projectColumnId != lOther$projectColumnId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectColumnId = projectColumnId;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectColumnId,
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectColumnInput<TRes> {
  factory CopyWith$Input$UpdateProjectColumnInput(
    Input$UpdateProjectColumnInput instance,
    TRes Function(Input$UpdateProjectColumnInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectColumnInput;

  factory CopyWith$Input$UpdateProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectColumnInput;

  TRes call({
    String? clientMutationId,
    String? projectColumnId,
    String? name,
  });
}

class _CopyWithImpl$Input$UpdateProjectColumnInput<TRes>
    implements CopyWith$Input$UpdateProjectColumnInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectColumnInput _instance;

  final TRes Function(Input$UpdateProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectColumnId = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$UpdateProjectColumnInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectColumnId != _undefined && projectColumnId != null)
          'projectColumnId': (projectColumnId as String),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectColumnInput<TRes>
    implements CopyWith$Input$UpdateProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectColumnInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectColumnId,
    String? name,
  }) =>
      _res;
}

class Input$UpdateProjectInput {
  factory Input$UpdateProjectInput({
    String? clientMutationId,
    required String projectId,
    String? name,
    String? body,
    Enum$ProjectState? state,
    bool? public,
  }) =>
      Input$UpdateProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        if (name != null) r'name': name,
        if (body != null) r'body': body,
        if (state != null) r'state': state,
        if (public != null) r'public': public,
      });

  Input$UpdateProjectInput._(this._$data);

  factory Input$UpdateProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$ProjectState((l$state as String));
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    return Input$UpdateProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String? get name => (_$data['name'] as String?);

  String? get body => (_$data['body'] as String?);

  Enum$ProjectState? get state => (_$data['state'] as Enum$ProjectState?);

  bool? get public => (_$data['public'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$ProjectState(l$state);
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectInput<Input$UpdateProjectInput> get copyWith =>
      CopyWith$Input$UpdateProjectInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$name = name;
    final l$body = body;
    final l$state = state;
    final l$public = public;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('public') ? l$public : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectInput<TRes> {
  factory CopyWith$Input$UpdateProjectInput(
    Input$UpdateProjectInput instance,
    TRes Function(Input$UpdateProjectInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectInput;

  factory CopyWith$Input$UpdateProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? name,
    String? body,
    Enum$ProjectState? state,
    bool? public,
  });
}

class _CopyWithImpl$Input$UpdateProjectInput<TRes>
    implements CopyWith$Input$UpdateProjectInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectInput _instance;

  final TRes Function(Input$UpdateProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? name = _undefined,
    Object? body = _undefined,
    Object? state = _undefined,
    Object? public = _undefined,
  }) =>
      _then(Input$UpdateProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (name != _undefined) 'name': (name as String?),
        if (body != _undefined) 'body': (body as String?),
        if (state != _undefined) 'state': (state as Enum$ProjectState?),
        if (public != _undefined) 'public': (public as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectInput<TRes>
    implements CopyWith$Input$UpdateProjectInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? name,
    String? body,
    Enum$ProjectState? state,
    bool? public,
  }) =>
      _res;
}

class Input$UpdateProjectV2CollaboratorsInput {
  factory Input$UpdateProjectV2CollaboratorsInput({
    String? clientMutationId,
    required String projectId,
    required List<Input$ProjectV2Collaborator> collaborators,
  }) =>
      Input$UpdateProjectV2CollaboratorsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'collaborators': collaborators,
      });

  Input$UpdateProjectV2CollaboratorsInput._(this._$data);

  factory Input$UpdateProjectV2CollaboratorsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$collaborators = data['collaborators'];
    result$data['collaborators'] = (l$collaborators as List<dynamic>)
        .map((e) =>
            Input$ProjectV2Collaborator.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$UpdateProjectV2CollaboratorsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  List<Input$ProjectV2Collaborator> get collaborators =>
      (_$data['collaborators'] as List<Input$ProjectV2Collaborator>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$collaborators = collaborators;
    result$data['collaborators'] =
        l$collaborators.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2CollaboratorsInput<
          Input$UpdateProjectV2CollaboratorsInput>
      get copyWith => CopyWith$Input$UpdateProjectV2CollaboratorsInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectV2CollaboratorsInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$collaborators = collaborators;
    final lOther$collaborators = other.collaborators;
    if (l$collaborators.length != lOther$collaborators.length) {
      return false;
    }
    for (int i = 0; i < l$collaborators.length; i++) {
      final l$collaborators$entry = l$collaborators[i];
      final lOther$collaborators$entry = lOther$collaborators[i];
      if (l$collaborators$entry != lOther$collaborators$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$collaborators = collaborators;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      Object.hashAll(l$collaborators.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2CollaboratorsInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2CollaboratorsInput(
    Input$UpdateProjectV2CollaboratorsInput instance,
    TRes Function(Input$UpdateProjectV2CollaboratorsInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2CollaboratorsInput;

  factory CopyWith$Input$UpdateProjectV2CollaboratorsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2CollaboratorsInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    List<Input$ProjectV2Collaborator>? collaborators,
  });
  TRes collaborators(
      Iterable<Input$ProjectV2Collaborator> Function(
              Iterable<
                  CopyWith$Input$ProjectV2Collaborator<
                      Input$ProjectV2Collaborator>>)
          _fn);
}

class _CopyWithImpl$Input$UpdateProjectV2CollaboratorsInput<TRes>
    implements CopyWith$Input$UpdateProjectV2CollaboratorsInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2CollaboratorsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2CollaboratorsInput _instance;

  final TRes Function(Input$UpdateProjectV2CollaboratorsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? collaborators = _undefined,
  }) =>
      _then(Input$UpdateProjectV2CollaboratorsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (collaborators != _undefined && collaborators != null)
          'collaborators': (collaborators as List<Input$ProjectV2Collaborator>),
      }));

  TRes collaborators(
          Iterable<Input$ProjectV2Collaborator> Function(
                  Iterable<
                      CopyWith$Input$ProjectV2Collaborator<
                          Input$ProjectV2Collaborator>>)
              _fn) =>
      call(
          collaborators: _fn(_instance.collaborators
              .map((e) => CopyWith$Input$ProjectV2Collaborator(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$UpdateProjectV2CollaboratorsInput<TRes>
    implements CopyWith$Input$UpdateProjectV2CollaboratorsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2CollaboratorsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    List<Input$ProjectV2Collaborator>? collaborators,
  }) =>
      _res;

  collaborators(_fn) => _res;
}

class Input$UpdateProjectV2DraftIssueInput {
  factory Input$UpdateProjectV2DraftIssueInput({
    String? clientMutationId,
    required String draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
  }) =>
      Input$UpdateProjectV2DraftIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'draftIssueId': draftIssueId,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
      });

  Input$UpdateProjectV2DraftIssueInput._(this._$data);

  factory Input$UpdateProjectV2DraftIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$draftIssueId = data['draftIssueId'];
    result$data['draftIssueId'] = (l$draftIssueId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UpdateProjectV2DraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get draftIssueId => (_$data['draftIssueId'] as String);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$draftIssueId = draftIssueId;
    result$data['draftIssueId'] = l$draftIssueId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2DraftIssueInput<
          Input$UpdateProjectV2DraftIssueInput>
      get copyWith => CopyWith$Input$UpdateProjectV2DraftIssueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectV2DraftIssueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$draftIssueId = draftIssueId;
    final lOther$draftIssueId = other.draftIssueId;
    if (l$draftIssueId != lOther$draftIssueId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$draftIssueId = draftIssueId;
    final l$title = title;
    final l$body = body;
    final l$assigneeIds = assigneeIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$draftIssueId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2DraftIssueInput(
    Input$UpdateProjectV2DraftIssueInput instance,
    TRes Function(Input$UpdateProjectV2DraftIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput;

  factory CopyWith$Input$UpdateProjectV2DraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput;

  TRes call({
    String? clientMutationId,
    String? draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2DraftIssueInput _instance;

  final TRes Function(Input$UpdateProjectV2DraftIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? draftIssueId = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? assigneeIds = _undefined,
  }) =>
      _then(Input$UpdateProjectV2DraftIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (draftIssueId != _undefined && draftIssueId != null)
          'draftIssueId': (draftIssueId as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? draftIssueId,
    String? title,
    String? body,
    List<String>? assigneeIds,
  }) =>
      _res;
}

class Input$UpdateProjectV2FieldInput {
  factory Input$UpdateProjectV2FieldInput({
    String? clientMutationId,
    required String fieldId,
    String? name,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
    Input$ProjectV2IterationFieldConfigurationInput? iterationConfiguration,
  }) =>
      Input$UpdateProjectV2FieldInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fieldId': fieldId,
        if (name != null) r'name': name,
        if (singleSelectOptions != null)
          r'singleSelectOptions': singleSelectOptions,
        if (iterationConfiguration != null)
          r'iterationConfiguration': iterationConfiguration,
      });

  Input$UpdateProjectV2FieldInput._(this._$data);

  factory Input$UpdateProjectV2FieldInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('singleSelectOptions')) {
      final l$singleSelectOptions = data['singleSelectOptions'];
      result$data['singleSelectOptions'] =
          (l$singleSelectOptions as List<dynamic>?)
              ?.map((e) => Input$ProjectV2SingleSelectFieldOptionInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('iterationConfiguration')) {
      final l$iterationConfiguration = data['iterationConfiguration'];
      result$data['iterationConfiguration'] = l$iterationConfiguration == null
          ? null
          : Input$ProjectV2IterationFieldConfigurationInput.fromJson(
              (l$iterationConfiguration as Map<String, dynamic>));
    }
    return Input$UpdateProjectV2FieldInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get fieldId => (_$data['fieldId'] as String);

  String? get name => (_$data['name'] as String?);

  List<Input$ProjectV2SingleSelectFieldOptionInput>? get singleSelectOptions =>
      (_$data['singleSelectOptions']
          as List<Input$ProjectV2SingleSelectFieldOptionInput>?);

  Input$ProjectV2IterationFieldConfigurationInput? get iterationConfiguration =>
      (_$data['iterationConfiguration']
          as Input$ProjectV2IterationFieldConfigurationInput?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('singleSelectOptions')) {
      final l$singleSelectOptions = singleSelectOptions;
      result$data['singleSelectOptions'] =
          l$singleSelectOptions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('iterationConfiguration')) {
      final l$iterationConfiguration = iterationConfiguration;
      result$data['iterationConfiguration'] =
          l$iterationConfiguration?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2FieldInput<Input$UpdateProjectV2FieldInput>
      get copyWith => CopyWith$Input$UpdateProjectV2FieldInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectV2FieldInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$singleSelectOptions = singleSelectOptions;
    final lOther$singleSelectOptions = other.singleSelectOptions;
    if (_$data.containsKey('singleSelectOptions') !=
        other._$data.containsKey('singleSelectOptions')) {
      return false;
    }
    if (l$singleSelectOptions != null && lOther$singleSelectOptions != null) {
      if (l$singleSelectOptions.length != lOther$singleSelectOptions.length) {
        return false;
      }
      for (int i = 0; i < l$singleSelectOptions.length; i++) {
        final l$singleSelectOptions$entry = l$singleSelectOptions[i];
        final lOther$singleSelectOptions$entry = lOther$singleSelectOptions[i];
        if (l$singleSelectOptions$entry != lOther$singleSelectOptions$entry) {
          return false;
        }
      }
    } else if (l$singleSelectOptions != lOther$singleSelectOptions) {
      return false;
    }
    final l$iterationConfiguration = iterationConfiguration;
    final lOther$iterationConfiguration = other.iterationConfiguration;
    if (_$data.containsKey('iterationConfiguration') !=
        other._$data.containsKey('iterationConfiguration')) {
      return false;
    }
    if (l$iterationConfiguration != lOther$iterationConfiguration) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fieldId = fieldId;
    final l$name = name;
    final l$singleSelectOptions = singleSelectOptions;
    final l$iterationConfiguration = iterationConfiguration;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fieldId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('singleSelectOptions')
          ? l$singleSelectOptions == null
              ? null
              : Object.hashAll(l$singleSelectOptions.map((v) => v))
          : const {},
      _$data.containsKey('iterationConfiguration')
          ? l$iterationConfiguration
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2FieldInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2FieldInput(
    Input$UpdateProjectV2FieldInput instance,
    TRes Function(Input$UpdateProjectV2FieldInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2FieldInput;

  factory CopyWith$Input$UpdateProjectV2FieldInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2FieldInput;

  TRes call({
    String? clientMutationId,
    String? fieldId,
    String? name,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
    Input$ProjectV2IterationFieldConfigurationInput? iterationConfiguration,
  });
  TRes singleSelectOptions(
      Iterable<Input$ProjectV2SingleSelectFieldOptionInput>? Function(
              Iterable<
                  CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
                      Input$ProjectV2SingleSelectFieldOptionInput>>?)
          _fn);
  CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes>
      get iterationConfiguration;
}

class _CopyWithImpl$Input$UpdateProjectV2FieldInput<TRes>
    implements CopyWith$Input$UpdateProjectV2FieldInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2FieldInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2FieldInput _instance;

  final TRes Function(Input$UpdateProjectV2FieldInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fieldId = _undefined,
    Object? name = _undefined,
    Object? singleSelectOptions = _undefined,
    Object? iterationConfiguration = _undefined,
  }) =>
      _then(Input$UpdateProjectV2FieldInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
        if (name != _undefined) 'name': (name as String?),
        if (singleSelectOptions != _undefined)
          'singleSelectOptions': (singleSelectOptions
              as List<Input$ProjectV2SingleSelectFieldOptionInput>?),
        if (iterationConfiguration != _undefined)
          'iterationConfiguration': (iterationConfiguration
              as Input$ProjectV2IterationFieldConfigurationInput?),
      }));

  TRes singleSelectOptions(
          Iterable<Input$ProjectV2SingleSelectFieldOptionInput>? Function(
                  Iterable<
                      CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
                          Input$ProjectV2SingleSelectFieldOptionInput>>?)
              _fn) =>
      call(
          singleSelectOptions: _fn(_instance.singleSelectOptions
              ?.map((e) => CopyWith$Input$ProjectV2SingleSelectFieldOptionInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes>
      get iterationConfiguration {
    final local$iterationConfiguration = _instance.iterationConfiguration;
    return local$iterationConfiguration == null
        ? CopyWith$Input$ProjectV2IterationFieldConfigurationInput.stub(
            _then(_instance))
        : CopyWith$Input$ProjectV2IterationFieldConfigurationInput(
            local$iterationConfiguration,
            (e) => call(iterationConfiguration: e));
  }
}

class _CopyWithStubImpl$Input$UpdateProjectV2FieldInput<TRes>
    implements CopyWith$Input$UpdateProjectV2FieldInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2FieldInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fieldId,
    String? name,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
    Input$ProjectV2IterationFieldConfigurationInput? iterationConfiguration,
  }) =>
      _res;

  singleSelectOptions(_fn) => _res;

  CopyWith$Input$ProjectV2IterationFieldConfigurationInput<TRes>
      get iterationConfiguration =>
          CopyWith$Input$ProjectV2IterationFieldConfigurationInput.stub(_res);
}

class Input$UpdateProjectV2Input {
  factory Input$UpdateProjectV2Input({
    String? clientMutationId,
    required String projectId,
    String? title,
    String? shortDescription,
    String? readme,
    bool? closed,
    bool? public,
  }) =>
      Input$UpdateProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        if (title != null) r'title': title,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (readme != null) r'readme': readme,
        if (closed != null) r'closed': closed,
        if (public != null) r'public': public,
      });

  Input$UpdateProjectV2Input._(this._$data);

  factory Input$UpdateProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('readme')) {
      final l$readme = data['readme'];
      result$data['readme'] = (l$readme as String?);
    }
    if (data.containsKey('closed')) {
      final l$closed = data['closed'];
      result$data['closed'] = (l$closed as bool?);
    }
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    return Input$UpdateProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String? get title => (_$data['title'] as String?);

  String? get shortDescription => (_$data['shortDescription'] as String?);

  String? get readme => (_$data['readme'] as String?);

  bool? get closed => (_$data['closed'] as bool?);

  bool? get public => (_$data['public'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('readme')) {
      final l$readme = readme;
      result$data['readme'] = l$readme;
    }
    if (_$data.containsKey('closed')) {
      final l$closed = closed;
      result$data['closed'] = l$closed;
    }
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2Input<Input$UpdateProjectV2Input>
      get copyWith => CopyWith$Input$UpdateProjectV2Input(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectV2Input ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$readme = readme;
    final lOther$readme = other.readme;
    if (_$data.containsKey('readme') != other._$data.containsKey('readme')) {
      return false;
    }
    if (l$readme != lOther$readme) {
      return false;
    }
    final l$closed = closed;
    final lOther$closed = other.closed;
    if (_$data.containsKey('closed') != other._$data.containsKey('closed')) {
      return false;
    }
    if (l$closed != lOther$closed) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$title = title;
    final l$shortDescription = shortDescription;
    final l$readme = readme;
    final l$closed = closed;
    final l$public = public;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('readme') ? l$readme : const {},
      _$data.containsKey('closed') ? l$closed : const {},
      _$data.containsKey('public') ? l$public : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2Input<TRes> {
  factory CopyWith$Input$UpdateProjectV2Input(
    Input$UpdateProjectV2Input instance,
    TRes Function(Input$UpdateProjectV2Input) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2Input;

  factory CopyWith$Input$UpdateProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2Input;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? title,
    String? shortDescription,
    String? readme,
    bool? closed,
    bool? public,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2Input<TRes>
    implements CopyWith$Input$UpdateProjectV2Input<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2Input _instance;

  final TRes Function(Input$UpdateProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? title = _undefined,
    Object? shortDescription = _undefined,
    Object? readme = _undefined,
    Object? closed = _undefined,
    Object? public = _undefined,
  }) =>
      _then(Input$UpdateProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (title != _undefined) 'title': (title as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (readme != _undefined) 'readme': (readme as String?),
        if (closed != _undefined) 'closed': (closed as bool?),
        if (public != _undefined) 'public': (public as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2Input<TRes>
    implements CopyWith$Input$UpdateProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? title,
    String? shortDescription,
    String? readme,
    bool? closed,
    bool? public,
  }) =>
      _res;
}

class Input$UpdateProjectV2ItemFieldValueInput {
  factory Input$UpdateProjectV2ItemFieldValueInput({
    String? clientMutationId,
    required String projectId,
    required String itemId,
    required String fieldId,
    required Input$ProjectV2FieldValue value,
  }) =>
      Input$UpdateProjectV2ItemFieldValueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'itemId': itemId,
        r'fieldId': fieldId,
        r'value': value,
      });

  Input$UpdateProjectV2ItemFieldValueInput._(this._$data);

  factory Input$UpdateProjectV2ItemFieldValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    final l$value = data['value'];
    result$data['value'] =
        Input$ProjectV2FieldValue.fromJson((l$value as Map<String, dynamic>));
    return Input$UpdateProjectV2ItemFieldValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get itemId => (_$data['itemId'] as String);

  String get fieldId => (_$data['fieldId'] as String);

  Input$ProjectV2FieldValue get value =>
      (_$data['value'] as Input$ProjectV2FieldValue);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    final l$value = value;
    result$data['value'] = l$value.toJson();
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2ItemFieldValueInput<
          Input$UpdateProjectV2ItemFieldValueInput>
      get copyWith => CopyWith$Input$UpdateProjectV2ItemFieldValueInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectV2ItemFieldValueInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$fieldId = fieldId;
    final l$value = value;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$itemId,
      l$fieldId,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2ItemFieldValueInput(
    Input$UpdateProjectV2ItemFieldValueInput instance,
    TRes Function(Input$UpdateProjectV2ItemFieldValueInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput;

  factory CopyWith$Input$UpdateProjectV2ItemFieldValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
    String? fieldId,
    Input$ProjectV2FieldValue? value,
  });
  CopyWith$Input$ProjectV2FieldValue<TRes> get value;
}

class _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2ItemFieldValueInput _instance;

  final TRes Function(Input$UpdateProjectV2ItemFieldValueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? fieldId = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$UpdateProjectV2ItemFieldValueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
        if (value != _undefined && value != null)
          'value': (value as Input$ProjectV2FieldValue),
      }));

  CopyWith$Input$ProjectV2FieldValue<TRes> get value {
    final local$value = _instance.value;
    return CopyWith$Input$ProjectV2FieldValue(
        local$value, (e) => call(value: e));
  }
}

class _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
    String? fieldId,
    Input$ProjectV2FieldValue? value,
  }) =>
      _res;

  CopyWith$Input$ProjectV2FieldValue<TRes> get value =>
      CopyWith$Input$ProjectV2FieldValue.stub(_res);
}

class Input$UpdateProjectV2ItemPositionInput {
  factory Input$UpdateProjectV2ItemPositionInput({
    String? clientMutationId,
    required String projectId,
    required String itemId,
    String? afterId,
  }) =>
      Input$UpdateProjectV2ItemPositionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'itemId': itemId,
        if (afterId != null) r'afterId': afterId,
      });

  Input$UpdateProjectV2ItemPositionInput._(this._$data);

  factory Input$UpdateProjectV2ItemPositionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    if (data.containsKey('afterId')) {
      final l$afterId = data['afterId'];
      result$data['afterId'] = (l$afterId as String?);
    }
    return Input$UpdateProjectV2ItemPositionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get projectId => (_$data['projectId'] as String);

  String get itemId => (_$data['itemId'] as String);

  String? get afterId => (_$data['afterId'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    if (_$data.containsKey('afterId')) {
      final l$afterId = afterId;
      result$data['afterId'] = l$afterId;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2ItemPositionInput<
          Input$UpdateProjectV2ItemPositionInput>
      get copyWith => CopyWith$Input$UpdateProjectV2ItemPositionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectV2ItemPositionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$afterId = afterId;
    final lOther$afterId = other.afterId;
    if (_$data.containsKey('afterId') != other._$data.containsKey('afterId')) {
      return false;
    }
    if (l$afterId != lOther$afterId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$itemId = itemId;
    final l$afterId = afterId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$itemId,
      _$data.containsKey('afterId') ? l$afterId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2ItemPositionInput(
    Input$UpdateProjectV2ItemPositionInput instance,
    TRes Function(Input$UpdateProjectV2ItemPositionInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput;

  factory CopyWith$Input$UpdateProjectV2ItemPositionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
    String? afterId,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2ItemPositionInput _instance;

  final TRes Function(Input$UpdateProjectV2ItemPositionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? itemId = _undefined,
    Object? afterId = _undefined,
  }) =>
      _then(Input$UpdateProjectV2ItemPositionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (afterId != _undefined) 'afterId': (afterId as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? itemId,
    String? afterId,
  }) =>
      _res;
}

class Input$UpdateProjectV2StatusUpdateInput {
  factory Input$UpdateProjectV2StatusUpdateInput({
    String? clientMutationId,
    required String statusUpdateId,
    String? startDate,
    String? targetDate,
    Enum$ProjectV2StatusUpdateStatus? status,
    String? body,
  }) =>
      Input$UpdateProjectV2StatusUpdateInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'statusUpdateId': statusUpdateId,
        if (startDate != null) r'startDate': startDate,
        if (targetDate != null) r'targetDate': targetDate,
        if (status != null) r'status': status,
        if (body != null) r'body': body,
      });

  Input$UpdateProjectV2StatusUpdateInput._(this._$data);

  factory Input$UpdateProjectV2StatusUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$statusUpdateId = data['statusUpdateId'];
    result$data['statusUpdateId'] = (l$statusUpdateId as String);
    if (data.containsKey('startDate')) {
      final l$startDate = data['startDate'];
      result$data['startDate'] = (l$startDate as String?);
    }
    if (data.containsKey('targetDate')) {
      final l$targetDate = data['targetDate'];
      result$data['targetDate'] = (l$targetDate as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$ProjectV2StatusUpdateStatus((l$status as String));
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    return Input$UpdateProjectV2StatusUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get statusUpdateId => (_$data['statusUpdateId'] as String);

  String? get startDate => (_$data['startDate'] as String?);

  String? get targetDate => (_$data['targetDate'] as String?);

  Enum$ProjectV2StatusUpdateStatus? get status =>
      (_$data['status'] as Enum$ProjectV2StatusUpdateStatus?);

  String? get body => (_$data['body'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$statusUpdateId = statusUpdateId;
    result$data['statusUpdateId'] = l$statusUpdateId;
    if (_$data.containsKey('startDate')) {
      final l$startDate = startDate;
      result$data['startDate'] = l$startDate;
    }
    if (_$data.containsKey('targetDate')) {
      final l$targetDate = targetDate;
      result$data['targetDate'] = l$targetDate;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$ProjectV2StatusUpdateStatus(l$status);
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2StatusUpdateInput<
          Input$UpdateProjectV2StatusUpdateInput>
      get copyWith => CopyWith$Input$UpdateProjectV2StatusUpdateInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateProjectV2StatusUpdateInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$statusUpdateId = statusUpdateId;
    final lOther$statusUpdateId = other.statusUpdateId;
    if (l$statusUpdateId != lOther$statusUpdateId) {
      return false;
    }
    final l$startDate = startDate;
    final lOther$startDate = other.startDate;
    if (_$data.containsKey('startDate') !=
        other._$data.containsKey('startDate')) {
      return false;
    }
    if (l$startDate != lOther$startDate) {
      return false;
    }
    final l$targetDate = targetDate;
    final lOther$targetDate = other.targetDate;
    if (_$data.containsKey('targetDate') !=
        other._$data.containsKey('targetDate')) {
      return false;
    }
    if (l$targetDate != lOther$targetDate) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$statusUpdateId = statusUpdateId;
    final l$startDate = startDate;
    final l$targetDate = targetDate;
    final l$status = status;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$statusUpdateId,
      _$data.containsKey('startDate') ? l$startDate : const {},
      _$data.containsKey('targetDate') ? l$targetDate : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('body') ? l$body : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2StatusUpdateInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2StatusUpdateInput(
    Input$UpdateProjectV2StatusUpdateInput instance,
    TRes Function(Input$UpdateProjectV2StatusUpdateInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2StatusUpdateInput;

  factory CopyWith$Input$UpdateProjectV2StatusUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2StatusUpdateInput;

  TRes call({
    String? clientMutationId,
    String? statusUpdateId,
    String? startDate,
    String? targetDate,
    Enum$ProjectV2StatusUpdateStatus? status,
    String? body,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2StatusUpdateInput<TRes>
    implements CopyWith$Input$UpdateProjectV2StatusUpdateInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2StatusUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2StatusUpdateInput _instance;

  final TRes Function(Input$UpdateProjectV2StatusUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? statusUpdateId = _undefined,
    Object? startDate = _undefined,
    Object? targetDate = _undefined,
    Object? status = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$UpdateProjectV2StatusUpdateInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (statusUpdateId != _undefined && statusUpdateId != null)
          'statusUpdateId': (statusUpdateId as String),
        if (startDate != _undefined) 'startDate': (startDate as String?),
        if (targetDate != _undefined) 'targetDate': (targetDate as String?),
        if (status != _undefined)
          'status': (status as Enum$ProjectV2StatusUpdateStatus?),
        if (body != _undefined) 'body': (body as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2StatusUpdateInput<TRes>
    implements CopyWith$Input$UpdateProjectV2StatusUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2StatusUpdateInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? statusUpdateId,
    String? startDate,
    String? targetDate,
    Enum$ProjectV2StatusUpdateStatus? status,
    String? body,
  }) =>
      _res;
}

class Input$UpdatePullRequestBranchInput {
  factory Input$UpdatePullRequestBranchInput({
    String? clientMutationId,
    required String pullRequestId,
    String? expectedHeadOid,
    Enum$PullRequestBranchUpdateMethod? updateMethod,
  }) =>
      Input$UpdatePullRequestBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
        if (updateMethod != null) r'updateMethod': updateMethod,
      });

  Input$UpdatePullRequestBranchInput._(this._$data);

  factory Input$UpdatePullRequestBranchInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    if (data.containsKey('updateMethod')) {
      final l$updateMethod = data['updateMethod'];
      result$data['updateMethod'] = l$updateMethod == null
          ? null
          : fromJson$Enum$PullRequestBranchUpdateMethod(
              (l$updateMethod as String));
    }
    return Input$UpdatePullRequestBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);

  Enum$PullRequestBranchUpdateMethod? get updateMethod =>
      (_$data['updateMethod'] as Enum$PullRequestBranchUpdateMethod?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    if (_$data.containsKey('updateMethod')) {
      final l$updateMethod = updateMethod;
      result$data['updateMethod'] = l$updateMethod == null
          ? null
          : toJson$Enum$PullRequestBranchUpdateMethod(l$updateMethod);
    }
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestBranchInput<
          Input$UpdatePullRequestBranchInput>
      get copyWith => CopyWith$Input$UpdatePullRequestBranchInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdatePullRequestBranchInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$updateMethod = updateMethod;
    final lOther$updateMethod = other.updateMethod;
    if (_$data.containsKey('updateMethod') !=
        other._$data.containsKey('updateMethod')) {
      return false;
    }
    if (l$updateMethod != lOther$updateMethod) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$expectedHeadOid = expectedHeadOid;
    final l$updateMethod = updateMethod;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
      _$data.containsKey('updateMethod') ? l$updateMethod : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestBranchInput(
    Input$UpdatePullRequestBranchInput instance,
    TRes Function(Input$UpdatePullRequestBranchInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestBranchInput;

  factory CopyWith$Input$UpdatePullRequestBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestBranchInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? expectedHeadOid,
    Enum$PullRequestBranchUpdateMethod? updateMethod,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestBranchInput<TRes>
    implements CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestBranchInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestBranchInput _instance;

  final TRes Function(Input$UpdatePullRequestBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? updateMethod = _undefined,
  }) =>
      _then(Input$UpdatePullRequestBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
        if (updateMethod != _undefined)
          'updateMethod': (updateMethod as Enum$PullRequestBranchUpdateMethod?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestBranchInput<TRes>
    implements CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? expectedHeadOid,
    Enum$PullRequestBranchUpdateMethod? updateMethod,
  }) =>
      _res;
}

class Input$UpdatePullRequestInput {
  factory Input$UpdatePullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
    String? baseRefName,
    String? title,
    String? body,
    Enum$PullRequestUpdateState? state,
    bool? maintainerCanModify,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
  }) =>
      Input$UpdatePullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (baseRefName != null) r'baseRefName': baseRefName,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (state != null) r'state': state,
        if (maintainerCanModify != null)
          r'maintainerCanModify': maintainerCanModify,
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (labelIds != null) r'labelIds': labelIds,
        if (projectIds != null) r'projectIds': projectIds,
      });

  Input$UpdatePullRequestInput._(this._$data);

  factory Input$UpdatePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('baseRefName')) {
      final l$baseRefName = data['baseRefName'];
      result$data['baseRefName'] = (l$baseRefName as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$PullRequestUpdateState((l$state as String));
    }
    if (data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = data['maintainerCanModify'];
      result$data['maintainerCanModify'] = (l$maintainerCanModify as bool?);
    }
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$UpdatePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestId => (_$data['pullRequestId'] as String);

  String? get baseRefName => (_$data['baseRefName'] as String?);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  Enum$PullRequestUpdateState? get state =>
      (_$data['state'] as Enum$PullRequestUpdateState?);

  bool? get maintainerCanModify => (_$data['maintainerCanModify'] as bool?);

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);

  String? get milestoneId => (_$data['milestoneId'] as String?);

  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);

  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('baseRefName')) {
      final l$baseRefName = baseRefName;
      result$data['baseRefName'] = l$baseRefName;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$PullRequestUpdateState(l$state);
    }
    if (_$data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = maintainerCanModify;
      result$data['maintainerCanModify'] = l$maintainerCanModify;
    }
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestInput<Input$UpdatePullRequestInput>
      get copyWith => CopyWith$Input$UpdatePullRequestInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdatePullRequestInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$baseRefName = baseRefName;
    final lOther$baseRefName = other.baseRefName;
    if (_$data.containsKey('baseRefName') !=
        other._$data.containsKey('baseRefName')) {
      return false;
    }
    if (l$baseRefName != lOther$baseRefName) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$maintainerCanModify = maintainerCanModify;
    final lOther$maintainerCanModify = other.maintainerCanModify;
    if (_$data.containsKey('maintainerCanModify') !=
        other._$data.containsKey('maintainerCanModify')) {
      return false;
    }
    if (l$maintainerCanModify != lOther$maintainerCanModify) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$baseRefName = baseRefName;
    final l$title = title;
    final l$body = body;
    final l$state = state;
    final l$maintainerCanModify = maintainerCanModify;
    final l$assigneeIds = assigneeIds;
    final l$milestoneId = milestoneId;
    final l$labelIds = labelIds;
    final l$projectIds = projectIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('baseRefName') ? l$baseRefName : const {},
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('maintainerCanModify')
          ? l$maintainerCanModify
          : const {},
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestInput(
    Input$UpdatePullRequestInput instance,
    TRes Function(Input$UpdatePullRequestInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestInput;

  factory CopyWith$Input$UpdatePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    String? baseRefName,
    String? title,
    String? body,
    Enum$PullRequestUpdateState? state,
    bool? maintainerCanModify,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestInput<TRes>
    implements CopyWith$Input$UpdatePullRequestInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestInput _instance;

  final TRes Function(Input$UpdatePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? baseRefName = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? state = _undefined,
    Object? maintainerCanModify = _undefined,
    Object? assigneeIds = _undefined,
    Object? milestoneId = _undefined,
    Object? labelIds = _undefined,
    Object? projectIds = _undefined,
  }) =>
      _then(Input$UpdatePullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (baseRefName != _undefined) 'baseRefName': (baseRefName as String?),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (state != _undefined)
          'state': (state as Enum$PullRequestUpdateState?),
        if (maintainerCanModify != _undefined)
          'maintainerCanModify': (maintainerCanModify as bool?),
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestInput<TRes>
    implements CopyWith$Input$UpdatePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    String? baseRefName,
    String? title,
    String? body,
    Enum$PullRequestUpdateState? state,
    bool? maintainerCanModify,
    List<String>? assigneeIds,
    String? milestoneId,
    List<String>? labelIds,
    List<String>? projectIds,
  }) =>
      _res;
}

class Input$UpdatePullRequestReviewCommentInput {
  factory Input$UpdatePullRequestReviewCommentInput({
    String? clientMutationId,
    required String pullRequestReviewCommentId,
    required String body,
  }) =>
      Input$UpdatePullRequestReviewCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestReviewCommentId': pullRequestReviewCommentId,
        r'body': body,
      });

  Input$UpdatePullRequestReviewCommentInput._(this._$data);

  factory Input$UpdatePullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestReviewCommentId = data['pullRequestReviewCommentId'];
    result$data['pullRequestReviewCommentId'] =
        (l$pullRequestReviewCommentId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$UpdatePullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestReviewCommentId =>
      (_$data['pullRequestReviewCommentId'] as String);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    result$data['pullRequestReviewCommentId'] = l$pullRequestReviewCommentId;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestReviewCommentInput<
          Input$UpdatePullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$UpdatePullRequestReviewCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdatePullRequestReviewCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    final lOther$pullRequestReviewCommentId = other.pullRequestReviewCommentId;
    if (l$pullRequestReviewCommentId != lOther$pullRequestReviewCommentId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestReviewCommentId,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestReviewCommentInput(
    Input$UpdatePullRequestReviewCommentInput instance,
    TRes Function(Input$UpdatePullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput;

  factory CopyWith$Input$UpdatePullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestReviewCommentId,
    String? body,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestReviewCommentInput _instance;

  final TRes Function(Input$UpdatePullRequestReviewCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewCommentId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$UpdatePullRequestReviewCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewCommentId != _undefined &&
            pullRequestReviewCommentId != null)
          'pullRequestReviewCommentId': (pullRequestReviewCommentId as String),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestReviewCommentId,
    String? body,
  }) =>
      _res;
}

class Input$UpdatePullRequestReviewInput {
  factory Input$UpdatePullRequestReviewInput({
    String? clientMutationId,
    required String pullRequestReviewId,
    required String body,
  }) =>
      Input$UpdatePullRequestReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestReviewId': pullRequestReviewId,
        r'body': body,
      });

  Input$UpdatePullRequestReviewInput._(this._$data);

  factory Input$UpdatePullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    return Input$UpdatePullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);

  String get body => (_$data['body'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    final l$body = body;
    result$data['body'] = l$body;
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestReviewInput<
          Input$UpdatePullRequestReviewInput>
      get copyWith => CopyWith$Input$UpdatePullRequestReviewInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdatePullRequestReviewInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$body = body;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestReviewId,
      l$body,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestReviewInput(
    Input$UpdatePullRequestReviewInput instance,
    TRes Function(Input$UpdatePullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestReviewInput;

  factory CopyWith$Input$UpdatePullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestReviewId,
    String? body,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestReviewInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestReviewInput _instance;

  final TRes Function(Input$UpdatePullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? body = _undefined,
  }) =>
      _then(Input$UpdatePullRequestReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
        if (body != _undefined && body != null) 'body': (body as String),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestReviewInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestReviewId,
    String? body,
  }) =>
      _res;
}

class Input$UpdateRefInput {
  factory Input$UpdateRefInput({
    String? clientMutationId,
    required String refId,
    required String oid,
    bool? force,
  }) =>
      Input$UpdateRefInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'refId': refId,
        r'oid': oid,
        if (force != null) r'force': force,
      });

  Input$UpdateRefInput._(this._$data);

  factory Input$UpdateRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    if (data.containsKey('force')) {
      final l$force = data['force'];
      result$data['force'] = (l$force as bool?);
    }
    return Input$UpdateRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get refId => (_$data['refId'] as String);

  String get oid => (_$data['oid'] as String);

  bool? get force => (_$data['force'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$refId = refId;
    result$data['refId'] = l$refId;
    final l$oid = oid;
    result$data['oid'] = l$oid;
    if (_$data.containsKey('force')) {
      final l$force = force;
      result$data['force'] = l$force;
    }
    return result$data;
  }

  CopyWith$Input$UpdateRefInput<Input$UpdateRefInput> get copyWith =>
      CopyWith$Input$UpdateRefInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateRefInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$force = force;
    final lOther$force = other.force;
    if (_$data.containsKey('force') != other._$data.containsKey('force')) {
      return false;
    }
    if (l$force != lOther$force) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$refId = refId;
    final l$oid = oid;
    final l$force = force;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$refId,
      l$oid,
      _$data.containsKey('force') ? l$force : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRefInput<TRes> {
  factory CopyWith$Input$UpdateRefInput(
    Input$UpdateRefInput instance,
    TRes Function(Input$UpdateRefInput) then,
  ) = _CopyWithImpl$Input$UpdateRefInput;

  factory CopyWith$Input$UpdateRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRefInput;

  TRes call({
    String? clientMutationId,
    String? refId,
    String? oid,
    bool? force,
  });
}

class _CopyWithImpl$Input$UpdateRefInput<TRes>
    implements CopyWith$Input$UpdateRefInput<TRes> {
  _CopyWithImpl$Input$UpdateRefInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRefInput _instance;

  final TRes Function(Input$UpdateRefInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? refId = _undefined,
    Object? oid = _undefined,
    Object? force = _undefined,
  }) =>
      _then(Input$UpdateRefInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (refId != _undefined && refId != null) 'refId': (refId as String),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (force != _undefined) 'force': (force as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateRefInput<TRes>
    implements CopyWith$Input$UpdateRefInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRefInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? refId,
    String? oid,
    bool? force,
  }) =>
      _res;
}

class Input$UpdateRefsInput {
  factory Input$UpdateRefsInput({
    String? clientMutationId,
    required String repositoryId,
    required List<Input$RefUpdate> refUpdates,
  }) =>
      Input$UpdateRefsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'refUpdates': refUpdates,
      });

  Input$UpdateRefsInput._(this._$data);

  factory Input$UpdateRefsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$refUpdates = data['refUpdates'];
    result$data['refUpdates'] = (l$refUpdates as List<dynamic>)
        .map((e) => Input$RefUpdate.fromJson((e as Map<String, dynamic>)))
        .toList();
    return Input$UpdateRefsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  List<Input$RefUpdate> get refUpdates =>
      (_$data['refUpdates'] as List<Input$RefUpdate>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$refUpdates = refUpdates;
    result$data['refUpdates'] = l$refUpdates.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$UpdateRefsInput<Input$UpdateRefsInput> get copyWith =>
      CopyWith$Input$UpdateRefsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateRefsInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$refUpdates = refUpdates;
    final lOther$refUpdates = other.refUpdates;
    if (l$refUpdates.length != lOther$refUpdates.length) {
      return false;
    }
    for (int i = 0; i < l$refUpdates.length; i++) {
      final l$refUpdates$entry = l$refUpdates[i];
      final lOther$refUpdates$entry = lOther$refUpdates[i];
      if (l$refUpdates$entry != lOther$refUpdates$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$refUpdates = refUpdates;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      Object.hashAll(l$refUpdates.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$UpdateRefsInput<TRes> {
  factory CopyWith$Input$UpdateRefsInput(
    Input$UpdateRefsInput instance,
    TRes Function(Input$UpdateRefsInput) then,
  ) = _CopyWithImpl$Input$UpdateRefsInput;

  factory CopyWith$Input$UpdateRefsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRefsInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    List<Input$RefUpdate>? refUpdates,
  });
  TRes refUpdates(
      Iterable<Input$RefUpdate> Function(
              Iterable<CopyWith$Input$RefUpdate<Input$RefUpdate>>)
          _fn);
}

class _CopyWithImpl$Input$UpdateRefsInput<TRes>
    implements CopyWith$Input$UpdateRefsInput<TRes> {
  _CopyWithImpl$Input$UpdateRefsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRefsInput _instance;

  final TRes Function(Input$UpdateRefsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? refUpdates = _undefined,
  }) =>
      _then(Input$UpdateRefsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (refUpdates != _undefined && refUpdates != null)
          'refUpdates': (refUpdates as List<Input$RefUpdate>),
      }));

  TRes refUpdates(
          Iterable<Input$RefUpdate> Function(
                  Iterable<CopyWith$Input$RefUpdate<Input$RefUpdate>>)
              _fn) =>
      call(
          refUpdates:
              _fn(_instance.refUpdates.map((e) => CopyWith$Input$RefUpdate(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$UpdateRefsInput<TRes>
    implements CopyWith$Input$UpdateRefsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRefsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    List<Input$RefUpdate>? refUpdates,
  }) =>
      _res;

  refUpdates(_fn) => _res;
}

class Input$UpdateRepositoryInput {
  factory Input$UpdateRepositoryInput({
    String? clientMutationId,
    required String repositoryId,
    String? name,
    String? description,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasDiscussionsEnabled,
    bool? hasSponsorshipsEnabled,
  }) =>
      Input$UpdateRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (template != null) r'template': template,
        if (homepageUrl != null) r'homepageUrl': homepageUrl,
        if (hasWikiEnabled != null) r'hasWikiEnabled': hasWikiEnabled,
        if (hasIssuesEnabled != null) r'hasIssuesEnabled': hasIssuesEnabled,
        if (hasProjectsEnabled != null)
          r'hasProjectsEnabled': hasProjectsEnabled,
        if (hasDiscussionsEnabled != null)
          r'hasDiscussionsEnabled': hasDiscussionsEnabled,
        if (hasSponsorshipsEnabled != null)
          r'hasSponsorshipsEnabled': hasSponsorshipsEnabled,
      });

  Input$UpdateRepositoryInput._(this._$data);

  factory Input$UpdateRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as bool?);
    }
    if (data.containsKey('homepageUrl')) {
      final l$homepageUrl = data['homepageUrl'];
      result$data['homepageUrl'] = (l$homepageUrl as String?);
    }
    if (data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = data['hasWikiEnabled'];
      result$data['hasWikiEnabled'] = (l$hasWikiEnabled as bool?);
    }
    if (data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = data['hasIssuesEnabled'];
      result$data['hasIssuesEnabled'] = (l$hasIssuesEnabled as bool?);
    }
    if (data.containsKey('hasProjectsEnabled')) {
      final l$hasProjectsEnabled = data['hasProjectsEnabled'];
      result$data['hasProjectsEnabled'] = (l$hasProjectsEnabled as bool?);
    }
    if (data.containsKey('hasDiscussionsEnabled')) {
      final l$hasDiscussionsEnabled = data['hasDiscussionsEnabled'];
      result$data['hasDiscussionsEnabled'] = (l$hasDiscussionsEnabled as bool?);
    }
    if (data.containsKey('hasSponsorshipsEnabled')) {
      final l$hasSponsorshipsEnabled = data['hasSponsorshipsEnabled'];
      result$data['hasSponsorshipsEnabled'] =
          (l$hasSponsorshipsEnabled as bool?);
    }
    return Input$UpdateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  bool? get template => (_$data['template'] as bool?);

  String? get homepageUrl => (_$data['homepageUrl'] as String?);

  bool? get hasWikiEnabled => (_$data['hasWikiEnabled'] as bool?);

  bool? get hasIssuesEnabled => (_$data['hasIssuesEnabled'] as bool?);

  bool? get hasProjectsEnabled => (_$data['hasProjectsEnabled'] as bool?);

  bool? get hasDiscussionsEnabled => (_$data['hasDiscussionsEnabled'] as bool?);

  bool? get hasSponsorshipsEnabled =>
      (_$data['hasSponsorshipsEnabled'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    if (_$data.containsKey('homepageUrl')) {
      final l$homepageUrl = homepageUrl;
      result$data['homepageUrl'] = l$homepageUrl;
    }
    if (_$data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = hasWikiEnabled;
      result$data['hasWikiEnabled'] = l$hasWikiEnabled;
    }
    if (_$data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = hasIssuesEnabled;
      result$data['hasIssuesEnabled'] = l$hasIssuesEnabled;
    }
    if (_$data.containsKey('hasProjectsEnabled')) {
      final l$hasProjectsEnabled = hasProjectsEnabled;
      result$data['hasProjectsEnabled'] = l$hasProjectsEnabled;
    }
    if (_$data.containsKey('hasDiscussionsEnabled')) {
      final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
      result$data['hasDiscussionsEnabled'] = l$hasDiscussionsEnabled;
    }
    if (_$data.containsKey('hasSponsorshipsEnabled')) {
      final l$hasSponsorshipsEnabled = hasSponsorshipsEnabled;
      result$data['hasSponsorshipsEnabled'] = l$hasSponsorshipsEnabled;
    }
    return result$data;
  }

  CopyWith$Input$UpdateRepositoryInput<Input$UpdateRepositoryInput>
      get copyWith => CopyWith$Input$UpdateRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$homepageUrl = homepageUrl;
    final lOther$homepageUrl = other.homepageUrl;
    if (_$data.containsKey('homepageUrl') !=
        other._$data.containsKey('homepageUrl')) {
      return false;
    }
    if (l$homepageUrl != lOther$homepageUrl) {
      return false;
    }
    final l$hasWikiEnabled = hasWikiEnabled;
    final lOther$hasWikiEnabled = other.hasWikiEnabled;
    if (_$data.containsKey('hasWikiEnabled') !=
        other._$data.containsKey('hasWikiEnabled')) {
      return false;
    }
    if (l$hasWikiEnabled != lOther$hasWikiEnabled) {
      return false;
    }
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final lOther$hasIssuesEnabled = other.hasIssuesEnabled;
    if (_$data.containsKey('hasIssuesEnabled') !=
        other._$data.containsKey('hasIssuesEnabled')) {
      return false;
    }
    if (l$hasIssuesEnabled != lOther$hasIssuesEnabled) {
      return false;
    }
    final l$hasProjectsEnabled = hasProjectsEnabled;
    final lOther$hasProjectsEnabled = other.hasProjectsEnabled;
    if (_$data.containsKey('hasProjectsEnabled') !=
        other._$data.containsKey('hasProjectsEnabled')) {
      return false;
    }
    if (l$hasProjectsEnabled != lOther$hasProjectsEnabled) {
      return false;
    }
    final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
    final lOther$hasDiscussionsEnabled = other.hasDiscussionsEnabled;
    if (_$data.containsKey('hasDiscussionsEnabled') !=
        other._$data.containsKey('hasDiscussionsEnabled')) {
      return false;
    }
    if (l$hasDiscussionsEnabled != lOther$hasDiscussionsEnabled) {
      return false;
    }
    final l$hasSponsorshipsEnabled = hasSponsorshipsEnabled;
    final lOther$hasSponsorshipsEnabled = other.hasSponsorshipsEnabled;
    if (_$data.containsKey('hasSponsorshipsEnabled') !=
        other._$data.containsKey('hasSponsorshipsEnabled')) {
      return false;
    }
    if (l$hasSponsorshipsEnabled != lOther$hasSponsorshipsEnabled) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$name = name;
    final l$description = description;
    final l$template = template;
    final l$homepageUrl = homepageUrl;
    final l$hasWikiEnabled = hasWikiEnabled;
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final l$hasProjectsEnabled = hasProjectsEnabled;
    final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
    final l$hasSponsorshipsEnabled = hasSponsorshipsEnabled;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('template') ? l$template : const {},
      _$data.containsKey('homepageUrl') ? l$homepageUrl : const {},
      _$data.containsKey('hasWikiEnabled') ? l$hasWikiEnabled : const {},
      _$data.containsKey('hasIssuesEnabled') ? l$hasIssuesEnabled : const {},
      _$data.containsKey('hasProjectsEnabled')
          ? l$hasProjectsEnabled
          : const {},
      _$data.containsKey('hasDiscussionsEnabled')
          ? l$hasDiscussionsEnabled
          : const {},
      _$data.containsKey('hasSponsorshipsEnabled')
          ? l$hasSponsorshipsEnabled
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRepositoryInput<TRes> {
  factory CopyWith$Input$UpdateRepositoryInput(
    Input$UpdateRepositoryInput instance,
    TRes Function(Input$UpdateRepositoryInput) then,
  ) = _CopyWithImpl$Input$UpdateRepositoryInput;

  factory CopyWith$Input$UpdateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? description,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasDiscussionsEnabled,
    bool? hasSponsorshipsEnabled,
  });
}

class _CopyWithImpl$Input$UpdateRepositoryInput<TRes>
    implements CopyWith$Input$UpdateRepositoryInput<TRes> {
  _CopyWithImpl$Input$UpdateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRepositoryInput _instance;

  final TRes Function(Input$UpdateRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? template = _undefined,
    Object? homepageUrl = _undefined,
    Object? hasWikiEnabled = _undefined,
    Object? hasIssuesEnabled = _undefined,
    Object? hasProjectsEnabled = _undefined,
    Object? hasDiscussionsEnabled = _undefined,
    Object? hasSponsorshipsEnabled = _undefined,
  }) =>
      _then(Input$UpdateRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (template != _undefined) 'template': (template as bool?),
        if (homepageUrl != _undefined) 'homepageUrl': (homepageUrl as String?),
        if (hasWikiEnabled != _undefined)
          'hasWikiEnabled': (hasWikiEnabled as bool?),
        if (hasIssuesEnabled != _undefined)
          'hasIssuesEnabled': (hasIssuesEnabled as bool?),
        if (hasProjectsEnabled != _undefined)
          'hasProjectsEnabled': (hasProjectsEnabled as bool?),
        if (hasDiscussionsEnabled != _undefined)
          'hasDiscussionsEnabled': (hasDiscussionsEnabled as bool?),
        if (hasSponsorshipsEnabled != _undefined)
          'hasSponsorshipsEnabled': (hasSponsorshipsEnabled as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateRepositoryInput<TRes>
    implements CopyWith$Input$UpdateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    String? name,
    String? description,
    bool? template,
    String? homepageUrl,
    bool? hasWikiEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasDiscussionsEnabled,
    bool? hasSponsorshipsEnabled,
  }) =>
      _res;
}

class Input$UpdateRepositoryRulesetInput {
  factory Input$UpdateRepositoryRulesetInput({
    String? clientMutationId,
    required String repositoryRulesetId,
    String? name,
    Enum$RepositoryRulesetTarget? target,
    List<Input$RepositoryRuleInput>? rules,
    Input$RepositoryRuleConditionsInput? conditions,
    Enum$RuleEnforcement? enforcement,
    List<Input$RepositoryRulesetBypassActorInput>? bypassActors,
  }) =>
      Input$UpdateRepositoryRulesetInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryRulesetId': repositoryRulesetId,
        if (name != null) r'name': name,
        if (target != null) r'target': target,
        if (rules != null) r'rules': rules,
        if (conditions != null) r'conditions': conditions,
        if (enforcement != null) r'enforcement': enforcement,
        if (bypassActors != null) r'bypassActors': bypassActors,
      });

  Input$UpdateRepositoryRulesetInput._(this._$data);

  factory Input$UpdateRepositoryRulesetInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryRulesetId = data['repositoryRulesetId'];
    result$data['repositoryRulesetId'] = (l$repositoryRulesetId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('target')) {
      final l$target = data['target'];
      result$data['target'] = l$target == null
          ? null
          : fromJson$Enum$RepositoryRulesetTarget((l$target as String));
    }
    if (data.containsKey('rules')) {
      final l$rules = data['rules'];
      result$data['rules'] = (l$rules as List<dynamic>?)
          ?.map((e) =>
              Input$RepositoryRuleInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('conditions')) {
      final l$conditions = data['conditions'];
      result$data['conditions'] = l$conditions == null
          ? null
          : Input$RepositoryRuleConditionsInput.fromJson(
              (l$conditions as Map<String, dynamic>));
    }
    if (data.containsKey('enforcement')) {
      final l$enforcement = data['enforcement'];
      result$data['enforcement'] = l$enforcement == null
          ? null
          : fromJson$Enum$RuleEnforcement((l$enforcement as String));
    }
    if (data.containsKey('bypassActors')) {
      final l$bypassActors = data['bypassActors'];
      result$data['bypassActors'] = (l$bypassActors as List<dynamic>?)
          ?.map((e) => Input$RepositoryRulesetBypassActorInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$UpdateRepositoryRulesetInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryRulesetId => (_$data['repositoryRulesetId'] as String);

  String? get name => (_$data['name'] as String?);

  Enum$RepositoryRulesetTarget? get target =>
      (_$data['target'] as Enum$RepositoryRulesetTarget?);

  List<Input$RepositoryRuleInput>? get rules =>
      (_$data['rules'] as List<Input$RepositoryRuleInput>?);

  Input$RepositoryRuleConditionsInput? get conditions =>
      (_$data['conditions'] as Input$RepositoryRuleConditionsInput?);

  Enum$RuleEnforcement? get enforcement =>
      (_$data['enforcement'] as Enum$RuleEnforcement?);

  List<Input$RepositoryRulesetBypassActorInput>? get bypassActors =>
      (_$data['bypassActors']
          as List<Input$RepositoryRulesetBypassActorInput>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryRulesetId = repositoryRulesetId;
    result$data['repositoryRulesetId'] = l$repositoryRulesetId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('target')) {
      final l$target = target;
      result$data['target'] = l$target == null
          ? null
          : toJson$Enum$RepositoryRulesetTarget(l$target);
    }
    if (_$data.containsKey('rules')) {
      final l$rules = rules;
      result$data['rules'] = l$rules?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('conditions')) {
      final l$conditions = conditions;
      result$data['conditions'] = l$conditions?.toJson();
    }
    if (_$data.containsKey('enforcement')) {
      final l$enforcement = enforcement;
      result$data['enforcement'] = l$enforcement == null
          ? null
          : toJson$Enum$RuleEnforcement(l$enforcement);
    }
    if (_$data.containsKey('bypassActors')) {
      final l$bypassActors = bypassActors;
      result$data['bypassActors'] =
          l$bypassActors?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateRepositoryRulesetInput<
          Input$UpdateRepositoryRulesetInput>
      get copyWith => CopyWith$Input$UpdateRepositoryRulesetInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateRepositoryRulesetInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryRulesetId = repositoryRulesetId;
    final lOther$repositoryRulesetId = other.repositoryRulesetId;
    if (l$repositoryRulesetId != lOther$repositoryRulesetId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$target = target;
    final lOther$target = other.target;
    if (_$data.containsKey('target') != other._$data.containsKey('target')) {
      return false;
    }
    if (l$target != lOther$target) {
      return false;
    }
    final l$rules = rules;
    final lOther$rules = other.rules;
    if (_$data.containsKey('rules') != other._$data.containsKey('rules')) {
      return false;
    }
    if (l$rules != null && lOther$rules != null) {
      if (l$rules.length != lOther$rules.length) {
        return false;
      }
      for (int i = 0; i < l$rules.length; i++) {
        final l$rules$entry = l$rules[i];
        final lOther$rules$entry = lOther$rules[i];
        if (l$rules$entry != lOther$rules$entry) {
          return false;
        }
      }
    } else if (l$rules != lOther$rules) {
      return false;
    }
    final l$conditions = conditions;
    final lOther$conditions = other.conditions;
    if (_$data.containsKey('conditions') !=
        other._$data.containsKey('conditions')) {
      return false;
    }
    if (l$conditions != lOther$conditions) {
      return false;
    }
    final l$enforcement = enforcement;
    final lOther$enforcement = other.enforcement;
    if (_$data.containsKey('enforcement') !=
        other._$data.containsKey('enforcement')) {
      return false;
    }
    if (l$enforcement != lOther$enforcement) {
      return false;
    }
    final l$bypassActors = bypassActors;
    final lOther$bypassActors = other.bypassActors;
    if (_$data.containsKey('bypassActors') !=
        other._$data.containsKey('bypassActors')) {
      return false;
    }
    if (l$bypassActors != null && lOther$bypassActors != null) {
      if (l$bypassActors.length != lOther$bypassActors.length) {
        return false;
      }
      for (int i = 0; i < l$bypassActors.length; i++) {
        final l$bypassActors$entry = l$bypassActors[i];
        final lOther$bypassActors$entry = lOther$bypassActors[i];
        if (l$bypassActors$entry != lOther$bypassActors$entry) {
          return false;
        }
      }
    } else if (l$bypassActors != lOther$bypassActors) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryRulesetId = repositoryRulesetId;
    final l$name = name;
    final l$target = target;
    final l$rules = rules;
    final l$conditions = conditions;
    final l$enforcement = enforcement;
    final l$bypassActors = bypassActors;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryRulesetId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('target') ? l$target : const {},
      _$data.containsKey('rules')
          ? l$rules == null
              ? null
              : Object.hashAll(l$rules.map((v) => v))
          : const {},
      _$data.containsKey('conditions') ? l$conditions : const {},
      _$data.containsKey('enforcement') ? l$enforcement : const {},
      _$data.containsKey('bypassActors')
          ? l$bypassActors == null
              ? null
              : Object.hashAll(l$bypassActors.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRepositoryRulesetInput<TRes> {
  factory CopyWith$Input$UpdateRepositoryRulesetInput(
    Input$UpdateRepositoryRulesetInput instance,
    TRes Function(Input$UpdateRepositoryRulesetInput) then,
  ) = _CopyWithImpl$Input$UpdateRepositoryRulesetInput;

  factory CopyWith$Input$UpdateRepositoryRulesetInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRepositoryRulesetInput;

  TRes call({
    String? clientMutationId,
    String? repositoryRulesetId,
    String? name,
    Enum$RepositoryRulesetTarget? target,
    List<Input$RepositoryRuleInput>? rules,
    Input$RepositoryRuleConditionsInput? conditions,
    Enum$RuleEnforcement? enforcement,
    List<Input$RepositoryRulesetBypassActorInput>? bypassActors,
  });
  TRes rules(
      Iterable<Input$RepositoryRuleInput>? Function(
              Iterable<
                  CopyWith$Input$RepositoryRuleInput<
                      Input$RepositoryRuleInput>>?)
          _fn);
  CopyWith$Input$RepositoryRuleConditionsInput<TRes> get conditions;
  TRes bypassActors(
      Iterable<Input$RepositoryRulesetBypassActorInput>? Function(
              Iterable<
                  CopyWith$Input$RepositoryRulesetBypassActorInput<
                      Input$RepositoryRulesetBypassActorInput>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateRepositoryRulesetInput<TRes>
    implements CopyWith$Input$UpdateRepositoryRulesetInput<TRes> {
  _CopyWithImpl$Input$UpdateRepositoryRulesetInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRepositoryRulesetInput _instance;

  final TRes Function(Input$UpdateRepositoryRulesetInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryRulesetId = _undefined,
    Object? name = _undefined,
    Object? target = _undefined,
    Object? rules = _undefined,
    Object? conditions = _undefined,
    Object? enforcement = _undefined,
    Object? bypassActors = _undefined,
  }) =>
      _then(Input$UpdateRepositoryRulesetInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryRulesetId != _undefined && repositoryRulesetId != null)
          'repositoryRulesetId': (repositoryRulesetId as String),
        if (name != _undefined) 'name': (name as String?),
        if (target != _undefined)
          'target': (target as Enum$RepositoryRulesetTarget?),
        if (rules != _undefined)
          'rules': (rules as List<Input$RepositoryRuleInput>?),
        if (conditions != _undefined)
          'conditions': (conditions as Input$RepositoryRuleConditionsInput?),
        if (enforcement != _undefined)
          'enforcement': (enforcement as Enum$RuleEnforcement?),
        if (bypassActors != _undefined)
          'bypassActors':
              (bypassActors as List<Input$RepositoryRulesetBypassActorInput>?),
      }));

  TRes rules(
          Iterable<Input$RepositoryRuleInput>? Function(
                  Iterable<
                      CopyWith$Input$RepositoryRuleInput<
                          Input$RepositoryRuleInput>>?)
              _fn) =>
      call(
          rules: _fn(
              _instance.rules?.map((e) => CopyWith$Input$RepositoryRuleInput(
                    e,
                    (i) => i,
                  )))?.toList());

  CopyWith$Input$RepositoryRuleConditionsInput<TRes> get conditions {
    final local$conditions = _instance.conditions;
    return local$conditions == null
        ? CopyWith$Input$RepositoryRuleConditionsInput.stub(_then(_instance))
        : CopyWith$Input$RepositoryRuleConditionsInput(
            local$conditions, (e) => call(conditions: e));
  }

  TRes bypassActors(
          Iterable<Input$RepositoryRulesetBypassActorInput>? Function(
                  Iterable<
                      CopyWith$Input$RepositoryRulesetBypassActorInput<
                          Input$RepositoryRulesetBypassActorInput>>?)
              _fn) =>
      call(
          bypassActors: _fn(_instance.bypassActors
              ?.map((e) => CopyWith$Input$RepositoryRulesetBypassActorInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateRepositoryRulesetInput<TRes>
    implements CopyWith$Input$UpdateRepositoryRulesetInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRepositoryRulesetInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryRulesetId,
    String? name,
    Enum$RepositoryRulesetTarget? target,
    List<Input$RepositoryRuleInput>? rules,
    Input$RepositoryRuleConditionsInput? conditions,
    Enum$RuleEnforcement? enforcement,
    List<Input$RepositoryRulesetBypassActorInput>? bypassActors,
  }) =>
      _res;

  rules(_fn) => _res;

  CopyWith$Input$RepositoryRuleConditionsInput<TRes> get conditions =>
      CopyWith$Input$RepositoryRuleConditionsInput.stub(_res);

  bypassActors(_fn) => _res;
}

class Input$UpdateRepositoryWebCommitSignoffSettingInput {
  factory Input$UpdateRepositoryWebCommitSignoffSettingInput({
    String? clientMutationId,
    required String repositoryId,
    required bool webCommitSignoffRequired,
  }) =>
      Input$UpdateRepositoryWebCommitSignoffSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'webCommitSignoffRequired': webCommitSignoffRequired,
      });

  Input$UpdateRepositoryWebCommitSignoffSettingInput._(this._$data);

  factory Input$UpdateRepositoryWebCommitSignoffSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$webCommitSignoffRequired = data['webCommitSignoffRequired'];
    result$data['webCommitSignoffRequired'] =
        (l$webCommitSignoffRequired as bool);
    return Input$UpdateRepositoryWebCommitSignoffSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  bool get webCommitSignoffRequired =>
      (_$data['webCommitSignoffRequired'] as bool);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    result$data['webCommitSignoffRequired'] = l$webCommitSignoffRequired;
    return result$data;
  }

  CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<
          Input$UpdateRepositoryWebCommitSignoffSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateRepositoryWebCommitSignoffSettingInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final lOther$webCommitSignoffRequired = other.webCommitSignoffRequired;
    if (l$webCommitSignoffRequired != lOther$webCommitSignoffRequired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$webCommitSignoffRequired,
    ]);
  }
}

abstract class CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput(
    Input$UpdateRepositoryWebCommitSignoffSettingInput instance,
    TRes Function(Input$UpdateRepositoryWebCommitSignoffSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput;

  factory CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    bool? webCommitSignoffRequired,
  });
}

class _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRepositoryWebCommitSignoffSettingInput _instance;

  final TRes Function(Input$UpdateRepositoryWebCommitSignoffSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? webCommitSignoffRequired = _undefined,
  }) =>
      _then(Input$UpdateRepositoryWebCommitSignoffSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (webCommitSignoffRequired != _undefined &&
            webCommitSignoffRequired != null)
          'webCommitSignoffRequired': (webCommitSignoffRequired as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    bool? webCommitSignoffRequired,
  }) =>
      _res;
}

class Input$UpdateSponsorshipPreferencesInput {
  factory Input$UpdateSponsorshipPreferencesInput({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
  }) =>
      Input$UpdateSponsorshipPreferencesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (receiveEmails != null) r'receiveEmails': receiveEmails,
        if (privacyLevel != null) r'privacyLevel': privacyLevel,
      });

  Input$UpdateSponsorshipPreferencesInput._(this._$data);

  factory Input$UpdateSponsorshipPreferencesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('receiveEmails')) {
      final l$receiveEmails = data['receiveEmails'];
      result$data['receiveEmails'] = (l$receiveEmails as bool?);
    }
    if (data.containsKey('privacyLevel')) {
      final l$privacyLevel = data['privacyLevel'];
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : fromJson$Enum$SponsorshipPrivacy((l$privacyLevel as String));
    }
    return Input$UpdateSponsorshipPreferencesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String? get sponsorId => (_$data['sponsorId'] as String?);

  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);

  String? get sponsorableId => (_$data['sponsorableId'] as String?);

  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);

  bool? get receiveEmails => (_$data['receiveEmails'] as bool?);

  Enum$SponsorshipPrivacy? get privacyLevel =>
      (_$data['privacyLevel'] as Enum$SponsorshipPrivacy?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('receiveEmails')) {
      final l$receiveEmails = receiveEmails;
      result$data['receiveEmails'] = l$receiveEmails;
    }
    if (_$data.containsKey('privacyLevel')) {
      final l$privacyLevel = privacyLevel;
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : toJson$Enum$SponsorshipPrivacy(l$privacyLevel);
    }
    return result$data;
  }

  CopyWith$Input$UpdateSponsorshipPreferencesInput<
          Input$UpdateSponsorshipPreferencesInput>
      get copyWith => CopyWith$Input$UpdateSponsorshipPreferencesInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateSponsorshipPreferencesInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$receiveEmails = receiveEmails;
    final lOther$receiveEmails = other.receiveEmails;
    if (_$data.containsKey('receiveEmails') !=
        other._$data.containsKey('receiveEmails')) {
      return false;
    }
    if (l$receiveEmails != lOther$receiveEmails) {
      return false;
    }
    final l$privacyLevel = privacyLevel;
    final lOther$privacyLevel = other.privacyLevel;
    if (_$data.containsKey('privacyLevel') !=
        other._$data.containsKey('privacyLevel')) {
      return false;
    }
    if (l$privacyLevel != lOther$privacyLevel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$receiveEmails = receiveEmails;
    final l$privacyLevel = privacyLevel;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('receiveEmails') ? l$receiveEmails : const {},
      _$data.containsKey('privacyLevel') ? l$privacyLevel : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  factory CopyWith$Input$UpdateSponsorshipPreferencesInput(
    Input$UpdateSponsorshipPreferencesInput instance,
    TRes Function(Input$UpdateSponsorshipPreferencesInput) then,
  ) = _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput;

  factory CopyWith$Input$UpdateSponsorshipPreferencesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput;

  TRes call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
  });
}

class _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput<TRes>
    implements CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSponsorshipPreferencesInput _instance;

  final TRes Function(Input$UpdateSponsorshipPreferencesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? receiveEmails = _undefined,
    Object? privacyLevel = _undefined,
  }) =>
      _then(Input$UpdateSponsorshipPreferencesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (receiveEmails != _undefined)
          'receiveEmails': (receiveEmails as bool?),
        if (privacyLevel != _undefined)
          'privacyLevel': (privacyLevel as Enum$SponsorshipPrivacy?),
      }));
}

class _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput<TRes>
    implements CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    bool? receiveEmails,
    Enum$SponsorshipPrivacy? privacyLevel,
  }) =>
      _res;
}

class Input$UpdateSubscriptionInput {
  factory Input$UpdateSubscriptionInput({
    String? clientMutationId,
    required String subscribableId,
    required Enum$SubscriptionState state,
  }) =>
      Input$UpdateSubscriptionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subscribableId': subscribableId,
        r'state': state,
      });

  Input$UpdateSubscriptionInput._(this._$data);

  factory Input$UpdateSubscriptionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subscribableId = data['subscribableId'];
    result$data['subscribableId'] = (l$subscribableId as String);
    final l$state = data['state'];
    result$data['state'] = fromJson$Enum$SubscriptionState((l$state as String));
    return Input$UpdateSubscriptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get subscribableId => (_$data['subscribableId'] as String);

  Enum$SubscriptionState get state =>
      (_$data['state'] as Enum$SubscriptionState);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subscribableId = subscribableId;
    result$data['subscribableId'] = l$subscribableId;
    final l$state = state;
    result$data['state'] = toJson$Enum$SubscriptionState(l$state);
    return result$data;
  }

  CopyWith$Input$UpdateSubscriptionInput<Input$UpdateSubscriptionInput>
      get copyWith => CopyWith$Input$UpdateSubscriptionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateSubscriptionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subscribableId = subscribableId;
    final lOther$subscribableId = other.subscribableId;
    if (l$subscribableId != lOther$subscribableId) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (l$state != lOther$state) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subscribableId = subscribableId;
    final l$state = state;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subscribableId,
      l$state,
    ]);
  }
}

abstract class CopyWith$Input$UpdateSubscriptionInput<TRes> {
  factory CopyWith$Input$UpdateSubscriptionInput(
    Input$UpdateSubscriptionInput instance,
    TRes Function(Input$UpdateSubscriptionInput) then,
  ) = _CopyWithImpl$Input$UpdateSubscriptionInput;

  factory CopyWith$Input$UpdateSubscriptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSubscriptionInput;

  TRes call({
    String? clientMutationId,
    String? subscribableId,
    Enum$SubscriptionState? state,
  });
}

class _CopyWithImpl$Input$UpdateSubscriptionInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionInput<TRes> {
  _CopyWithImpl$Input$UpdateSubscriptionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSubscriptionInput _instance;

  final TRes Function(Input$UpdateSubscriptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subscribableId = _undefined,
    Object? state = _undefined,
  }) =>
      _then(Input$UpdateSubscriptionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subscribableId != _undefined && subscribableId != null)
          'subscribableId': (subscribableId as String),
        if (state != _undefined && state != null)
          'state': (state as Enum$SubscriptionState),
      }));
}

class _CopyWithStubImpl$Input$UpdateSubscriptionInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSubscriptionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subscribableId,
    Enum$SubscriptionState? state,
  }) =>
      _res;
}

class Input$UpdateTeamDiscussionCommentInput {
  factory Input$UpdateTeamDiscussionCommentInput({
    String? clientMutationId,
    required String id,
    required String body,
    String? bodyVersion,
  }) =>
      Input$UpdateTeamDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'body': body,
        if (bodyVersion != null) r'bodyVersion': bodyVersion,
      });

  Input$UpdateTeamDiscussionCommentInput._(this._$data);

  factory Input$UpdateTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('bodyVersion')) {
      final l$bodyVersion = data['bodyVersion'];
      result$data['bodyVersion'] = (l$bodyVersion as String?);
    }
    return Input$UpdateTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  String get body => (_$data['body'] as String);

  String? get bodyVersion => (_$data['bodyVersion'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('bodyVersion')) {
      final l$bodyVersion = bodyVersion;
      result$data['bodyVersion'] = l$bodyVersion;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamDiscussionCommentInput<
          Input$UpdateTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$UpdateTeamDiscussionCommentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateTeamDiscussionCommentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$bodyVersion = bodyVersion;
    final lOther$bodyVersion = other.bodyVersion;
    if (_$data.containsKey('bodyVersion') !=
        other._$data.containsKey('bodyVersion')) {
      return false;
    }
    if (l$bodyVersion != lOther$bodyVersion) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$body = body;
    final l$bodyVersion = bodyVersion;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$body,
      _$data.containsKey('bodyVersion') ? l$bodyVersion : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$UpdateTeamDiscussionCommentInput(
    Input$UpdateTeamDiscussionCommentInput instance,
    TRes Function(Input$UpdateTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput;

  factory CopyWith$Input$UpdateTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? body,
    String? bodyVersion,
  });
}

class _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamDiscussionCommentInput _instance;

  final TRes Function(Input$UpdateTeamDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? body = _undefined,
    Object? bodyVersion = _undefined,
  }) =>
      _then(Input$UpdateTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (body != _undefined && body != null) 'body': (body as String),
        if (bodyVersion != _undefined) 'bodyVersion': (bodyVersion as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? body,
    String? bodyVersion,
  }) =>
      _res;
}

class Input$UpdateTeamDiscussionInput {
  factory Input$UpdateTeamDiscussionInput({
    String? clientMutationId,
    required String id,
    String? title,
    String? body,
    String? bodyVersion,
    bool? pinned,
  }) =>
      Input$UpdateTeamDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (title != null) r'title': title,
        if (body != null) r'body': body,
        if (bodyVersion != null) r'bodyVersion': bodyVersion,
        if (pinned != null) r'pinned': pinned,
      });

  Input$UpdateTeamDiscussionInput._(this._$data);

  factory Input$UpdateTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('bodyVersion')) {
      final l$bodyVersion = data['bodyVersion'];
      result$data['bodyVersion'] = (l$bodyVersion as String?);
    }
    if (data.containsKey('pinned')) {
      final l$pinned = data['pinned'];
      result$data['pinned'] = (l$pinned as bool?);
    }
    return Input$UpdateTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  String? get title => (_$data['title'] as String?);

  String? get body => (_$data['body'] as String?);

  String? get bodyVersion => (_$data['bodyVersion'] as String?);

  bool? get pinned => (_$data['pinned'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('bodyVersion')) {
      final l$bodyVersion = bodyVersion;
      result$data['bodyVersion'] = l$bodyVersion;
    }
    if (_$data.containsKey('pinned')) {
      final l$pinned = pinned;
      result$data['pinned'] = l$pinned;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamDiscussionInput<Input$UpdateTeamDiscussionInput>
      get copyWith => CopyWith$Input$UpdateTeamDiscussionInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateTeamDiscussionInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$bodyVersion = bodyVersion;
    final lOther$bodyVersion = other.bodyVersion;
    if (_$data.containsKey('bodyVersion') !=
        other._$data.containsKey('bodyVersion')) {
      return false;
    }
    if (l$bodyVersion != lOther$bodyVersion) {
      return false;
    }
    final l$pinned = pinned;
    final lOther$pinned = other.pinned;
    if (_$data.containsKey('pinned') != other._$data.containsKey('pinned')) {
      return false;
    }
    if (l$pinned != lOther$pinned) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$title = title;
    final l$body = body;
    final l$bodyVersion = bodyVersion;
    final l$pinned = pinned;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('title') ? l$title : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('bodyVersion') ? l$bodyVersion : const {},
      _$data.containsKey('pinned') ? l$pinned : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  factory CopyWith$Input$UpdateTeamDiscussionInput(
    Input$UpdateTeamDiscussionInput instance,
    TRes Function(Input$UpdateTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamDiscussionInput;

  factory CopyWith$Input$UpdateTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? id,
    String? title,
    String? body,
    String? bodyVersion,
    bool? pinned,
  });
}

class _CopyWithImpl$Input$UpdateTeamDiscussionInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamDiscussionInput _instance;

  final TRes Function(Input$UpdateTeamDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? title = _undefined,
    Object? body = _undefined,
    Object? bodyVersion = _undefined,
    Object? pinned = _undefined,
  }) =>
      _then(Input$UpdateTeamDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (title != _undefined) 'title': (title as String?),
        if (body != _undefined) 'body': (body as String?),
        if (bodyVersion != _undefined) 'bodyVersion': (bodyVersion as String?),
        if (pinned != _undefined) 'pinned': (pinned as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamDiscussionInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    String? title,
    String? body,
    String? bodyVersion,
    bool? pinned,
  }) =>
      _res;
}

class Input$UpdateTeamReviewAssignmentInput {
  factory Input$UpdateTeamReviewAssignmentInput({
    String? clientMutationId,
    required String id,
    required bool enabled,
    Enum$TeamReviewAssignmentAlgorithm? algorithm,
    int? teamMemberCount,
    bool? notifyTeam,
    bool? removeTeamRequest,
    bool? includeChildTeamMembers,
    bool? countMembersAlreadyRequested,
    List<String>? excludedTeamMemberIds,
  }) =>
      Input$UpdateTeamReviewAssignmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        r'enabled': enabled,
        if (algorithm != null) r'algorithm': algorithm,
        if (teamMemberCount != null) r'teamMemberCount': teamMemberCount,
        if (notifyTeam != null) r'notifyTeam': notifyTeam,
        if (removeTeamRequest != null) r'removeTeamRequest': removeTeamRequest,
        if (includeChildTeamMembers != null)
          r'includeChildTeamMembers': includeChildTeamMembers,
        if (countMembersAlreadyRequested != null)
          r'countMembersAlreadyRequested': countMembersAlreadyRequested,
        if (excludedTeamMemberIds != null)
          r'excludedTeamMemberIds': excludedTeamMemberIds,
      });

  Input$UpdateTeamReviewAssignmentInput._(this._$data);

  factory Input$UpdateTeamReviewAssignmentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    final l$enabled = data['enabled'];
    result$data['enabled'] = (l$enabled as bool);
    if (data.containsKey('algorithm')) {
      final l$algorithm = data['algorithm'];
      result$data['algorithm'] = l$algorithm == null
          ? null
          : fromJson$Enum$TeamReviewAssignmentAlgorithm(
              (l$algorithm as String));
    }
    if (data.containsKey('teamMemberCount')) {
      final l$teamMemberCount = data['teamMemberCount'];
      result$data['teamMemberCount'] = (l$teamMemberCount as int?);
    }
    if (data.containsKey('notifyTeam')) {
      final l$notifyTeam = data['notifyTeam'];
      result$data['notifyTeam'] = (l$notifyTeam as bool?);
    }
    if (data.containsKey('removeTeamRequest')) {
      final l$removeTeamRequest = data['removeTeamRequest'];
      result$data['removeTeamRequest'] = (l$removeTeamRequest as bool?);
    }
    if (data.containsKey('includeChildTeamMembers')) {
      final l$includeChildTeamMembers = data['includeChildTeamMembers'];
      result$data['includeChildTeamMembers'] =
          (l$includeChildTeamMembers as bool?);
    }
    if (data.containsKey('countMembersAlreadyRequested')) {
      final l$countMembersAlreadyRequested =
          data['countMembersAlreadyRequested'];
      result$data['countMembersAlreadyRequested'] =
          (l$countMembersAlreadyRequested as bool?);
    }
    if (data.containsKey('excludedTeamMemberIds')) {
      final l$excludedTeamMemberIds = data['excludedTeamMemberIds'];
      result$data['excludedTeamMemberIds'] =
          (l$excludedTeamMemberIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    return Input$UpdateTeamReviewAssignmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  bool get enabled => (_$data['enabled'] as bool);

  Enum$TeamReviewAssignmentAlgorithm? get algorithm =>
      (_$data['algorithm'] as Enum$TeamReviewAssignmentAlgorithm?);

  int? get teamMemberCount => (_$data['teamMemberCount'] as int?);

  bool? get notifyTeam => (_$data['notifyTeam'] as bool?);

  bool? get removeTeamRequest => (_$data['removeTeamRequest'] as bool?);

  bool? get includeChildTeamMembers =>
      (_$data['includeChildTeamMembers'] as bool?);

  bool? get countMembersAlreadyRequested =>
      (_$data['countMembersAlreadyRequested'] as bool?);

  List<String>? get excludedTeamMemberIds =>
      (_$data['excludedTeamMemberIds'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    final l$enabled = enabled;
    result$data['enabled'] = l$enabled;
    if (_$data.containsKey('algorithm')) {
      final l$algorithm = algorithm;
      result$data['algorithm'] = l$algorithm == null
          ? null
          : toJson$Enum$TeamReviewAssignmentAlgorithm(l$algorithm);
    }
    if (_$data.containsKey('teamMemberCount')) {
      final l$teamMemberCount = teamMemberCount;
      result$data['teamMemberCount'] = l$teamMemberCount;
    }
    if (_$data.containsKey('notifyTeam')) {
      final l$notifyTeam = notifyTeam;
      result$data['notifyTeam'] = l$notifyTeam;
    }
    if (_$data.containsKey('removeTeamRequest')) {
      final l$removeTeamRequest = removeTeamRequest;
      result$data['removeTeamRequest'] = l$removeTeamRequest;
    }
    if (_$data.containsKey('includeChildTeamMembers')) {
      final l$includeChildTeamMembers = includeChildTeamMembers;
      result$data['includeChildTeamMembers'] = l$includeChildTeamMembers;
    }
    if (_$data.containsKey('countMembersAlreadyRequested')) {
      final l$countMembersAlreadyRequested = countMembersAlreadyRequested;
      result$data['countMembersAlreadyRequested'] =
          l$countMembersAlreadyRequested;
    }
    if (_$data.containsKey('excludedTeamMemberIds')) {
      final l$excludedTeamMemberIds = excludedTeamMemberIds;
      result$data['excludedTeamMemberIds'] =
          l$excludedTeamMemberIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamReviewAssignmentInput<
          Input$UpdateTeamReviewAssignmentInput>
      get copyWith => CopyWith$Input$UpdateTeamReviewAssignmentInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateTeamReviewAssignmentInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$enabled = enabled;
    final lOther$enabled = other.enabled;
    if (l$enabled != lOther$enabled) {
      return false;
    }
    final l$algorithm = algorithm;
    final lOther$algorithm = other.algorithm;
    if (_$data.containsKey('algorithm') !=
        other._$data.containsKey('algorithm')) {
      return false;
    }
    if (l$algorithm != lOther$algorithm) {
      return false;
    }
    final l$teamMemberCount = teamMemberCount;
    final lOther$teamMemberCount = other.teamMemberCount;
    if (_$data.containsKey('teamMemberCount') !=
        other._$data.containsKey('teamMemberCount')) {
      return false;
    }
    if (l$teamMemberCount != lOther$teamMemberCount) {
      return false;
    }
    final l$notifyTeam = notifyTeam;
    final lOther$notifyTeam = other.notifyTeam;
    if (_$data.containsKey('notifyTeam') !=
        other._$data.containsKey('notifyTeam')) {
      return false;
    }
    if (l$notifyTeam != lOther$notifyTeam) {
      return false;
    }
    final l$removeTeamRequest = removeTeamRequest;
    final lOther$removeTeamRequest = other.removeTeamRequest;
    if (_$data.containsKey('removeTeamRequest') !=
        other._$data.containsKey('removeTeamRequest')) {
      return false;
    }
    if (l$removeTeamRequest != lOther$removeTeamRequest) {
      return false;
    }
    final l$includeChildTeamMembers = includeChildTeamMembers;
    final lOther$includeChildTeamMembers = other.includeChildTeamMembers;
    if (_$data.containsKey('includeChildTeamMembers') !=
        other._$data.containsKey('includeChildTeamMembers')) {
      return false;
    }
    if (l$includeChildTeamMembers != lOther$includeChildTeamMembers) {
      return false;
    }
    final l$countMembersAlreadyRequested = countMembersAlreadyRequested;
    final lOther$countMembersAlreadyRequested =
        other.countMembersAlreadyRequested;
    if (_$data.containsKey('countMembersAlreadyRequested') !=
        other._$data.containsKey('countMembersAlreadyRequested')) {
      return false;
    }
    if (l$countMembersAlreadyRequested != lOther$countMembersAlreadyRequested) {
      return false;
    }
    final l$excludedTeamMemberIds = excludedTeamMemberIds;
    final lOther$excludedTeamMemberIds = other.excludedTeamMemberIds;
    if (_$data.containsKey('excludedTeamMemberIds') !=
        other._$data.containsKey('excludedTeamMemberIds')) {
      return false;
    }
    if (l$excludedTeamMemberIds != null &&
        lOther$excludedTeamMemberIds != null) {
      if (l$excludedTeamMemberIds.length !=
          lOther$excludedTeamMemberIds.length) {
        return false;
      }
      for (int i = 0; i < l$excludedTeamMemberIds.length; i++) {
        final l$excludedTeamMemberIds$entry = l$excludedTeamMemberIds[i];
        final lOther$excludedTeamMemberIds$entry =
            lOther$excludedTeamMemberIds[i];
        if (l$excludedTeamMemberIds$entry !=
            lOther$excludedTeamMemberIds$entry) {
          return false;
        }
      }
    } else if (l$excludedTeamMemberIds != lOther$excludedTeamMemberIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$enabled = enabled;
    final l$algorithm = algorithm;
    final l$teamMemberCount = teamMemberCount;
    final l$notifyTeam = notifyTeam;
    final l$removeTeamRequest = removeTeamRequest;
    final l$includeChildTeamMembers = includeChildTeamMembers;
    final l$countMembersAlreadyRequested = countMembersAlreadyRequested;
    final l$excludedTeamMemberIds = excludedTeamMemberIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      l$enabled,
      _$data.containsKey('algorithm') ? l$algorithm : const {},
      _$data.containsKey('teamMemberCount') ? l$teamMemberCount : const {},
      _$data.containsKey('notifyTeam') ? l$notifyTeam : const {},
      _$data.containsKey('removeTeamRequest') ? l$removeTeamRequest : const {},
      _$data.containsKey('includeChildTeamMembers')
          ? l$includeChildTeamMembers
          : const {},
      _$data.containsKey('countMembersAlreadyRequested')
          ? l$countMembersAlreadyRequested
          : const {},
      _$data.containsKey('excludedTeamMemberIds')
          ? l$excludedTeamMemberIds == null
              ? null
              : Object.hashAll(l$excludedTeamMemberIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamReviewAssignmentInput<TRes> {
  factory CopyWith$Input$UpdateTeamReviewAssignmentInput(
    Input$UpdateTeamReviewAssignmentInput instance,
    TRes Function(Input$UpdateTeamReviewAssignmentInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamReviewAssignmentInput;

  factory CopyWith$Input$UpdateTeamReviewAssignmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamReviewAssignmentInput;

  TRes call({
    String? clientMutationId,
    String? id,
    bool? enabled,
    Enum$TeamReviewAssignmentAlgorithm? algorithm,
    int? teamMemberCount,
    bool? notifyTeam,
    bool? removeTeamRequest,
    bool? includeChildTeamMembers,
    bool? countMembersAlreadyRequested,
    List<String>? excludedTeamMemberIds,
  });
}

class _CopyWithImpl$Input$UpdateTeamReviewAssignmentInput<TRes>
    implements CopyWith$Input$UpdateTeamReviewAssignmentInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamReviewAssignmentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamReviewAssignmentInput _instance;

  final TRes Function(Input$UpdateTeamReviewAssignmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? enabled = _undefined,
    Object? algorithm = _undefined,
    Object? teamMemberCount = _undefined,
    Object? notifyTeam = _undefined,
    Object? removeTeamRequest = _undefined,
    Object? includeChildTeamMembers = _undefined,
    Object? countMembersAlreadyRequested = _undefined,
    Object? excludedTeamMemberIds = _undefined,
  }) =>
      _then(Input$UpdateTeamReviewAssignmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (enabled != _undefined && enabled != null)
          'enabled': (enabled as bool),
        if (algorithm != _undefined)
          'algorithm': (algorithm as Enum$TeamReviewAssignmentAlgorithm?),
        if (teamMemberCount != _undefined)
          'teamMemberCount': (teamMemberCount as int?),
        if (notifyTeam != _undefined) 'notifyTeam': (notifyTeam as bool?),
        if (removeTeamRequest != _undefined)
          'removeTeamRequest': (removeTeamRequest as bool?),
        if (includeChildTeamMembers != _undefined)
          'includeChildTeamMembers': (includeChildTeamMembers as bool?),
        if (countMembersAlreadyRequested != _undefined)
          'countMembersAlreadyRequested':
              (countMembersAlreadyRequested as bool?),
        if (excludedTeamMemberIds != _undefined)
          'excludedTeamMemberIds': (excludedTeamMemberIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamReviewAssignmentInput<TRes>
    implements CopyWith$Input$UpdateTeamReviewAssignmentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamReviewAssignmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
    bool? enabled,
    Enum$TeamReviewAssignmentAlgorithm? algorithm,
    int? teamMemberCount,
    bool? notifyTeam,
    bool? removeTeamRequest,
    bool? includeChildTeamMembers,
    bool? countMembersAlreadyRequested,
    List<String>? excludedTeamMemberIds,
  }) =>
      _res;
}

class Input$UpdateTeamsRepositoryInput {
  factory Input$UpdateTeamsRepositoryInput({
    String? clientMutationId,
    required String repositoryId,
    required List<String> teamIds,
    required Enum$RepositoryPermission permission,
  }) =>
      Input$UpdateTeamsRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'teamIds': teamIds,
        r'permission': permission,
      });

  Input$UpdateTeamsRepositoryInput._(this._$data);

  factory Input$UpdateTeamsRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$teamIds = data['teamIds'];
    result$data['teamIds'] =
        (l$teamIds as List<dynamic>).map((e) => (e as String)).toList();
    final l$permission = data['permission'];
    result$data['permission'] =
        fromJson$Enum$RepositoryPermission((l$permission as String));
    return Input$UpdateTeamsRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  List<String> get teamIds => (_$data['teamIds'] as List<String>);

  Enum$RepositoryPermission get permission =>
      (_$data['permission'] as Enum$RepositoryPermission);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$teamIds = teamIds;
    result$data['teamIds'] = l$teamIds.map((e) => e).toList();
    final l$permission = permission;
    result$data['permission'] = toJson$Enum$RepositoryPermission(l$permission);
    return result$data;
  }

  CopyWith$Input$UpdateTeamsRepositoryInput<Input$UpdateTeamsRepositoryInput>
      get copyWith => CopyWith$Input$UpdateTeamsRepositoryInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateTeamsRepositoryInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$teamIds = teamIds;
    final lOther$teamIds = other.teamIds;
    if (l$teamIds.length != lOther$teamIds.length) {
      return false;
    }
    for (int i = 0; i < l$teamIds.length; i++) {
      final l$teamIds$entry = l$teamIds[i];
      final lOther$teamIds$entry = lOther$teamIds[i];
      if (l$teamIds$entry != lOther$teamIds$entry) {
        return false;
      }
    }
    final l$permission = permission;
    final lOther$permission = other.permission;
    if (l$permission != lOther$permission) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$teamIds = teamIds;
    final l$permission = permission;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      Object.hashAll(l$teamIds.map((v) => v)),
      l$permission,
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  factory CopyWith$Input$UpdateTeamsRepositoryInput(
    Input$UpdateTeamsRepositoryInput instance,
    TRes Function(Input$UpdateTeamsRepositoryInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamsRepositoryInput;

  factory CopyWith$Input$UpdateTeamsRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    List<String>? teamIds,
    Enum$RepositoryPermission? permission,
  });
}

class _CopyWithImpl$Input$UpdateTeamsRepositoryInput<TRes>
    implements CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamsRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamsRepositoryInput _instance;

  final TRes Function(Input$UpdateTeamsRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? teamIds = _undefined,
    Object? permission = _undefined,
  }) =>
      _then(Input$UpdateTeamsRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (teamIds != _undefined && teamIds != null)
          'teamIds': (teamIds as List<String>),
        if (permission != _undefined && permission != null)
          'permission': (permission as Enum$RepositoryPermission),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput<TRes>
    implements CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    List<String>? teamIds,
    Enum$RepositoryPermission? permission,
  }) =>
      _res;
}

class Input$UpdateTopicsInput {
  factory Input$UpdateTopicsInput({
    String? clientMutationId,
    required String repositoryId,
    required List<String> topicNames,
  }) =>
      Input$UpdateTopicsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'topicNames': topicNames,
      });

  Input$UpdateTopicsInput._(this._$data);

  factory Input$UpdateTopicsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$topicNames = data['topicNames'];
    result$data['topicNames'] =
        (l$topicNames as List<dynamic>).map((e) => (e as String)).toList();
    return Input$UpdateTopicsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get repositoryId => (_$data['repositoryId'] as String);

  List<String> get topicNames => (_$data['topicNames'] as List<String>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$topicNames = topicNames;
    result$data['topicNames'] = l$topicNames.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$UpdateTopicsInput<Input$UpdateTopicsInput> get copyWith =>
      CopyWith$Input$UpdateTopicsInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateTopicsInput || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$topicNames = topicNames;
    final lOther$topicNames = other.topicNames;
    if (l$topicNames.length != lOther$topicNames.length) {
      return false;
    }
    for (int i = 0; i < l$topicNames.length; i++) {
      final l$topicNames$entry = l$topicNames[i];
      final lOther$topicNames$entry = lOther$topicNames[i];
      if (l$topicNames$entry != lOther$topicNames$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$topicNames = topicNames;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      Object.hashAll(l$topicNames.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$UpdateTopicsInput<TRes> {
  factory CopyWith$Input$UpdateTopicsInput(
    Input$UpdateTopicsInput instance,
    TRes Function(Input$UpdateTopicsInput) then,
  ) = _CopyWithImpl$Input$UpdateTopicsInput;

  factory CopyWith$Input$UpdateTopicsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTopicsInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    List<String>? topicNames,
  });
}

class _CopyWithImpl$Input$UpdateTopicsInput<TRes>
    implements CopyWith$Input$UpdateTopicsInput<TRes> {
  _CopyWithImpl$Input$UpdateTopicsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTopicsInput _instance;

  final TRes Function(Input$UpdateTopicsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? topicNames = _undefined,
  }) =>
      _then(Input$UpdateTopicsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (topicNames != _undefined && topicNames != null)
          'topicNames': (topicNames as List<String>),
      }));
}

class _CopyWithStubImpl$Input$UpdateTopicsInput<TRes>
    implements CopyWith$Input$UpdateTopicsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTopicsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    List<String>? topicNames,
  }) =>
      _res;
}

class Input$UpdateUserListInput {
  factory Input$UpdateUserListInput({
    String? clientMutationId,
    required String listId,
    String? name,
    String? description,
    bool? isPrivate,
  }) =>
      Input$UpdateUserListInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'listId': listId,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (isPrivate != null) r'isPrivate': isPrivate,
      });

  Input$UpdateUserListInput._(this._$data);

  factory Input$UpdateUserListInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$listId = data['listId'];
    result$data['listId'] = (l$listId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('isPrivate')) {
      final l$isPrivate = data['isPrivate'];
      result$data['isPrivate'] = (l$isPrivate as bool?);
    }
    return Input$UpdateUserListInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get listId => (_$data['listId'] as String);

  String? get name => (_$data['name'] as String?);

  String? get description => (_$data['description'] as String?);

  bool? get isPrivate => (_$data['isPrivate'] as bool?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$listId = listId;
    result$data['listId'] = l$listId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('isPrivate')) {
      final l$isPrivate = isPrivate;
      result$data['isPrivate'] = l$isPrivate;
    }
    return result$data;
  }

  CopyWith$Input$UpdateUserListInput<Input$UpdateUserListInput> get copyWith =>
      CopyWith$Input$UpdateUserListInput(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateUserListInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$listId = listId;
    final lOther$listId = other.listId;
    if (l$listId != lOther$listId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$isPrivate = isPrivate;
    final lOther$isPrivate = other.isPrivate;
    if (_$data.containsKey('isPrivate') !=
        other._$data.containsKey('isPrivate')) {
      return false;
    }
    if (l$isPrivate != lOther$isPrivate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$listId = listId;
    final l$name = name;
    final l$description = description;
    final l$isPrivate = isPrivate;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$listId,
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('isPrivate') ? l$isPrivate : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateUserListInput<TRes> {
  factory CopyWith$Input$UpdateUserListInput(
    Input$UpdateUserListInput instance,
    TRes Function(Input$UpdateUserListInput) then,
  ) = _CopyWithImpl$Input$UpdateUserListInput;

  factory CopyWith$Input$UpdateUserListInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateUserListInput;

  TRes call({
    String? clientMutationId,
    String? listId,
    String? name,
    String? description,
    bool? isPrivate,
  });
}

class _CopyWithImpl$Input$UpdateUserListInput<TRes>
    implements CopyWith$Input$UpdateUserListInput<TRes> {
  _CopyWithImpl$Input$UpdateUserListInput(
    this._instance,
    this._then,
  );

  final Input$UpdateUserListInput _instance;

  final TRes Function(Input$UpdateUserListInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? listId = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? isPrivate = _undefined,
  }) =>
      _then(Input$UpdateUserListInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (listId != _undefined && listId != null)
          'listId': (listId as String),
        if (name != _undefined) 'name': (name as String?),
        if (description != _undefined) 'description': (description as String?),
        if (isPrivate != _undefined) 'isPrivate': (isPrivate as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateUserListInput<TRes>
    implements CopyWith$Input$UpdateUserListInput<TRes> {
  _CopyWithStubImpl$Input$UpdateUserListInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? listId,
    String? name,
    String? description,
    bool? isPrivate,
  }) =>
      _res;
}

class Input$UpdateUserListsForItemInput {
  factory Input$UpdateUserListsForItemInput({
    String? clientMutationId,
    required String itemId,
    required List<String> listIds,
    List<String>? suggestedListIds,
  }) =>
      Input$UpdateUserListsForItemInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'itemId': itemId,
        r'listIds': listIds,
        if (suggestedListIds != null) r'suggestedListIds': suggestedListIds,
      });

  Input$UpdateUserListsForItemInput._(this._$data);

  factory Input$UpdateUserListsForItemInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$listIds = data['listIds'];
    result$data['listIds'] =
        (l$listIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('suggestedListIds')) {
      final l$suggestedListIds = data['suggestedListIds'];
      result$data['suggestedListIds'] = (l$suggestedListIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    return Input$UpdateUserListsForItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get itemId => (_$data['itemId'] as String);

  List<String> get listIds => (_$data['listIds'] as List<String>);

  List<String>? get suggestedListIds =>
      (_$data['suggestedListIds'] as List<String>?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$listIds = listIds;
    result$data['listIds'] = l$listIds.map((e) => e).toList();
    if (_$data.containsKey('suggestedListIds')) {
      final l$suggestedListIds = suggestedListIds;
      result$data['suggestedListIds'] =
          l$suggestedListIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateUserListsForItemInput<Input$UpdateUserListsForItemInput>
      get copyWith => CopyWith$Input$UpdateUserListsForItemInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UpdateUserListsForItemInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$listIds = listIds;
    final lOther$listIds = other.listIds;
    if (l$listIds.length != lOther$listIds.length) {
      return false;
    }
    for (int i = 0; i < l$listIds.length; i++) {
      final l$listIds$entry = l$listIds[i];
      final lOther$listIds$entry = lOther$listIds[i];
      if (l$listIds$entry != lOther$listIds$entry) {
        return false;
      }
    }
    final l$suggestedListIds = suggestedListIds;
    final lOther$suggestedListIds = other.suggestedListIds;
    if (_$data.containsKey('suggestedListIds') !=
        other._$data.containsKey('suggestedListIds')) {
      return false;
    }
    if (l$suggestedListIds != null && lOther$suggestedListIds != null) {
      if (l$suggestedListIds.length != lOther$suggestedListIds.length) {
        return false;
      }
      for (int i = 0; i < l$suggestedListIds.length; i++) {
        final l$suggestedListIds$entry = l$suggestedListIds[i];
        final lOther$suggestedListIds$entry = lOther$suggestedListIds[i];
        if (l$suggestedListIds$entry != lOther$suggestedListIds$entry) {
          return false;
        }
      }
    } else if (l$suggestedListIds != lOther$suggestedListIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$itemId = itemId;
    final l$listIds = listIds;
    final l$suggestedListIds = suggestedListIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$itemId,
      Object.hashAll(l$listIds.map((v) => v)),
      _$data.containsKey('suggestedListIds')
          ? l$suggestedListIds == null
              ? null
              : Object.hashAll(l$suggestedListIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateUserListsForItemInput<TRes> {
  factory CopyWith$Input$UpdateUserListsForItemInput(
    Input$UpdateUserListsForItemInput instance,
    TRes Function(Input$UpdateUserListsForItemInput) then,
  ) = _CopyWithImpl$Input$UpdateUserListsForItemInput;

  factory CopyWith$Input$UpdateUserListsForItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateUserListsForItemInput;

  TRes call({
    String? clientMutationId,
    String? itemId,
    List<String>? listIds,
    List<String>? suggestedListIds,
  });
}

class _CopyWithImpl$Input$UpdateUserListsForItemInput<TRes>
    implements CopyWith$Input$UpdateUserListsForItemInput<TRes> {
  _CopyWithImpl$Input$UpdateUserListsForItemInput(
    this._instance,
    this._then,
  );

  final Input$UpdateUserListsForItemInput _instance;

  final TRes Function(Input$UpdateUserListsForItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? itemId = _undefined,
    Object? listIds = _undefined,
    Object? suggestedListIds = _undefined,
  }) =>
      _then(Input$UpdateUserListsForItemInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (listIds != _undefined && listIds != null)
          'listIds': (listIds as List<String>),
        if (suggestedListIds != _undefined)
          'suggestedListIds': (suggestedListIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$UpdateUserListsForItemInput<TRes>
    implements CopyWith$Input$UpdateUserListsForItemInput<TRes> {
  _CopyWithStubImpl$Input$UpdateUserListsForItemInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? itemId,
    List<String>? listIds,
    List<String>? suggestedListIds,
  }) =>
      _res;
}

class Input$UserStatusOrder {
  factory Input$UserStatusOrder({
    required Enum$UserStatusOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$UserStatusOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$UserStatusOrder._(this._$data);

  factory Input$UserStatusOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$UserStatusOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$UserStatusOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserStatusOrderField get field =>
      (_$data['field'] as Enum$UserStatusOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$UserStatusOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$UserStatusOrder<Input$UserStatusOrder> get copyWith =>
      CopyWith$Input$UserStatusOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$UserStatusOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$UserStatusOrder<TRes> {
  factory CopyWith$Input$UserStatusOrder(
    Input$UserStatusOrder instance,
    TRes Function(Input$UserStatusOrder) then,
  ) = _CopyWithImpl$Input$UserStatusOrder;

  factory CopyWith$Input$UserStatusOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$UserStatusOrder;

  TRes call({
    Enum$UserStatusOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$UserStatusOrder<TRes>
    implements CopyWith$Input$UserStatusOrder<TRes> {
  _CopyWithImpl$Input$UserStatusOrder(
    this._instance,
    this._then,
  );

  final Input$UserStatusOrder _instance;

  final TRes Function(Input$UserStatusOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$UserStatusOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$UserStatusOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$UserStatusOrder<TRes>
    implements CopyWith$Input$UserStatusOrder<TRes> {
  _CopyWithStubImpl$Input$UserStatusOrder(this._res);

  TRes _res;

  call({
    Enum$UserStatusOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$VerifiableDomainOrder {
  factory Input$VerifiableDomainOrder({
    required Enum$VerifiableDomainOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$VerifiableDomainOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$VerifiableDomainOrder._(this._$data);

  factory Input$VerifiableDomainOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$VerifiableDomainOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$VerifiableDomainOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$VerifiableDomainOrderField get field =>
      (_$data['field'] as Enum$VerifiableDomainOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$VerifiableDomainOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$VerifiableDomainOrder<Input$VerifiableDomainOrder>
      get copyWith => CopyWith$Input$VerifiableDomainOrder(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$VerifiableDomainOrder ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$VerifiableDomainOrder<TRes> {
  factory CopyWith$Input$VerifiableDomainOrder(
    Input$VerifiableDomainOrder instance,
    TRes Function(Input$VerifiableDomainOrder) then,
  ) = _CopyWithImpl$Input$VerifiableDomainOrder;

  factory CopyWith$Input$VerifiableDomainOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$VerifiableDomainOrder;

  TRes call({
    Enum$VerifiableDomainOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$VerifiableDomainOrder<TRes>
    implements CopyWith$Input$VerifiableDomainOrder<TRes> {
  _CopyWithImpl$Input$VerifiableDomainOrder(
    this._instance,
    this._then,
  );

  final Input$VerifiableDomainOrder _instance;

  final TRes Function(Input$VerifiableDomainOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$VerifiableDomainOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$VerifiableDomainOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$VerifiableDomainOrder<TRes>
    implements CopyWith$Input$VerifiableDomainOrder<TRes> {
  _CopyWithStubImpl$Input$VerifiableDomainOrder(this._res);

  TRes _res;

  call({
    Enum$VerifiableDomainOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$VerifyVerifiableDomainInput {
  factory Input$VerifyVerifiableDomainInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$VerifyVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$VerifyVerifiableDomainInput._(this._$data);

  factory Input$VerifyVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$VerifyVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);

  String get id => (_$data['id'] as String);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$VerifyVerifiableDomainInput<Input$VerifyVerifiableDomainInput>
      get copyWith => CopyWith$Input$VerifyVerifiableDomainInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$VerifyVerifiableDomainInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  factory CopyWith$Input$VerifyVerifiableDomainInput(
    Input$VerifyVerifiableDomainInput instance,
    TRes Function(Input$VerifyVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$VerifyVerifiableDomainInput;

  factory CopyWith$Input$VerifyVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VerifyVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$VerifyVerifiableDomainInput<TRes>
    implements CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$VerifyVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$VerifyVerifiableDomainInput _instance;

  final TRes Function(Input$VerifyVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$VerifyVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$VerifyVerifiableDomainInput<TRes>
    implements CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$VerifyVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$WorkflowFileReferenceInput {
  factory Input$WorkflowFileReferenceInput({
    required String path,
    String? ref,
    required int repositoryId,
    String? sha,
  }) =>
      Input$WorkflowFileReferenceInput._({
        r'path': path,
        if (ref != null) r'ref': ref,
        r'repositoryId': repositoryId,
        if (sha != null) r'sha': sha,
      });

  Input$WorkflowFileReferenceInput._(this._$data);

  factory Input$WorkflowFileReferenceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('ref')) {
      final l$ref = data['ref'];
      result$data['ref'] = (l$ref as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as int);
    if (data.containsKey('sha')) {
      final l$sha = data['sha'];
      result$data['sha'] = (l$sha as String?);
    }
    return Input$WorkflowFileReferenceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);

  String? get ref => (_$data['ref'] as String?);

  int get repositoryId => (_$data['repositoryId'] as int);

  String? get sha => (_$data['sha'] as String?);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('ref')) {
      final l$ref = ref;
      result$data['ref'] = l$ref;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('sha')) {
      final l$sha = sha;
      result$data['sha'] = l$sha;
    }
    return result$data;
  }

  CopyWith$Input$WorkflowFileReferenceInput<Input$WorkflowFileReferenceInput>
      get copyWith => CopyWith$Input$WorkflowFileReferenceInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WorkflowFileReferenceInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$ref = ref;
    final lOther$ref = other.ref;
    if (_$data.containsKey('ref') != other._$data.containsKey('ref')) {
      return false;
    }
    if (l$ref != lOther$ref) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$sha = sha;
    final lOther$sha = other.sha;
    if (_$data.containsKey('sha') != other._$data.containsKey('sha')) {
      return false;
    }
    if (l$sha != lOther$sha) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$ref = ref;
    final l$repositoryId = repositoryId;
    final l$sha = sha;
    return Object.hashAll([
      l$path,
      _$data.containsKey('ref') ? l$ref : const {},
      l$repositoryId,
      _$data.containsKey('sha') ? l$sha : const {},
    ]);
  }
}

abstract class CopyWith$Input$WorkflowFileReferenceInput<TRes> {
  factory CopyWith$Input$WorkflowFileReferenceInput(
    Input$WorkflowFileReferenceInput instance,
    TRes Function(Input$WorkflowFileReferenceInput) then,
  ) = _CopyWithImpl$Input$WorkflowFileReferenceInput;

  factory CopyWith$Input$WorkflowFileReferenceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkflowFileReferenceInput;

  TRes call({
    String? path,
    String? ref,
    int? repositoryId,
    String? sha,
  });
}

class _CopyWithImpl$Input$WorkflowFileReferenceInput<TRes>
    implements CopyWith$Input$WorkflowFileReferenceInput<TRes> {
  _CopyWithImpl$Input$WorkflowFileReferenceInput(
    this._instance,
    this._then,
  );

  final Input$WorkflowFileReferenceInput _instance;

  final TRes Function(Input$WorkflowFileReferenceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? ref = _undefined,
    Object? repositoryId = _undefined,
    Object? sha = _undefined,
  }) =>
      _then(Input$WorkflowFileReferenceInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (ref != _undefined) 'ref': (ref as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as int),
        if (sha != _undefined) 'sha': (sha as String?),
      }));
}

class _CopyWithStubImpl$Input$WorkflowFileReferenceInput<TRes>
    implements CopyWith$Input$WorkflowFileReferenceInput<TRes> {
  _CopyWithStubImpl$Input$WorkflowFileReferenceInput(this._res);

  TRes _res;

  call({
    String? path,
    String? ref,
    int? repositoryId,
    String? sha,
  }) =>
      _res;
}

class Input$WorkflowRunOrder {
  factory Input$WorkflowRunOrder({
    required Enum$WorkflowRunOrderField field,
    required Enum$OrderDirection direction,
  }) =>
      Input$WorkflowRunOrder._({
        r'field': field,
        r'direction': direction,
      });

  Input$WorkflowRunOrder._(this._$data);

  factory Input$WorkflowRunOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$WorkflowRunOrderField((l$field as String));
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$WorkflowRunOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$WorkflowRunOrderField get field =>
      (_$data['field'] as Enum$WorkflowRunOrderField);

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$field = field;
    result$data['field'] = toJson$Enum$WorkflowRunOrderField(l$field);
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$WorkflowRunOrder<Input$WorkflowRunOrder> get copyWith =>
      CopyWith$Input$WorkflowRunOrder(
        this,
        (i) => i,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WorkflowRunOrder || runtimeType != other.runtimeType) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$field = field;
    final l$direction = direction;
    return Object.hashAll([
      l$field,
      l$direction,
    ]);
  }
}

abstract class CopyWith$Input$WorkflowRunOrder<TRes> {
  factory CopyWith$Input$WorkflowRunOrder(
    Input$WorkflowRunOrder instance,
    TRes Function(Input$WorkflowRunOrder) then,
  ) = _CopyWithImpl$Input$WorkflowRunOrder;

  factory CopyWith$Input$WorkflowRunOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkflowRunOrder;

  TRes call({
    Enum$WorkflowRunOrderField? field,
    Enum$OrderDirection? direction,
  });
}

class _CopyWithImpl$Input$WorkflowRunOrder<TRes>
    implements CopyWith$Input$WorkflowRunOrder<TRes> {
  _CopyWithImpl$Input$WorkflowRunOrder(
    this._instance,
    this._then,
  );

  final Input$WorkflowRunOrder _instance;

  final TRes Function(Input$WorkflowRunOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? field = _undefined,
    Object? direction = _undefined,
  }) =>
      _then(Input$WorkflowRunOrder._({
        ..._instance._$data,
        if (field != _undefined && field != null)
          'field': (field as Enum$WorkflowRunOrderField),
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$WorkflowRunOrder<TRes>
    implements CopyWith$Input$WorkflowRunOrder<TRes> {
  _CopyWithStubImpl$Input$WorkflowRunOrder(this._res);

  TRes _res;

  call({
    Enum$WorkflowRunOrderField? field,
    Enum$OrderDirection? direction,
  }) =>
      _res;
}

class Input$WorkflowsParametersInput {
  factory Input$WorkflowsParametersInput({
    bool? doNotEnforceOnCreate,
    required List<Input$WorkflowFileReferenceInput> workflows,
  }) =>
      Input$WorkflowsParametersInput._({
        if (doNotEnforceOnCreate != null)
          r'doNotEnforceOnCreate': doNotEnforceOnCreate,
        r'workflows': workflows,
      });

  Input$WorkflowsParametersInput._(this._$data);

  factory Input$WorkflowsParametersInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('doNotEnforceOnCreate')) {
      final l$doNotEnforceOnCreate = data['doNotEnforceOnCreate'];
      result$data['doNotEnforceOnCreate'] = (l$doNotEnforceOnCreate as bool?);
    }
    final l$workflows = data['workflows'];
    result$data['workflows'] = (l$workflows as List<dynamic>)
        .map((e) => Input$WorkflowFileReferenceInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    return Input$WorkflowsParametersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get doNotEnforceOnCreate => (_$data['doNotEnforceOnCreate'] as bool?);

  List<Input$WorkflowFileReferenceInput> get workflows =>
      (_$data['workflows'] as List<Input$WorkflowFileReferenceInput>);

  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('doNotEnforceOnCreate')) {
      final l$doNotEnforceOnCreate = doNotEnforceOnCreate;
      result$data['doNotEnforceOnCreate'] = l$doNotEnforceOnCreate;
    }
    final l$workflows = workflows;
    result$data['workflows'] = l$workflows.map((e) => e.toJson()).toList();
    return result$data;
  }

  CopyWith$Input$WorkflowsParametersInput<Input$WorkflowsParametersInput>
      get copyWith => CopyWith$Input$WorkflowsParametersInput(
            this,
            (i) => i,
          );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (other is! Input$WorkflowsParametersInput ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$doNotEnforceOnCreate = doNotEnforceOnCreate;
    final lOther$doNotEnforceOnCreate = other.doNotEnforceOnCreate;
    if (_$data.containsKey('doNotEnforceOnCreate') !=
        other._$data.containsKey('doNotEnforceOnCreate')) {
      return false;
    }
    if (l$doNotEnforceOnCreate != lOther$doNotEnforceOnCreate) {
      return false;
    }
    final l$workflows = workflows;
    final lOther$workflows = other.workflows;
    if (l$workflows.length != lOther$workflows.length) {
      return false;
    }
    for (int i = 0; i < l$workflows.length; i++) {
      final l$workflows$entry = l$workflows[i];
      final lOther$workflows$entry = lOther$workflows[i];
      if (l$workflows$entry != lOther$workflows$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$doNotEnforceOnCreate = doNotEnforceOnCreate;
    final l$workflows = workflows;
    return Object.hashAll([
      _$data.containsKey('doNotEnforceOnCreate')
          ? l$doNotEnforceOnCreate
          : const {},
      Object.hashAll(l$workflows.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$WorkflowsParametersInput<TRes> {
  factory CopyWith$Input$WorkflowsParametersInput(
    Input$WorkflowsParametersInput instance,
    TRes Function(Input$WorkflowsParametersInput) then,
  ) = _CopyWithImpl$Input$WorkflowsParametersInput;

  factory CopyWith$Input$WorkflowsParametersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkflowsParametersInput;

  TRes call({
    bool? doNotEnforceOnCreate,
    List<Input$WorkflowFileReferenceInput>? workflows,
  });
  TRes workflows(
      Iterable<Input$WorkflowFileReferenceInput> Function(
              Iterable<
                  CopyWith$Input$WorkflowFileReferenceInput<
                      Input$WorkflowFileReferenceInput>>)
          _fn);
}

class _CopyWithImpl$Input$WorkflowsParametersInput<TRes>
    implements CopyWith$Input$WorkflowsParametersInput<TRes> {
  _CopyWithImpl$Input$WorkflowsParametersInput(
    this._instance,
    this._then,
  );

  final Input$WorkflowsParametersInput _instance;

  final TRes Function(Input$WorkflowsParametersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? doNotEnforceOnCreate = _undefined,
    Object? workflows = _undefined,
  }) =>
      _then(Input$WorkflowsParametersInput._({
        ..._instance._$data,
        if (doNotEnforceOnCreate != _undefined)
          'doNotEnforceOnCreate': (doNotEnforceOnCreate as bool?),
        if (workflows != _undefined && workflows != null)
          'workflows': (workflows as List<Input$WorkflowFileReferenceInput>),
      }));

  TRes workflows(
          Iterable<Input$WorkflowFileReferenceInput> Function(
                  Iterable<
                      CopyWith$Input$WorkflowFileReferenceInput<
                          Input$WorkflowFileReferenceInput>>)
              _fn) =>
      call(
          workflows: _fn(_instance.workflows
              .map((e) => CopyWith$Input$WorkflowFileReferenceInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$WorkflowsParametersInput<TRes>
    implements CopyWith$Input$WorkflowsParametersInput<TRes> {
  _CopyWithStubImpl$Input$WorkflowsParametersInput(this._res);

  TRes _res;

  call({
    bool? doNotEnforceOnCreate,
    List<Input$WorkflowFileReferenceInput>? workflows,
  }) =>
      _res;

  workflows(_fn) => _res;
}

enum Enum$ActorType {
  USER,
  TEAM,
  $unknown;

  factory Enum$ActorType.fromJson(String value) =>
      fromJson$Enum$ActorType(value);

  String toJson() => toJson$Enum$ActorType(this);
}

String toJson$Enum$ActorType(Enum$ActorType e) {
  switch (e) {
    case Enum$ActorType.USER:
      return r'USER';
    case Enum$ActorType.TEAM:
      return r'TEAM';
    case Enum$ActorType.$unknown:
      return r'$unknown';
  }
}

Enum$ActorType fromJson$Enum$ActorType(String value) {
  switch (value) {
    case r'USER':
      return Enum$ActorType.USER;
    case r'TEAM':
      return Enum$ActorType.TEAM;
    default:
      return Enum$ActorType.$unknown;
  }
}

enum Enum$AuditLogOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$AuditLogOrderField.fromJson(String value) =>
      fromJson$Enum$AuditLogOrderField(value);

  String toJson() => toJson$Enum$AuditLogOrderField(this);
}

String toJson$Enum$AuditLogOrderField(Enum$AuditLogOrderField e) {
  switch (e) {
    case Enum$AuditLogOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$AuditLogOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$AuditLogOrderField fromJson$Enum$AuditLogOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$AuditLogOrderField.CREATED_AT;
    default:
      return Enum$AuditLogOrderField.$unknown;
  }
}

enum Enum$CheckAnnotationLevel {
  FAILURE,
  NOTICE,
  WARNING,
  $unknown;

  factory Enum$CheckAnnotationLevel.fromJson(String value) =>
      fromJson$Enum$CheckAnnotationLevel(value);

  String toJson() => toJson$Enum$CheckAnnotationLevel(this);
}

String toJson$Enum$CheckAnnotationLevel(Enum$CheckAnnotationLevel e) {
  switch (e) {
    case Enum$CheckAnnotationLevel.FAILURE:
      return r'FAILURE';
    case Enum$CheckAnnotationLevel.NOTICE:
      return r'NOTICE';
    case Enum$CheckAnnotationLevel.WARNING:
      return r'WARNING';
    case Enum$CheckAnnotationLevel.$unknown:
      return r'$unknown';
  }
}

Enum$CheckAnnotationLevel fromJson$Enum$CheckAnnotationLevel(String value) {
  switch (value) {
    case r'FAILURE':
      return Enum$CheckAnnotationLevel.FAILURE;
    case r'NOTICE':
      return Enum$CheckAnnotationLevel.NOTICE;
    case r'WARNING':
      return Enum$CheckAnnotationLevel.WARNING;
    default:
      return Enum$CheckAnnotationLevel.$unknown;
  }
}

enum Enum$CheckConclusionState {
  ACTION_REQUIRED,
  TIMED_OUT,
  CANCELLED,
  FAILURE,
  SUCCESS,
  NEUTRAL,
  SKIPPED,
  STARTUP_FAILURE,
  STALE,
  $unknown;

  factory Enum$CheckConclusionState.fromJson(String value) =>
      fromJson$Enum$CheckConclusionState(value);

  String toJson() => toJson$Enum$CheckConclusionState(this);
}

String toJson$Enum$CheckConclusionState(Enum$CheckConclusionState e) {
  switch (e) {
    case Enum$CheckConclusionState.ACTION_REQUIRED:
      return r'ACTION_REQUIRED';
    case Enum$CheckConclusionState.TIMED_OUT:
      return r'TIMED_OUT';
    case Enum$CheckConclusionState.CANCELLED:
      return r'CANCELLED';
    case Enum$CheckConclusionState.FAILURE:
      return r'FAILURE';
    case Enum$CheckConclusionState.SUCCESS:
      return r'SUCCESS';
    case Enum$CheckConclusionState.NEUTRAL:
      return r'NEUTRAL';
    case Enum$CheckConclusionState.SKIPPED:
      return r'SKIPPED';
    case Enum$CheckConclusionState.STARTUP_FAILURE:
      return r'STARTUP_FAILURE';
    case Enum$CheckConclusionState.STALE:
      return r'STALE';
    case Enum$CheckConclusionState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckConclusionState fromJson$Enum$CheckConclusionState(String value) {
  switch (value) {
    case r'ACTION_REQUIRED':
      return Enum$CheckConclusionState.ACTION_REQUIRED;
    case r'TIMED_OUT':
      return Enum$CheckConclusionState.TIMED_OUT;
    case r'CANCELLED':
      return Enum$CheckConclusionState.CANCELLED;
    case r'FAILURE':
      return Enum$CheckConclusionState.FAILURE;
    case r'SUCCESS':
      return Enum$CheckConclusionState.SUCCESS;
    case r'NEUTRAL':
      return Enum$CheckConclusionState.NEUTRAL;
    case r'SKIPPED':
      return Enum$CheckConclusionState.SKIPPED;
    case r'STARTUP_FAILURE':
      return Enum$CheckConclusionState.STARTUP_FAILURE;
    case r'STALE':
      return Enum$CheckConclusionState.STALE;
    default:
      return Enum$CheckConclusionState.$unknown;
  }
}

enum Enum$CheckRunState {
  ACTION_REQUIRED,
  CANCELLED,
  COMPLETED,
  FAILURE,
  IN_PROGRESS,
  NEUTRAL,
  PENDING,
  QUEUED,
  SKIPPED,
  STALE,
  STARTUP_FAILURE,
  SUCCESS,
  TIMED_OUT,
  WAITING,
  $unknown;

  factory Enum$CheckRunState.fromJson(String value) =>
      fromJson$Enum$CheckRunState(value);

  String toJson() => toJson$Enum$CheckRunState(this);
}

String toJson$Enum$CheckRunState(Enum$CheckRunState e) {
  switch (e) {
    case Enum$CheckRunState.ACTION_REQUIRED:
      return r'ACTION_REQUIRED';
    case Enum$CheckRunState.CANCELLED:
      return r'CANCELLED';
    case Enum$CheckRunState.COMPLETED:
      return r'COMPLETED';
    case Enum$CheckRunState.FAILURE:
      return r'FAILURE';
    case Enum$CheckRunState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$CheckRunState.NEUTRAL:
      return r'NEUTRAL';
    case Enum$CheckRunState.PENDING:
      return r'PENDING';
    case Enum$CheckRunState.QUEUED:
      return r'QUEUED';
    case Enum$CheckRunState.SKIPPED:
      return r'SKIPPED';
    case Enum$CheckRunState.STALE:
      return r'STALE';
    case Enum$CheckRunState.STARTUP_FAILURE:
      return r'STARTUP_FAILURE';
    case Enum$CheckRunState.SUCCESS:
      return r'SUCCESS';
    case Enum$CheckRunState.TIMED_OUT:
      return r'TIMED_OUT';
    case Enum$CheckRunState.WAITING:
      return r'WAITING';
    case Enum$CheckRunState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckRunState fromJson$Enum$CheckRunState(String value) {
  switch (value) {
    case r'ACTION_REQUIRED':
      return Enum$CheckRunState.ACTION_REQUIRED;
    case r'CANCELLED':
      return Enum$CheckRunState.CANCELLED;
    case r'COMPLETED':
      return Enum$CheckRunState.COMPLETED;
    case r'FAILURE':
      return Enum$CheckRunState.FAILURE;
    case r'IN_PROGRESS':
      return Enum$CheckRunState.IN_PROGRESS;
    case r'NEUTRAL':
      return Enum$CheckRunState.NEUTRAL;
    case r'PENDING':
      return Enum$CheckRunState.PENDING;
    case r'QUEUED':
      return Enum$CheckRunState.QUEUED;
    case r'SKIPPED':
      return Enum$CheckRunState.SKIPPED;
    case r'STALE':
      return Enum$CheckRunState.STALE;
    case r'STARTUP_FAILURE':
      return Enum$CheckRunState.STARTUP_FAILURE;
    case r'SUCCESS':
      return Enum$CheckRunState.SUCCESS;
    case r'TIMED_OUT':
      return Enum$CheckRunState.TIMED_OUT;
    case r'WAITING':
      return Enum$CheckRunState.WAITING;
    default:
      return Enum$CheckRunState.$unknown;
  }
}

enum Enum$CheckRunType {
  ALL,
  LATEST,
  $unknown;

  factory Enum$CheckRunType.fromJson(String value) =>
      fromJson$Enum$CheckRunType(value);

  String toJson() => toJson$Enum$CheckRunType(this);
}

String toJson$Enum$CheckRunType(Enum$CheckRunType e) {
  switch (e) {
    case Enum$CheckRunType.ALL:
      return r'ALL';
    case Enum$CheckRunType.LATEST:
      return r'LATEST';
    case Enum$CheckRunType.$unknown:
      return r'$unknown';
  }
}

Enum$CheckRunType fromJson$Enum$CheckRunType(String value) {
  switch (value) {
    case r'ALL':
      return Enum$CheckRunType.ALL;
    case r'LATEST':
      return Enum$CheckRunType.LATEST;
    default:
      return Enum$CheckRunType.$unknown;
  }
}

enum Enum$CheckStatusState {
  REQUESTED,
  QUEUED,
  IN_PROGRESS,
  COMPLETED,
  WAITING,
  PENDING,
  $unknown;

  factory Enum$CheckStatusState.fromJson(String value) =>
      fromJson$Enum$CheckStatusState(value);

  String toJson() => toJson$Enum$CheckStatusState(this);
}

String toJson$Enum$CheckStatusState(Enum$CheckStatusState e) {
  switch (e) {
    case Enum$CheckStatusState.REQUESTED:
      return r'REQUESTED';
    case Enum$CheckStatusState.QUEUED:
      return r'QUEUED';
    case Enum$CheckStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$CheckStatusState.COMPLETED:
      return r'COMPLETED';
    case Enum$CheckStatusState.WAITING:
      return r'WAITING';
    case Enum$CheckStatusState.PENDING:
      return r'PENDING';
    case Enum$CheckStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckStatusState fromJson$Enum$CheckStatusState(String value) {
  switch (value) {
    case r'REQUESTED':
      return Enum$CheckStatusState.REQUESTED;
    case r'QUEUED':
      return Enum$CheckStatusState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$CheckStatusState.IN_PROGRESS;
    case r'COMPLETED':
      return Enum$CheckStatusState.COMPLETED;
    case r'WAITING':
      return Enum$CheckStatusState.WAITING;
    case r'PENDING':
      return Enum$CheckStatusState.PENDING;
    default:
      return Enum$CheckStatusState.$unknown;
  }
}

enum Enum$CollaboratorAffiliation {
  OUTSIDE,
  DIRECT,
  ALL,
  $unknown;

  factory Enum$CollaboratorAffiliation.fromJson(String value) =>
      fromJson$Enum$CollaboratorAffiliation(value);

  String toJson() => toJson$Enum$CollaboratorAffiliation(this);
}

String toJson$Enum$CollaboratorAffiliation(Enum$CollaboratorAffiliation e) {
  switch (e) {
    case Enum$CollaboratorAffiliation.OUTSIDE:
      return r'OUTSIDE';
    case Enum$CollaboratorAffiliation.DIRECT:
      return r'DIRECT';
    case Enum$CollaboratorAffiliation.ALL:
      return r'ALL';
    case Enum$CollaboratorAffiliation.$unknown:
      return r'$unknown';
  }
}

Enum$CollaboratorAffiliation fromJson$Enum$CollaboratorAffiliation(
    String value) {
  switch (value) {
    case r'OUTSIDE':
      return Enum$CollaboratorAffiliation.OUTSIDE;
    case r'DIRECT':
      return Enum$CollaboratorAffiliation.DIRECT;
    case r'ALL':
      return Enum$CollaboratorAffiliation.ALL;
    default:
      return Enum$CollaboratorAffiliation.$unknown;
  }
}

enum Enum$CommentAuthorAssociation {
  MEMBER,
  OWNER,
  MANNEQUIN,
  COLLABORATOR,
  CONTRIBUTOR,
  FIRST_TIME_CONTRIBUTOR,
  FIRST_TIMER,
  NONE,
  $unknown;

  factory Enum$CommentAuthorAssociation.fromJson(String value) =>
      fromJson$Enum$CommentAuthorAssociation(value);

  String toJson() => toJson$Enum$CommentAuthorAssociation(this);
}

String toJson$Enum$CommentAuthorAssociation(Enum$CommentAuthorAssociation e) {
  switch (e) {
    case Enum$CommentAuthorAssociation.MEMBER:
      return r'MEMBER';
    case Enum$CommentAuthorAssociation.OWNER:
      return r'OWNER';
    case Enum$CommentAuthorAssociation.MANNEQUIN:
      return r'MANNEQUIN';
    case Enum$CommentAuthorAssociation.COLLABORATOR:
      return r'COLLABORATOR';
    case Enum$CommentAuthorAssociation.CONTRIBUTOR:
      return r'CONTRIBUTOR';
    case Enum$CommentAuthorAssociation.FIRST_TIME_CONTRIBUTOR:
      return r'FIRST_TIME_CONTRIBUTOR';
    case Enum$CommentAuthorAssociation.FIRST_TIMER:
      return r'FIRST_TIMER';
    case Enum$CommentAuthorAssociation.NONE:
      return r'NONE';
    case Enum$CommentAuthorAssociation.$unknown:
      return r'$unknown';
  }
}

Enum$CommentAuthorAssociation fromJson$Enum$CommentAuthorAssociation(
    String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$CommentAuthorAssociation.MEMBER;
    case r'OWNER':
      return Enum$CommentAuthorAssociation.OWNER;
    case r'MANNEQUIN':
      return Enum$CommentAuthorAssociation.MANNEQUIN;
    case r'COLLABORATOR':
      return Enum$CommentAuthorAssociation.COLLABORATOR;
    case r'CONTRIBUTOR':
      return Enum$CommentAuthorAssociation.CONTRIBUTOR;
    case r'FIRST_TIME_CONTRIBUTOR':
      return Enum$CommentAuthorAssociation.FIRST_TIME_CONTRIBUTOR;
    case r'FIRST_TIMER':
      return Enum$CommentAuthorAssociation.FIRST_TIMER;
    case r'NONE':
      return Enum$CommentAuthorAssociation.NONE;
    default:
      return Enum$CommentAuthorAssociation.$unknown;
  }
}

enum Enum$CommentCannotUpdateReason {
  ARCHIVED,
  INSUFFICIENT_ACCESS,
  LOCKED,
  LOGIN_REQUIRED,
  MAINTENANCE,
  VERIFIED_EMAIL_REQUIRED,
  DENIED,
  $unknown;

  factory Enum$CommentCannotUpdateReason.fromJson(String value) =>
      fromJson$Enum$CommentCannotUpdateReason(value);

  String toJson() => toJson$Enum$CommentCannotUpdateReason(this);
}

String toJson$Enum$CommentCannotUpdateReason(Enum$CommentCannotUpdateReason e) {
  switch (e) {
    case Enum$CommentCannotUpdateReason.ARCHIVED:
      return r'ARCHIVED';
    case Enum$CommentCannotUpdateReason.INSUFFICIENT_ACCESS:
      return r'INSUFFICIENT_ACCESS';
    case Enum$CommentCannotUpdateReason.LOCKED:
      return r'LOCKED';
    case Enum$CommentCannotUpdateReason.LOGIN_REQUIRED:
      return r'LOGIN_REQUIRED';
    case Enum$CommentCannotUpdateReason.MAINTENANCE:
      return r'MAINTENANCE';
    case Enum$CommentCannotUpdateReason.VERIFIED_EMAIL_REQUIRED:
      return r'VERIFIED_EMAIL_REQUIRED';
    case Enum$CommentCannotUpdateReason.DENIED:
      return r'DENIED';
    case Enum$CommentCannotUpdateReason.$unknown:
      return r'$unknown';
  }
}

Enum$CommentCannotUpdateReason fromJson$Enum$CommentCannotUpdateReason(
    String value) {
  switch (value) {
    case r'ARCHIVED':
      return Enum$CommentCannotUpdateReason.ARCHIVED;
    case r'INSUFFICIENT_ACCESS':
      return Enum$CommentCannotUpdateReason.INSUFFICIENT_ACCESS;
    case r'LOCKED':
      return Enum$CommentCannotUpdateReason.LOCKED;
    case r'LOGIN_REQUIRED':
      return Enum$CommentCannotUpdateReason.LOGIN_REQUIRED;
    case r'MAINTENANCE':
      return Enum$CommentCannotUpdateReason.MAINTENANCE;
    case r'VERIFIED_EMAIL_REQUIRED':
      return Enum$CommentCannotUpdateReason.VERIFIED_EMAIL_REQUIRED;
    case r'DENIED':
      return Enum$CommentCannotUpdateReason.DENIED;
    default:
      return Enum$CommentCannotUpdateReason.$unknown;
  }
}

enum Enum$CommitContributionOrderField {
  OCCURRED_AT,
  COMMIT_COUNT,
  $unknown;

  factory Enum$CommitContributionOrderField.fromJson(String value) =>
      fromJson$Enum$CommitContributionOrderField(value);

  String toJson() => toJson$Enum$CommitContributionOrderField(this);
}

String toJson$Enum$CommitContributionOrderField(
    Enum$CommitContributionOrderField e) {
  switch (e) {
    case Enum$CommitContributionOrderField.OCCURRED_AT:
      return r'OCCURRED_AT';
    case Enum$CommitContributionOrderField.COMMIT_COUNT:
      return r'COMMIT_COUNT';
    case Enum$CommitContributionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$CommitContributionOrderField fromJson$Enum$CommitContributionOrderField(
    String value) {
  switch (value) {
    case r'OCCURRED_AT':
      return Enum$CommitContributionOrderField.OCCURRED_AT;
    case r'COMMIT_COUNT':
      return Enum$CommitContributionOrderField.COMMIT_COUNT;
    default:
      return Enum$CommitContributionOrderField.$unknown;
  }
}

enum Enum$ComparisonStatus {
  DIVERGED,
  AHEAD,
  BEHIND,
  IDENTICAL,
  $unknown;

  factory Enum$ComparisonStatus.fromJson(String value) =>
      fromJson$Enum$ComparisonStatus(value);

  String toJson() => toJson$Enum$ComparisonStatus(this);
}

String toJson$Enum$ComparisonStatus(Enum$ComparisonStatus e) {
  switch (e) {
    case Enum$ComparisonStatus.DIVERGED:
      return r'DIVERGED';
    case Enum$ComparisonStatus.AHEAD:
      return r'AHEAD';
    case Enum$ComparisonStatus.BEHIND:
      return r'BEHIND';
    case Enum$ComparisonStatus.IDENTICAL:
      return r'IDENTICAL';
    case Enum$ComparisonStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ComparisonStatus fromJson$Enum$ComparisonStatus(String value) {
  switch (value) {
    case r'DIVERGED':
      return Enum$ComparisonStatus.DIVERGED;
    case r'AHEAD':
      return Enum$ComparisonStatus.AHEAD;
    case r'BEHIND':
      return Enum$ComparisonStatus.BEHIND;
    case r'IDENTICAL':
      return Enum$ComparisonStatus.IDENTICAL;
    default:
      return Enum$ComparisonStatus.$unknown;
  }
}

enum Enum$ContributionLevel {
  NONE,
  FIRST_QUARTILE,
  SECOND_QUARTILE,
  THIRD_QUARTILE,
  FOURTH_QUARTILE,
  $unknown;

  factory Enum$ContributionLevel.fromJson(String value) =>
      fromJson$Enum$ContributionLevel(value);

  String toJson() => toJson$Enum$ContributionLevel(this);
}

String toJson$Enum$ContributionLevel(Enum$ContributionLevel e) {
  switch (e) {
    case Enum$ContributionLevel.NONE:
      return r'NONE';
    case Enum$ContributionLevel.FIRST_QUARTILE:
      return r'FIRST_QUARTILE';
    case Enum$ContributionLevel.SECOND_QUARTILE:
      return r'SECOND_QUARTILE';
    case Enum$ContributionLevel.THIRD_QUARTILE:
      return r'THIRD_QUARTILE';
    case Enum$ContributionLevel.FOURTH_QUARTILE:
      return r'FOURTH_QUARTILE';
    case Enum$ContributionLevel.$unknown:
      return r'$unknown';
  }
}

Enum$ContributionLevel fromJson$Enum$ContributionLevel(String value) {
  switch (value) {
    case r'NONE':
      return Enum$ContributionLevel.NONE;
    case r'FIRST_QUARTILE':
      return Enum$ContributionLevel.FIRST_QUARTILE;
    case r'SECOND_QUARTILE':
      return Enum$ContributionLevel.SECOND_QUARTILE;
    case r'THIRD_QUARTILE':
      return Enum$ContributionLevel.THIRD_QUARTILE;
    case r'FOURTH_QUARTILE':
      return Enum$ContributionLevel.FOURTH_QUARTILE;
    default:
      return Enum$ContributionLevel.$unknown;
  }
}

enum Enum$DefaultRepositoryPermissionField {
  NONE,
  READ,
  WRITE,
  ADMIN,
  $unknown;

  factory Enum$DefaultRepositoryPermissionField.fromJson(String value) =>
      fromJson$Enum$DefaultRepositoryPermissionField(value);

  String toJson() => toJson$Enum$DefaultRepositoryPermissionField(this);
}

String toJson$Enum$DefaultRepositoryPermissionField(
    Enum$DefaultRepositoryPermissionField e) {
  switch (e) {
    case Enum$DefaultRepositoryPermissionField.NONE:
      return r'NONE';
    case Enum$DefaultRepositoryPermissionField.READ:
      return r'READ';
    case Enum$DefaultRepositoryPermissionField.WRITE:
      return r'WRITE';
    case Enum$DefaultRepositoryPermissionField.ADMIN:
      return r'ADMIN';
    case Enum$DefaultRepositoryPermissionField.$unknown:
      return r'$unknown';
  }
}

Enum$DefaultRepositoryPermissionField
    fromJson$Enum$DefaultRepositoryPermissionField(String value) {
  switch (value) {
    case r'NONE':
      return Enum$DefaultRepositoryPermissionField.NONE;
    case r'READ':
      return Enum$DefaultRepositoryPermissionField.READ;
    case r'WRITE':
      return Enum$DefaultRepositoryPermissionField.WRITE;
    case r'ADMIN':
      return Enum$DefaultRepositoryPermissionField.ADMIN;
    default:
      return Enum$DefaultRepositoryPermissionField.$unknown;
  }
}

enum Enum$DependencyGraphEcosystem {
  RUBYGEMS,
  NPM,
  PIP,
  MAVEN,
  NUGET,
  COMPOSER,
  GO,
  ACTIONS,
  RUST,
  PUB,
  SWIFT,
  $unknown;

  factory Enum$DependencyGraphEcosystem.fromJson(String value) =>
      fromJson$Enum$DependencyGraphEcosystem(value);

  String toJson() => toJson$Enum$DependencyGraphEcosystem(this);
}

String toJson$Enum$DependencyGraphEcosystem(Enum$DependencyGraphEcosystem e) {
  switch (e) {
    case Enum$DependencyGraphEcosystem.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$DependencyGraphEcosystem.NPM:
      return r'NPM';
    case Enum$DependencyGraphEcosystem.PIP:
      return r'PIP';
    case Enum$DependencyGraphEcosystem.MAVEN:
      return r'MAVEN';
    case Enum$DependencyGraphEcosystem.NUGET:
      return r'NUGET';
    case Enum$DependencyGraphEcosystem.COMPOSER:
      return r'COMPOSER';
    case Enum$DependencyGraphEcosystem.GO:
      return r'GO';
    case Enum$DependencyGraphEcosystem.ACTIONS:
      return r'ACTIONS';
    case Enum$DependencyGraphEcosystem.RUST:
      return r'RUST';
    case Enum$DependencyGraphEcosystem.PUB:
      return r'PUB';
    case Enum$DependencyGraphEcosystem.SWIFT:
      return r'SWIFT';
    case Enum$DependencyGraphEcosystem.$unknown:
      return r'$unknown';
  }
}

Enum$DependencyGraphEcosystem fromJson$Enum$DependencyGraphEcosystem(
    String value) {
  switch (value) {
    case r'RUBYGEMS':
      return Enum$DependencyGraphEcosystem.RUBYGEMS;
    case r'NPM':
      return Enum$DependencyGraphEcosystem.NPM;
    case r'PIP':
      return Enum$DependencyGraphEcosystem.PIP;
    case r'MAVEN':
      return Enum$DependencyGraphEcosystem.MAVEN;
    case r'NUGET':
      return Enum$DependencyGraphEcosystem.NUGET;
    case r'COMPOSER':
      return Enum$DependencyGraphEcosystem.COMPOSER;
    case r'GO':
      return Enum$DependencyGraphEcosystem.GO;
    case r'ACTIONS':
      return Enum$DependencyGraphEcosystem.ACTIONS;
    case r'RUST':
      return Enum$DependencyGraphEcosystem.RUST;
    case r'PUB':
      return Enum$DependencyGraphEcosystem.PUB;
    case r'SWIFT':
      return Enum$DependencyGraphEcosystem.SWIFT;
    default:
      return Enum$DependencyGraphEcosystem.$unknown;
  }
}

enum Enum$DeploymentOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$DeploymentOrderField.fromJson(String value) =>
      fromJson$Enum$DeploymentOrderField(value);

  String toJson() => toJson$Enum$DeploymentOrderField(this);
}

String toJson$Enum$DeploymentOrderField(Enum$DeploymentOrderField e) {
  switch (e) {
    case Enum$DeploymentOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$DeploymentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentOrderField fromJson$Enum$DeploymentOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$DeploymentOrderField.CREATED_AT;
    default:
      return Enum$DeploymentOrderField.$unknown;
  }
}

enum Enum$DeploymentProtectionRuleType {
  REQUIRED_REVIEWERS,
  WAIT_TIMER,
  BRANCH_POLICY,
  $unknown;

  factory Enum$DeploymentProtectionRuleType.fromJson(String value) =>
      fromJson$Enum$DeploymentProtectionRuleType(value);

  String toJson() => toJson$Enum$DeploymentProtectionRuleType(this);
}

String toJson$Enum$DeploymentProtectionRuleType(
    Enum$DeploymentProtectionRuleType e) {
  switch (e) {
    case Enum$DeploymentProtectionRuleType.REQUIRED_REVIEWERS:
      return r'REQUIRED_REVIEWERS';
    case Enum$DeploymentProtectionRuleType.WAIT_TIMER:
      return r'WAIT_TIMER';
    case Enum$DeploymentProtectionRuleType.BRANCH_POLICY:
      return r'BRANCH_POLICY';
    case Enum$DeploymentProtectionRuleType.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentProtectionRuleType fromJson$Enum$DeploymentProtectionRuleType(
    String value) {
  switch (value) {
    case r'REQUIRED_REVIEWERS':
      return Enum$DeploymentProtectionRuleType.REQUIRED_REVIEWERS;
    case r'WAIT_TIMER':
      return Enum$DeploymentProtectionRuleType.WAIT_TIMER;
    case r'BRANCH_POLICY':
      return Enum$DeploymentProtectionRuleType.BRANCH_POLICY;
    default:
      return Enum$DeploymentProtectionRuleType.$unknown;
  }
}

enum Enum$DeploymentReviewState {
  APPROVED,
  REJECTED,
  $unknown;

  factory Enum$DeploymentReviewState.fromJson(String value) =>
      fromJson$Enum$DeploymentReviewState(value);

  String toJson() => toJson$Enum$DeploymentReviewState(this);
}

String toJson$Enum$DeploymentReviewState(Enum$DeploymentReviewState e) {
  switch (e) {
    case Enum$DeploymentReviewState.APPROVED:
      return r'APPROVED';
    case Enum$DeploymentReviewState.REJECTED:
      return r'REJECTED';
    case Enum$DeploymentReviewState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentReviewState fromJson$Enum$DeploymentReviewState(String value) {
  switch (value) {
    case r'APPROVED':
      return Enum$DeploymentReviewState.APPROVED;
    case r'REJECTED':
      return Enum$DeploymentReviewState.REJECTED;
    default:
      return Enum$DeploymentReviewState.$unknown;
  }
}

enum Enum$DeploymentState {
  ABANDONED,
  ACTIVE,
  DESTROYED,
  ERROR,
  FAILURE,
  INACTIVE,
  PENDING,
  SUCCESS,
  QUEUED,
  IN_PROGRESS,
  WAITING,
  $unknown;

  factory Enum$DeploymentState.fromJson(String value) =>
      fromJson$Enum$DeploymentState(value);

  String toJson() => toJson$Enum$DeploymentState(this);
}

String toJson$Enum$DeploymentState(Enum$DeploymentState e) {
  switch (e) {
    case Enum$DeploymentState.ABANDONED:
      return r'ABANDONED';
    case Enum$DeploymentState.ACTIVE:
      return r'ACTIVE';
    case Enum$DeploymentState.DESTROYED:
      return r'DESTROYED';
    case Enum$DeploymentState.ERROR:
      return r'ERROR';
    case Enum$DeploymentState.FAILURE:
      return r'FAILURE';
    case Enum$DeploymentState.INACTIVE:
      return r'INACTIVE';
    case Enum$DeploymentState.PENDING:
      return r'PENDING';
    case Enum$DeploymentState.SUCCESS:
      return r'SUCCESS';
    case Enum$DeploymentState.QUEUED:
      return r'QUEUED';
    case Enum$DeploymentState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$DeploymentState.WAITING:
      return r'WAITING';
    case Enum$DeploymentState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentState fromJson$Enum$DeploymentState(String value) {
  switch (value) {
    case r'ABANDONED':
      return Enum$DeploymentState.ABANDONED;
    case r'ACTIVE':
      return Enum$DeploymentState.ACTIVE;
    case r'DESTROYED':
      return Enum$DeploymentState.DESTROYED;
    case r'ERROR':
      return Enum$DeploymentState.ERROR;
    case r'FAILURE':
      return Enum$DeploymentState.FAILURE;
    case r'INACTIVE':
      return Enum$DeploymentState.INACTIVE;
    case r'PENDING':
      return Enum$DeploymentState.PENDING;
    case r'SUCCESS':
      return Enum$DeploymentState.SUCCESS;
    case r'QUEUED':
      return Enum$DeploymentState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$DeploymentState.IN_PROGRESS;
    case r'WAITING':
      return Enum$DeploymentState.WAITING;
    default:
      return Enum$DeploymentState.$unknown;
  }
}

enum Enum$DeploymentStatusState {
  PENDING,
  SUCCESS,
  FAILURE,
  INACTIVE,
  ERROR,
  QUEUED,
  IN_PROGRESS,
  WAITING,
  $unknown;

  factory Enum$DeploymentStatusState.fromJson(String value) =>
      fromJson$Enum$DeploymentStatusState(value);

  String toJson() => toJson$Enum$DeploymentStatusState(this);
}

String toJson$Enum$DeploymentStatusState(Enum$DeploymentStatusState e) {
  switch (e) {
    case Enum$DeploymentStatusState.PENDING:
      return r'PENDING';
    case Enum$DeploymentStatusState.SUCCESS:
      return r'SUCCESS';
    case Enum$DeploymentStatusState.FAILURE:
      return r'FAILURE';
    case Enum$DeploymentStatusState.INACTIVE:
      return r'INACTIVE';
    case Enum$DeploymentStatusState.ERROR:
      return r'ERROR';
    case Enum$DeploymentStatusState.QUEUED:
      return r'QUEUED';
    case Enum$DeploymentStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$DeploymentStatusState.WAITING:
      return r'WAITING';
    case Enum$DeploymentStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentStatusState fromJson$Enum$DeploymentStatusState(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$DeploymentStatusState.PENDING;
    case r'SUCCESS':
      return Enum$DeploymentStatusState.SUCCESS;
    case r'FAILURE':
      return Enum$DeploymentStatusState.FAILURE;
    case r'INACTIVE':
      return Enum$DeploymentStatusState.INACTIVE;
    case r'ERROR':
      return Enum$DeploymentStatusState.ERROR;
    case r'QUEUED':
      return Enum$DeploymentStatusState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$DeploymentStatusState.IN_PROGRESS;
    case r'WAITING':
      return Enum$DeploymentStatusState.WAITING;
    default:
      return Enum$DeploymentStatusState.$unknown;
  }
}

enum Enum$DiffSide {
  LEFT,
  RIGHT,
  $unknown;

  factory Enum$DiffSide.fromJson(String value) => fromJson$Enum$DiffSide(value);

  String toJson() => toJson$Enum$DiffSide(this);
}

String toJson$Enum$DiffSide(Enum$DiffSide e) {
  switch (e) {
    case Enum$DiffSide.LEFT:
      return r'LEFT';
    case Enum$DiffSide.RIGHT:
      return r'RIGHT';
    case Enum$DiffSide.$unknown:
      return r'$unknown';
  }
}

Enum$DiffSide fromJson$Enum$DiffSide(String value) {
  switch (value) {
    case r'LEFT':
      return Enum$DiffSide.LEFT;
    case r'RIGHT':
      return Enum$DiffSide.RIGHT;
    default:
      return Enum$DiffSide.$unknown;
  }
}

enum Enum$DiscussionCloseReason {
  RESOLVED,
  OUTDATED,
  DUPLICATE,
  $unknown;

  factory Enum$DiscussionCloseReason.fromJson(String value) =>
      fromJson$Enum$DiscussionCloseReason(value);

  String toJson() => toJson$Enum$DiscussionCloseReason(this);
}

String toJson$Enum$DiscussionCloseReason(Enum$DiscussionCloseReason e) {
  switch (e) {
    case Enum$DiscussionCloseReason.RESOLVED:
      return r'RESOLVED';
    case Enum$DiscussionCloseReason.OUTDATED:
      return r'OUTDATED';
    case Enum$DiscussionCloseReason.DUPLICATE:
      return r'DUPLICATE';
    case Enum$DiscussionCloseReason.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionCloseReason fromJson$Enum$DiscussionCloseReason(String value) {
  switch (value) {
    case r'RESOLVED':
      return Enum$DiscussionCloseReason.RESOLVED;
    case r'OUTDATED':
      return Enum$DiscussionCloseReason.OUTDATED;
    case r'DUPLICATE':
      return Enum$DiscussionCloseReason.DUPLICATE;
    default:
      return Enum$DiscussionCloseReason.$unknown;
  }
}

enum Enum$DiscussionOrderField {
  CREATED_AT,
  UPDATED_AT,
  $unknown;

  factory Enum$DiscussionOrderField.fromJson(String value) =>
      fromJson$Enum$DiscussionOrderField(value);

  String toJson() => toJson$Enum$DiscussionOrderField(this);
}

String toJson$Enum$DiscussionOrderField(Enum$DiscussionOrderField e) {
  switch (e) {
    case Enum$DiscussionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$DiscussionOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$DiscussionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionOrderField fromJson$Enum$DiscussionOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$DiscussionOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$DiscussionOrderField.UPDATED_AT;
    default:
      return Enum$DiscussionOrderField.$unknown;
  }
}

enum Enum$DiscussionPollOptionOrderField {
  AUTHORED_ORDER,
  VOTE_COUNT,
  $unknown;

  factory Enum$DiscussionPollOptionOrderField.fromJson(String value) =>
      fromJson$Enum$DiscussionPollOptionOrderField(value);

  String toJson() => toJson$Enum$DiscussionPollOptionOrderField(this);
}

String toJson$Enum$DiscussionPollOptionOrderField(
    Enum$DiscussionPollOptionOrderField e) {
  switch (e) {
    case Enum$DiscussionPollOptionOrderField.AUTHORED_ORDER:
      return r'AUTHORED_ORDER';
    case Enum$DiscussionPollOptionOrderField.VOTE_COUNT:
      return r'VOTE_COUNT';
    case Enum$DiscussionPollOptionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionPollOptionOrderField
    fromJson$Enum$DiscussionPollOptionOrderField(String value) {
  switch (value) {
    case r'AUTHORED_ORDER':
      return Enum$DiscussionPollOptionOrderField.AUTHORED_ORDER;
    case r'VOTE_COUNT':
      return Enum$DiscussionPollOptionOrderField.VOTE_COUNT;
    default:
      return Enum$DiscussionPollOptionOrderField.$unknown;
  }
}

enum Enum$DiscussionState {
  OPEN,
  CLOSED,
  $unknown;

  factory Enum$DiscussionState.fromJson(String value) =>
      fromJson$Enum$DiscussionState(value);

  String toJson() => toJson$Enum$DiscussionState(this);
}

String toJson$Enum$DiscussionState(Enum$DiscussionState e) {
  switch (e) {
    case Enum$DiscussionState.OPEN:
      return r'OPEN';
    case Enum$DiscussionState.CLOSED:
      return r'CLOSED';
    case Enum$DiscussionState.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionState fromJson$Enum$DiscussionState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$DiscussionState.OPEN;
    case r'CLOSED':
      return Enum$DiscussionState.CLOSED;
    default:
      return Enum$DiscussionState.$unknown;
  }
}

enum Enum$DiscussionStateReason {
  RESOLVED,
  OUTDATED,
  DUPLICATE,
  REOPENED,
  $unknown;

  factory Enum$DiscussionStateReason.fromJson(String value) =>
      fromJson$Enum$DiscussionStateReason(value);

  String toJson() => toJson$Enum$DiscussionStateReason(this);
}

String toJson$Enum$DiscussionStateReason(Enum$DiscussionStateReason e) {
  switch (e) {
    case Enum$DiscussionStateReason.RESOLVED:
      return r'RESOLVED';
    case Enum$DiscussionStateReason.OUTDATED:
      return r'OUTDATED';
    case Enum$DiscussionStateReason.DUPLICATE:
      return r'DUPLICATE';
    case Enum$DiscussionStateReason.REOPENED:
      return r'REOPENED';
    case Enum$DiscussionStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionStateReason fromJson$Enum$DiscussionStateReason(String value) {
  switch (value) {
    case r'RESOLVED':
      return Enum$DiscussionStateReason.RESOLVED;
    case r'OUTDATED':
      return Enum$DiscussionStateReason.OUTDATED;
    case r'DUPLICATE':
      return Enum$DiscussionStateReason.DUPLICATE;
    case r'REOPENED':
      return Enum$DiscussionStateReason.REOPENED;
    default:
      return Enum$DiscussionStateReason.$unknown;
  }
}

enum Enum$DismissReason {
  FIX_STARTED,
  NO_BANDWIDTH,
  TOLERABLE_RISK,
  INACCURATE,
  NOT_USED,
  $unknown;

  factory Enum$DismissReason.fromJson(String value) =>
      fromJson$Enum$DismissReason(value);

  String toJson() => toJson$Enum$DismissReason(this);
}

String toJson$Enum$DismissReason(Enum$DismissReason e) {
  switch (e) {
    case Enum$DismissReason.FIX_STARTED:
      return r'FIX_STARTED';
    case Enum$DismissReason.NO_BANDWIDTH:
      return r'NO_BANDWIDTH';
    case Enum$DismissReason.TOLERABLE_RISK:
      return r'TOLERABLE_RISK';
    case Enum$DismissReason.INACCURATE:
      return r'INACCURATE';
    case Enum$DismissReason.NOT_USED:
      return r'NOT_USED';
    case Enum$DismissReason.$unknown:
      return r'$unknown';
  }
}

Enum$DismissReason fromJson$Enum$DismissReason(String value) {
  switch (value) {
    case r'FIX_STARTED':
      return Enum$DismissReason.FIX_STARTED;
    case r'NO_BANDWIDTH':
      return Enum$DismissReason.NO_BANDWIDTH;
    case r'TOLERABLE_RISK':
      return Enum$DismissReason.TOLERABLE_RISK;
    case r'INACCURATE':
      return Enum$DismissReason.INACCURATE;
    case r'NOT_USED':
      return Enum$DismissReason.NOT_USED;
    default:
      return Enum$DismissReason.$unknown;
  }
}

enum Enum$EnterpriseAdministratorInvitationOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$EnterpriseAdministratorInvitationOrderField.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseAdministratorInvitationOrderField(value);

  String toJson() =>
      toJson$Enum$EnterpriseAdministratorInvitationOrderField(this);
}

String toJson$Enum$EnterpriseAdministratorInvitationOrderField(
    Enum$EnterpriseAdministratorInvitationOrderField e) {
  switch (e) {
    case Enum$EnterpriseAdministratorInvitationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseAdministratorInvitationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAdministratorInvitationOrderField
    fromJson$Enum$EnterpriseAdministratorInvitationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseAdministratorInvitationOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseAdministratorInvitationOrderField.$unknown;
  }
}

enum Enum$EnterpriseAdministratorRole {
  OWNER,
  BILLING_MANAGER,
  UNAFFILIATED,
  $unknown;

  factory Enum$EnterpriseAdministratorRole.fromJson(String value) =>
      fromJson$Enum$EnterpriseAdministratorRole(value);

  String toJson() => toJson$Enum$EnterpriseAdministratorRole(this);
}

String toJson$Enum$EnterpriseAdministratorRole(
    Enum$EnterpriseAdministratorRole e) {
  switch (e) {
    case Enum$EnterpriseAdministratorRole.OWNER:
      return r'OWNER';
    case Enum$EnterpriseAdministratorRole.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$EnterpriseAdministratorRole.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$EnterpriseAdministratorRole.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAdministratorRole fromJson$Enum$EnterpriseAdministratorRole(
    String value) {
  switch (value) {
    case r'OWNER':
      return Enum$EnterpriseAdministratorRole.OWNER;
    case r'BILLING_MANAGER':
      return Enum$EnterpriseAdministratorRole.BILLING_MANAGER;
    case r'UNAFFILIATED':
      return Enum$EnterpriseAdministratorRole.UNAFFILIATED;
    default:
      return Enum$EnterpriseAdministratorRole.$unknown;
  }
}

enum Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  ENTERPRISE_ORGANIZATIONS,
  SAME_ORGANIZATION,
  SAME_ORGANIZATION_USER_ACCOUNTS,
  ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS,
  USER_ACCOUNTS,
  EVERYWHERE,
  $unknown;

  factory Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(value);

  String toJson() =>
      toJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(this);
}

String toJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue e) {
  switch (e) {
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS:
      return r'ENTERPRISE_ORGANIZATIONS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION:
      return r'SAME_ORGANIZATION';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION_USER_ACCOUNTS:
      return r'SAME_ORGANIZATION_USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS:
      return r'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.USER_ACCOUNTS:
      return r'USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.EVERYWHERE:
      return r'EVERYWHERE';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
    fromJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
        String value) {
  switch (value) {
    case r'ENTERPRISE_ORGANIZATIONS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS;
    case r'SAME_ORGANIZATION':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION;
    case r'SAME_ORGANIZATION_USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION_USER_ACCOUNTS;
    case r'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS;
    case r'USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .USER_ACCOUNTS;
    case r'EVERYWHERE':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.EVERYWHERE;
    default:
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.$unknown;
  }
}

enum Enum$EnterpriseDefaultRepositoryPermissionSettingValue {
  NO_POLICY,
  ADMIN,
  WRITE,
  READ,
  NONE,
  $unknown;

  factory Enum$EnterpriseDefaultRepositoryPermissionSettingValue.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(value);

  String toJson() =>
      toJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(this);
}

String toJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue e) {
  switch (e) {
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.ADMIN:
      return r'ADMIN';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.WRITE:
      return r'WRITE';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.READ:
      return r'READ';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NONE:
      return r'NONE';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseDefaultRepositoryPermissionSettingValue
    fromJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
        String value) {
  switch (value) {
    case r'NO_POLICY':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NO_POLICY;
    case r'ADMIN':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.ADMIN;
    case r'WRITE':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.WRITE;
    case r'READ':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.READ;
    case r'NONE':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NONE;
    default:
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.$unknown;
  }
}

enum Enum$EnterpriseDisallowedMethodsSettingValue {
  INSECURE,
  NO_POLICY,
  $unknown;

  factory Enum$EnterpriseDisallowedMethodsSettingValue.fromJson(String value) =>
      fromJson$Enum$EnterpriseDisallowedMethodsSettingValue(value);

  String toJson() => toJson$Enum$EnterpriseDisallowedMethodsSettingValue(this);
}

String toJson$Enum$EnterpriseDisallowedMethodsSettingValue(
    Enum$EnterpriseDisallowedMethodsSettingValue e) {
  switch (e) {
    case Enum$EnterpriseDisallowedMethodsSettingValue.INSECURE:
      return r'INSECURE';
    case Enum$EnterpriseDisallowedMethodsSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseDisallowedMethodsSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseDisallowedMethodsSettingValue
    fromJson$Enum$EnterpriseDisallowedMethodsSettingValue(String value) {
  switch (value) {
    case r'INSECURE':
      return Enum$EnterpriseDisallowedMethodsSettingValue.INSECURE;
    case r'NO_POLICY':
      return Enum$EnterpriseDisallowedMethodsSettingValue.NO_POLICY;
    default:
      return Enum$EnterpriseDisallowedMethodsSettingValue.$unknown;
  }
}

enum Enum$EnterpriseEnabledDisabledSettingValue {
  ENABLED,
  DISABLED,
  NO_POLICY,
  $unknown;

  factory Enum$EnterpriseEnabledDisabledSettingValue.fromJson(String value) =>
      fromJson$Enum$EnterpriseEnabledDisabledSettingValue(value);

  String toJson() => toJson$Enum$EnterpriseEnabledDisabledSettingValue(this);
}

String toJson$Enum$EnterpriseEnabledDisabledSettingValue(
    Enum$EnterpriseEnabledDisabledSettingValue e) {
  switch (e) {
    case Enum$EnterpriseEnabledDisabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseEnabledDisabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseEnabledDisabledSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseEnabledDisabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseEnabledDisabledSettingValue
    fromJson$Enum$EnterpriseEnabledDisabledSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$EnterpriseEnabledDisabledSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$EnterpriseEnabledDisabledSettingValue.DISABLED;
    case r'NO_POLICY':
      return Enum$EnterpriseEnabledDisabledSettingValue.NO_POLICY;
    default:
      return Enum$EnterpriseEnabledDisabledSettingValue.$unknown;
  }
}

enum Enum$EnterpriseEnabledSettingValue {
  ENABLED,
  NO_POLICY,
  $unknown;

  factory Enum$EnterpriseEnabledSettingValue.fromJson(String value) =>
      fromJson$Enum$EnterpriseEnabledSettingValue(value);

  String toJson() => toJson$Enum$EnterpriseEnabledSettingValue(this);
}

String toJson$Enum$EnterpriseEnabledSettingValue(
    Enum$EnterpriseEnabledSettingValue e) {
  switch (e) {
    case Enum$EnterpriseEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseEnabledSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseEnabledSettingValue fromJson$Enum$EnterpriseEnabledSettingValue(
    String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$EnterpriseEnabledSettingValue.ENABLED;
    case r'NO_POLICY':
      return Enum$EnterpriseEnabledSettingValue.NO_POLICY;
    default:
      return Enum$EnterpriseEnabledSettingValue.$unknown;
  }
}

enum Enum$EnterpriseMemberInvitationOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$EnterpriseMemberInvitationOrderField.fromJson(String value) =>
      fromJson$Enum$EnterpriseMemberInvitationOrderField(value);

  String toJson() => toJson$Enum$EnterpriseMemberInvitationOrderField(this);
}

String toJson$Enum$EnterpriseMemberInvitationOrderField(
    Enum$EnterpriseMemberInvitationOrderField e) {
  switch (e) {
    case Enum$EnterpriseMemberInvitationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseMemberInvitationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMemberInvitationOrderField
    fromJson$Enum$EnterpriseMemberInvitationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseMemberInvitationOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseMemberInvitationOrderField.$unknown;
  }
}

enum Enum$EnterpriseMemberOrderField {
  LOGIN,
  CREATED_AT,
  $unknown;

  factory Enum$EnterpriseMemberOrderField.fromJson(String value) =>
      fromJson$Enum$EnterpriseMemberOrderField(value);

  String toJson() => toJson$Enum$EnterpriseMemberOrderField(this);
}

String toJson$Enum$EnterpriseMemberOrderField(
    Enum$EnterpriseMemberOrderField e) {
  switch (e) {
    case Enum$EnterpriseMemberOrderField.LOGIN:
      return r'LOGIN';
    case Enum$EnterpriseMemberOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseMemberOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMemberOrderField fromJson$Enum$EnterpriseMemberOrderField(
    String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$EnterpriseMemberOrderField.LOGIN;
    case r'CREATED_AT':
      return Enum$EnterpriseMemberOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseMemberOrderField.$unknown;
  }
}

enum Enum$EnterpriseMembersCanCreateRepositoriesSettingValue {
  NO_POLICY,
  ALL,
  PUBLIC,
  PRIVATE,
  DISABLED,
  $unknown;

  factory Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(value);

  String toJson() =>
      toJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(this);
}

String toJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue e) {
  switch (e) {
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.ALL:
      return r'ALL';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PUBLIC:
      return r'PUBLIC';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PRIVATE:
      return r'PRIVATE';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMembersCanCreateRepositoriesSettingValue
    fromJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
        String value) {
  switch (value) {
    case r'NO_POLICY':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.NO_POLICY;
    case r'ALL':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.ALL;
    case r'PUBLIC':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PUBLIC;
    case r'PRIVATE':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PRIVATE;
    case r'DISABLED':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.DISABLED;
    default:
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.$unknown;
  }
}

enum Enum$EnterpriseMembersCanMakePurchasesSettingValue {
  ENABLED,
  DISABLED,
  $unknown;

  factory Enum$EnterpriseMembersCanMakePurchasesSettingValue.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(value);

  String toJson() =>
      toJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(this);
}

String toJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
    Enum$EnterpriseMembersCanMakePurchasesSettingValue e) {
  switch (e) {
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMembersCanMakePurchasesSettingValue
    fromJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.DISABLED;
    default:
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.$unknown;
  }
}

enum Enum$EnterpriseMembershipType {
  ALL,
  ADMIN,
  BILLING_MANAGER,
  ORG_MEMBERSHIP,
  $unknown;

  factory Enum$EnterpriseMembershipType.fromJson(String value) =>
      fromJson$Enum$EnterpriseMembershipType(value);

  String toJson() => toJson$Enum$EnterpriseMembershipType(this);
}

String toJson$Enum$EnterpriseMembershipType(Enum$EnterpriseMembershipType e) {
  switch (e) {
    case Enum$EnterpriseMembershipType.ALL:
      return r'ALL';
    case Enum$EnterpriseMembershipType.ADMIN:
      return r'ADMIN';
    case Enum$EnterpriseMembershipType.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$EnterpriseMembershipType.ORG_MEMBERSHIP:
      return r'ORG_MEMBERSHIP';
    case Enum$EnterpriseMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMembershipType fromJson$Enum$EnterpriseMembershipType(
    String value) {
  switch (value) {
    case r'ALL':
      return Enum$EnterpriseMembershipType.ALL;
    case r'ADMIN':
      return Enum$EnterpriseMembershipType.ADMIN;
    case r'BILLING_MANAGER':
      return Enum$EnterpriseMembershipType.BILLING_MANAGER;
    case r'ORG_MEMBERSHIP':
      return Enum$EnterpriseMembershipType.ORG_MEMBERSHIP;
    default:
      return Enum$EnterpriseMembershipType.$unknown;
  }
}

enum Enum$EnterpriseOrderField {
  NAME,
  $unknown;

  factory Enum$EnterpriseOrderField.fromJson(String value) =>
      fromJson$Enum$EnterpriseOrderField(value);

  String toJson() => toJson$Enum$EnterpriseOrderField(this);
}

String toJson$Enum$EnterpriseOrderField(Enum$EnterpriseOrderField e) {
  switch (e) {
    case Enum$EnterpriseOrderField.NAME:
      return r'NAME';
    case Enum$EnterpriseOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseOrderField fromJson$Enum$EnterpriseOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$EnterpriseOrderField.NAME;
    default:
      return Enum$EnterpriseOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerInstallationOrderField {
  HOST_NAME,
  CUSTOMER_NAME,
  CREATED_AT,
  $unknown;

  factory Enum$EnterpriseServerInstallationOrderField.fromJson(String value) =>
      fromJson$Enum$EnterpriseServerInstallationOrderField(value);

  String toJson() => toJson$Enum$EnterpriseServerInstallationOrderField(this);
}

String toJson$Enum$EnterpriseServerInstallationOrderField(
    Enum$EnterpriseServerInstallationOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerInstallationOrderField.HOST_NAME:
      return r'HOST_NAME';
    case Enum$EnterpriseServerInstallationOrderField.CUSTOMER_NAME:
      return r'CUSTOMER_NAME';
    case Enum$EnterpriseServerInstallationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseServerInstallationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerInstallationOrderField
    fromJson$Enum$EnterpriseServerInstallationOrderField(String value) {
  switch (value) {
    case r'HOST_NAME':
      return Enum$EnterpriseServerInstallationOrderField.HOST_NAME;
    case r'CUSTOMER_NAME':
      return Enum$EnterpriseServerInstallationOrderField.CUSTOMER_NAME;
    case r'CREATED_AT':
      return Enum$EnterpriseServerInstallationOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseServerInstallationOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountEmailOrderField {
  EMAIL,
  $unknown;

  factory Enum$EnterpriseServerUserAccountEmailOrderField.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseServerUserAccountEmailOrderField(value);

  String toJson() =>
      toJson$Enum$EnterpriseServerUserAccountEmailOrderField(this);
}

String toJson$Enum$EnterpriseServerUserAccountEmailOrderField(
    Enum$EnterpriseServerUserAccountEmailOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountEmailOrderField.EMAIL:
      return r'EMAIL';
    case Enum$EnterpriseServerUserAccountEmailOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountEmailOrderField
    fromJson$Enum$EnterpriseServerUserAccountEmailOrderField(String value) {
  switch (value) {
    case r'EMAIL':
      return Enum$EnterpriseServerUserAccountEmailOrderField.EMAIL;
    default:
      return Enum$EnterpriseServerUserAccountEmailOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountOrderField {
  LOGIN,
  REMOTE_CREATED_AT,
  $unknown;

  factory Enum$EnterpriseServerUserAccountOrderField.fromJson(String value) =>
      fromJson$Enum$EnterpriseServerUserAccountOrderField(value);

  String toJson() => toJson$Enum$EnterpriseServerUserAccountOrderField(this);
}

String toJson$Enum$EnterpriseServerUserAccountOrderField(
    Enum$EnterpriseServerUserAccountOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountOrderField.LOGIN:
      return r'LOGIN';
    case Enum$EnterpriseServerUserAccountOrderField.REMOTE_CREATED_AT:
      return r'REMOTE_CREATED_AT';
    case Enum$EnterpriseServerUserAccountOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountOrderField
    fromJson$Enum$EnterpriseServerUserAccountOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$EnterpriseServerUserAccountOrderField.LOGIN;
    case r'REMOTE_CREATED_AT':
      return Enum$EnterpriseServerUserAccountOrderField.REMOTE_CREATED_AT;
    default:
      return Enum$EnterpriseServerUserAccountOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountsUploadOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$EnterpriseServerUserAccountsUploadOrderField.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseServerUserAccountsUploadOrderField(value);

  String toJson() =>
      toJson$Enum$EnterpriseServerUserAccountsUploadOrderField(this);
}

String toJson$Enum$EnterpriseServerUserAccountsUploadOrderField(
    Enum$EnterpriseServerUserAccountsUploadOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountsUploadOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseServerUserAccountsUploadOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountsUploadOrderField
    fromJson$Enum$EnterpriseServerUserAccountsUploadOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseServerUserAccountsUploadOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseServerUserAccountsUploadOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountsUploadSyncState {
  PENDING,
  SUCCESS,
  FAILURE,
  $unknown;

  factory Enum$EnterpriseServerUserAccountsUploadSyncState.fromJson(
          String value) =>
      fromJson$Enum$EnterpriseServerUserAccountsUploadSyncState(value);

  String toJson() =>
      toJson$Enum$EnterpriseServerUserAccountsUploadSyncState(this);
}

String toJson$Enum$EnterpriseServerUserAccountsUploadSyncState(
    Enum$EnterpriseServerUserAccountsUploadSyncState e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountsUploadSyncState.PENDING:
      return r'PENDING';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.SUCCESS:
      return r'SUCCESS';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.FAILURE:
      return r'FAILURE';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountsUploadSyncState
    fromJson$Enum$EnterpriseServerUserAccountsUploadSyncState(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.PENDING;
    case r'SUCCESS':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.SUCCESS;
    case r'FAILURE':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.FAILURE;
    default:
      return Enum$EnterpriseServerUserAccountsUploadSyncState.$unknown;
  }
}

enum Enum$EnterpriseUserAccountMembershipRole {
  MEMBER,
  OWNER,
  UNAFFILIATED,
  $unknown;

  factory Enum$EnterpriseUserAccountMembershipRole.fromJson(String value) =>
      fromJson$Enum$EnterpriseUserAccountMembershipRole(value);

  String toJson() => toJson$Enum$EnterpriseUserAccountMembershipRole(this);
}

String toJson$Enum$EnterpriseUserAccountMembershipRole(
    Enum$EnterpriseUserAccountMembershipRole e) {
  switch (e) {
    case Enum$EnterpriseUserAccountMembershipRole.MEMBER:
      return r'MEMBER';
    case Enum$EnterpriseUserAccountMembershipRole.OWNER:
      return r'OWNER';
    case Enum$EnterpriseUserAccountMembershipRole.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$EnterpriseUserAccountMembershipRole.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseUserAccountMembershipRole
    fromJson$Enum$EnterpriseUserAccountMembershipRole(String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$EnterpriseUserAccountMembershipRole.MEMBER;
    case r'OWNER':
      return Enum$EnterpriseUserAccountMembershipRole.OWNER;
    case r'UNAFFILIATED':
      return Enum$EnterpriseUserAccountMembershipRole.UNAFFILIATED;
    default:
      return Enum$EnterpriseUserAccountMembershipRole.$unknown;
  }
}

enum Enum$EnterpriseUserDeployment {
  CLOUD,
  SERVER,
  $unknown;

  factory Enum$EnterpriseUserDeployment.fromJson(String value) =>
      fromJson$Enum$EnterpriseUserDeployment(value);

  String toJson() => toJson$Enum$EnterpriseUserDeployment(this);
}

String toJson$Enum$EnterpriseUserDeployment(Enum$EnterpriseUserDeployment e) {
  switch (e) {
    case Enum$EnterpriseUserDeployment.CLOUD:
      return r'CLOUD';
    case Enum$EnterpriseUserDeployment.SERVER:
      return r'SERVER';
    case Enum$EnterpriseUserDeployment.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseUserDeployment fromJson$Enum$EnterpriseUserDeployment(
    String value) {
  switch (value) {
    case r'CLOUD':
      return Enum$EnterpriseUserDeployment.CLOUD;
    case r'SERVER':
      return Enum$EnterpriseUserDeployment.SERVER;
    default:
      return Enum$EnterpriseUserDeployment.$unknown;
  }
}

enum Enum$EnvironmentOrderField {
  NAME,
  $unknown;

  factory Enum$EnvironmentOrderField.fromJson(String value) =>
      fromJson$Enum$EnvironmentOrderField(value);

  String toJson() => toJson$Enum$EnvironmentOrderField(this);
}

String toJson$Enum$EnvironmentOrderField(Enum$EnvironmentOrderField e) {
  switch (e) {
    case Enum$EnvironmentOrderField.NAME:
      return r'NAME';
    case Enum$EnvironmentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnvironmentOrderField fromJson$Enum$EnvironmentOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$EnvironmentOrderField.NAME;
    default:
      return Enum$EnvironmentOrderField.$unknown;
  }
}

enum Enum$EnvironmentPinnedFilterField {
  ALL,
  ONLY,
  NONE,
  $unknown;

  factory Enum$EnvironmentPinnedFilterField.fromJson(String value) =>
      fromJson$Enum$EnvironmentPinnedFilterField(value);

  String toJson() => toJson$Enum$EnvironmentPinnedFilterField(this);
}

String toJson$Enum$EnvironmentPinnedFilterField(
    Enum$EnvironmentPinnedFilterField e) {
  switch (e) {
    case Enum$EnvironmentPinnedFilterField.ALL:
      return r'ALL';
    case Enum$EnvironmentPinnedFilterField.ONLY:
      return r'ONLY';
    case Enum$EnvironmentPinnedFilterField.NONE:
      return r'NONE';
    case Enum$EnvironmentPinnedFilterField.$unknown:
      return r'$unknown';
  }
}

Enum$EnvironmentPinnedFilterField fromJson$Enum$EnvironmentPinnedFilterField(
    String value) {
  switch (value) {
    case r'ALL':
      return Enum$EnvironmentPinnedFilterField.ALL;
    case r'ONLY':
      return Enum$EnvironmentPinnedFilterField.ONLY;
    case r'NONE':
      return Enum$EnvironmentPinnedFilterField.NONE;
    default:
      return Enum$EnvironmentPinnedFilterField.$unknown;
  }
}

enum Enum$FileViewedState {
  DISMISSED,
  VIEWED,
  UNVIEWED,
  $unknown;

  factory Enum$FileViewedState.fromJson(String value) =>
      fromJson$Enum$FileViewedState(value);

  String toJson() => toJson$Enum$FileViewedState(this);
}

String toJson$Enum$FileViewedState(Enum$FileViewedState e) {
  switch (e) {
    case Enum$FileViewedState.DISMISSED:
      return r'DISMISSED';
    case Enum$FileViewedState.VIEWED:
      return r'VIEWED';
    case Enum$FileViewedState.UNVIEWED:
      return r'UNVIEWED';
    case Enum$FileViewedState.$unknown:
      return r'$unknown';
  }
}

Enum$FileViewedState fromJson$Enum$FileViewedState(String value) {
  switch (value) {
    case r'DISMISSED':
      return Enum$FileViewedState.DISMISSED;
    case r'VIEWED':
      return Enum$FileViewedState.VIEWED;
    case r'UNVIEWED':
      return Enum$FileViewedState.UNVIEWED;
    default:
      return Enum$FileViewedState.$unknown;
  }
}

enum Enum$FundingPlatform {
  GITHUB,
  PATREON,
  OPEN_COLLECTIVE,
  KO_FI,
  TIDELIFT,
  COMMUNITY_BRIDGE,
  LIBERAPAY,
  ISSUEHUNT,
  LFX_CROWDFUNDING,
  POLAR,
  BUY_ME_A_COFFEE,
  THANKS_DEV,
  CUSTOM,
  $unknown;

  factory Enum$FundingPlatform.fromJson(String value) =>
      fromJson$Enum$FundingPlatform(value);

  String toJson() => toJson$Enum$FundingPlatform(this);
}

String toJson$Enum$FundingPlatform(Enum$FundingPlatform e) {
  switch (e) {
    case Enum$FundingPlatform.GITHUB:
      return r'GITHUB';
    case Enum$FundingPlatform.PATREON:
      return r'PATREON';
    case Enum$FundingPlatform.OPEN_COLLECTIVE:
      return r'OPEN_COLLECTIVE';
    case Enum$FundingPlatform.KO_FI:
      return r'KO_FI';
    case Enum$FundingPlatform.TIDELIFT:
      return r'TIDELIFT';
    case Enum$FundingPlatform.COMMUNITY_BRIDGE:
      return r'COMMUNITY_BRIDGE';
    case Enum$FundingPlatform.LIBERAPAY:
      return r'LIBERAPAY';
    case Enum$FundingPlatform.ISSUEHUNT:
      return r'ISSUEHUNT';
    case Enum$FundingPlatform.LFX_CROWDFUNDING:
      return r'LFX_CROWDFUNDING';
    case Enum$FundingPlatform.POLAR:
      return r'POLAR';
    case Enum$FundingPlatform.BUY_ME_A_COFFEE:
      return r'BUY_ME_A_COFFEE';
    case Enum$FundingPlatform.THANKS_DEV:
      return r'THANKS_DEV';
    case Enum$FundingPlatform.CUSTOM:
      return r'CUSTOM';
    case Enum$FundingPlatform.$unknown:
      return r'$unknown';
  }
}

Enum$FundingPlatform fromJson$Enum$FundingPlatform(String value) {
  switch (value) {
    case r'GITHUB':
      return Enum$FundingPlatform.GITHUB;
    case r'PATREON':
      return Enum$FundingPlatform.PATREON;
    case r'OPEN_COLLECTIVE':
      return Enum$FundingPlatform.OPEN_COLLECTIVE;
    case r'KO_FI':
      return Enum$FundingPlatform.KO_FI;
    case r'TIDELIFT':
      return Enum$FundingPlatform.TIDELIFT;
    case r'COMMUNITY_BRIDGE':
      return Enum$FundingPlatform.COMMUNITY_BRIDGE;
    case r'LIBERAPAY':
      return Enum$FundingPlatform.LIBERAPAY;
    case r'ISSUEHUNT':
      return Enum$FundingPlatform.ISSUEHUNT;
    case r'LFX_CROWDFUNDING':
      return Enum$FundingPlatform.LFX_CROWDFUNDING;
    case r'POLAR':
      return Enum$FundingPlatform.POLAR;
    case r'BUY_ME_A_COFFEE':
      return Enum$FundingPlatform.BUY_ME_A_COFFEE;
    case r'THANKS_DEV':
      return Enum$FundingPlatform.THANKS_DEV;
    case r'CUSTOM':
      return Enum$FundingPlatform.CUSTOM;
    default:
      return Enum$FundingPlatform.$unknown;
  }
}

enum Enum$GistOrderField {
  CREATED_AT,
  UPDATED_AT,
  PUSHED_AT,
  $unknown;

  factory Enum$GistOrderField.fromJson(String value) =>
      fromJson$Enum$GistOrderField(value);

  String toJson() => toJson$Enum$GistOrderField(this);
}

String toJson$Enum$GistOrderField(Enum$GistOrderField e) {
  switch (e) {
    case Enum$GistOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$GistOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$GistOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$GistOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$GistOrderField fromJson$Enum$GistOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$GistOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$GistOrderField.UPDATED_AT;
    case r'PUSHED_AT':
      return Enum$GistOrderField.PUSHED_AT;
    default:
      return Enum$GistOrderField.$unknown;
  }
}

enum Enum$GistPrivacy {
  PUBLIC,
  SECRET,
  ALL,
  $unknown;

  factory Enum$GistPrivacy.fromJson(String value) =>
      fromJson$Enum$GistPrivacy(value);

  String toJson() => toJson$Enum$GistPrivacy(this);
}

String toJson$Enum$GistPrivacy(Enum$GistPrivacy e) {
  switch (e) {
    case Enum$GistPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$GistPrivacy.SECRET:
      return r'SECRET';
    case Enum$GistPrivacy.ALL:
      return r'ALL';
    case Enum$GistPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$GistPrivacy fromJson$Enum$GistPrivacy(String value) {
  switch (value) {
    case r'PUBLIC':
      return Enum$GistPrivacy.PUBLIC;
    case r'SECRET':
      return Enum$GistPrivacy.SECRET;
    case r'ALL':
      return Enum$GistPrivacy.ALL;
    default:
      return Enum$GistPrivacy.$unknown;
  }
}

enum Enum$GitSignatureState {
  VALID,
  INVALID,
  MALFORMED_SIG,
  UNKNOWN_KEY,
  BAD_EMAIL,
  UNVERIFIED_EMAIL,
  NO_USER,
  UNKNOWN_SIG_TYPE,
  UNSIGNED,
  GPGVERIFY_UNAVAILABLE,
  GPGVERIFY_ERROR,
  NOT_SIGNING_KEY,
  EXPIRED_KEY,
  OCSP_PENDING,
  OCSP_ERROR,
  BAD_CERT,
  OCSP_REVOKED,
  $unknown;

  factory Enum$GitSignatureState.fromJson(String value) =>
      fromJson$Enum$GitSignatureState(value);

  String toJson() => toJson$Enum$GitSignatureState(this);
}

String toJson$Enum$GitSignatureState(Enum$GitSignatureState e) {
  switch (e) {
    case Enum$GitSignatureState.VALID:
      return r'VALID';
    case Enum$GitSignatureState.INVALID:
      return r'INVALID';
    case Enum$GitSignatureState.MALFORMED_SIG:
      return r'MALFORMED_SIG';
    case Enum$GitSignatureState.UNKNOWN_KEY:
      return r'UNKNOWN_KEY';
    case Enum$GitSignatureState.BAD_EMAIL:
      return r'BAD_EMAIL';
    case Enum$GitSignatureState.UNVERIFIED_EMAIL:
      return r'UNVERIFIED_EMAIL';
    case Enum$GitSignatureState.NO_USER:
      return r'NO_USER';
    case Enum$GitSignatureState.UNKNOWN_SIG_TYPE:
      return r'UNKNOWN_SIG_TYPE';
    case Enum$GitSignatureState.UNSIGNED:
      return r'UNSIGNED';
    case Enum$GitSignatureState.GPGVERIFY_UNAVAILABLE:
      return r'GPGVERIFY_UNAVAILABLE';
    case Enum$GitSignatureState.GPGVERIFY_ERROR:
      return r'GPGVERIFY_ERROR';
    case Enum$GitSignatureState.NOT_SIGNING_KEY:
      return r'NOT_SIGNING_KEY';
    case Enum$GitSignatureState.EXPIRED_KEY:
      return r'EXPIRED_KEY';
    case Enum$GitSignatureState.OCSP_PENDING:
      return r'OCSP_PENDING';
    case Enum$GitSignatureState.OCSP_ERROR:
      return r'OCSP_ERROR';
    case Enum$GitSignatureState.BAD_CERT:
      return r'BAD_CERT';
    case Enum$GitSignatureState.OCSP_REVOKED:
      return r'OCSP_REVOKED';
    case Enum$GitSignatureState.$unknown:
      return r'$unknown';
  }
}

Enum$GitSignatureState fromJson$Enum$GitSignatureState(String value) {
  switch (value) {
    case r'VALID':
      return Enum$GitSignatureState.VALID;
    case r'INVALID':
      return Enum$GitSignatureState.INVALID;
    case r'MALFORMED_SIG':
      return Enum$GitSignatureState.MALFORMED_SIG;
    case r'UNKNOWN_KEY':
      return Enum$GitSignatureState.UNKNOWN_KEY;
    case r'BAD_EMAIL':
      return Enum$GitSignatureState.BAD_EMAIL;
    case r'UNVERIFIED_EMAIL':
      return Enum$GitSignatureState.UNVERIFIED_EMAIL;
    case r'NO_USER':
      return Enum$GitSignatureState.NO_USER;
    case r'UNKNOWN_SIG_TYPE':
      return Enum$GitSignatureState.UNKNOWN_SIG_TYPE;
    case r'UNSIGNED':
      return Enum$GitSignatureState.UNSIGNED;
    case r'GPGVERIFY_UNAVAILABLE':
      return Enum$GitSignatureState.GPGVERIFY_UNAVAILABLE;
    case r'GPGVERIFY_ERROR':
      return Enum$GitSignatureState.GPGVERIFY_ERROR;
    case r'NOT_SIGNING_KEY':
      return Enum$GitSignatureState.NOT_SIGNING_KEY;
    case r'EXPIRED_KEY':
      return Enum$GitSignatureState.EXPIRED_KEY;
    case r'OCSP_PENDING':
      return Enum$GitSignatureState.OCSP_PENDING;
    case r'OCSP_ERROR':
      return Enum$GitSignatureState.OCSP_ERROR;
    case r'BAD_CERT':
      return Enum$GitSignatureState.BAD_CERT;
    case r'OCSP_REVOKED':
      return Enum$GitSignatureState.OCSP_REVOKED;
    default:
      return Enum$GitSignatureState.$unknown;
  }
}

enum Enum$IdentityProviderConfigurationState {
  ENFORCED,
  CONFIGURED,
  UNCONFIGURED,
  $unknown;

  factory Enum$IdentityProviderConfigurationState.fromJson(String value) =>
      fromJson$Enum$IdentityProviderConfigurationState(value);

  String toJson() => toJson$Enum$IdentityProviderConfigurationState(this);
}

String toJson$Enum$IdentityProviderConfigurationState(
    Enum$IdentityProviderConfigurationState e) {
  switch (e) {
    case Enum$IdentityProviderConfigurationState.ENFORCED:
      return r'ENFORCED';
    case Enum$IdentityProviderConfigurationState.CONFIGURED:
      return r'CONFIGURED';
    case Enum$IdentityProviderConfigurationState.UNCONFIGURED:
      return r'UNCONFIGURED';
    case Enum$IdentityProviderConfigurationState.$unknown:
      return r'$unknown';
  }
}

Enum$IdentityProviderConfigurationState
    fromJson$Enum$IdentityProviderConfigurationState(String value) {
  switch (value) {
    case r'ENFORCED':
      return Enum$IdentityProviderConfigurationState.ENFORCED;
    case r'CONFIGURED':
      return Enum$IdentityProviderConfigurationState.CONFIGURED;
    case r'UNCONFIGURED':
      return Enum$IdentityProviderConfigurationState.UNCONFIGURED;
    default:
      return Enum$IdentityProviderConfigurationState.$unknown;
  }
}

enum Enum$IpAllowListEnabledSettingValue {
  ENABLED,
  DISABLED,
  $unknown;

  factory Enum$IpAllowListEnabledSettingValue.fromJson(String value) =>
      fromJson$Enum$IpAllowListEnabledSettingValue(value);

  String toJson() => toJson$Enum$IpAllowListEnabledSettingValue(this);
}

String toJson$Enum$IpAllowListEnabledSettingValue(
    Enum$IpAllowListEnabledSettingValue e) {
  switch (e) {
    case Enum$IpAllowListEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$IpAllowListEnabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$IpAllowListEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListEnabledSettingValue
    fromJson$Enum$IpAllowListEnabledSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$IpAllowListEnabledSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$IpAllowListEnabledSettingValue.DISABLED;
    default:
      return Enum$IpAllowListEnabledSettingValue.$unknown;
  }
}

enum Enum$IpAllowListEntryOrderField {
  CREATED_AT,
  ALLOW_LIST_VALUE,
  $unknown;

  factory Enum$IpAllowListEntryOrderField.fromJson(String value) =>
      fromJson$Enum$IpAllowListEntryOrderField(value);

  String toJson() => toJson$Enum$IpAllowListEntryOrderField(this);
}

String toJson$Enum$IpAllowListEntryOrderField(
    Enum$IpAllowListEntryOrderField e) {
  switch (e) {
    case Enum$IpAllowListEntryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IpAllowListEntryOrderField.ALLOW_LIST_VALUE:
      return r'ALLOW_LIST_VALUE';
    case Enum$IpAllowListEntryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListEntryOrderField fromJson$Enum$IpAllowListEntryOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$IpAllowListEntryOrderField.CREATED_AT;
    case r'ALLOW_LIST_VALUE':
      return Enum$IpAllowListEntryOrderField.ALLOW_LIST_VALUE;
    default:
      return Enum$IpAllowListEntryOrderField.$unknown;
  }
}

enum Enum$IpAllowListForInstalledAppsEnabledSettingValue {
  ENABLED,
  DISABLED,
  $unknown;

  factory Enum$IpAllowListForInstalledAppsEnabledSettingValue.fromJson(
          String value) =>
      fromJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(value);

  String toJson() =>
      toJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(this);
}

String toJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
    Enum$IpAllowListForInstalledAppsEnabledSettingValue e) {
  switch (e) {
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListForInstalledAppsEnabledSettingValue
    fromJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.DISABLED;
    default:
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.$unknown;
  }
}

enum Enum$IssueClosedStateReason {
  COMPLETED,
  NOT_PLANNED,
  DUPLICATE,
  $unknown;

  factory Enum$IssueClosedStateReason.fromJson(String value) =>
      fromJson$Enum$IssueClosedStateReason(value);

  String toJson() => toJson$Enum$IssueClosedStateReason(this);
}

String toJson$Enum$IssueClosedStateReason(Enum$IssueClosedStateReason e) {
  switch (e) {
    case Enum$IssueClosedStateReason.COMPLETED:
      return r'COMPLETED';
    case Enum$IssueClosedStateReason.NOT_PLANNED:
      return r'NOT_PLANNED';
    case Enum$IssueClosedStateReason.DUPLICATE:
      return r'DUPLICATE';
    case Enum$IssueClosedStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$IssueClosedStateReason fromJson$Enum$IssueClosedStateReason(String value) {
  switch (value) {
    case r'COMPLETED':
      return Enum$IssueClosedStateReason.COMPLETED;
    case r'NOT_PLANNED':
      return Enum$IssueClosedStateReason.NOT_PLANNED;
    case r'DUPLICATE':
      return Enum$IssueClosedStateReason.DUPLICATE;
    default:
      return Enum$IssueClosedStateReason.$unknown;
  }
}

enum Enum$IssueCommentOrderField {
  UPDATED_AT,
  $unknown;

  factory Enum$IssueCommentOrderField.fromJson(String value) =>
      fromJson$Enum$IssueCommentOrderField(value);

  String toJson() => toJson$Enum$IssueCommentOrderField(this);
}

String toJson$Enum$IssueCommentOrderField(Enum$IssueCommentOrderField e) {
  switch (e) {
    case Enum$IssueCommentOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$IssueCommentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueCommentOrderField fromJson$Enum$IssueCommentOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$IssueCommentOrderField.UPDATED_AT;
    default:
      return Enum$IssueCommentOrderField.$unknown;
  }
}

enum Enum$IssueDependencyOrderField {
  DEPENDENCY_ADDED_AT,
  CREATED_AT,
  $unknown;

  factory Enum$IssueDependencyOrderField.fromJson(String value) =>
      fromJson$Enum$IssueDependencyOrderField(value);

  String toJson() => toJson$Enum$IssueDependencyOrderField(this);
}

String toJson$Enum$IssueDependencyOrderField(Enum$IssueDependencyOrderField e) {
  switch (e) {
    case Enum$IssueDependencyOrderField.DEPENDENCY_ADDED_AT:
      return r'DEPENDENCY_ADDED_AT';
    case Enum$IssueDependencyOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IssueDependencyOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueDependencyOrderField fromJson$Enum$IssueDependencyOrderField(
    String value) {
  switch (value) {
    case r'DEPENDENCY_ADDED_AT':
      return Enum$IssueDependencyOrderField.DEPENDENCY_ADDED_AT;
    case r'CREATED_AT':
      return Enum$IssueDependencyOrderField.CREATED_AT;
    default:
      return Enum$IssueDependencyOrderField.$unknown;
  }
}

enum Enum$IssueOrderField {
  CREATED_AT,
  UPDATED_AT,
  COMMENTS,
  $unknown;

  factory Enum$IssueOrderField.fromJson(String value) =>
      fromJson$Enum$IssueOrderField(value);

  String toJson() => toJson$Enum$IssueOrderField(this);
}

String toJson$Enum$IssueOrderField(Enum$IssueOrderField e) {
  switch (e) {
    case Enum$IssueOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IssueOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$IssueOrderField.COMMENTS:
      return r'COMMENTS';
    case Enum$IssueOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueOrderField fromJson$Enum$IssueOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$IssueOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$IssueOrderField.UPDATED_AT;
    case r'COMMENTS':
      return Enum$IssueOrderField.COMMENTS;
    default:
      return Enum$IssueOrderField.$unknown;
  }
}

enum Enum$IssueState {
  OPEN,
  CLOSED,
  $unknown;

  factory Enum$IssueState.fromJson(String value) =>
      fromJson$Enum$IssueState(value);

  String toJson() => toJson$Enum$IssueState(this);
}

String toJson$Enum$IssueState(Enum$IssueState e) {
  switch (e) {
    case Enum$IssueState.OPEN:
      return r'OPEN';
    case Enum$IssueState.CLOSED:
      return r'CLOSED';
    case Enum$IssueState.$unknown:
      return r'$unknown';
  }
}

Enum$IssueState fromJson$Enum$IssueState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$IssueState.OPEN;
    case r'CLOSED':
      return Enum$IssueState.CLOSED;
    default:
      return Enum$IssueState.$unknown;
  }
}

enum Enum$IssueStateReason {
  REOPENED,
  NOT_PLANNED,
  COMPLETED,
  DUPLICATE,
  $unknown;

  factory Enum$IssueStateReason.fromJson(String value) =>
      fromJson$Enum$IssueStateReason(value);

  String toJson() => toJson$Enum$IssueStateReason(this);
}

String toJson$Enum$IssueStateReason(Enum$IssueStateReason e) {
  switch (e) {
    case Enum$IssueStateReason.REOPENED:
      return r'REOPENED';
    case Enum$IssueStateReason.NOT_PLANNED:
      return r'NOT_PLANNED';
    case Enum$IssueStateReason.COMPLETED:
      return r'COMPLETED';
    case Enum$IssueStateReason.DUPLICATE:
      return r'DUPLICATE';
    case Enum$IssueStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$IssueStateReason fromJson$Enum$IssueStateReason(String value) {
  switch (value) {
    case r'REOPENED':
      return Enum$IssueStateReason.REOPENED;
    case r'NOT_PLANNED':
      return Enum$IssueStateReason.NOT_PLANNED;
    case r'COMPLETED':
      return Enum$IssueStateReason.COMPLETED;
    case r'DUPLICATE':
      return Enum$IssueStateReason.DUPLICATE;
    default:
      return Enum$IssueStateReason.$unknown;
  }
}

enum Enum$IssueTimelineItemsItemType {
  ISSUE_COMMENT,
  CROSS_REFERENCED_EVENT,
  ADDED_TO_PROJECT_EVENT,
  ASSIGNED_EVENT,
  CLOSED_EVENT,
  COMMENT_DELETED_EVENT,
  CONNECTED_EVENT,
  CONVERTED_NOTE_TO_ISSUE_EVENT,
  CONVERTED_TO_DISCUSSION_EVENT,
  DEMILESTONED_EVENT,
  DISCONNECTED_EVENT,
  LABELED_EVENT,
  LOCKED_EVENT,
  MARKED_AS_DUPLICATE_EVENT,
  MENTIONED_EVENT,
  MILESTONED_EVENT,
  MOVED_COLUMNS_IN_PROJECT_EVENT,
  PINNED_EVENT,
  REFERENCED_EVENT,
  REMOVED_FROM_PROJECT_EVENT,
  RENAMED_TITLE_EVENT,
  REOPENED_EVENT,
  SUBSCRIBED_EVENT,
  TRANSFERRED_EVENT,
  UNASSIGNED_EVENT,
  UNLABELED_EVENT,
  UNLOCKED_EVENT,
  USER_BLOCKED_EVENT,
  UNMARKED_AS_DUPLICATE_EVENT,
  UNPINNED_EVENT,
  UNSUBSCRIBED_EVENT,
  ISSUE_TYPE_ADDED_EVENT,
  ISSUE_TYPE_REMOVED_EVENT,
  ISSUE_TYPE_CHANGED_EVENT,
  SUB_ISSUE_ADDED_EVENT,
  SUB_ISSUE_REMOVED_EVENT,
  PARENT_ISSUE_ADDED_EVENT,
  PARENT_ISSUE_REMOVED_EVENT,
  BLOCKED_BY_ADDED_EVENT,
  BLOCKING_ADDED_EVENT,
  BLOCKED_BY_REMOVED_EVENT,
  BLOCKING_REMOVED_EVENT,
  $unknown;

  factory Enum$IssueTimelineItemsItemType.fromJson(String value) =>
      fromJson$Enum$IssueTimelineItemsItemType(value);

  String toJson() => toJson$Enum$IssueTimelineItemsItemType(this);
}

String toJson$Enum$IssueTimelineItemsItemType(
    Enum$IssueTimelineItemsItemType e) {
  switch (e) {
    case Enum$IssueTimelineItemsItemType.ISSUE_COMMENT:
      return r'ISSUE_COMMENT';
    case Enum$IssueTimelineItemsItemType.CROSS_REFERENCED_EVENT:
      return r'CROSS_REFERENCED_EVENT';
    case Enum$IssueTimelineItemsItemType.ADDED_TO_PROJECT_EVENT:
      return r'ADDED_TO_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.ASSIGNED_EVENT:
      return r'ASSIGNED_EVENT';
    case Enum$IssueTimelineItemsItemType.CLOSED_EVENT:
      return r'CLOSED_EVENT';
    case Enum$IssueTimelineItemsItemType.COMMENT_DELETED_EVENT:
      return r'COMMENT_DELETED_EVENT';
    case Enum$IssueTimelineItemsItemType.CONNECTED_EVENT:
      return r'CONNECTED_EVENT';
    case Enum$IssueTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT:
      return r'CONVERTED_NOTE_TO_ISSUE_EVENT';
    case Enum$IssueTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT:
      return r'CONVERTED_TO_DISCUSSION_EVENT';
    case Enum$IssueTimelineItemsItemType.DEMILESTONED_EVENT:
      return r'DEMILESTONED_EVENT';
    case Enum$IssueTimelineItemsItemType.DISCONNECTED_EVENT:
      return r'DISCONNECTED_EVENT';
    case Enum$IssueTimelineItemsItemType.LABELED_EVENT:
      return r'LABELED_EVENT';
    case Enum$IssueTimelineItemsItemType.LOCKED_EVENT:
      return r'LOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT:
      return r'MARKED_AS_DUPLICATE_EVENT';
    case Enum$IssueTimelineItemsItemType.MENTIONED_EVENT:
      return r'MENTIONED_EVENT';
    case Enum$IssueTimelineItemsItemType.MILESTONED_EVENT:
      return r'MILESTONED_EVENT';
    case Enum$IssueTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT:
      return r'MOVED_COLUMNS_IN_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.PINNED_EVENT:
      return r'PINNED_EVENT';
    case Enum$IssueTimelineItemsItemType.REFERENCED_EVENT:
      return r'REFERENCED_EVENT';
    case Enum$IssueTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT:
      return r'REMOVED_FROM_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.RENAMED_TITLE_EVENT:
      return r'RENAMED_TITLE_EVENT';
    case Enum$IssueTimelineItemsItemType.REOPENED_EVENT:
      return r'REOPENED_EVENT';
    case Enum$IssueTimelineItemsItemType.SUBSCRIBED_EVENT:
      return r'SUBSCRIBED_EVENT';
    case Enum$IssueTimelineItemsItemType.TRANSFERRED_EVENT:
      return r'TRANSFERRED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNASSIGNED_EVENT:
      return r'UNASSIGNED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNLABELED_EVENT:
      return r'UNLABELED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNLOCKED_EVENT:
      return r'UNLOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.USER_BLOCKED_EVENT:
      return r'USER_BLOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT:
      return r'UNMARKED_AS_DUPLICATE_EVENT';
    case Enum$IssueTimelineItemsItemType.UNPINNED_EVENT:
      return r'UNPINNED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNSUBSCRIBED_EVENT:
      return r'UNSUBSCRIBED_EVENT';
    case Enum$IssueTimelineItemsItemType.ISSUE_TYPE_ADDED_EVENT:
      return r'ISSUE_TYPE_ADDED_EVENT';
    case Enum$IssueTimelineItemsItemType.ISSUE_TYPE_REMOVED_EVENT:
      return r'ISSUE_TYPE_REMOVED_EVENT';
    case Enum$IssueTimelineItemsItemType.ISSUE_TYPE_CHANGED_EVENT:
      return r'ISSUE_TYPE_CHANGED_EVENT';
    case Enum$IssueTimelineItemsItemType.SUB_ISSUE_ADDED_EVENT:
      return r'SUB_ISSUE_ADDED_EVENT';
    case Enum$IssueTimelineItemsItemType.SUB_ISSUE_REMOVED_EVENT:
      return r'SUB_ISSUE_REMOVED_EVENT';
    case Enum$IssueTimelineItemsItemType.PARENT_ISSUE_ADDED_EVENT:
      return r'PARENT_ISSUE_ADDED_EVENT';
    case Enum$IssueTimelineItemsItemType.PARENT_ISSUE_REMOVED_EVENT:
      return r'PARENT_ISSUE_REMOVED_EVENT';
    case Enum$IssueTimelineItemsItemType.BLOCKED_BY_ADDED_EVENT:
      return r'BLOCKED_BY_ADDED_EVENT';
    case Enum$IssueTimelineItemsItemType.BLOCKING_ADDED_EVENT:
      return r'BLOCKING_ADDED_EVENT';
    case Enum$IssueTimelineItemsItemType.BLOCKED_BY_REMOVED_EVENT:
      return r'BLOCKED_BY_REMOVED_EVENT';
    case Enum$IssueTimelineItemsItemType.BLOCKING_REMOVED_EVENT:
      return r'BLOCKING_REMOVED_EVENT';
    case Enum$IssueTimelineItemsItemType.$unknown:
      return r'$unknown';
  }
}

Enum$IssueTimelineItemsItemType fromJson$Enum$IssueTimelineItemsItemType(
    String value) {
  switch (value) {
    case r'ISSUE_COMMENT':
      return Enum$IssueTimelineItemsItemType.ISSUE_COMMENT;
    case r'CROSS_REFERENCED_EVENT':
      return Enum$IssueTimelineItemsItemType.CROSS_REFERENCED_EVENT;
    case r'ADDED_TO_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.ADDED_TO_PROJECT_EVENT;
    case r'ASSIGNED_EVENT':
      return Enum$IssueTimelineItemsItemType.ASSIGNED_EVENT;
    case r'CLOSED_EVENT':
      return Enum$IssueTimelineItemsItemType.CLOSED_EVENT;
    case r'COMMENT_DELETED_EVENT':
      return Enum$IssueTimelineItemsItemType.COMMENT_DELETED_EVENT;
    case r'CONNECTED_EVENT':
      return Enum$IssueTimelineItemsItemType.CONNECTED_EVENT;
    case r'CONVERTED_NOTE_TO_ISSUE_EVENT':
      return Enum$IssueTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT;
    case r'CONVERTED_TO_DISCUSSION_EVENT':
      return Enum$IssueTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT;
    case r'DEMILESTONED_EVENT':
      return Enum$IssueTimelineItemsItemType.DEMILESTONED_EVENT;
    case r'DISCONNECTED_EVENT':
      return Enum$IssueTimelineItemsItemType.DISCONNECTED_EVENT;
    case r'LABELED_EVENT':
      return Enum$IssueTimelineItemsItemType.LABELED_EVENT;
    case r'LOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.LOCKED_EVENT;
    case r'MARKED_AS_DUPLICATE_EVENT':
      return Enum$IssueTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT;
    case r'MENTIONED_EVENT':
      return Enum$IssueTimelineItemsItemType.MENTIONED_EVENT;
    case r'MILESTONED_EVENT':
      return Enum$IssueTimelineItemsItemType.MILESTONED_EVENT;
    case r'MOVED_COLUMNS_IN_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT;
    case r'PINNED_EVENT':
      return Enum$IssueTimelineItemsItemType.PINNED_EVENT;
    case r'REFERENCED_EVENT':
      return Enum$IssueTimelineItemsItemType.REFERENCED_EVENT;
    case r'REMOVED_FROM_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT;
    case r'RENAMED_TITLE_EVENT':
      return Enum$IssueTimelineItemsItemType.RENAMED_TITLE_EVENT;
    case r'REOPENED_EVENT':
      return Enum$IssueTimelineItemsItemType.REOPENED_EVENT;
    case r'SUBSCRIBED_EVENT':
      return Enum$IssueTimelineItemsItemType.SUBSCRIBED_EVENT;
    case r'TRANSFERRED_EVENT':
      return Enum$IssueTimelineItemsItemType.TRANSFERRED_EVENT;
    case r'UNASSIGNED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNASSIGNED_EVENT;
    case r'UNLABELED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNLABELED_EVENT;
    case r'UNLOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNLOCKED_EVENT;
    case r'USER_BLOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.USER_BLOCKED_EVENT;
    case r'UNMARKED_AS_DUPLICATE_EVENT':
      return Enum$IssueTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT;
    case r'UNPINNED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNPINNED_EVENT;
    case r'UNSUBSCRIBED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNSUBSCRIBED_EVENT;
    case r'ISSUE_TYPE_ADDED_EVENT':
      return Enum$IssueTimelineItemsItemType.ISSUE_TYPE_ADDED_EVENT;
    case r'ISSUE_TYPE_REMOVED_EVENT':
      return Enum$IssueTimelineItemsItemType.ISSUE_TYPE_REMOVED_EVENT;
    case r'ISSUE_TYPE_CHANGED_EVENT':
      return Enum$IssueTimelineItemsItemType.ISSUE_TYPE_CHANGED_EVENT;
    case r'SUB_ISSUE_ADDED_EVENT':
      return Enum$IssueTimelineItemsItemType.SUB_ISSUE_ADDED_EVENT;
    case r'SUB_ISSUE_REMOVED_EVENT':
      return Enum$IssueTimelineItemsItemType.SUB_ISSUE_REMOVED_EVENT;
    case r'PARENT_ISSUE_ADDED_EVENT':
      return Enum$IssueTimelineItemsItemType.PARENT_ISSUE_ADDED_EVENT;
    case r'PARENT_ISSUE_REMOVED_EVENT':
      return Enum$IssueTimelineItemsItemType.PARENT_ISSUE_REMOVED_EVENT;
    case r'BLOCKED_BY_ADDED_EVENT':
      return Enum$IssueTimelineItemsItemType.BLOCKED_BY_ADDED_EVENT;
    case r'BLOCKING_ADDED_EVENT':
      return Enum$IssueTimelineItemsItemType.BLOCKING_ADDED_EVENT;
    case r'BLOCKED_BY_REMOVED_EVENT':
      return Enum$IssueTimelineItemsItemType.BLOCKED_BY_REMOVED_EVENT;
    case r'BLOCKING_REMOVED_EVENT':
      return Enum$IssueTimelineItemsItemType.BLOCKING_REMOVED_EVENT;
    default:
      return Enum$IssueTimelineItemsItemType.$unknown;
  }
}

enum Enum$IssueTypeColor {
  GRAY,
  BLUE,
  GREEN,
  YELLOW,
  ORANGE,
  RED,
  PINK,
  PURPLE,
  $unknown;

  factory Enum$IssueTypeColor.fromJson(String value) =>
      fromJson$Enum$IssueTypeColor(value);

  String toJson() => toJson$Enum$IssueTypeColor(this);
}

String toJson$Enum$IssueTypeColor(Enum$IssueTypeColor e) {
  switch (e) {
    case Enum$IssueTypeColor.GRAY:
      return r'GRAY';
    case Enum$IssueTypeColor.BLUE:
      return r'BLUE';
    case Enum$IssueTypeColor.GREEN:
      return r'GREEN';
    case Enum$IssueTypeColor.YELLOW:
      return r'YELLOW';
    case Enum$IssueTypeColor.ORANGE:
      return r'ORANGE';
    case Enum$IssueTypeColor.RED:
      return r'RED';
    case Enum$IssueTypeColor.PINK:
      return r'PINK';
    case Enum$IssueTypeColor.PURPLE:
      return r'PURPLE';
    case Enum$IssueTypeColor.$unknown:
      return r'$unknown';
  }
}

Enum$IssueTypeColor fromJson$Enum$IssueTypeColor(String value) {
  switch (value) {
    case r'GRAY':
      return Enum$IssueTypeColor.GRAY;
    case r'BLUE':
      return Enum$IssueTypeColor.BLUE;
    case r'GREEN':
      return Enum$IssueTypeColor.GREEN;
    case r'YELLOW':
      return Enum$IssueTypeColor.YELLOW;
    case r'ORANGE':
      return Enum$IssueTypeColor.ORANGE;
    case r'RED':
      return Enum$IssueTypeColor.RED;
    case r'PINK':
      return Enum$IssueTypeColor.PINK;
    case r'PURPLE':
      return Enum$IssueTypeColor.PURPLE;
    default:
      return Enum$IssueTypeColor.$unknown;
  }
}

enum Enum$IssueTypeOrderField {
  CREATED_AT,
  NAME,
  $unknown;

  factory Enum$IssueTypeOrderField.fromJson(String value) =>
      fromJson$Enum$IssueTypeOrderField(value);

  String toJson() => toJson$Enum$IssueTypeOrderField(this);
}

String toJson$Enum$IssueTypeOrderField(Enum$IssueTypeOrderField e) {
  switch (e) {
    case Enum$IssueTypeOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IssueTypeOrderField.NAME:
      return r'NAME';
    case Enum$IssueTypeOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueTypeOrderField fromJson$Enum$IssueTypeOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$IssueTypeOrderField.CREATED_AT;
    case r'NAME':
      return Enum$IssueTypeOrderField.NAME;
    default:
      return Enum$IssueTypeOrderField.$unknown;
  }
}

enum Enum$LabelOrderField {
  NAME,
  CREATED_AT,
  ISSUE_COUNT,
  $unknown;

  factory Enum$LabelOrderField.fromJson(String value) =>
      fromJson$Enum$LabelOrderField(value);

  String toJson() => toJson$Enum$LabelOrderField(this);
}

String toJson$Enum$LabelOrderField(Enum$LabelOrderField e) {
  switch (e) {
    case Enum$LabelOrderField.NAME:
      return r'NAME';
    case Enum$LabelOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$LabelOrderField.ISSUE_COUNT:
      return r'ISSUE_COUNT';
    case Enum$LabelOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$LabelOrderField fromJson$Enum$LabelOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$LabelOrderField.NAME;
    case r'CREATED_AT':
      return Enum$LabelOrderField.CREATED_AT;
    case r'ISSUE_COUNT':
      return Enum$LabelOrderField.ISSUE_COUNT;
    default:
      return Enum$LabelOrderField.$unknown;
  }
}

enum Enum$LanguageOrderField {
  SIZE,
  $unknown;

  factory Enum$LanguageOrderField.fromJson(String value) =>
      fromJson$Enum$LanguageOrderField(value);

  String toJson() => toJson$Enum$LanguageOrderField(this);
}

String toJson$Enum$LanguageOrderField(Enum$LanguageOrderField e) {
  switch (e) {
    case Enum$LanguageOrderField.SIZE:
      return r'SIZE';
    case Enum$LanguageOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$LanguageOrderField fromJson$Enum$LanguageOrderField(String value) {
  switch (value) {
    case r'SIZE':
      return Enum$LanguageOrderField.SIZE;
    default:
      return Enum$LanguageOrderField.$unknown;
  }
}

enum Enum$LockReason {
  OFF_TOPIC,
  TOO_HEATED,
  RESOLVED,
  SPAM,
  $unknown;

  factory Enum$LockReason.fromJson(String value) =>
      fromJson$Enum$LockReason(value);

  String toJson() => toJson$Enum$LockReason(this);
}

String toJson$Enum$LockReason(Enum$LockReason e) {
  switch (e) {
    case Enum$LockReason.OFF_TOPIC:
      return r'OFF_TOPIC';
    case Enum$LockReason.TOO_HEATED:
      return r'TOO_HEATED';
    case Enum$LockReason.RESOLVED:
      return r'RESOLVED';
    case Enum$LockReason.SPAM:
      return r'SPAM';
    case Enum$LockReason.$unknown:
      return r'$unknown';
  }
}

Enum$LockReason fromJson$Enum$LockReason(String value) {
  switch (value) {
    case r'OFF_TOPIC':
      return Enum$LockReason.OFF_TOPIC;
    case r'TOO_HEATED':
      return Enum$LockReason.TOO_HEATED;
    case r'RESOLVED':
      return Enum$LockReason.RESOLVED;
    case r'SPAM':
      return Enum$LockReason.SPAM;
    default:
      return Enum$LockReason.$unknown;
  }
}

enum Enum$MannequinOrderField {
  LOGIN,
  CREATED_AT,
  $unknown;

  factory Enum$MannequinOrderField.fromJson(String value) =>
      fromJson$Enum$MannequinOrderField(value);

  String toJson() => toJson$Enum$MannequinOrderField(this);
}

String toJson$Enum$MannequinOrderField(Enum$MannequinOrderField e) {
  switch (e) {
    case Enum$MannequinOrderField.LOGIN:
      return r'LOGIN';
    case Enum$MannequinOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$MannequinOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$MannequinOrderField fromJson$Enum$MannequinOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$MannequinOrderField.LOGIN;
    case r'CREATED_AT':
      return Enum$MannequinOrderField.CREATED_AT;
    default:
      return Enum$MannequinOrderField.$unknown;
  }
}

enum Enum$MergeableState {
  MERGEABLE,
  CONFLICTING,
  UNKNOWN,
  $unknown;

  factory Enum$MergeableState.fromJson(String value) =>
      fromJson$Enum$MergeableState(value);

  String toJson() => toJson$Enum$MergeableState(this);
}

String toJson$Enum$MergeableState(Enum$MergeableState e) {
  switch (e) {
    case Enum$MergeableState.MERGEABLE:
      return r'MERGEABLE';
    case Enum$MergeableState.CONFLICTING:
      return r'CONFLICTING';
    case Enum$MergeableState.UNKNOWN:
      return r'UNKNOWN';
    case Enum$MergeableState.$unknown:
      return r'$unknown';
  }
}

Enum$MergeableState fromJson$Enum$MergeableState(String value) {
  switch (value) {
    case r'MERGEABLE':
      return Enum$MergeableState.MERGEABLE;
    case r'CONFLICTING':
      return Enum$MergeableState.CONFLICTING;
    case r'UNKNOWN':
      return Enum$MergeableState.UNKNOWN;
    default:
      return Enum$MergeableState.$unknown;
  }
}

enum Enum$MergeCommitMessage {
  PR_TITLE,
  PR_BODY,
  BLANK,
  $unknown;

  factory Enum$MergeCommitMessage.fromJson(String value) =>
      fromJson$Enum$MergeCommitMessage(value);

  String toJson() => toJson$Enum$MergeCommitMessage(this);
}

String toJson$Enum$MergeCommitMessage(Enum$MergeCommitMessage e) {
  switch (e) {
    case Enum$MergeCommitMessage.PR_TITLE:
      return r'PR_TITLE';
    case Enum$MergeCommitMessage.PR_BODY:
      return r'PR_BODY';
    case Enum$MergeCommitMessage.BLANK:
      return r'BLANK';
    case Enum$MergeCommitMessage.$unknown:
      return r'$unknown';
  }
}

Enum$MergeCommitMessage fromJson$Enum$MergeCommitMessage(String value) {
  switch (value) {
    case r'PR_TITLE':
      return Enum$MergeCommitMessage.PR_TITLE;
    case r'PR_BODY':
      return Enum$MergeCommitMessage.PR_BODY;
    case r'BLANK':
      return Enum$MergeCommitMessage.BLANK;
    default:
      return Enum$MergeCommitMessage.$unknown;
  }
}

enum Enum$MergeCommitTitle {
  PR_TITLE,
  MERGE_MESSAGE,
  $unknown;

  factory Enum$MergeCommitTitle.fromJson(String value) =>
      fromJson$Enum$MergeCommitTitle(value);

  String toJson() => toJson$Enum$MergeCommitTitle(this);
}

String toJson$Enum$MergeCommitTitle(Enum$MergeCommitTitle e) {
  switch (e) {
    case Enum$MergeCommitTitle.PR_TITLE:
      return r'PR_TITLE';
    case Enum$MergeCommitTitle.MERGE_MESSAGE:
      return r'MERGE_MESSAGE';
    case Enum$MergeCommitTitle.$unknown:
      return r'$unknown';
  }
}

Enum$MergeCommitTitle fromJson$Enum$MergeCommitTitle(String value) {
  switch (value) {
    case r'PR_TITLE':
      return Enum$MergeCommitTitle.PR_TITLE;
    case r'MERGE_MESSAGE':
      return Enum$MergeCommitTitle.MERGE_MESSAGE;
    default:
      return Enum$MergeCommitTitle.$unknown;
  }
}

enum Enum$MergeQueueEntryState {
  QUEUED,
  AWAITING_CHECKS,
  MERGEABLE,
  UNMERGEABLE,
  LOCKED,
  $unknown;

  factory Enum$MergeQueueEntryState.fromJson(String value) =>
      fromJson$Enum$MergeQueueEntryState(value);

  String toJson() => toJson$Enum$MergeQueueEntryState(this);
}

String toJson$Enum$MergeQueueEntryState(Enum$MergeQueueEntryState e) {
  switch (e) {
    case Enum$MergeQueueEntryState.QUEUED:
      return r'QUEUED';
    case Enum$MergeQueueEntryState.AWAITING_CHECKS:
      return r'AWAITING_CHECKS';
    case Enum$MergeQueueEntryState.MERGEABLE:
      return r'MERGEABLE';
    case Enum$MergeQueueEntryState.UNMERGEABLE:
      return r'UNMERGEABLE';
    case Enum$MergeQueueEntryState.LOCKED:
      return r'LOCKED';
    case Enum$MergeQueueEntryState.$unknown:
      return r'$unknown';
  }
}

Enum$MergeQueueEntryState fromJson$Enum$MergeQueueEntryState(String value) {
  switch (value) {
    case r'QUEUED':
      return Enum$MergeQueueEntryState.QUEUED;
    case r'AWAITING_CHECKS':
      return Enum$MergeQueueEntryState.AWAITING_CHECKS;
    case r'MERGEABLE':
      return Enum$MergeQueueEntryState.MERGEABLE;
    case r'UNMERGEABLE':
      return Enum$MergeQueueEntryState.UNMERGEABLE;
    case r'LOCKED':
      return Enum$MergeQueueEntryState.LOCKED;
    default:
      return Enum$MergeQueueEntryState.$unknown;
  }
}

enum Enum$MergeQueueGroupingStrategy {
  ALLGREEN,
  HEADGREEN,
  $unknown;

  factory Enum$MergeQueueGroupingStrategy.fromJson(String value) =>
      fromJson$Enum$MergeQueueGroupingStrategy(value);

  String toJson() => toJson$Enum$MergeQueueGroupingStrategy(this);
}

String toJson$Enum$MergeQueueGroupingStrategy(
    Enum$MergeQueueGroupingStrategy e) {
  switch (e) {
    case Enum$MergeQueueGroupingStrategy.ALLGREEN:
      return r'ALLGREEN';
    case Enum$MergeQueueGroupingStrategy.HEADGREEN:
      return r'HEADGREEN';
    case Enum$MergeQueueGroupingStrategy.$unknown:
      return r'$unknown';
  }
}

Enum$MergeQueueGroupingStrategy fromJson$Enum$MergeQueueGroupingStrategy(
    String value) {
  switch (value) {
    case r'ALLGREEN':
      return Enum$MergeQueueGroupingStrategy.ALLGREEN;
    case r'HEADGREEN':
      return Enum$MergeQueueGroupingStrategy.HEADGREEN;
    default:
      return Enum$MergeQueueGroupingStrategy.$unknown;
  }
}

enum Enum$MergeQueueMergeMethod {
  MERGE,
  SQUASH,
  REBASE,
  $unknown;

  factory Enum$MergeQueueMergeMethod.fromJson(String value) =>
      fromJson$Enum$MergeQueueMergeMethod(value);

  String toJson() => toJson$Enum$MergeQueueMergeMethod(this);
}

String toJson$Enum$MergeQueueMergeMethod(Enum$MergeQueueMergeMethod e) {
  switch (e) {
    case Enum$MergeQueueMergeMethod.MERGE:
      return r'MERGE';
    case Enum$MergeQueueMergeMethod.SQUASH:
      return r'SQUASH';
    case Enum$MergeQueueMergeMethod.REBASE:
      return r'REBASE';
    case Enum$MergeQueueMergeMethod.$unknown:
      return r'$unknown';
  }
}

Enum$MergeQueueMergeMethod fromJson$Enum$MergeQueueMergeMethod(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$MergeQueueMergeMethod.MERGE;
    case r'SQUASH':
      return Enum$MergeQueueMergeMethod.SQUASH;
    case r'REBASE':
      return Enum$MergeQueueMergeMethod.REBASE;
    default:
      return Enum$MergeQueueMergeMethod.$unknown;
  }
}

enum Enum$MergeQueueMergingStrategy {
  ALLGREEN,
  HEADGREEN,
  $unknown;

  factory Enum$MergeQueueMergingStrategy.fromJson(String value) =>
      fromJson$Enum$MergeQueueMergingStrategy(value);

  String toJson() => toJson$Enum$MergeQueueMergingStrategy(this);
}

String toJson$Enum$MergeQueueMergingStrategy(Enum$MergeQueueMergingStrategy e) {
  switch (e) {
    case Enum$MergeQueueMergingStrategy.ALLGREEN:
      return r'ALLGREEN';
    case Enum$MergeQueueMergingStrategy.HEADGREEN:
      return r'HEADGREEN';
    case Enum$MergeQueueMergingStrategy.$unknown:
      return r'$unknown';
  }
}

Enum$MergeQueueMergingStrategy fromJson$Enum$MergeQueueMergingStrategy(
    String value) {
  switch (value) {
    case r'ALLGREEN':
      return Enum$MergeQueueMergingStrategy.ALLGREEN;
    case r'HEADGREEN':
      return Enum$MergeQueueMergingStrategy.HEADGREEN;
    default:
      return Enum$MergeQueueMergingStrategy.$unknown;
  }
}

enum Enum$MergeStateStatus {
  DIRTY,
  UNKNOWN,
  BLOCKED,
  BEHIND,
  @Deprecated(
      'DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.')
  DRAFT,
  UNSTABLE,
  HAS_HOOKS,
  CLEAN,
  $unknown;

  factory Enum$MergeStateStatus.fromJson(String value) =>
      fromJson$Enum$MergeStateStatus(value);

  String toJson() => toJson$Enum$MergeStateStatus(this);
}

String toJson$Enum$MergeStateStatus(Enum$MergeStateStatus e) {
  switch (e) {
    case Enum$MergeStateStatus.DIRTY:
      return r'DIRTY';
    case Enum$MergeStateStatus.UNKNOWN:
      return r'UNKNOWN';
    case Enum$MergeStateStatus.BLOCKED:
      return r'BLOCKED';
    case Enum$MergeStateStatus.BEHIND:
      return r'BEHIND';
    case Enum$MergeStateStatus.DRAFT:
      return r'DRAFT';
    case Enum$MergeStateStatus.UNSTABLE:
      return r'UNSTABLE';
    case Enum$MergeStateStatus.HAS_HOOKS:
      return r'HAS_HOOKS';
    case Enum$MergeStateStatus.CLEAN:
      return r'CLEAN';
    case Enum$MergeStateStatus.$unknown:
      return r'$unknown';
  }
}

Enum$MergeStateStatus fromJson$Enum$MergeStateStatus(String value) {
  switch (value) {
    case r'DIRTY':
      return Enum$MergeStateStatus.DIRTY;
    case r'UNKNOWN':
      return Enum$MergeStateStatus.UNKNOWN;
    case r'BLOCKED':
      return Enum$MergeStateStatus.BLOCKED;
    case r'BEHIND':
      return Enum$MergeStateStatus.BEHIND;
    case r'DRAFT':
      return Enum$MergeStateStatus.DRAFT;
    case r'UNSTABLE':
      return Enum$MergeStateStatus.UNSTABLE;
    case r'HAS_HOOKS':
      return Enum$MergeStateStatus.HAS_HOOKS;
    case r'CLEAN':
      return Enum$MergeStateStatus.CLEAN;
    default:
      return Enum$MergeStateStatus.$unknown;
  }
}

enum Enum$MigrationSourceType {
  AZURE_DEVOPS,
  BITBUCKET_SERVER,
  GITHUB_ARCHIVE,
  $unknown;

  factory Enum$MigrationSourceType.fromJson(String value) =>
      fromJson$Enum$MigrationSourceType(value);

  String toJson() => toJson$Enum$MigrationSourceType(this);
}

String toJson$Enum$MigrationSourceType(Enum$MigrationSourceType e) {
  switch (e) {
    case Enum$MigrationSourceType.AZURE_DEVOPS:
      return r'AZURE_DEVOPS';
    case Enum$MigrationSourceType.BITBUCKET_SERVER:
      return r'BITBUCKET_SERVER';
    case Enum$MigrationSourceType.GITHUB_ARCHIVE:
      return r'GITHUB_ARCHIVE';
    case Enum$MigrationSourceType.$unknown:
      return r'$unknown';
  }
}

Enum$MigrationSourceType fromJson$Enum$MigrationSourceType(String value) {
  switch (value) {
    case r'AZURE_DEVOPS':
      return Enum$MigrationSourceType.AZURE_DEVOPS;
    case r'BITBUCKET_SERVER':
      return Enum$MigrationSourceType.BITBUCKET_SERVER;
    case r'GITHUB_ARCHIVE':
      return Enum$MigrationSourceType.GITHUB_ARCHIVE;
    default:
      return Enum$MigrationSourceType.$unknown;
  }
}

enum Enum$MigrationState {
  NOT_STARTED,
  QUEUED,
  IN_PROGRESS,
  SUCCEEDED,
  FAILED,
  PENDING_VALIDATION,
  FAILED_VALIDATION,
  $unknown;

  factory Enum$MigrationState.fromJson(String value) =>
      fromJson$Enum$MigrationState(value);

  String toJson() => toJson$Enum$MigrationState(this);
}

String toJson$Enum$MigrationState(Enum$MigrationState e) {
  switch (e) {
    case Enum$MigrationState.NOT_STARTED:
      return r'NOT_STARTED';
    case Enum$MigrationState.QUEUED:
      return r'QUEUED';
    case Enum$MigrationState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$MigrationState.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$MigrationState.FAILED:
      return r'FAILED';
    case Enum$MigrationState.PENDING_VALIDATION:
      return r'PENDING_VALIDATION';
    case Enum$MigrationState.FAILED_VALIDATION:
      return r'FAILED_VALIDATION';
    case Enum$MigrationState.$unknown:
      return r'$unknown';
  }
}

Enum$MigrationState fromJson$Enum$MigrationState(String value) {
  switch (value) {
    case r'NOT_STARTED':
      return Enum$MigrationState.NOT_STARTED;
    case r'QUEUED':
      return Enum$MigrationState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$MigrationState.IN_PROGRESS;
    case r'SUCCEEDED':
      return Enum$MigrationState.SUCCEEDED;
    case r'FAILED':
      return Enum$MigrationState.FAILED;
    case r'PENDING_VALIDATION':
      return Enum$MigrationState.PENDING_VALIDATION;
    case r'FAILED_VALIDATION':
      return Enum$MigrationState.FAILED_VALIDATION;
    default:
      return Enum$MigrationState.$unknown;
  }
}

enum Enum$MilestoneOrderField {
  DUE_DATE,
  CREATED_AT,
  UPDATED_AT,
  NUMBER,
  $unknown;

  factory Enum$MilestoneOrderField.fromJson(String value) =>
      fromJson$Enum$MilestoneOrderField(value);

  String toJson() => toJson$Enum$MilestoneOrderField(this);
}

String toJson$Enum$MilestoneOrderField(Enum$MilestoneOrderField e) {
  switch (e) {
    case Enum$MilestoneOrderField.DUE_DATE:
      return r'DUE_DATE';
    case Enum$MilestoneOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$MilestoneOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$MilestoneOrderField.NUMBER:
      return r'NUMBER';
    case Enum$MilestoneOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneOrderField fromJson$Enum$MilestoneOrderField(String value) {
  switch (value) {
    case r'DUE_DATE':
      return Enum$MilestoneOrderField.DUE_DATE;
    case r'CREATED_AT':
      return Enum$MilestoneOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$MilestoneOrderField.UPDATED_AT;
    case r'NUMBER':
      return Enum$MilestoneOrderField.NUMBER;
    default:
      return Enum$MilestoneOrderField.$unknown;
  }
}

enum Enum$MilestoneState {
  OPEN,
  CLOSED,
  $unknown;

  factory Enum$MilestoneState.fromJson(String value) =>
      fromJson$Enum$MilestoneState(value);

  String toJson() => toJson$Enum$MilestoneState(this);
}

String toJson$Enum$MilestoneState(Enum$MilestoneState e) {
  switch (e) {
    case Enum$MilestoneState.OPEN:
      return r'OPEN';
    case Enum$MilestoneState.CLOSED:
      return r'CLOSED';
    case Enum$MilestoneState.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneState fromJson$Enum$MilestoneState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$MilestoneState.OPEN;
    case r'CLOSED':
      return Enum$MilestoneState.CLOSED;
    default:
      return Enum$MilestoneState.$unknown;
  }
}

enum Enum$NotificationRestrictionSettingValue {
  ENABLED,
  DISABLED,
  $unknown;

  factory Enum$NotificationRestrictionSettingValue.fromJson(String value) =>
      fromJson$Enum$NotificationRestrictionSettingValue(value);

  String toJson() => toJson$Enum$NotificationRestrictionSettingValue(this);
}

String toJson$Enum$NotificationRestrictionSettingValue(
    Enum$NotificationRestrictionSettingValue e) {
  switch (e) {
    case Enum$NotificationRestrictionSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$NotificationRestrictionSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$NotificationRestrictionSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$NotificationRestrictionSettingValue
    fromJson$Enum$NotificationRestrictionSettingValue(String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$NotificationRestrictionSettingValue.ENABLED;
    case r'DISABLED':
      return Enum$NotificationRestrictionSettingValue.DISABLED;
    default:
      return Enum$NotificationRestrictionSettingValue.$unknown;
  }
}

enum Enum$OauthApplicationCreateAuditEntryState {
  ACTIVE,
  SUSPENDED,
  PENDING_DELETION,
  $unknown;

  factory Enum$OauthApplicationCreateAuditEntryState.fromJson(String value) =>
      fromJson$Enum$OauthApplicationCreateAuditEntryState(value);

  String toJson() => toJson$Enum$OauthApplicationCreateAuditEntryState(this);
}

String toJson$Enum$OauthApplicationCreateAuditEntryState(
    Enum$OauthApplicationCreateAuditEntryState e) {
  switch (e) {
    case Enum$OauthApplicationCreateAuditEntryState.ACTIVE:
      return r'ACTIVE';
    case Enum$OauthApplicationCreateAuditEntryState.SUSPENDED:
      return r'SUSPENDED';
    case Enum$OauthApplicationCreateAuditEntryState.PENDING_DELETION:
      return r'PENDING_DELETION';
    case Enum$OauthApplicationCreateAuditEntryState.$unknown:
      return r'$unknown';
  }
}

Enum$OauthApplicationCreateAuditEntryState
    fromJson$Enum$OauthApplicationCreateAuditEntryState(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$OauthApplicationCreateAuditEntryState.ACTIVE;
    case r'SUSPENDED':
      return Enum$OauthApplicationCreateAuditEntryState.SUSPENDED;
    case r'PENDING_DELETION':
      return Enum$OauthApplicationCreateAuditEntryState.PENDING_DELETION;
    default:
      return Enum$OauthApplicationCreateAuditEntryState.$unknown;
  }
}

enum Enum$OIDCProviderType {
  AAD,
  $unknown;

  factory Enum$OIDCProviderType.fromJson(String value) =>
      fromJson$Enum$OIDCProviderType(value);

  String toJson() => toJson$Enum$OIDCProviderType(this);
}

String toJson$Enum$OIDCProviderType(Enum$OIDCProviderType e) {
  switch (e) {
    case Enum$OIDCProviderType.AAD:
      return r'AAD';
    case Enum$OIDCProviderType.$unknown:
      return r'$unknown';
  }
}

Enum$OIDCProviderType fromJson$Enum$OIDCProviderType(String value) {
  switch (value) {
    case r'AAD':
      return Enum$OIDCProviderType.AAD;
    default:
      return Enum$OIDCProviderType.$unknown;
  }
}

enum Enum$OperationType {
  ACCESS,
  AUTHENTICATION,
  CREATE,
  MODIFY,
  REMOVE,
  RESTORE,
  TRANSFER,
  $unknown;

  factory Enum$OperationType.fromJson(String value) =>
      fromJson$Enum$OperationType(value);

  String toJson() => toJson$Enum$OperationType(this);
}

String toJson$Enum$OperationType(Enum$OperationType e) {
  switch (e) {
    case Enum$OperationType.ACCESS:
      return r'ACCESS';
    case Enum$OperationType.AUTHENTICATION:
      return r'AUTHENTICATION';
    case Enum$OperationType.CREATE:
      return r'CREATE';
    case Enum$OperationType.MODIFY:
      return r'MODIFY';
    case Enum$OperationType.REMOVE:
      return r'REMOVE';
    case Enum$OperationType.RESTORE:
      return r'RESTORE';
    case Enum$OperationType.TRANSFER:
      return r'TRANSFER';
    case Enum$OperationType.$unknown:
      return r'$unknown';
  }
}

Enum$OperationType fromJson$Enum$OperationType(String value) {
  switch (value) {
    case r'ACCESS':
      return Enum$OperationType.ACCESS;
    case r'AUTHENTICATION':
      return Enum$OperationType.AUTHENTICATION;
    case r'CREATE':
      return Enum$OperationType.CREATE;
    case r'MODIFY':
      return Enum$OperationType.MODIFY;
    case r'REMOVE':
      return Enum$OperationType.REMOVE;
    case r'RESTORE':
      return Enum$OperationType.RESTORE;
    case r'TRANSFER':
      return Enum$OperationType.TRANSFER;
    default:
      return Enum$OperationType.$unknown;
  }
}

enum Enum$OrderDirection {
  ASC,
  DESC,
  $unknown;

  factory Enum$OrderDirection.fromJson(String value) =>
      fromJson$Enum$OrderDirection(value);

  String toJson() => toJson$Enum$OrderDirection(this);
}

String toJson$Enum$OrderDirection(Enum$OrderDirection e) {
  switch (e) {
    case Enum$OrderDirection.ASC:
      return r'ASC';
    case Enum$OrderDirection.DESC:
      return r'DESC';
    case Enum$OrderDirection.$unknown:
      return r'$unknown';
  }
}

Enum$OrderDirection fromJson$Enum$OrderDirection(String value) {
  switch (value) {
    case r'ASC':
      return Enum$OrderDirection.ASC;
    case r'DESC':
      return Enum$OrderDirection.DESC;
    default:
      return Enum$OrderDirection.$unknown;
  }
}

enum Enum$OrgAddMemberAuditEntryPermission {
  READ,
  ADMIN,
  $unknown;

  factory Enum$OrgAddMemberAuditEntryPermission.fromJson(String value) =>
      fromJson$Enum$OrgAddMemberAuditEntryPermission(value);

  String toJson() => toJson$Enum$OrgAddMemberAuditEntryPermission(this);
}

String toJson$Enum$OrgAddMemberAuditEntryPermission(
    Enum$OrgAddMemberAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgAddMemberAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgAddMemberAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgAddMemberAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgAddMemberAuditEntryPermission
    fromJson$Enum$OrgAddMemberAuditEntryPermission(String value) {
  switch (value) {
    case r'READ':
      return Enum$OrgAddMemberAuditEntryPermission.READ;
    case r'ADMIN':
      return Enum$OrgAddMemberAuditEntryPermission.ADMIN;
    default:
      return Enum$OrgAddMemberAuditEntryPermission.$unknown;
  }
}

enum Enum$OrganizationInvitationRole {
  DIRECT_MEMBER,
  ADMIN,
  BILLING_MANAGER,
  REINSTATE,
  $unknown;

  factory Enum$OrganizationInvitationRole.fromJson(String value) =>
      fromJson$Enum$OrganizationInvitationRole(value);

  String toJson() => toJson$Enum$OrganizationInvitationRole(this);
}

String toJson$Enum$OrganizationInvitationRole(
    Enum$OrganizationInvitationRole e) {
  switch (e) {
    case Enum$OrganizationInvitationRole.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$OrganizationInvitationRole.ADMIN:
      return r'ADMIN';
    case Enum$OrganizationInvitationRole.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrganizationInvitationRole.REINSTATE:
      return r'REINSTATE';
    case Enum$OrganizationInvitationRole.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationRole fromJson$Enum$OrganizationInvitationRole(
    String value) {
  switch (value) {
    case r'DIRECT_MEMBER':
      return Enum$OrganizationInvitationRole.DIRECT_MEMBER;
    case r'ADMIN':
      return Enum$OrganizationInvitationRole.ADMIN;
    case r'BILLING_MANAGER':
      return Enum$OrganizationInvitationRole.BILLING_MANAGER;
    case r'REINSTATE':
      return Enum$OrganizationInvitationRole.REINSTATE;
    default:
      return Enum$OrganizationInvitationRole.$unknown;
  }
}

enum Enum$OrganizationInvitationSource {
  UNKNOWN,
  MEMBER,
  SCIM,
  $unknown;

  factory Enum$OrganizationInvitationSource.fromJson(String value) =>
      fromJson$Enum$OrganizationInvitationSource(value);

  String toJson() => toJson$Enum$OrganizationInvitationSource(this);
}

String toJson$Enum$OrganizationInvitationSource(
    Enum$OrganizationInvitationSource e) {
  switch (e) {
    case Enum$OrganizationInvitationSource.UNKNOWN:
      return r'UNKNOWN';
    case Enum$OrganizationInvitationSource.MEMBER:
      return r'MEMBER';
    case Enum$OrganizationInvitationSource.SCIM:
      return r'SCIM';
    case Enum$OrganizationInvitationSource.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationSource fromJson$Enum$OrganizationInvitationSource(
    String value) {
  switch (value) {
    case r'UNKNOWN':
      return Enum$OrganizationInvitationSource.UNKNOWN;
    case r'MEMBER':
      return Enum$OrganizationInvitationSource.MEMBER;
    case r'SCIM':
      return Enum$OrganizationInvitationSource.SCIM;
    default:
      return Enum$OrganizationInvitationSource.$unknown;
  }
}

enum Enum$OrganizationInvitationType {
  USER,
  EMAIL,
  $unknown;

  factory Enum$OrganizationInvitationType.fromJson(String value) =>
      fromJson$Enum$OrganizationInvitationType(value);

  String toJson() => toJson$Enum$OrganizationInvitationType(this);
}

String toJson$Enum$OrganizationInvitationType(
    Enum$OrganizationInvitationType e) {
  switch (e) {
    case Enum$OrganizationInvitationType.USER:
      return r'USER';
    case Enum$OrganizationInvitationType.EMAIL:
      return r'EMAIL';
    case Enum$OrganizationInvitationType.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationType fromJson$Enum$OrganizationInvitationType(
    String value) {
  switch (value) {
    case r'USER':
      return Enum$OrganizationInvitationType.USER;
    case r'EMAIL':
      return Enum$OrganizationInvitationType.EMAIL;
    default:
      return Enum$OrganizationInvitationType.$unknown;
  }
}

enum Enum$OrganizationMemberRole {
  MEMBER,
  ADMIN,
  $unknown;

  factory Enum$OrganizationMemberRole.fromJson(String value) =>
      fromJson$Enum$OrganizationMemberRole(value);

  String toJson() => toJson$Enum$OrganizationMemberRole(this);
}

String toJson$Enum$OrganizationMemberRole(Enum$OrganizationMemberRole e) {
  switch (e) {
    case Enum$OrganizationMemberRole.MEMBER:
      return r'MEMBER';
    case Enum$OrganizationMemberRole.ADMIN:
      return r'ADMIN';
    case Enum$OrganizationMemberRole.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMemberRole fromJson$Enum$OrganizationMemberRole(String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$OrganizationMemberRole.MEMBER;
    case r'ADMIN':
      return Enum$OrganizationMemberRole.ADMIN;
    default:
      return Enum$OrganizationMemberRole.$unknown;
  }
}

enum Enum$OrganizationMembersCanCreateRepositoriesSettingValue {
  ALL,
  PRIVATE,
  INTERNAL,
  DISABLED,
  $unknown;

  factory Enum$OrganizationMembersCanCreateRepositoriesSettingValue.fromJson(
          String value) =>
      fromJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(value);

  String toJson() =>
      toJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(this);
}

String toJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(
    Enum$OrganizationMembersCanCreateRepositoriesSettingValue e) {
  switch (e) {
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.ALL:
      return r'ALL';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.PRIVATE:
      return r'PRIVATE';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.INTERNAL:
      return r'INTERNAL';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMembersCanCreateRepositoriesSettingValue
    fromJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(
        String value) {
  switch (value) {
    case r'ALL':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.ALL;
    case r'PRIVATE':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.PRIVATE;
    case r'INTERNAL':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.INTERNAL;
    case r'DISABLED':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.DISABLED;
    default:
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.$unknown;
  }
}

enum Enum$OrganizationMigrationState {
  NOT_STARTED,
  QUEUED,
  IN_PROGRESS,
  PRE_REPO_MIGRATION,
  REPO_MIGRATION,
  POST_REPO_MIGRATION,
  SUCCEEDED,
  FAILED,
  PENDING_VALIDATION,
  FAILED_VALIDATION,
  $unknown;

  factory Enum$OrganizationMigrationState.fromJson(String value) =>
      fromJson$Enum$OrganizationMigrationState(value);

  String toJson() => toJson$Enum$OrganizationMigrationState(this);
}

String toJson$Enum$OrganizationMigrationState(
    Enum$OrganizationMigrationState e) {
  switch (e) {
    case Enum$OrganizationMigrationState.NOT_STARTED:
      return r'NOT_STARTED';
    case Enum$OrganizationMigrationState.QUEUED:
      return r'QUEUED';
    case Enum$OrganizationMigrationState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$OrganizationMigrationState.PRE_REPO_MIGRATION:
      return r'PRE_REPO_MIGRATION';
    case Enum$OrganizationMigrationState.REPO_MIGRATION:
      return r'REPO_MIGRATION';
    case Enum$OrganizationMigrationState.POST_REPO_MIGRATION:
      return r'POST_REPO_MIGRATION';
    case Enum$OrganizationMigrationState.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$OrganizationMigrationState.FAILED:
      return r'FAILED';
    case Enum$OrganizationMigrationState.PENDING_VALIDATION:
      return r'PENDING_VALIDATION';
    case Enum$OrganizationMigrationState.FAILED_VALIDATION:
      return r'FAILED_VALIDATION';
    case Enum$OrganizationMigrationState.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMigrationState fromJson$Enum$OrganizationMigrationState(
    String value) {
  switch (value) {
    case r'NOT_STARTED':
      return Enum$OrganizationMigrationState.NOT_STARTED;
    case r'QUEUED':
      return Enum$OrganizationMigrationState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$OrganizationMigrationState.IN_PROGRESS;
    case r'PRE_REPO_MIGRATION':
      return Enum$OrganizationMigrationState.PRE_REPO_MIGRATION;
    case r'REPO_MIGRATION':
      return Enum$OrganizationMigrationState.REPO_MIGRATION;
    case r'POST_REPO_MIGRATION':
      return Enum$OrganizationMigrationState.POST_REPO_MIGRATION;
    case r'SUCCEEDED':
      return Enum$OrganizationMigrationState.SUCCEEDED;
    case r'FAILED':
      return Enum$OrganizationMigrationState.FAILED;
    case r'PENDING_VALIDATION':
      return Enum$OrganizationMigrationState.PENDING_VALIDATION;
    case r'FAILED_VALIDATION':
      return Enum$OrganizationMigrationState.FAILED_VALIDATION;
    default:
      return Enum$OrganizationMigrationState.$unknown;
  }
}

enum Enum$OrganizationOrderField {
  CREATED_AT,
  LOGIN,
  $unknown;

  factory Enum$OrganizationOrderField.fromJson(String value) =>
      fromJson$Enum$OrganizationOrderField(value);

  String toJson() => toJson$Enum$OrganizationOrderField(this);
}

String toJson$Enum$OrganizationOrderField(Enum$OrganizationOrderField e) {
  switch (e) {
    case Enum$OrganizationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$OrganizationOrderField.LOGIN:
      return r'LOGIN';
    case Enum$OrganizationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationOrderField fromJson$Enum$OrganizationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$OrganizationOrderField.CREATED_AT;
    case r'LOGIN':
      return Enum$OrganizationOrderField.LOGIN;
    default:
      return Enum$OrganizationOrderField.$unknown;
  }
}

enum Enum$OrgCreateAuditEntryBillingPlan {
  FREE,
  BUSINESS,
  BUSINESS_PLUS,
  UNLIMITED,
  TIERED_PER_SEAT,
  $unknown;

  factory Enum$OrgCreateAuditEntryBillingPlan.fromJson(String value) =>
      fromJson$Enum$OrgCreateAuditEntryBillingPlan(value);

  String toJson() => toJson$Enum$OrgCreateAuditEntryBillingPlan(this);
}

String toJson$Enum$OrgCreateAuditEntryBillingPlan(
    Enum$OrgCreateAuditEntryBillingPlan e) {
  switch (e) {
    case Enum$OrgCreateAuditEntryBillingPlan.FREE:
      return r'FREE';
    case Enum$OrgCreateAuditEntryBillingPlan.BUSINESS:
      return r'BUSINESS';
    case Enum$OrgCreateAuditEntryBillingPlan.BUSINESS_PLUS:
      return r'BUSINESS_PLUS';
    case Enum$OrgCreateAuditEntryBillingPlan.UNLIMITED:
      return r'UNLIMITED';
    case Enum$OrgCreateAuditEntryBillingPlan.TIERED_PER_SEAT:
      return r'TIERED_PER_SEAT';
    case Enum$OrgCreateAuditEntryBillingPlan.$unknown:
      return r'$unknown';
  }
}

Enum$OrgCreateAuditEntryBillingPlan
    fromJson$Enum$OrgCreateAuditEntryBillingPlan(String value) {
  switch (value) {
    case r'FREE':
      return Enum$OrgCreateAuditEntryBillingPlan.FREE;
    case r'BUSINESS':
      return Enum$OrgCreateAuditEntryBillingPlan.BUSINESS;
    case r'BUSINESS_PLUS':
      return Enum$OrgCreateAuditEntryBillingPlan.BUSINESS_PLUS;
    case r'UNLIMITED':
      return Enum$OrgCreateAuditEntryBillingPlan.UNLIMITED;
    case r'TIERED_PER_SEAT':
      return Enum$OrgCreateAuditEntryBillingPlan.TIERED_PER_SEAT;
    default:
      return Enum$OrgCreateAuditEntryBillingPlan.$unknown;
  }
}

enum Enum$OrgEnterpriseOwnerOrderField {
  LOGIN,
  $unknown;

  factory Enum$OrgEnterpriseOwnerOrderField.fromJson(String value) =>
      fromJson$Enum$OrgEnterpriseOwnerOrderField(value);

  String toJson() => toJson$Enum$OrgEnterpriseOwnerOrderField(this);
}

String toJson$Enum$OrgEnterpriseOwnerOrderField(
    Enum$OrgEnterpriseOwnerOrderField e) {
  switch (e) {
    case Enum$OrgEnterpriseOwnerOrderField.LOGIN:
      return r'LOGIN';
    case Enum$OrgEnterpriseOwnerOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$OrgEnterpriseOwnerOrderField fromJson$Enum$OrgEnterpriseOwnerOrderField(
    String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$OrgEnterpriseOwnerOrderField.LOGIN;
    default:
      return Enum$OrgEnterpriseOwnerOrderField.$unknown;
  }
}

enum Enum$OrgRemoveBillingManagerAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  SAML_EXTERNAL_IDENTITY_MISSING,
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY,
  $unknown;

  factory Enum$OrgRemoveBillingManagerAuditEntryReason.fromJson(String value) =>
      fromJson$Enum$OrgRemoveBillingManagerAuditEntryReason(value);

  String toJson() => toJson$Enum$OrgRemoveBillingManagerAuditEntryReason(this);
}

String toJson$Enum$OrgRemoveBillingManagerAuditEntryReason(
    Enum$OrgRemoveBillingManagerAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveBillingManagerAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY:
      return r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY';
    case Enum$OrgRemoveBillingManagerAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveBillingManagerAuditEntryReason
    fromJson$Enum$OrgRemoveBillingManagerAuditEntryReason(String value) {
  switch (value) {
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    case r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY;
    default:
      return Enum$OrgRemoveBillingManagerAuditEntryReason.$unknown;
  }
}

enum Enum$OrgRemoveMemberAuditEntryMembershipType {
  SUSPENDED,
  DIRECT_MEMBER,
  ADMIN,
  BILLING_MANAGER,
  UNAFFILIATED,
  OUTSIDE_COLLABORATOR,
  $unknown;

  factory Enum$OrgRemoveMemberAuditEntryMembershipType.fromJson(String value) =>
      fromJson$Enum$OrgRemoveMemberAuditEntryMembershipType(value);

  String toJson() => toJson$Enum$OrgRemoveMemberAuditEntryMembershipType(this);
}

String toJson$Enum$OrgRemoveMemberAuditEntryMembershipType(
    Enum$OrgRemoveMemberAuditEntryMembershipType e) {
  switch (e) {
    case Enum$OrgRemoveMemberAuditEntryMembershipType.SUSPENDED:
      return r'SUSPENDED';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.ADMIN:
      return r'ADMIN';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.OUTSIDE_COLLABORATOR:
      return r'OUTSIDE_COLLABORATOR';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveMemberAuditEntryMembershipType
    fromJson$Enum$OrgRemoveMemberAuditEntryMembershipType(String value) {
  switch (value) {
    case r'SUSPENDED':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.SUSPENDED;
    case r'DIRECT_MEMBER':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.DIRECT_MEMBER;
    case r'ADMIN':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.ADMIN;
    case r'BILLING_MANAGER':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.BILLING_MANAGER;
    case r'UNAFFILIATED':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.UNAFFILIATED;
    case r'OUTSIDE_COLLABORATOR':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.OUTSIDE_COLLABORATOR;
    default:
      return Enum$OrgRemoveMemberAuditEntryMembershipType.$unknown;
  }
}

enum Enum$OrgRemoveMemberAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  SAML_EXTERNAL_IDENTITY_MISSING,
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY,
  USER_ACCOUNT_DELETED,
  TWO_FACTOR_ACCOUNT_RECOVERY,
  $unknown;

  factory Enum$OrgRemoveMemberAuditEntryReason.fromJson(String value) =>
      fromJson$Enum$OrgRemoveMemberAuditEntryReason(value);

  String toJson() => toJson$Enum$OrgRemoveMemberAuditEntryReason(this);
}

String toJson$Enum$OrgRemoveMemberAuditEntryReason(
    Enum$OrgRemoveMemberAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveMemberAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveMemberAuditEntryReason.SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveMemberAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY:
      return r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY';
    case Enum$OrgRemoveMemberAuditEntryReason.USER_ACCOUNT_DELETED:
      return r'USER_ACCOUNT_DELETED';
    case Enum$OrgRemoveMemberAuditEntryReason.TWO_FACTOR_ACCOUNT_RECOVERY:
      return r'TWO_FACTOR_ACCOUNT_RECOVERY';
    case Enum$OrgRemoveMemberAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveMemberAuditEntryReason
    fromJson$Enum$OrgRemoveMemberAuditEntryReason(String value) {
  switch (value) {
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveMemberAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveMemberAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    case r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY':
      return Enum$OrgRemoveMemberAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY;
    case r'USER_ACCOUNT_DELETED':
      return Enum$OrgRemoveMemberAuditEntryReason.USER_ACCOUNT_DELETED;
    case r'TWO_FACTOR_ACCOUNT_RECOVERY':
      return Enum$OrgRemoveMemberAuditEntryReason.TWO_FACTOR_ACCOUNT_RECOVERY;
    default:
      return Enum$OrgRemoveMemberAuditEntryReason.$unknown;
  }
}

enum Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  OUTSIDE_COLLABORATOR,
  UNAFFILIATED,
  BILLING_MANAGER,
  $unknown;

  factory Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.fromJson(
          String value) =>
      fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(value);

  String toJson() =>
      toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(this);
}

String toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(
    Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType e) {
  switch (e) {
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .OUTSIDE_COLLABORATOR:
      return r'OUTSIDE_COLLABORATOR';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
    fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(
        String value) {
  switch (value) {
    case r'OUTSIDE_COLLABORATOR':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .OUTSIDE_COLLABORATOR;
    case r'UNAFFILIATED':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .UNAFFILIATED;
    case r'BILLING_MANAGER':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .BILLING_MANAGER;
    default:
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.$unknown;
  }
}

enum Enum$OrgRemoveOutsideCollaboratorAuditEntryReason {
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  SAML_EXTERNAL_IDENTITY_MISSING,
  $unknown;

  factory Enum$OrgRemoveOutsideCollaboratorAuditEntryReason.fromJson(
          String value) =>
      fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(value);

  String toJson() =>
      toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(this);
}

String toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(
    Enum$OrgRemoveOutsideCollaboratorAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
    fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(String value) {
  switch (value) {
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    default:
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason.$unknown;
  }
}

enum Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  READ,
  WRITE,
  ADMIN,
  NONE,
  $unknown;

  factory Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.fromJson(
          String value) =>
      fromJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
          value);

  String toJson() =>
      toJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
          this);
}

String toJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
    Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.WRITE:
      return r'WRITE';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.NONE:
      return r'NONE';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
    fromJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
        String value) {
  switch (value) {
    case r'READ':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.READ;
    case r'WRITE':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .WRITE;
    case r'ADMIN':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .ADMIN;
    case r'NONE':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.NONE;
    default:
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .$unknown;
  }
}

enum Enum$OrgUpdateMemberAuditEntryPermission {
  READ,
  ADMIN,
  $unknown;

  factory Enum$OrgUpdateMemberAuditEntryPermission.fromJson(String value) =>
      fromJson$Enum$OrgUpdateMemberAuditEntryPermission(value);

  String toJson() => toJson$Enum$OrgUpdateMemberAuditEntryPermission(this);
}

String toJson$Enum$OrgUpdateMemberAuditEntryPermission(
    Enum$OrgUpdateMemberAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgUpdateMemberAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgUpdateMemberAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgUpdateMemberAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateMemberAuditEntryPermission
    fromJson$Enum$OrgUpdateMemberAuditEntryPermission(String value) {
  switch (value) {
    case r'READ':
      return Enum$OrgUpdateMemberAuditEntryPermission.READ;
    case r'ADMIN':
      return Enum$OrgUpdateMemberAuditEntryPermission.ADMIN;
    default:
      return Enum$OrgUpdateMemberAuditEntryPermission.$unknown;
  }
}

enum Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  ALL,
  PUBLIC,
  NONE,
  PRIVATE,
  INTERNAL,
  PUBLIC_INTERNAL,
  PRIVATE_INTERNAL,
  PUBLIC_PRIVATE,
  $unknown;

  factory Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility.fromJson(
          String value) =>
      fromJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
          value);

  String toJson() =>
      toJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
          this);
}

String
    toJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
        Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
            e) {
  switch (e) {
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .ALL:
      return r'ALL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC:
      return r'PUBLIC';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .NONE:
      return r'NONE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE:
      return r'PRIVATE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .INTERNAL:
      return r'INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_INTERNAL:
      return r'PUBLIC_INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE_INTERNAL:
      return r'PRIVATE_INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_PRIVATE:
      return r'PUBLIC_PRIVATE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
    fromJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
        String value) {
  switch (value) {
    case r'ALL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .ALL;
    case r'PUBLIC':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC;
    case r'NONE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .NONE;
    case r'PRIVATE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE;
    case r'INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .INTERNAL;
    case r'PUBLIC_INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_INTERNAL;
    case r'PRIVATE_INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE_INTERNAL;
    case r'PUBLIC_PRIVATE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_PRIVATE;
    default:
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .$unknown;
  }
}

enum Enum$PackageFileOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$PackageFileOrderField.fromJson(String value) =>
      fromJson$Enum$PackageFileOrderField(value);

  String toJson() => toJson$Enum$PackageFileOrderField(this);
}

String toJson$Enum$PackageFileOrderField(Enum$PackageFileOrderField e) {
  switch (e) {
    case Enum$PackageFileOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageFileOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageFileOrderField fromJson$Enum$PackageFileOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageFileOrderField.CREATED_AT;
    default:
      return Enum$PackageFileOrderField.$unknown;
  }
}

enum Enum$PackageOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$PackageOrderField.fromJson(String value) =>
      fromJson$Enum$PackageOrderField(value);

  String toJson() => toJson$Enum$PackageOrderField(this);
}

String toJson$Enum$PackageOrderField(Enum$PackageOrderField e) {
  switch (e) {
    case Enum$PackageOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageOrderField fromJson$Enum$PackageOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageOrderField.CREATED_AT;
    default:
      return Enum$PackageOrderField.$unknown;
  }
}

enum Enum$PackageType {
  @Deprecated(
      'NPM will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.')
  NPM,
  @Deprecated(
      'RUBYGEMS will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-12-28 UTC.')
  RUBYGEMS,
  @Deprecated(
      'MAVEN will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2023-02-10 UTC.')
  MAVEN,
  @Deprecated(
      'DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.')
  DOCKER,
  DEBIAN,
  @Deprecated(
      'NUGET will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.')
  NUGET,
  PYPI,
  $unknown;

  factory Enum$PackageType.fromJson(String value) =>
      fromJson$Enum$PackageType(value);

  String toJson() => toJson$Enum$PackageType(this);
}

String toJson$Enum$PackageType(Enum$PackageType e) {
  switch (e) {
    case Enum$PackageType.NPM:
      return r'NPM';
    case Enum$PackageType.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$PackageType.MAVEN:
      return r'MAVEN';
    case Enum$PackageType.DOCKER:
      return r'DOCKER';
    case Enum$PackageType.DEBIAN:
      return r'DEBIAN';
    case Enum$PackageType.NUGET:
      return r'NUGET';
    case Enum$PackageType.PYPI:
      return r'PYPI';
    case Enum$PackageType.$unknown:
      return r'$unknown';
  }
}

Enum$PackageType fromJson$Enum$PackageType(String value) {
  switch (value) {
    case r'NPM':
      return Enum$PackageType.NPM;
    case r'RUBYGEMS':
      return Enum$PackageType.RUBYGEMS;
    case r'MAVEN':
      return Enum$PackageType.MAVEN;
    case r'DOCKER':
      return Enum$PackageType.DOCKER;
    case r'DEBIAN':
      return Enum$PackageType.DEBIAN;
    case r'NUGET':
      return Enum$PackageType.NUGET;
    case r'PYPI':
      return Enum$PackageType.PYPI;
    default:
      return Enum$PackageType.$unknown;
  }
}

enum Enum$PackageVersionOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$PackageVersionOrderField.fromJson(String value) =>
      fromJson$Enum$PackageVersionOrderField(value);

  String toJson() => toJson$Enum$PackageVersionOrderField(this);
}

String toJson$Enum$PackageVersionOrderField(Enum$PackageVersionOrderField e) {
  switch (e) {
    case Enum$PackageVersionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageVersionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageVersionOrderField fromJson$Enum$PackageVersionOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageVersionOrderField.CREATED_AT;
    default:
      return Enum$PackageVersionOrderField.$unknown;
  }
}

enum Enum$PatchStatus {
  ADDED,
  DELETED,
  RENAMED,
  COPIED,
  MODIFIED,
  CHANGED,
  $unknown;

  factory Enum$PatchStatus.fromJson(String value) =>
      fromJson$Enum$PatchStatus(value);

  String toJson() => toJson$Enum$PatchStatus(this);
}

String toJson$Enum$PatchStatus(Enum$PatchStatus e) {
  switch (e) {
    case Enum$PatchStatus.ADDED:
      return r'ADDED';
    case Enum$PatchStatus.DELETED:
      return r'DELETED';
    case Enum$PatchStatus.RENAMED:
      return r'RENAMED';
    case Enum$PatchStatus.COPIED:
      return r'COPIED';
    case Enum$PatchStatus.MODIFIED:
      return r'MODIFIED';
    case Enum$PatchStatus.CHANGED:
      return r'CHANGED';
    case Enum$PatchStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PatchStatus fromJson$Enum$PatchStatus(String value) {
  switch (value) {
    case r'ADDED':
      return Enum$PatchStatus.ADDED;
    case r'DELETED':
      return Enum$PatchStatus.DELETED;
    case r'RENAMED':
      return Enum$PatchStatus.RENAMED;
    case r'COPIED':
      return Enum$PatchStatus.COPIED;
    case r'MODIFIED':
      return Enum$PatchStatus.MODIFIED;
    case r'CHANGED':
      return Enum$PatchStatus.CHANGED;
    default:
      return Enum$PatchStatus.$unknown;
  }
}

enum Enum$PinnableItemType {
  REPOSITORY,
  GIST,
  ISSUE,
  PROJECT,
  PULL_REQUEST,
  USER,
  ORGANIZATION,
  TEAM,
  $unknown;

  factory Enum$PinnableItemType.fromJson(String value) =>
      fromJson$Enum$PinnableItemType(value);

  String toJson() => toJson$Enum$PinnableItemType(this);
}

String toJson$Enum$PinnableItemType(Enum$PinnableItemType e) {
  switch (e) {
    case Enum$PinnableItemType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$PinnableItemType.GIST:
      return r'GIST';
    case Enum$PinnableItemType.ISSUE:
      return r'ISSUE';
    case Enum$PinnableItemType.PROJECT:
      return r'PROJECT';
    case Enum$PinnableItemType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$PinnableItemType.USER:
      return r'USER';
    case Enum$PinnableItemType.ORGANIZATION:
      return r'ORGANIZATION';
    case Enum$PinnableItemType.TEAM:
      return r'TEAM';
    case Enum$PinnableItemType.$unknown:
      return r'$unknown';
  }
}

Enum$PinnableItemType fromJson$Enum$PinnableItemType(String value) {
  switch (value) {
    case r'REPOSITORY':
      return Enum$PinnableItemType.REPOSITORY;
    case r'GIST':
      return Enum$PinnableItemType.GIST;
    case r'ISSUE':
      return Enum$PinnableItemType.ISSUE;
    case r'PROJECT':
      return Enum$PinnableItemType.PROJECT;
    case r'PULL_REQUEST':
      return Enum$PinnableItemType.PULL_REQUEST;
    case r'USER':
      return Enum$PinnableItemType.USER;
    case r'ORGANIZATION':
      return Enum$PinnableItemType.ORGANIZATION;
    case r'TEAM':
      return Enum$PinnableItemType.TEAM;
    default:
      return Enum$PinnableItemType.$unknown;
  }
}

enum Enum$PinnedDiscussionGradient {
  RED_ORANGE,
  BLUE_MINT,
  BLUE_PURPLE,
  PINK_BLUE,
  PURPLE_CORAL,
  $unknown;

  factory Enum$PinnedDiscussionGradient.fromJson(String value) =>
      fromJson$Enum$PinnedDiscussionGradient(value);

  String toJson() => toJson$Enum$PinnedDiscussionGradient(this);
}

String toJson$Enum$PinnedDiscussionGradient(Enum$PinnedDiscussionGradient e) {
  switch (e) {
    case Enum$PinnedDiscussionGradient.RED_ORANGE:
      return r'RED_ORANGE';
    case Enum$PinnedDiscussionGradient.BLUE_MINT:
      return r'BLUE_MINT';
    case Enum$PinnedDiscussionGradient.BLUE_PURPLE:
      return r'BLUE_PURPLE';
    case Enum$PinnedDiscussionGradient.PINK_BLUE:
      return r'PINK_BLUE';
    case Enum$PinnedDiscussionGradient.PURPLE_CORAL:
      return r'PURPLE_CORAL';
    case Enum$PinnedDiscussionGradient.$unknown:
      return r'$unknown';
  }
}

Enum$PinnedDiscussionGradient fromJson$Enum$PinnedDiscussionGradient(
    String value) {
  switch (value) {
    case r'RED_ORANGE':
      return Enum$PinnedDiscussionGradient.RED_ORANGE;
    case r'BLUE_MINT':
      return Enum$PinnedDiscussionGradient.BLUE_MINT;
    case r'BLUE_PURPLE':
      return Enum$PinnedDiscussionGradient.BLUE_PURPLE;
    case r'PINK_BLUE':
      return Enum$PinnedDiscussionGradient.PINK_BLUE;
    case r'PURPLE_CORAL':
      return Enum$PinnedDiscussionGradient.PURPLE_CORAL;
    default:
      return Enum$PinnedDiscussionGradient.$unknown;
  }
}

enum Enum$PinnedDiscussionPattern {
  DOT_FILL,
  PLUS,
  ZAP,
  CHEVRON_UP,
  DOT,
  HEART_FILL,
  $unknown;

  factory Enum$PinnedDiscussionPattern.fromJson(String value) =>
      fromJson$Enum$PinnedDiscussionPattern(value);

  String toJson() => toJson$Enum$PinnedDiscussionPattern(this);
}

String toJson$Enum$PinnedDiscussionPattern(Enum$PinnedDiscussionPattern e) {
  switch (e) {
    case Enum$PinnedDiscussionPattern.DOT_FILL:
      return r'DOT_FILL';
    case Enum$PinnedDiscussionPattern.PLUS:
      return r'PLUS';
    case Enum$PinnedDiscussionPattern.ZAP:
      return r'ZAP';
    case Enum$PinnedDiscussionPattern.CHEVRON_UP:
      return r'CHEVRON_UP';
    case Enum$PinnedDiscussionPattern.DOT:
      return r'DOT';
    case Enum$PinnedDiscussionPattern.HEART_FILL:
      return r'HEART_FILL';
    case Enum$PinnedDiscussionPattern.$unknown:
      return r'$unknown';
  }
}

Enum$PinnedDiscussionPattern fromJson$Enum$PinnedDiscussionPattern(
    String value) {
  switch (value) {
    case r'DOT_FILL':
      return Enum$PinnedDiscussionPattern.DOT_FILL;
    case r'PLUS':
      return Enum$PinnedDiscussionPattern.PLUS;
    case r'ZAP':
      return Enum$PinnedDiscussionPattern.ZAP;
    case r'CHEVRON_UP':
      return Enum$PinnedDiscussionPattern.CHEVRON_UP;
    case r'DOT':
      return Enum$PinnedDiscussionPattern.DOT;
    case r'HEART_FILL':
      return Enum$PinnedDiscussionPattern.HEART_FILL;
    default:
      return Enum$PinnedDiscussionPattern.$unknown;
  }
}

enum Enum$PinnedEnvironmentOrderField {
  POSITION,
  $unknown;

  factory Enum$PinnedEnvironmentOrderField.fromJson(String value) =>
      fromJson$Enum$PinnedEnvironmentOrderField(value);

  String toJson() => toJson$Enum$PinnedEnvironmentOrderField(this);
}

String toJson$Enum$PinnedEnvironmentOrderField(
    Enum$PinnedEnvironmentOrderField e) {
  switch (e) {
    case Enum$PinnedEnvironmentOrderField.POSITION:
      return r'POSITION';
    case Enum$PinnedEnvironmentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PinnedEnvironmentOrderField fromJson$Enum$PinnedEnvironmentOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$PinnedEnvironmentOrderField.POSITION;
    default:
      return Enum$PinnedEnvironmentOrderField.$unknown;
  }
}

enum Enum$ProjectCardArchivedState {
  @Deprecated(
      'Projects (classic) is being deprecated in favor of the new Projects experience, see: https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/. Removal on 2025-04-01 UTC.')
  ARCHIVED,
  @Deprecated(
      'Projects (classic) is being deprecated in favor of the new Projects experience, see: https://github.blog/changelog/2024-05-23-sunset-notice-projects-classic/. Removal on 2025-04-01 UTC.')
  NOT_ARCHIVED,
  $unknown;

  factory Enum$ProjectCardArchivedState.fromJson(String value) =>
      fromJson$Enum$ProjectCardArchivedState(value);

  String toJson() => toJson$Enum$ProjectCardArchivedState(this);
}

String toJson$Enum$ProjectCardArchivedState(Enum$ProjectCardArchivedState e) {
  switch (e) {
    case Enum$ProjectCardArchivedState.ARCHIVED:
      return r'ARCHIVED';
    case Enum$ProjectCardArchivedState.NOT_ARCHIVED:
      return r'NOT_ARCHIVED';
    case Enum$ProjectCardArchivedState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectCardArchivedState fromJson$Enum$ProjectCardArchivedState(
    String value) {
  switch (value) {
    case r'ARCHIVED':
      return Enum$ProjectCardArchivedState.ARCHIVED;
    case r'NOT_ARCHIVED':
      return Enum$ProjectCardArchivedState.NOT_ARCHIVED;
    default:
      return Enum$ProjectCardArchivedState.$unknown;
  }
}

enum Enum$ProjectCardState {
  CONTENT_ONLY,
  NOTE_ONLY,
  REDACTED,
  $unknown;

  factory Enum$ProjectCardState.fromJson(String value) =>
      fromJson$Enum$ProjectCardState(value);

  String toJson() => toJson$Enum$ProjectCardState(this);
}

String toJson$Enum$ProjectCardState(Enum$ProjectCardState e) {
  switch (e) {
    case Enum$ProjectCardState.CONTENT_ONLY:
      return r'CONTENT_ONLY';
    case Enum$ProjectCardState.NOTE_ONLY:
      return r'NOTE_ONLY';
    case Enum$ProjectCardState.REDACTED:
      return r'REDACTED';
    case Enum$ProjectCardState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectCardState fromJson$Enum$ProjectCardState(String value) {
  switch (value) {
    case r'CONTENT_ONLY':
      return Enum$ProjectCardState.CONTENT_ONLY;
    case r'NOTE_ONLY':
      return Enum$ProjectCardState.NOTE_ONLY;
    case r'REDACTED':
      return Enum$ProjectCardState.REDACTED;
    default:
      return Enum$ProjectCardState.$unknown;
  }
}

enum Enum$ProjectColumnPurpose {
  TODO,
  IN_PROGRESS,
  DONE,
  $unknown;

  factory Enum$ProjectColumnPurpose.fromJson(String value) =>
      fromJson$Enum$ProjectColumnPurpose(value);

  String toJson() => toJson$Enum$ProjectColumnPurpose(this);
}

String toJson$Enum$ProjectColumnPurpose(Enum$ProjectColumnPurpose e) {
  switch (e) {
    case Enum$ProjectColumnPurpose.TODO:
      return r'TODO';
    case Enum$ProjectColumnPurpose.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$ProjectColumnPurpose.DONE:
      return r'DONE';
    case Enum$ProjectColumnPurpose.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectColumnPurpose fromJson$Enum$ProjectColumnPurpose(String value) {
  switch (value) {
    case r'TODO':
      return Enum$ProjectColumnPurpose.TODO;
    case r'IN_PROGRESS':
      return Enum$ProjectColumnPurpose.IN_PROGRESS;
    case r'DONE':
      return Enum$ProjectColumnPurpose.DONE;
    default:
      return Enum$ProjectColumnPurpose.$unknown;
  }
}

enum Enum$ProjectOrderField {
  CREATED_AT,
  UPDATED_AT,
  NAME,
  $unknown;

  factory Enum$ProjectOrderField.fromJson(String value) =>
      fromJson$Enum$ProjectOrderField(value);

  String toJson() => toJson$Enum$ProjectOrderField(this);
}

String toJson$Enum$ProjectOrderField(Enum$ProjectOrderField e) {
  switch (e) {
    case Enum$ProjectOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectOrderField.NAME:
      return r'NAME';
    case Enum$ProjectOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectOrderField fromJson$Enum$ProjectOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$ProjectOrderField.UPDATED_AT;
    case r'NAME':
      return Enum$ProjectOrderField.NAME;
    default:
      return Enum$ProjectOrderField.$unknown;
  }
}

enum Enum$ProjectState {
  OPEN,
  CLOSED,
  $unknown;

  factory Enum$ProjectState.fromJson(String value) =>
      fromJson$Enum$ProjectState(value);

  String toJson() => toJson$Enum$ProjectState(this);
}

String toJson$Enum$ProjectState(Enum$ProjectState e) {
  switch (e) {
    case Enum$ProjectState.OPEN:
      return r'OPEN';
    case Enum$ProjectState.CLOSED:
      return r'CLOSED';
    case Enum$ProjectState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectState fromJson$Enum$ProjectState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$ProjectState.OPEN;
    case r'CLOSED':
      return Enum$ProjectState.CLOSED;
    default:
      return Enum$ProjectState.$unknown;
  }
}

enum Enum$ProjectTemplate {
  BASIC_KANBAN,
  AUTOMATED_KANBAN_V2,
  AUTOMATED_REVIEWS_KANBAN,
  BUG_TRIAGE,
  $unknown;

  factory Enum$ProjectTemplate.fromJson(String value) =>
      fromJson$Enum$ProjectTemplate(value);

  String toJson() => toJson$Enum$ProjectTemplate(this);
}

String toJson$Enum$ProjectTemplate(Enum$ProjectTemplate e) {
  switch (e) {
    case Enum$ProjectTemplate.BASIC_KANBAN:
      return r'BASIC_KANBAN';
    case Enum$ProjectTemplate.AUTOMATED_KANBAN_V2:
      return r'AUTOMATED_KANBAN_V2';
    case Enum$ProjectTemplate.AUTOMATED_REVIEWS_KANBAN:
      return r'AUTOMATED_REVIEWS_KANBAN';
    case Enum$ProjectTemplate.BUG_TRIAGE:
      return r'BUG_TRIAGE';
    case Enum$ProjectTemplate.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectTemplate fromJson$Enum$ProjectTemplate(String value) {
  switch (value) {
    case r'BASIC_KANBAN':
      return Enum$ProjectTemplate.BASIC_KANBAN;
    case r'AUTOMATED_KANBAN_V2':
      return Enum$ProjectTemplate.AUTOMATED_KANBAN_V2;
    case r'AUTOMATED_REVIEWS_KANBAN':
      return Enum$ProjectTemplate.AUTOMATED_REVIEWS_KANBAN;
    case r'BUG_TRIAGE':
      return Enum$ProjectTemplate.BUG_TRIAGE;
    default:
      return Enum$ProjectTemplate.$unknown;
  }
}

enum Enum$ProjectV2CustomFieldType {
  TEXT,
  SINGLE_SELECT,
  NUMBER,
  DATE,
  ITERATION,
  $unknown;

  factory Enum$ProjectV2CustomFieldType.fromJson(String value) =>
      fromJson$Enum$ProjectV2CustomFieldType(value);

  String toJson() => toJson$Enum$ProjectV2CustomFieldType(this);
}

String toJson$Enum$ProjectV2CustomFieldType(Enum$ProjectV2CustomFieldType e) {
  switch (e) {
    case Enum$ProjectV2CustomFieldType.TEXT:
      return r'TEXT';
    case Enum$ProjectV2CustomFieldType.SINGLE_SELECT:
      return r'SINGLE_SELECT';
    case Enum$ProjectV2CustomFieldType.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2CustomFieldType.DATE:
      return r'DATE';
    case Enum$ProjectV2CustomFieldType.ITERATION:
      return r'ITERATION';
    case Enum$ProjectV2CustomFieldType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2CustomFieldType fromJson$Enum$ProjectV2CustomFieldType(
    String value) {
  switch (value) {
    case r'TEXT':
      return Enum$ProjectV2CustomFieldType.TEXT;
    case r'SINGLE_SELECT':
      return Enum$ProjectV2CustomFieldType.SINGLE_SELECT;
    case r'NUMBER':
      return Enum$ProjectV2CustomFieldType.NUMBER;
    case r'DATE':
      return Enum$ProjectV2CustomFieldType.DATE;
    case r'ITERATION':
      return Enum$ProjectV2CustomFieldType.ITERATION;
    default:
      return Enum$ProjectV2CustomFieldType.$unknown;
  }
}

enum Enum$ProjectV2FieldOrderField {
  POSITION,
  CREATED_AT,
  NAME,
  $unknown;

  factory Enum$ProjectV2FieldOrderField.fromJson(String value) =>
      fromJson$Enum$ProjectV2FieldOrderField(value);

  String toJson() => toJson$Enum$ProjectV2FieldOrderField(this);
}

String toJson$Enum$ProjectV2FieldOrderField(Enum$ProjectV2FieldOrderField e) {
  switch (e) {
    case Enum$ProjectV2FieldOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2FieldOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2FieldOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2FieldOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2FieldOrderField fromJson$Enum$ProjectV2FieldOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2FieldOrderField.POSITION;
    case r'CREATED_AT':
      return Enum$ProjectV2FieldOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectV2FieldOrderField.NAME;
    default:
      return Enum$ProjectV2FieldOrderField.$unknown;
  }
}

enum Enum$ProjectV2FieldType {
  ASSIGNEES,
  LINKED_PULL_REQUESTS,
  REVIEWERS,
  LABELS,
  MILESTONE,
  REPOSITORY,
  TITLE,
  TEXT,
  SINGLE_SELECT,
  NUMBER,
  DATE,
  ITERATION,
  TRACKS,
  TRACKED_BY,
  ISSUE_TYPE,
  PARENT_ISSUE,
  SUB_ISSUES_PROGRESS,
  $unknown;

  factory Enum$ProjectV2FieldType.fromJson(String value) =>
      fromJson$Enum$ProjectV2FieldType(value);

  String toJson() => toJson$Enum$ProjectV2FieldType(this);
}

String toJson$Enum$ProjectV2FieldType(Enum$ProjectV2FieldType e) {
  switch (e) {
    case Enum$ProjectV2FieldType.ASSIGNEES:
      return r'ASSIGNEES';
    case Enum$ProjectV2FieldType.LINKED_PULL_REQUESTS:
      return r'LINKED_PULL_REQUESTS';
    case Enum$ProjectV2FieldType.REVIEWERS:
      return r'REVIEWERS';
    case Enum$ProjectV2FieldType.LABELS:
      return r'LABELS';
    case Enum$ProjectV2FieldType.MILESTONE:
      return r'MILESTONE';
    case Enum$ProjectV2FieldType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$ProjectV2FieldType.TITLE:
      return r'TITLE';
    case Enum$ProjectV2FieldType.TEXT:
      return r'TEXT';
    case Enum$ProjectV2FieldType.SINGLE_SELECT:
      return r'SINGLE_SELECT';
    case Enum$ProjectV2FieldType.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2FieldType.DATE:
      return r'DATE';
    case Enum$ProjectV2FieldType.ITERATION:
      return r'ITERATION';
    case Enum$ProjectV2FieldType.TRACKS:
      return r'TRACKS';
    case Enum$ProjectV2FieldType.TRACKED_BY:
      return r'TRACKED_BY';
    case Enum$ProjectV2FieldType.ISSUE_TYPE:
      return r'ISSUE_TYPE';
    case Enum$ProjectV2FieldType.PARENT_ISSUE:
      return r'PARENT_ISSUE';
    case Enum$ProjectV2FieldType.SUB_ISSUES_PROGRESS:
      return r'SUB_ISSUES_PROGRESS';
    case Enum$ProjectV2FieldType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2FieldType fromJson$Enum$ProjectV2FieldType(String value) {
  switch (value) {
    case r'ASSIGNEES':
      return Enum$ProjectV2FieldType.ASSIGNEES;
    case r'LINKED_PULL_REQUESTS':
      return Enum$ProjectV2FieldType.LINKED_PULL_REQUESTS;
    case r'REVIEWERS':
      return Enum$ProjectV2FieldType.REVIEWERS;
    case r'LABELS':
      return Enum$ProjectV2FieldType.LABELS;
    case r'MILESTONE':
      return Enum$ProjectV2FieldType.MILESTONE;
    case r'REPOSITORY':
      return Enum$ProjectV2FieldType.REPOSITORY;
    case r'TITLE':
      return Enum$ProjectV2FieldType.TITLE;
    case r'TEXT':
      return Enum$ProjectV2FieldType.TEXT;
    case r'SINGLE_SELECT':
      return Enum$ProjectV2FieldType.SINGLE_SELECT;
    case r'NUMBER':
      return Enum$ProjectV2FieldType.NUMBER;
    case r'DATE':
      return Enum$ProjectV2FieldType.DATE;
    case r'ITERATION':
      return Enum$ProjectV2FieldType.ITERATION;
    case r'TRACKS':
      return Enum$ProjectV2FieldType.TRACKS;
    case r'TRACKED_BY':
      return Enum$ProjectV2FieldType.TRACKED_BY;
    case r'ISSUE_TYPE':
      return Enum$ProjectV2FieldType.ISSUE_TYPE;
    case r'PARENT_ISSUE':
      return Enum$ProjectV2FieldType.PARENT_ISSUE;
    case r'SUB_ISSUES_PROGRESS':
      return Enum$ProjectV2FieldType.SUB_ISSUES_PROGRESS;
    default:
      return Enum$ProjectV2FieldType.$unknown;
  }
}

enum Enum$ProjectV2ItemFieldValueOrderField {
  POSITION,
  $unknown;

  factory Enum$ProjectV2ItemFieldValueOrderField.fromJson(String value) =>
      fromJson$Enum$ProjectV2ItemFieldValueOrderField(value);

  String toJson() => toJson$Enum$ProjectV2ItemFieldValueOrderField(this);
}

String toJson$Enum$ProjectV2ItemFieldValueOrderField(
    Enum$ProjectV2ItemFieldValueOrderField e) {
  switch (e) {
    case Enum$ProjectV2ItemFieldValueOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ItemFieldValueOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemFieldValueOrderField
    fromJson$Enum$ProjectV2ItemFieldValueOrderField(String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ItemFieldValueOrderField.POSITION;
    default:
      return Enum$ProjectV2ItemFieldValueOrderField.$unknown;
  }
}

enum Enum$ProjectV2ItemOrderField {
  POSITION,
  $unknown;

  factory Enum$ProjectV2ItemOrderField.fromJson(String value) =>
      fromJson$Enum$ProjectV2ItemOrderField(value);

  String toJson() => toJson$Enum$ProjectV2ItemOrderField(this);
}

String toJson$Enum$ProjectV2ItemOrderField(Enum$ProjectV2ItemOrderField e) {
  switch (e) {
    case Enum$ProjectV2ItemOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ItemOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemOrderField fromJson$Enum$ProjectV2ItemOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ItemOrderField.POSITION;
    default:
      return Enum$ProjectV2ItemOrderField.$unknown;
  }
}

enum Enum$ProjectV2ItemType {
  ISSUE,
  PULL_REQUEST,
  DRAFT_ISSUE,
  REDACTED,
  $unknown;

  factory Enum$ProjectV2ItemType.fromJson(String value) =>
      fromJson$Enum$ProjectV2ItemType(value);

  String toJson() => toJson$Enum$ProjectV2ItemType(this);
}

String toJson$Enum$ProjectV2ItemType(Enum$ProjectV2ItemType e) {
  switch (e) {
    case Enum$ProjectV2ItemType.ISSUE:
      return r'ISSUE';
    case Enum$ProjectV2ItemType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$ProjectV2ItemType.DRAFT_ISSUE:
      return r'DRAFT_ISSUE';
    case Enum$ProjectV2ItemType.REDACTED:
      return r'REDACTED';
    case Enum$ProjectV2ItemType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemType fromJson$Enum$ProjectV2ItemType(String value) {
  switch (value) {
    case r'ISSUE':
      return Enum$ProjectV2ItemType.ISSUE;
    case r'PULL_REQUEST':
      return Enum$ProjectV2ItemType.PULL_REQUEST;
    case r'DRAFT_ISSUE':
      return Enum$ProjectV2ItemType.DRAFT_ISSUE;
    case r'REDACTED':
      return Enum$ProjectV2ItemType.REDACTED;
    default:
      return Enum$ProjectV2ItemType.$unknown;
  }
}

enum Enum$ProjectV2OrderField {
  TITLE,
  NUMBER,
  UPDATED_AT,
  CREATED_AT,
  $unknown;

  factory Enum$ProjectV2OrderField.fromJson(String value) =>
      fromJson$Enum$ProjectV2OrderField(value);

  String toJson() => toJson$Enum$ProjectV2OrderField(this);
}

String toJson$Enum$ProjectV2OrderField(Enum$ProjectV2OrderField e) {
  switch (e) {
    case Enum$ProjectV2OrderField.TITLE:
      return r'TITLE';
    case Enum$ProjectV2OrderField.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2OrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectV2OrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2OrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2OrderField fromJson$Enum$ProjectV2OrderField(String value) {
  switch (value) {
    case r'TITLE':
      return Enum$ProjectV2OrderField.TITLE;
    case r'NUMBER':
      return Enum$ProjectV2OrderField.NUMBER;
    case r'UPDATED_AT':
      return Enum$ProjectV2OrderField.UPDATED_AT;
    case r'CREATED_AT':
      return Enum$ProjectV2OrderField.CREATED_AT;
    default:
      return Enum$ProjectV2OrderField.$unknown;
  }
}

enum Enum$ProjectV2PermissionLevel {
  READ,
  WRITE,
  ADMIN,
  $unknown;

  factory Enum$ProjectV2PermissionLevel.fromJson(String value) =>
      fromJson$Enum$ProjectV2PermissionLevel(value);

  String toJson() => toJson$Enum$ProjectV2PermissionLevel(this);
}

String toJson$Enum$ProjectV2PermissionLevel(Enum$ProjectV2PermissionLevel e) {
  switch (e) {
    case Enum$ProjectV2PermissionLevel.READ:
      return r'READ';
    case Enum$ProjectV2PermissionLevel.WRITE:
      return r'WRITE';
    case Enum$ProjectV2PermissionLevel.ADMIN:
      return r'ADMIN';
    case Enum$ProjectV2PermissionLevel.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2PermissionLevel fromJson$Enum$ProjectV2PermissionLevel(
    String value) {
  switch (value) {
    case r'READ':
      return Enum$ProjectV2PermissionLevel.READ;
    case r'WRITE':
      return Enum$ProjectV2PermissionLevel.WRITE;
    case r'ADMIN':
      return Enum$ProjectV2PermissionLevel.ADMIN;
    default:
      return Enum$ProjectV2PermissionLevel.$unknown;
  }
}

enum Enum$ProjectV2Roles {
  NONE,
  READER,
  WRITER,
  ADMIN,
  $unknown;

  factory Enum$ProjectV2Roles.fromJson(String value) =>
      fromJson$Enum$ProjectV2Roles(value);

  String toJson() => toJson$Enum$ProjectV2Roles(this);
}

String toJson$Enum$ProjectV2Roles(Enum$ProjectV2Roles e) {
  switch (e) {
    case Enum$ProjectV2Roles.NONE:
      return r'NONE';
    case Enum$ProjectV2Roles.READER:
      return r'READER';
    case Enum$ProjectV2Roles.WRITER:
      return r'WRITER';
    case Enum$ProjectV2Roles.ADMIN:
      return r'ADMIN';
    case Enum$ProjectV2Roles.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2Roles fromJson$Enum$ProjectV2Roles(String value) {
  switch (value) {
    case r'NONE':
      return Enum$ProjectV2Roles.NONE;
    case r'READER':
      return Enum$ProjectV2Roles.READER;
    case r'WRITER':
      return Enum$ProjectV2Roles.WRITER;
    case r'ADMIN':
      return Enum$ProjectV2Roles.ADMIN;
    default:
      return Enum$ProjectV2Roles.$unknown;
  }
}

enum Enum$ProjectV2SingleSelectFieldOptionColor {
  GRAY,
  BLUE,
  GREEN,
  YELLOW,
  ORANGE,
  RED,
  PINK,
  PURPLE,
  $unknown;

  factory Enum$ProjectV2SingleSelectFieldOptionColor.fromJson(String value) =>
      fromJson$Enum$ProjectV2SingleSelectFieldOptionColor(value);

  String toJson() => toJson$Enum$ProjectV2SingleSelectFieldOptionColor(this);
}

String toJson$Enum$ProjectV2SingleSelectFieldOptionColor(
    Enum$ProjectV2SingleSelectFieldOptionColor e) {
  switch (e) {
    case Enum$ProjectV2SingleSelectFieldOptionColor.GRAY:
      return r'GRAY';
    case Enum$ProjectV2SingleSelectFieldOptionColor.BLUE:
      return r'BLUE';
    case Enum$ProjectV2SingleSelectFieldOptionColor.GREEN:
      return r'GREEN';
    case Enum$ProjectV2SingleSelectFieldOptionColor.YELLOW:
      return r'YELLOW';
    case Enum$ProjectV2SingleSelectFieldOptionColor.ORANGE:
      return r'ORANGE';
    case Enum$ProjectV2SingleSelectFieldOptionColor.RED:
      return r'RED';
    case Enum$ProjectV2SingleSelectFieldOptionColor.PINK:
      return r'PINK';
    case Enum$ProjectV2SingleSelectFieldOptionColor.PURPLE:
      return r'PURPLE';
    case Enum$ProjectV2SingleSelectFieldOptionColor.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2SingleSelectFieldOptionColor
    fromJson$Enum$ProjectV2SingleSelectFieldOptionColor(String value) {
  switch (value) {
    case r'GRAY':
      return Enum$ProjectV2SingleSelectFieldOptionColor.GRAY;
    case r'BLUE':
      return Enum$ProjectV2SingleSelectFieldOptionColor.BLUE;
    case r'GREEN':
      return Enum$ProjectV2SingleSelectFieldOptionColor.GREEN;
    case r'YELLOW':
      return Enum$ProjectV2SingleSelectFieldOptionColor.YELLOW;
    case r'ORANGE':
      return Enum$ProjectV2SingleSelectFieldOptionColor.ORANGE;
    case r'RED':
      return Enum$ProjectV2SingleSelectFieldOptionColor.RED;
    case r'PINK':
      return Enum$ProjectV2SingleSelectFieldOptionColor.PINK;
    case r'PURPLE':
      return Enum$ProjectV2SingleSelectFieldOptionColor.PURPLE;
    default:
      return Enum$ProjectV2SingleSelectFieldOptionColor.$unknown;
  }
}

enum Enum$ProjectV2State {
  OPEN,
  CLOSED,
  $unknown;

  factory Enum$ProjectV2State.fromJson(String value) =>
      fromJson$Enum$ProjectV2State(value);

  String toJson() => toJson$Enum$ProjectV2State(this);
}

String toJson$Enum$ProjectV2State(Enum$ProjectV2State e) {
  switch (e) {
    case Enum$ProjectV2State.OPEN:
      return r'OPEN';
    case Enum$ProjectV2State.CLOSED:
      return r'CLOSED';
    case Enum$ProjectV2State.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2State fromJson$Enum$ProjectV2State(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$ProjectV2State.OPEN;
    case r'CLOSED':
      return Enum$ProjectV2State.CLOSED;
    default:
      return Enum$ProjectV2State.$unknown;
  }
}

enum Enum$ProjectV2StatusUpdateOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$ProjectV2StatusUpdateOrderField.fromJson(String value) =>
      fromJson$Enum$ProjectV2StatusUpdateOrderField(value);

  String toJson() => toJson$Enum$ProjectV2StatusUpdateOrderField(this);
}

String toJson$Enum$ProjectV2StatusUpdateOrderField(
    Enum$ProjectV2StatusUpdateOrderField e) {
  switch (e) {
    case Enum$ProjectV2StatusUpdateOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2StatusUpdateOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2StatusUpdateOrderField
    fromJson$Enum$ProjectV2StatusUpdateOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectV2StatusUpdateOrderField.CREATED_AT;
    default:
      return Enum$ProjectV2StatusUpdateOrderField.$unknown;
  }
}

enum Enum$ProjectV2StatusUpdateStatus {
  INACTIVE,
  ON_TRACK,
  AT_RISK,
  OFF_TRACK,
  COMPLETE,
  $unknown;

  factory Enum$ProjectV2StatusUpdateStatus.fromJson(String value) =>
      fromJson$Enum$ProjectV2StatusUpdateStatus(value);

  String toJson() => toJson$Enum$ProjectV2StatusUpdateStatus(this);
}

String toJson$Enum$ProjectV2StatusUpdateStatus(
    Enum$ProjectV2StatusUpdateStatus e) {
  switch (e) {
    case Enum$ProjectV2StatusUpdateStatus.INACTIVE:
      return r'INACTIVE';
    case Enum$ProjectV2StatusUpdateStatus.ON_TRACK:
      return r'ON_TRACK';
    case Enum$ProjectV2StatusUpdateStatus.AT_RISK:
      return r'AT_RISK';
    case Enum$ProjectV2StatusUpdateStatus.OFF_TRACK:
      return r'OFF_TRACK';
    case Enum$ProjectV2StatusUpdateStatus.COMPLETE:
      return r'COMPLETE';
    case Enum$ProjectV2StatusUpdateStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2StatusUpdateStatus fromJson$Enum$ProjectV2StatusUpdateStatus(
    String value) {
  switch (value) {
    case r'INACTIVE':
      return Enum$ProjectV2StatusUpdateStatus.INACTIVE;
    case r'ON_TRACK':
      return Enum$ProjectV2StatusUpdateStatus.ON_TRACK;
    case r'AT_RISK':
      return Enum$ProjectV2StatusUpdateStatus.AT_RISK;
    case r'OFF_TRACK':
      return Enum$ProjectV2StatusUpdateStatus.OFF_TRACK;
    case r'COMPLETE':
      return Enum$ProjectV2StatusUpdateStatus.COMPLETE;
    default:
      return Enum$ProjectV2StatusUpdateStatus.$unknown;
  }
}

enum Enum$ProjectV2ViewLayout {
  BOARD_LAYOUT,
  TABLE_LAYOUT,
  ROADMAP_LAYOUT,
  $unknown;

  factory Enum$ProjectV2ViewLayout.fromJson(String value) =>
      fromJson$Enum$ProjectV2ViewLayout(value);

  String toJson() => toJson$Enum$ProjectV2ViewLayout(this);
}

String toJson$Enum$ProjectV2ViewLayout(Enum$ProjectV2ViewLayout e) {
  switch (e) {
    case Enum$ProjectV2ViewLayout.BOARD_LAYOUT:
      return r'BOARD_LAYOUT';
    case Enum$ProjectV2ViewLayout.TABLE_LAYOUT:
      return r'TABLE_LAYOUT';
    case Enum$ProjectV2ViewLayout.ROADMAP_LAYOUT:
      return r'ROADMAP_LAYOUT';
    case Enum$ProjectV2ViewLayout.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ViewLayout fromJson$Enum$ProjectV2ViewLayout(String value) {
  switch (value) {
    case r'BOARD_LAYOUT':
      return Enum$ProjectV2ViewLayout.BOARD_LAYOUT;
    case r'TABLE_LAYOUT':
      return Enum$ProjectV2ViewLayout.TABLE_LAYOUT;
    case r'ROADMAP_LAYOUT':
      return Enum$ProjectV2ViewLayout.ROADMAP_LAYOUT;
    default:
      return Enum$ProjectV2ViewLayout.$unknown;
  }
}

enum Enum$ProjectV2ViewOrderField {
  POSITION,
  CREATED_AT,
  NAME,
  $unknown;

  factory Enum$ProjectV2ViewOrderField.fromJson(String value) =>
      fromJson$Enum$ProjectV2ViewOrderField(value);

  String toJson() => toJson$Enum$ProjectV2ViewOrderField(this);
}

String toJson$Enum$ProjectV2ViewOrderField(Enum$ProjectV2ViewOrderField e) {
  switch (e) {
    case Enum$ProjectV2ViewOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ViewOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2ViewOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2ViewOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ViewOrderField fromJson$Enum$ProjectV2ViewOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ViewOrderField.POSITION;
    case r'CREATED_AT':
      return Enum$ProjectV2ViewOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectV2ViewOrderField.NAME;
    default:
      return Enum$ProjectV2ViewOrderField.$unknown;
  }
}

enum Enum$ProjectV2WorkflowsOrderField {
  NAME,
  NUMBER,
  UPDATED_AT,
  CREATED_AT,
  $unknown;

  factory Enum$ProjectV2WorkflowsOrderField.fromJson(String value) =>
      fromJson$Enum$ProjectV2WorkflowsOrderField(value);

  String toJson() => toJson$Enum$ProjectV2WorkflowsOrderField(this);
}

String toJson$Enum$ProjectV2WorkflowsOrderField(
    Enum$ProjectV2WorkflowsOrderField e) {
  switch (e) {
    case Enum$ProjectV2WorkflowsOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2WorkflowsOrderField.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2WorkflowsOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectV2WorkflowsOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2WorkflowsOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2WorkflowsOrderField fromJson$Enum$ProjectV2WorkflowsOrderField(
    String value) {
  switch (value) {
    case r'NAME':
      return Enum$ProjectV2WorkflowsOrderField.NAME;
    case r'NUMBER':
      return Enum$ProjectV2WorkflowsOrderField.NUMBER;
    case r'UPDATED_AT':
      return Enum$ProjectV2WorkflowsOrderField.UPDATED_AT;
    case r'CREATED_AT':
      return Enum$ProjectV2WorkflowsOrderField.CREATED_AT;
    default:
      return Enum$ProjectV2WorkflowsOrderField.$unknown;
  }
}

enum Enum$PullRequestAllowedMergeMethods {
  MERGE,
  SQUASH,
  REBASE,
  $unknown;

  factory Enum$PullRequestAllowedMergeMethods.fromJson(String value) =>
      fromJson$Enum$PullRequestAllowedMergeMethods(value);

  String toJson() => toJson$Enum$PullRequestAllowedMergeMethods(this);
}

String toJson$Enum$PullRequestAllowedMergeMethods(
    Enum$PullRequestAllowedMergeMethods e) {
  switch (e) {
    case Enum$PullRequestAllowedMergeMethods.MERGE:
      return r'MERGE';
    case Enum$PullRequestAllowedMergeMethods.SQUASH:
      return r'SQUASH';
    case Enum$PullRequestAllowedMergeMethods.REBASE:
      return r'REBASE';
    case Enum$PullRequestAllowedMergeMethods.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestAllowedMergeMethods
    fromJson$Enum$PullRequestAllowedMergeMethods(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$PullRequestAllowedMergeMethods.MERGE;
    case r'SQUASH':
      return Enum$PullRequestAllowedMergeMethods.SQUASH;
    case r'REBASE':
      return Enum$PullRequestAllowedMergeMethods.REBASE;
    default:
      return Enum$PullRequestAllowedMergeMethods.$unknown;
  }
}

enum Enum$PullRequestBranchUpdateMethod {
  MERGE,
  REBASE,
  $unknown;

  factory Enum$PullRequestBranchUpdateMethod.fromJson(String value) =>
      fromJson$Enum$PullRequestBranchUpdateMethod(value);

  String toJson() => toJson$Enum$PullRequestBranchUpdateMethod(this);
}

String toJson$Enum$PullRequestBranchUpdateMethod(
    Enum$PullRequestBranchUpdateMethod e) {
  switch (e) {
    case Enum$PullRequestBranchUpdateMethod.MERGE:
      return r'MERGE';
    case Enum$PullRequestBranchUpdateMethod.REBASE:
      return r'REBASE';
    case Enum$PullRequestBranchUpdateMethod.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestBranchUpdateMethod fromJson$Enum$PullRequestBranchUpdateMethod(
    String value) {
  switch (value) {
    case r'MERGE':
      return Enum$PullRequestBranchUpdateMethod.MERGE;
    case r'REBASE':
      return Enum$PullRequestBranchUpdateMethod.REBASE;
    default:
      return Enum$PullRequestBranchUpdateMethod.$unknown;
  }
}

enum Enum$PullRequestMergeMethod {
  MERGE,
  SQUASH,
  REBASE,
  $unknown;

  factory Enum$PullRequestMergeMethod.fromJson(String value) =>
      fromJson$Enum$PullRequestMergeMethod(value);

  String toJson() => toJson$Enum$PullRequestMergeMethod(this);
}

String toJson$Enum$PullRequestMergeMethod(Enum$PullRequestMergeMethod e) {
  switch (e) {
    case Enum$PullRequestMergeMethod.MERGE:
      return r'MERGE';
    case Enum$PullRequestMergeMethod.SQUASH:
      return r'SQUASH';
    case Enum$PullRequestMergeMethod.REBASE:
      return r'REBASE';
    case Enum$PullRequestMergeMethod.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestMergeMethod fromJson$Enum$PullRequestMergeMethod(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$PullRequestMergeMethod.MERGE;
    case r'SQUASH':
      return Enum$PullRequestMergeMethod.SQUASH;
    case r'REBASE':
      return Enum$PullRequestMergeMethod.REBASE;
    default:
      return Enum$PullRequestMergeMethod.$unknown;
  }
}

enum Enum$PullRequestOrderField {
  CREATED_AT,
  UPDATED_AT,
  $unknown;

  factory Enum$PullRequestOrderField.fromJson(String value) =>
      fromJson$Enum$PullRequestOrderField(value);

  String toJson() => toJson$Enum$PullRequestOrderField(this);
}

String toJson$Enum$PullRequestOrderField(Enum$PullRequestOrderField e) {
  switch (e) {
    case Enum$PullRequestOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PullRequestOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$PullRequestOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestOrderField fromJson$Enum$PullRequestOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PullRequestOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$PullRequestOrderField.UPDATED_AT;
    default:
      return Enum$PullRequestOrderField.$unknown;
  }
}

enum Enum$PullRequestReviewCommentState {
  PENDING,
  SUBMITTED,
  $unknown;

  factory Enum$PullRequestReviewCommentState.fromJson(String value) =>
      fromJson$Enum$PullRequestReviewCommentState(value);

  String toJson() => toJson$Enum$PullRequestReviewCommentState(this);
}

String toJson$Enum$PullRequestReviewCommentState(
    Enum$PullRequestReviewCommentState e) {
  switch (e) {
    case Enum$PullRequestReviewCommentState.PENDING:
      return r'PENDING';
    case Enum$PullRequestReviewCommentState.SUBMITTED:
      return r'SUBMITTED';
    case Enum$PullRequestReviewCommentState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewCommentState fromJson$Enum$PullRequestReviewCommentState(
    String value) {
  switch (value) {
    case r'PENDING':
      return Enum$PullRequestReviewCommentState.PENDING;
    case r'SUBMITTED':
      return Enum$PullRequestReviewCommentState.SUBMITTED;
    default:
      return Enum$PullRequestReviewCommentState.$unknown;
  }
}

enum Enum$PullRequestReviewDecision {
  CHANGES_REQUESTED,
  APPROVED,
  REVIEW_REQUIRED,
  $unknown;

  factory Enum$PullRequestReviewDecision.fromJson(String value) =>
      fromJson$Enum$PullRequestReviewDecision(value);

  String toJson() => toJson$Enum$PullRequestReviewDecision(this);
}

String toJson$Enum$PullRequestReviewDecision(Enum$PullRequestReviewDecision e) {
  switch (e) {
    case Enum$PullRequestReviewDecision.CHANGES_REQUESTED:
      return r'CHANGES_REQUESTED';
    case Enum$PullRequestReviewDecision.APPROVED:
      return r'APPROVED';
    case Enum$PullRequestReviewDecision.REVIEW_REQUIRED:
      return r'REVIEW_REQUIRED';
    case Enum$PullRequestReviewDecision.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewDecision fromJson$Enum$PullRequestReviewDecision(
    String value) {
  switch (value) {
    case r'CHANGES_REQUESTED':
      return Enum$PullRequestReviewDecision.CHANGES_REQUESTED;
    case r'APPROVED':
      return Enum$PullRequestReviewDecision.APPROVED;
    case r'REVIEW_REQUIRED':
      return Enum$PullRequestReviewDecision.REVIEW_REQUIRED;
    default:
      return Enum$PullRequestReviewDecision.$unknown;
  }
}

enum Enum$PullRequestReviewEvent {
  COMMENT,
  APPROVE,
  REQUEST_CHANGES,
  DISMISS,
  $unknown;

  factory Enum$PullRequestReviewEvent.fromJson(String value) =>
      fromJson$Enum$PullRequestReviewEvent(value);

  String toJson() => toJson$Enum$PullRequestReviewEvent(this);
}

String toJson$Enum$PullRequestReviewEvent(Enum$PullRequestReviewEvent e) {
  switch (e) {
    case Enum$PullRequestReviewEvent.COMMENT:
      return r'COMMENT';
    case Enum$PullRequestReviewEvent.APPROVE:
      return r'APPROVE';
    case Enum$PullRequestReviewEvent.REQUEST_CHANGES:
      return r'REQUEST_CHANGES';
    case Enum$PullRequestReviewEvent.DISMISS:
      return r'DISMISS';
    case Enum$PullRequestReviewEvent.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewEvent fromJson$Enum$PullRequestReviewEvent(String value) {
  switch (value) {
    case r'COMMENT':
      return Enum$PullRequestReviewEvent.COMMENT;
    case r'APPROVE':
      return Enum$PullRequestReviewEvent.APPROVE;
    case r'REQUEST_CHANGES':
      return Enum$PullRequestReviewEvent.REQUEST_CHANGES;
    case r'DISMISS':
      return Enum$PullRequestReviewEvent.DISMISS;
    default:
      return Enum$PullRequestReviewEvent.$unknown;
  }
}

enum Enum$PullRequestReviewState {
  PENDING,
  COMMENTED,
  APPROVED,
  CHANGES_REQUESTED,
  DISMISSED,
  $unknown;

  factory Enum$PullRequestReviewState.fromJson(String value) =>
      fromJson$Enum$PullRequestReviewState(value);

  String toJson() => toJson$Enum$PullRequestReviewState(this);
}

String toJson$Enum$PullRequestReviewState(Enum$PullRequestReviewState e) {
  switch (e) {
    case Enum$PullRequestReviewState.PENDING:
      return r'PENDING';
    case Enum$PullRequestReviewState.COMMENTED:
      return r'COMMENTED';
    case Enum$PullRequestReviewState.APPROVED:
      return r'APPROVED';
    case Enum$PullRequestReviewState.CHANGES_REQUESTED:
      return r'CHANGES_REQUESTED';
    case Enum$PullRequestReviewState.DISMISSED:
      return r'DISMISSED';
    case Enum$PullRequestReviewState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewState fromJson$Enum$PullRequestReviewState(String value) {
  switch (value) {
    case r'PENDING':
      return Enum$PullRequestReviewState.PENDING;
    case r'COMMENTED':
      return Enum$PullRequestReviewState.COMMENTED;
    case r'APPROVED':
      return Enum$PullRequestReviewState.APPROVED;
    case r'CHANGES_REQUESTED':
      return Enum$PullRequestReviewState.CHANGES_REQUESTED;
    case r'DISMISSED':
      return Enum$PullRequestReviewState.DISMISSED;
    default:
      return Enum$PullRequestReviewState.$unknown;
  }
}

enum Enum$PullRequestReviewThreadSubjectType {
  LINE,
  FILE,
  $unknown;

  factory Enum$PullRequestReviewThreadSubjectType.fromJson(String value) =>
      fromJson$Enum$PullRequestReviewThreadSubjectType(value);

  String toJson() => toJson$Enum$PullRequestReviewThreadSubjectType(this);
}

String toJson$Enum$PullRequestReviewThreadSubjectType(
    Enum$PullRequestReviewThreadSubjectType e) {
  switch (e) {
    case Enum$PullRequestReviewThreadSubjectType.LINE:
      return r'LINE';
    case Enum$PullRequestReviewThreadSubjectType.FILE:
      return r'FILE';
    case Enum$PullRequestReviewThreadSubjectType.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewThreadSubjectType
    fromJson$Enum$PullRequestReviewThreadSubjectType(String value) {
  switch (value) {
    case r'LINE':
      return Enum$PullRequestReviewThreadSubjectType.LINE;
    case r'FILE':
      return Enum$PullRequestReviewThreadSubjectType.FILE;
    default:
      return Enum$PullRequestReviewThreadSubjectType.$unknown;
  }
}

enum Enum$PullRequestState {
  OPEN,
  CLOSED,
  MERGED,
  $unknown;

  factory Enum$PullRequestState.fromJson(String value) =>
      fromJson$Enum$PullRequestState(value);

  String toJson() => toJson$Enum$PullRequestState(this);
}

String toJson$Enum$PullRequestState(Enum$PullRequestState e) {
  switch (e) {
    case Enum$PullRequestState.OPEN:
      return r'OPEN';
    case Enum$PullRequestState.CLOSED:
      return r'CLOSED';
    case Enum$PullRequestState.MERGED:
      return r'MERGED';
    case Enum$PullRequestState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestState fromJson$Enum$PullRequestState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$PullRequestState.OPEN;
    case r'CLOSED':
      return Enum$PullRequestState.CLOSED;
    case r'MERGED':
      return Enum$PullRequestState.MERGED;
    default:
      return Enum$PullRequestState.$unknown;
  }
}

enum Enum$PullRequestTimelineItemsItemType {
  PULL_REQUEST_COMMIT,
  PULL_REQUEST_COMMIT_COMMENT_THREAD,
  PULL_REQUEST_REVIEW,
  PULL_REQUEST_REVIEW_THREAD,
  PULL_REQUEST_REVISION_MARKER,
  ADDED_TO_MERGE_QUEUE_EVENT,
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT,
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT,
  AUTO_MERGE_DISABLED_EVENT,
  AUTO_MERGE_ENABLED_EVENT,
  AUTO_REBASE_ENABLED_EVENT,
  AUTO_SQUASH_ENABLED_EVENT,
  BASE_REF_CHANGED_EVENT,
  BASE_REF_FORCE_PUSHED_EVENT,
  BASE_REF_DELETED_EVENT,
  CONVERT_TO_DRAFT_EVENT,
  DEPLOYED_EVENT,
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT,
  HEAD_REF_DELETED_EVENT,
  HEAD_REF_FORCE_PUSHED_EVENT,
  HEAD_REF_RESTORED_EVENT,
  MERGED_EVENT,
  READY_FOR_REVIEW_EVENT,
  REMOVED_FROM_MERGE_QUEUE_EVENT,
  REVIEW_DISMISSED_EVENT,
  REVIEW_REQUESTED_EVENT,
  REVIEW_REQUEST_REMOVED_EVENT,
  ISSUE_COMMENT,
  CROSS_REFERENCED_EVENT,
  ADDED_TO_PROJECT_EVENT,
  ASSIGNED_EVENT,
  CLOSED_EVENT,
  COMMENT_DELETED_EVENT,
  CONNECTED_EVENT,
  CONVERTED_NOTE_TO_ISSUE_EVENT,
  CONVERTED_TO_DISCUSSION_EVENT,
  DEMILESTONED_EVENT,
  DISCONNECTED_EVENT,
  LABELED_EVENT,
  LOCKED_EVENT,
  MARKED_AS_DUPLICATE_EVENT,
  MENTIONED_EVENT,
  MILESTONED_EVENT,
  MOVED_COLUMNS_IN_PROJECT_EVENT,
  PINNED_EVENT,
  REFERENCED_EVENT,
  REMOVED_FROM_PROJECT_EVENT,
  RENAMED_TITLE_EVENT,
  REOPENED_EVENT,
  SUBSCRIBED_EVENT,
  TRANSFERRED_EVENT,
  UNASSIGNED_EVENT,
  UNLABELED_EVENT,
  UNLOCKED_EVENT,
  USER_BLOCKED_EVENT,
  UNMARKED_AS_DUPLICATE_EVENT,
  UNPINNED_EVENT,
  UNSUBSCRIBED_EVENT,
  ISSUE_TYPE_ADDED_EVENT,
  ISSUE_TYPE_REMOVED_EVENT,
  ISSUE_TYPE_CHANGED_EVENT,
  SUB_ISSUE_ADDED_EVENT,
  SUB_ISSUE_REMOVED_EVENT,
  PARENT_ISSUE_ADDED_EVENT,
  PARENT_ISSUE_REMOVED_EVENT,
  BLOCKED_BY_ADDED_EVENT,
  BLOCKING_ADDED_EVENT,
  BLOCKED_BY_REMOVED_EVENT,
  BLOCKING_REMOVED_EVENT,
  $unknown;

  factory Enum$PullRequestTimelineItemsItemType.fromJson(String value) =>
      fromJson$Enum$PullRequestTimelineItemsItemType(value);

  String toJson() => toJson$Enum$PullRequestTimelineItemsItemType(this);
}

String toJson$Enum$PullRequestTimelineItemsItemType(
    Enum$PullRequestTimelineItemsItemType e) {
  switch (e) {
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_COMMIT:
      return r'PULL_REQUEST_COMMIT';
    case Enum$PullRequestTimelineItemsItemType
          .PULL_REQUEST_COMMIT_COMMENT_THREAD:
      return r'PULL_REQUEST_COMMIT_COMMENT_THREAD';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW:
      return r'PULL_REQUEST_REVIEW';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW_THREAD:
      return r'PULL_REQUEST_REVIEW_THREAD';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVISION_MARKER:
      return r'PULL_REQUEST_REVISION_MARKER';
    case Enum$PullRequestTimelineItemsItemType.ADDED_TO_MERGE_QUEUE_EVENT:
      return r'ADDED_TO_MERGE_QUEUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_FAILED_EVENT:
      return r'AUTOMATIC_BASE_CHANGE_FAILED_EVENT';
    case Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT:
      return r'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_DISABLED_EVENT:
      return r'AUTO_MERGE_DISABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_ENABLED_EVENT:
      return r'AUTO_MERGE_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_REBASE_ENABLED_EVENT:
      return r'AUTO_REBASE_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_SQUASH_ENABLED_EVENT:
      return r'AUTO_SQUASH_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_CHANGED_EVENT:
      return r'BASE_REF_CHANGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_FORCE_PUSHED_EVENT:
      return r'BASE_REF_FORCE_PUSHED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_DELETED_EVENT:
      return r'BASE_REF_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERT_TO_DRAFT_EVENT:
      return r'CONVERT_TO_DRAFT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DEPLOYED_EVENT:
      return r'DEPLOYED_EVENT';
    case Enum$PullRequestTimelineItemsItemType
          .DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT:
      return r'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_DELETED_EVENT:
      return r'HEAD_REF_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_FORCE_PUSHED_EVENT:
      return r'HEAD_REF_FORCE_PUSHED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_RESTORED_EVENT:
      return r'HEAD_REF_RESTORED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MERGED_EVENT:
      return r'MERGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.READY_FOR_REVIEW_EVENT:
      return r'READY_FOR_REVIEW_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_MERGE_QUEUE_EVENT:
      return r'REMOVED_FROM_MERGE_QUEUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_DISMISSED_EVENT:
      return r'REVIEW_DISMISSED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_REQUESTED_EVENT:
      return r'REVIEW_REQUESTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_REQUEST_REMOVED_EVENT:
      return r'REVIEW_REQUEST_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ISSUE_COMMENT:
      return r'ISSUE_COMMENT';
    case Enum$PullRequestTimelineItemsItemType.CROSS_REFERENCED_EVENT:
      return r'CROSS_REFERENCED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ADDED_TO_PROJECT_EVENT:
      return r'ADDED_TO_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ASSIGNED_EVENT:
      return r'ASSIGNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CLOSED_EVENT:
      return r'CLOSED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.COMMENT_DELETED_EVENT:
      return r'COMMENT_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONNECTED_EVENT:
      return r'CONNECTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT:
      return r'CONVERTED_NOTE_TO_ISSUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT:
      return r'CONVERTED_TO_DISCUSSION_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DEMILESTONED_EVENT:
      return r'DEMILESTONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DISCONNECTED_EVENT:
      return r'DISCONNECTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.LABELED_EVENT:
      return r'LABELED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.LOCKED_EVENT:
      return r'LOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT:
      return r'MARKED_AS_DUPLICATE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MENTIONED_EVENT:
      return r'MENTIONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MILESTONED_EVENT:
      return r'MILESTONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT:
      return r'MOVED_COLUMNS_IN_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.PINNED_EVENT:
      return r'PINNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REFERENCED_EVENT:
      return r'REFERENCED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT:
      return r'REMOVED_FROM_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.RENAMED_TITLE_EVENT:
      return r'RENAMED_TITLE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REOPENED_EVENT:
      return r'REOPENED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.SUBSCRIBED_EVENT:
      return r'SUBSCRIBED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.TRANSFERRED_EVENT:
      return r'TRANSFERRED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNASSIGNED_EVENT:
      return r'UNASSIGNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNLABELED_EVENT:
      return r'UNLABELED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNLOCKED_EVENT:
      return r'UNLOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.USER_BLOCKED_EVENT:
      return r'USER_BLOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT:
      return r'UNMARKED_AS_DUPLICATE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNPINNED_EVENT:
      return r'UNPINNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNSUBSCRIBED_EVENT:
      return r'UNSUBSCRIBED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ISSUE_TYPE_ADDED_EVENT:
      return r'ISSUE_TYPE_ADDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ISSUE_TYPE_REMOVED_EVENT:
      return r'ISSUE_TYPE_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ISSUE_TYPE_CHANGED_EVENT:
      return r'ISSUE_TYPE_CHANGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.SUB_ISSUE_ADDED_EVENT:
      return r'SUB_ISSUE_ADDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.SUB_ISSUE_REMOVED_EVENT:
      return r'SUB_ISSUE_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.PARENT_ISSUE_ADDED_EVENT:
      return r'PARENT_ISSUE_ADDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.PARENT_ISSUE_REMOVED_EVENT:
      return r'PARENT_ISSUE_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BLOCKED_BY_ADDED_EVENT:
      return r'BLOCKED_BY_ADDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BLOCKING_ADDED_EVENT:
      return r'BLOCKING_ADDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BLOCKED_BY_REMOVED_EVENT:
      return r'BLOCKED_BY_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BLOCKING_REMOVED_EVENT:
      return r'BLOCKING_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestTimelineItemsItemType
    fromJson$Enum$PullRequestTimelineItemsItemType(String value) {
  switch (value) {
    case r'PULL_REQUEST_COMMIT':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_COMMIT;
    case r'PULL_REQUEST_COMMIT_COMMENT_THREAD':
      return Enum$PullRequestTimelineItemsItemType
          .PULL_REQUEST_COMMIT_COMMENT_THREAD;
    case r'PULL_REQUEST_REVIEW':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW;
    case r'PULL_REQUEST_REVIEW_THREAD':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW_THREAD;
    case r'PULL_REQUEST_REVISION_MARKER':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVISION_MARKER;
    case r'ADDED_TO_MERGE_QUEUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ADDED_TO_MERGE_QUEUE_EVENT;
    case r'AUTOMATIC_BASE_CHANGE_FAILED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_FAILED_EVENT;
    case r'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT;
    case r'AUTO_MERGE_DISABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_DISABLED_EVENT;
    case r'AUTO_MERGE_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_ENABLED_EVENT;
    case r'AUTO_REBASE_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_REBASE_ENABLED_EVENT;
    case r'AUTO_SQUASH_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_SQUASH_ENABLED_EVENT;
    case r'BASE_REF_CHANGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_CHANGED_EVENT;
    case r'BASE_REF_FORCE_PUSHED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_FORCE_PUSHED_EVENT;
    case r'BASE_REF_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_DELETED_EVENT;
    case r'CONVERT_TO_DRAFT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CONVERT_TO_DRAFT_EVENT;
    case r'DEPLOYED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DEPLOYED_EVENT;
    case r'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT;
    case r'HEAD_REF_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_DELETED_EVENT;
    case r'HEAD_REF_FORCE_PUSHED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_FORCE_PUSHED_EVENT;
    case r'HEAD_REF_RESTORED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_RESTORED_EVENT;
    case r'MERGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MERGED_EVENT;
    case r'READY_FOR_REVIEW_EVENT':
      return Enum$PullRequestTimelineItemsItemType.READY_FOR_REVIEW_EVENT;
    case r'REMOVED_FROM_MERGE_QUEUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .REMOVED_FROM_MERGE_QUEUE_EVENT;
    case r'REVIEW_DISMISSED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_DISMISSED_EVENT;
    case r'REVIEW_REQUESTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_REQUESTED_EVENT;
    case r'REVIEW_REQUEST_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_REQUEST_REMOVED_EVENT;
    case r'ISSUE_COMMENT':
      return Enum$PullRequestTimelineItemsItemType.ISSUE_COMMENT;
    case r'CROSS_REFERENCED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CROSS_REFERENCED_EVENT;
    case r'ADDED_TO_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ADDED_TO_PROJECT_EVENT;
    case r'ASSIGNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ASSIGNED_EVENT;
    case r'CLOSED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CLOSED_EVENT;
    case r'COMMENT_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.COMMENT_DELETED_EVENT;
    case r'CONNECTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CONNECTED_EVENT;
    case r'CONVERTED_NOTE_TO_ISSUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .CONVERTED_NOTE_TO_ISSUE_EVENT;
    case r'CONVERTED_TO_DISCUSSION_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .CONVERTED_TO_DISCUSSION_EVENT;
    case r'DEMILESTONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DEMILESTONED_EVENT;
    case r'DISCONNECTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DISCONNECTED_EVENT;
    case r'LABELED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.LABELED_EVENT;
    case r'LOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.LOCKED_EVENT;
    case r'MARKED_AS_DUPLICATE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT;
    case r'MENTIONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MENTIONED_EVENT;
    case r'MILESTONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MILESTONED_EVENT;
    case r'MOVED_COLUMNS_IN_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .MOVED_COLUMNS_IN_PROJECT_EVENT;
    case r'PINNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.PINNED_EVENT;
    case r'REFERENCED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REFERENCED_EVENT;
    case r'REMOVED_FROM_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT;
    case r'RENAMED_TITLE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.RENAMED_TITLE_EVENT;
    case r'REOPENED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REOPENED_EVENT;
    case r'SUBSCRIBED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.SUBSCRIBED_EVENT;
    case r'TRANSFERRED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.TRANSFERRED_EVENT;
    case r'UNASSIGNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNASSIGNED_EVENT;
    case r'UNLABELED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNLABELED_EVENT;
    case r'UNLOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNLOCKED_EVENT;
    case r'USER_BLOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.USER_BLOCKED_EVENT;
    case r'UNMARKED_AS_DUPLICATE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT;
    case r'UNPINNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNPINNED_EVENT;
    case r'UNSUBSCRIBED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNSUBSCRIBED_EVENT;
    case r'ISSUE_TYPE_ADDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ISSUE_TYPE_ADDED_EVENT;
    case r'ISSUE_TYPE_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ISSUE_TYPE_REMOVED_EVENT;
    case r'ISSUE_TYPE_CHANGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ISSUE_TYPE_CHANGED_EVENT;
    case r'SUB_ISSUE_ADDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.SUB_ISSUE_ADDED_EVENT;
    case r'SUB_ISSUE_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.SUB_ISSUE_REMOVED_EVENT;
    case r'PARENT_ISSUE_ADDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.PARENT_ISSUE_ADDED_EVENT;
    case r'PARENT_ISSUE_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.PARENT_ISSUE_REMOVED_EVENT;
    case r'BLOCKED_BY_ADDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BLOCKED_BY_ADDED_EVENT;
    case r'BLOCKING_ADDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BLOCKING_ADDED_EVENT;
    case r'BLOCKED_BY_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BLOCKED_BY_REMOVED_EVENT;
    case r'BLOCKING_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BLOCKING_REMOVED_EVENT;
    default:
      return Enum$PullRequestTimelineItemsItemType.$unknown;
  }
}

enum Enum$PullRequestUpdateState {
  OPEN,
  CLOSED,
  $unknown;

  factory Enum$PullRequestUpdateState.fromJson(String value) =>
      fromJson$Enum$PullRequestUpdateState(value);

  String toJson() => toJson$Enum$PullRequestUpdateState(this);
}

String toJson$Enum$PullRequestUpdateState(Enum$PullRequestUpdateState e) {
  switch (e) {
    case Enum$PullRequestUpdateState.OPEN:
      return r'OPEN';
    case Enum$PullRequestUpdateState.CLOSED:
      return r'CLOSED';
    case Enum$PullRequestUpdateState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestUpdateState fromJson$Enum$PullRequestUpdateState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$PullRequestUpdateState.OPEN;
    case r'CLOSED':
      return Enum$PullRequestUpdateState.CLOSED;
    default:
      return Enum$PullRequestUpdateState.$unknown;
  }
}

enum Enum$ReactionContent {
  THUMBS_UP,
  THUMBS_DOWN,
  LAUGH,
  HOORAY,
  CONFUSED,
  HEART,
  ROCKET,
  EYES,
  $unknown;

  factory Enum$ReactionContent.fromJson(String value) =>
      fromJson$Enum$ReactionContent(value);

  String toJson() => toJson$Enum$ReactionContent(this);
}

String toJson$Enum$ReactionContent(Enum$ReactionContent e) {
  switch (e) {
    case Enum$ReactionContent.THUMBS_UP:
      return r'THUMBS_UP';
    case Enum$ReactionContent.THUMBS_DOWN:
      return r'THUMBS_DOWN';
    case Enum$ReactionContent.LAUGH:
      return r'LAUGH';
    case Enum$ReactionContent.HOORAY:
      return r'HOORAY';
    case Enum$ReactionContent.CONFUSED:
      return r'CONFUSED';
    case Enum$ReactionContent.HEART:
      return r'HEART';
    case Enum$ReactionContent.ROCKET:
      return r'ROCKET';
    case Enum$ReactionContent.EYES:
      return r'EYES';
    case Enum$ReactionContent.$unknown:
      return r'$unknown';
  }
}

Enum$ReactionContent fromJson$Enum$ReactionContent(String value) {
  switch (value) {
    case r'THUMBS_UP':
      return Enum$ReactionContent.THUMBS_UP;
    case r'THUMBS_DOWN':
      return Enum$ReactionContent.THUMBS_DOWN;
    case r'LAUGH':
      return Enum$ReactionContent.LAUGH;
    case r'HOORAY':
      return Enum$ReactionContent.HOORAY;
    case r'CONFUSED':
      return Enum$ReactionContent.CONFUSED;
    case r'HEART':
      return Enum$ReactionContent.HEART;
    case r'ROCKET':
      return Enum$ReactionContent.ROCKET;
    case r'EYES':
      return Enum$ReactionContent.EYES;
    default:
      return Enum$ReactionContent.$unknown;
  }
}

enum Enum$ReactionOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$ReactionOrderField.fromJson(String value) =>
      fromJson$Enum$ReactionOrderField(value);

  String toJson() => toJson$Enum$ReactionOrderField(this);
}

String toJson$Enum$ReactionOrderField(Enum$ReactionOrderField e) {
  switch (e) {
    case Enum$ReactionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ReactionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ReactionOrderField fromJson$Enum$ReactionOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ReactionOrderField.CREATED_AT;
    default:
      return Enum$ReactionOrderField.$unknown;
  }
}

enum Enum$RefOrderField {
  TAG_COMMIT_DATE,
  ALPHABETICAL,
  $unknown;

  factory Enum$RefOrderField.fromJson(String value) =>
      fromJson$Enum$RefOrderField(value);

  String toJson() => toJson$Enum$RefOrderField(this);
}

String toJson$Enum$RefOrderField(Enum$RefOrderField e) {
  switch (e) {
    case Enum$RefOrderField.TAG_COMMIT_DATE:
      return r'TAG_COMMIT_DATE';
    case Enum$RefOrderField.ALPHABETICAL:
      return r'ALPHABETICAL';
    case Enum$RefOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RefOrderField fromJson$Enum$RefOrderField(String value) {
  switch (value) {
    case r'TAG_COMMIT_DATE':
      return Enum$RefOrderField.TAG_COMMIT_DATE;
    case r'ALPHABETICAL':
      return Enum$RefOrderField.ALPHABETICAL;
    default:
      return Enum$RefOrderField.$unknown;
  }
}

enum Enum$ReleaseOrderField {
  CREATED_AT,
  NAME,
  $unknown;

  factory Enum$ReleaseOrderField.fromJson(String value) =>
      fromJson$Enum$ReleaseOrderField(value);

  String toJson() => toJson$Enum$ReleaseOrderField(this);
}

String toJson$Enum$ReleaseOrderField(Enum$ReleaseOrderField e) {
  switch (e) {
    case Enum$ReleaseOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ReleaseOrderField.NAME:
      return r'NAME';
    case Enum$ReleaseOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ReleaseOrderField fromJson$Enum$ReleaseOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ReleaseOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ReleaseOrderField.NAME;
    default:
      return Enum$ReleaseOrderField.$unknown;
  }
}

enum Enum$RepoAccessAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown;

  factory Enum$RepoAccessAuditEntryVisibility.fromJson(String value) =>
      fromJson$Enum$RepoAccessAuditEntryVisibility(value);

  String toJson() => toJson$Enum$RepoAccessAuditEntryVisibility(this);
}

String toJson$Enum$RepoAccessAuditEntryVisibility(
    Enum$RepoAccessAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoAccessAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoAccessAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoAccessAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoAccessAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoAccessAuditEntryVisibility
    fromJson$Enum$RepoAccessAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoAccessAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoAccessAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoAccessAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoAccessAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoAddMemberAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown;

  factory Enum$RepoAddMemberAuditEntryVisibility.fromJson(String value) =>
      fromJson$Enum$RepoAddMemberAuditEntryVisibility(value);

  String toJson() => toJson$Enum$RepoAddMemberAuditEntryVisibility(this);
}

String toJson$Enum$RepoAddMemberAuditEntryVisibility(
    Enum$RepoAddMemberAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoAddMemberAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoAddMemberAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoAddMemberAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoAddMemberAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoAddMemberAuditEntryVisibility
    fromJson$Enum$RepoAddMemberAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoAddMemberAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoAddMemberAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoAddMemberAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoAddMemberAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoArchivedAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown;

  factory Enum$RepoArchivedAuditEntryVisibility.fromJson(String value) =>
      fromJson$Enum$RepoArchivedAuditEntryVisibility(value);

  String toJson() => toJson$Enum$RepoArchivedAuditEntryVisibility(this);
}

String toJson$Enum$RepoArchivedAuditEntryVisibility(
    Enum$RepoArchivedAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoArchivedAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoArchivedAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoArchivedAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoArchivedAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoArchivedAuditEntryVisibility
    fromJson$Enum$RepoArchivedAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoArchivedAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoArchivedAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoArchivedAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoArchivedAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoChangeMergeSettingAuditEntryMergeType {
  MERGE,
  REBASE,
  SQUASH,
  $unknown;

  factory Enum$RepoChangeMergeSettingAuditEntryMergeType.fromJson(
          String value) =>
      fromJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(value);

  String toJson() =>
      toJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(this);
}

String toJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(
    Enum$RepoChangeMergeSettingAuditEntryMergeType e) {
  switch (e) {
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.MERGE:
      return r'MERGE';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.REBASE:
      return r'REBASE';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.SQUASH:
      return r'SQUASH';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.$unknown:
      return r'$unknown';
  }
}

Enum$RepoChangeMergeSettingAuditEntryMergeType
    fromJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.MERGE;
    case r'REBASE':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.REBASE;
    case r'SQUASH':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.SQUASH;
    default:
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.$unknown;
  }
}

enum Enum$RepoCreateAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown;

  factory Enum$RepoCreateAuditEntryVisibility.fromJson(String value) =>
      fromJson$Enum$RepoCreateAuditEntryVisibility(value);

  String toJson() => toJson$Enum$RepoCreateAuditEntryVisibility(this);
}

String toJson$Enum$RepoCreateAuditEntryVisibility(
    Enum$RepoCreateAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoCreateAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoCreateAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoCreateAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoCreateAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoCreateAuditEntryVisibility
    fromJson$Enum$RepoCreateAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoCreateAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoCreateAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoCreateAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoCreateAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoDestroyAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown;

  factory Enum$RepoDestroyAuditEntryVisibility.fromJson(String value) =>
      fromJson$Enum$RepoDestroyAuditEntryVisibility(value);

  String toJson() => toJson$Enum$RepoDestroyAuditEntryVisibility(this);
}

String toJson$Enum$RepoDestroyAuditEntryVisibility(
    Enum$RepoDestroyAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoDestroyAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoDestroyAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoDestroyAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoDestroyAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoDestroyAuditEntryVisibility
    fromJson$Enum$RepoDestroyAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoDestroyAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoDestroyAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoDestroyAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoDestroyAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoRemoveMemberAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown;

  factory Enum$RepoRemoveMemberAuditEntryVisibility.fromJson(String value) =>
      fromJson$Enum$RepoRemoveMemberAuditEntryVisibility(value);

  String toJson() => toJson$Enum$RepoRemoveMemberAuditEntryVisibility(this);
}

String toJson$Enum$RepoRemoveMemberAuditEntryVisibility(
    Enum$RepoRemoveMemberAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoRemoveMemberAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoRemoveMemberAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoRemoveMemberAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoRemoveMemberAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoRemoveMemberAuditEntryVisibility
    fromJson$Enum$RepoRemoveMemberAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoRemoveMemberAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoRemoveMemberAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoRemoveMemberAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoRemoveMemberAuditEntryVisibility.$unknown;
  }
}

enum Enum$ReportedContentClassifiers {
  SPAM,
  ABUSE,
  OFF_TOPIC,
  OUTDATED,
  DUPLICATE,
  RESOLVED,
  $unknown;

  factory Enum$ReportedContentClassifiers.fromJson(String value) =>
      fromJson$Enum$ReportedContentClassifiers(value);

  String toJson() => toJson$Enum$ReportedContentClassifiers(this);
}

String toJson$Enum$ReportedContentClassifiers(
    Enum$ReportedContentClassifiers e) {
  switch (e) {
    case Enum$ReportedContentClassifiers.SPAM:
      return r'SPAM';
    case Enum$ReportedContentClassifiers.ABUSE:
      return r'ABUSE';
    case Enum$ReportedContentClassifiers.OFF_TOPIC:
      return r'OFF_TOPIC';
    case Enum$ReportedContentClassifiers.OUTDATED:
      return r'OUTDATED';
    case Enum$ReportedContentClassifiers.DUPLICATE:
      return r'DUPLICATE';
    case Enum$ReportedContentClassifiers.RESOLVED:
      return r'RESOLVED';
    case Enum$ReportedContentClassifiers.$unknown:
      return r'$unknown';
  }
}

Enum$ReportedContentClassifiers fromJson$Enum$ReportedContentClassifiers(
    String value) {
  switch (value) {
    case r'SPAM':
      return Enum$ReportedContentClassifiers.SPAM;
    case r'ABUSE':
      return Enum$ReportedContentClassifiers.ABUSE;
    case r'OFF_TOPIC':
      return Enum$ReportedContentClassifiers.OFF_TOPIC;
    case r'OUTDATED':
      return Enum$ReportedContentClassifiers.OUTDATED;
    case r'DUPLICATE':
      return Enum$ReportedContentClassifiers.DUPLICATE;
    case r'RESOLVED':
      return Enum$ReportedContentClassifiers.RESOLVED;
    default:
      return Enum$ReportedContentClassifiers.$unknown;
  }
}

enum Enum$RepositoryAffiliation {
  OWNER,
  COLLABORATOR,
  ORGANIZATION_MEMBER,
  $unknown;

  factory Enum$RepositoryAffiliation.fromJson(String value) =>
      fromJson$Enum$RepositoryAffiliation(value);

  String toJson() => toJson$Enum$RepositoryAffiliation(this);
}

String toJson$Enum$RepositoryAffiliation(Enum$RepositoryAffiliation e) {
  switch (e) {
    case Enum$RepositoryAffiliation.OWNER:
      return r'OWNER';
    case Enum$RepositoryAffiliation.COLLABORATOR:
      return r'COLLABORATOR';
    case Enum$RepositoryAffiliation.ORGANIZATION_MEMBER:
      return r'ORGANIZATION_MEMBER';
    case Enum$RepositoryAffiliation.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryAffiliation fromJson$Enum$RepositoryAffiliation(String value) {
  switch (value) {
    case r'OWNER':
      return Enum$RepositoryAffiliation.OWNER;
    case r'COLLABORATOR':
      return Enum$RepositoryAffiliation.COLLABORATOR;
    case r'ORGANIZATION_MEMBER':
      return Enum$RepositoryAffiliation.ORGANIZATION_MEMBER;
    default:
      return Enum$RepositoryAffiliation.$unknown;
  }
}

enum Enum$RepositoryContributionType {
  COMMIT,
  ISSUE,
  PULL_REQUEST,
  REPOSITORY,
  PULL_REQUEST_REVIEW,
  $unknown;

  factory Enum$RepositoryContributionType.fromJson(String value) =>
      fromJson$Enum$RepositoryContributionType(value);

  String toJson() => toJson$Enum$RepositoryContributionType(this);
}

String toJson$Enum$RepositoryContributionType(
    Enum$RepositoryContributionType e) {
  switch (e) {
    case Enum$RepositoryContributionType.COMMIT:
      return r'COMMIT';
    case Enum$RepositoryContributionType.ISSUE:
      return r'ISSUE';
    case Enum$RepositoryContributionType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$RepositoryContributionType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$RepositoryContributionType.PULL_REQUEST_REVIEW:
      return r'PULL_REQUEST_REVIEW';
    case Enum$RepositoryContributionType.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryContributionType fromJson$Enum$RepositoryContributionType(
    String value) {
  switch (value) {
    case r'COMMIT':
      return Enum$RepositoryContributionType.COMMIT;
    case r'ISSUE':
      return Enum$RepositoryContributionType.ISSUE;
    case r'PULL_REQUEST':
      return Enum$RepositoryContributionType.PULL_REQUEST;
    case r'REPOSITORY':
      return Enum$RepositoryContributionType.REPOSITORY;
    case r'PULL_REQUEST_REVIEW':
      return Enum$RepositoryContributionType.PULL_REQUEST_REVIEW;
    default:
      return Enum$RepositoryContributionType.$unknown;
  }
}

enum Enum$RepositoryInteractionLimit {
  EXISTING_USERS,
  CONTRIBUTORS_ONLY,
  COLLABORATORS_ONLY,
  NO_LIMIT,
  $unknown;

  factory Enum$RepositoryInteractionLimit.fromJson(String value) =>
      fromJson$Enum$RepositoryInteractionLimit(value);

  String toJson() => toJson$Enum$RepositoryInteractionLimit(this);
}

String toJson$Enum$RepositoryInteractionLimit(
    Enum$RepositoryInteractionLimit e) {
  switch (e) {
    case Enum$RepositoryInteractionLimit.EXISTING_USERS:
      return r'EXISTING_USERS';
    case Enum$RepositoryInteractionLimit.CONTRIBUTORS_ONLY:
      return r'CONTRIBUTORS_ONLY';
    case Enum$RepositoryInteractionLimit.COLLABORATORS_ONLY:
      return r'COLLABORATORS_ONLY';
    case Enum$RepositoryInteractionLimit.NO_LIMIT:
      return r'NO_LIMIT';
    case Enum$RepositoryInteractionLimit.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimit fromJson$Enum$RepositoryInteractionLimit(
    String value) {
  switch (value) {
    case r'EXISTING_USERS':
      return Enum$RepositoryInteractionLimit.EXISTING_USERS;
    case r'CONTRIBUTORS_ONLY':
      return Enum$RepositoryInteractionLimit.CONTRIBUTORS_ONLY;
    case r'COLLABORATORS_ONLY':
      return Enum$RepositoryInteractionLimit.COLLABORATORS_ONLY;
    case r'NO_LIMIT':
      return Enum$RepositoryInteractionLimit.NO_LIMIT;
    default:
      return Enum$RepositoryInteractionLimit.$unknown;
  }
}

enum Enum$RepositoryInteractionLimitExpiry {
  ONE_DAY,
  THREE_DAYS,
  ONE_WEEK,
  ONE_MONTH,
  SIX_MONTHS,
  $unknown;

  factory Enum$RepositoryInteractionLimitExpiry.fromJson(String value) =>
      fromJson$Enum$RepositoryInteractionLimitExpiry(value);

  String toJson() => toJson$Enum$RepositoryInteractionLimitExpiry(this);
}

String toJson$Enum$RepositoryInteractionLimitExpiry(
    Enum$RepositoryInteractionLimitExpiry e) {
  switch (e) {
    case Enum$RepositoryInteractionLimitExpiry.ONE_DAY:
      return r'ONE_DAY';
    case Enum$RepositoryInteractionLimitExpiry.THREE_DAYS:
      return r'THREE_DAYS';
    case Enum$RepositoryInteractionLimitExpiry.ONE_WEEK:
      return r'ONE_WEEK';
    case Enum$RepositoryInteractionLimitExpiry.ONE_MONTH:
      return r'ONE_MONTH';
    case Enum$RepositoryInteractionLimitExpiry.SIX_MONTHS:
      return r'SIX_MONTHS';
    case Enum$RepositoryInteractionLimitExpiry.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimitExpiry
    fromJson$Enum$RepositoryInteractionLimitExpiry(String value) {
  switch (value) {
    case r'ONE_DAY':
      return Enum$RepositoryInteractionLimitExpiry.ONE_DAY;
    case r'THREE_DAYS':
      return Enum$RepositoryInteractionLimitExpiry.THREE_DAYS;
    case r'ONE_WEEK':
      return Enum$RepositoryInteractionLimitExpiry.ONE_WEEK;
    case r'ONE_MONTH':
      return Enum$RepositoryInteractionLimitExpiry.ONE_MONTH;
    case r'SIX_MONTHS':
      return Enum$RepositoryInteractionLimitExpiry.SIX_MONTHS;
    default:
      return Enum$RepositoryInteractionLimitExpiry.$unknown;
  }
}

enum Enum$RepositoryInteractionLimitOrigin {
  REPOSITORY,
  ORGANIZATION,
  USER,
  $unknown;

  factory Enum$RepositoryInteractionLimitOrigin.fromJson(String value) =>
      fromJson$Enum$RepositoryInteractionLimitOrigin(value);

  String toJson() => toJson$Enum$RepositoryInteractionLimitOrigin(this);
}

String toJson$Enum$RepositoryInteractionLimitOrigin(
    Enum$RepositoryInteractionLimitOrigin e) {
  switch (e) {
    case Enum$RepositoryInteractionLimitOrigin.REPOSITORY:
      return r'REPOSITORY';
    case Enum$RepositoryInteractionLimitOrigin.ORGANIZATION:
      return r'ORGANIZATION';
    case Enum$RepositoryInteractionLimitOrigin.USER:
      return r'USER';
    case Enum$RepositoryInteractionLimitOrigin.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimitOrigin
    fromJson$Enum$RepositoryInteractionLimitOrigin(String value) {
  switch (value) {
    case r'REPOSITORY':
      return Enum$RepositoryInteractionLimitOrigin.REPOSITORY;
    case r'ORGANIZATION':
      return Enum$RepositoryInteractionLimitOrigin.ORGANIZATION;
    case r'USER':
      return Enum$RepositoryInteractionLimitOrigin.USER;
    default:
      return Enum$RepositoryInteractionLimitOrigin.$unknown;
  }
}

enum Enum$RepositoryInvitationOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$RepositoryInvitationOrderField.fromJson(String value) =>
      fromJson$Enum$RepositoryInvitationOrderField(value);

  String toJson() => toJson$Enum$RepositoryInvitationOrderField(this);
}

String toJson$Enum$RepositoryInvitationOrderField(
    Enum$RepositoryInvitationOrderField e) {
  switch (e) {
    case Enum$RepositoryInvitationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryInvitationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInvitationOrderField
    fromJson$Enum$RepositoryInvitationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryInvitationOrderField.CREATED_AT;
    default:
      return Enum$RepositoryInvitationOrderField.$unknown;
  }
}

enum Enum$RepositoryLockReason {
  MOVING,
  BILLING,
  RENAME,
  MIGRATING,
  TRADE_RESTRICTION,
  TRANSFERRING_OWNERSHIP,
  $unknown;

  factory Enum$RepositoryLockReason.fromJson(String value) =>
      fromJson$Enum$RepositoryLockReason(value);

  String toJson() => toJson$Enum$RepositoryLockReason(this);
}

String toJson$Enum$RepositoryLockReason(Enum$RepositoryLockReason e) {
  switch (e) {
    case Enum$RepositoryLockReason.MOVING:
      return r'MOVING';
    case Enum$RepositoryLockReason.BILLING:
      return r'BILLING';
    case Enum$RepositoryLockReason.RENAME:
      return r'RENAME';
    case Enum$RepositoryLockReason.MIGRATING:
      return r'MIGRATING';
    case Enum$RepositoryLockReason.TRADE_RESTRICTION:
      return r'TRADE_RESTRICTION';
    case Enum$RepositoryLockReason.TRANSFERRING_OWNERSHIP:
      return r'TRANSFERRING_OWNERSHIP';
    case Enum$RepositoryLockReason.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryLockReason fromJson$Enum$RepositoryLockReason(String value) {
  switch (value) {
    case r'MOVING':
      return Enum$RepositoryLockReason.MOVING;
    case r'BILLING':
      return Enum$RepositoryLockReason.BILLING;
    case r'RENAME':
      return Enum$RepositoryLockReason.RENAME;
    case r'MIGRATING':
      return Enum$RepositoryLockReason.MIGRATING;
    case r'TRADE_RESTRICTION':
      return Enum$RepositoryLockReason.TRADE_RESTRICTION;
    case r'TRANSFERRING_OWNERSHIP':
      return Enum$RepositoryLockReason.TRANSFERRING_OWNERSHIP;
    default:
      return Enum$RepositoryLockReason.$unknown;
  }
}

enum Enum$RepositoryMigrationOrderDirection {
  ASC,
  DESC,
  $unknown;

  factory Enum$RepositoryMigrationOrderDirection.fromJson(String value) =>
      fromJson$Enum$RepositoryMigrationOrderDirection(value);

  String toJson() => toJson$Enum$RepositoryMigrationOrderDirection(this);
}

String toJson$Enum$RepositoryMigrationOrderDirection(
    Enum$RepositoryMigrationOrderDirection e) {
  switch (e) {
    case Enum$RepositoryMigrationOrderDirection.ASC:
      return r'ASC';
    case Enum$RepositoryMigrationOrderDirection.DESC:
      return r'DESC';
    case Enum$RepositoryMigrationOrderDirection.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryMigrationOrderDirection
    fromJson$Enum$RepositoryMigrationOrderDirection(String value) {
  switch (value) {
    case r'ASC':
      return Enum$RepositoryMigrationOrderDirection.ASC;
    case r'DESC':
      return Enum$RepositoryMigrationOrderDirection.DESC;
    default:
      return Enum$RepositoryMigrationOrderDirection.$unknown;
  }
}

enum Enum$RepositoryMigrationOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$RepositoryMigrationOrderField.fromJson(String value) =>
      fromJson$Enum$RepositoryMigrationOrderField(value);

  String toJson() => toJson$Enum$RepositoryMigrationOrderField(this);
}

String toJson$Enum$RepositoryMigrationOrderField(
    Enum$RepositoryMigrationOrderField e) {
  switch (e) {
    case Enum$RepositoryMigrationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryMigrationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryMigrationOrderField fromJson$Enum$RepositoryMigrationOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryMigrationOrderField.CREATED_AT;
    default:
      return Enum$RepositoryMigrationOrderField.$unknown;
  }
}

enum Enum$RepositoryOrderField {
  CREATED_AT,
  UPDATED_AT,
  PUSHED_AT,
  NAME,
  STARGAZERS,
  $unknown;

  factory Enum$RepositoryOrderField.fromJson(String value) =>
      fromJson$Enum$RepositoryOrderField(value);

  String toJson() => toJson$Enum$RepositoryOrderField(this);
}

String toJson$Enum$RepositoryOrderField(Enum$RepositoryOrderField e) {
  switch (e) {
    case Enum$RepositoryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$RepositoryOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$RepositoryOrderField.NAME:
      return r'NAME';
    case Enum$RepositoryOrderField.STARGAZERS:
      return r'STARGAZERS';
    case Enum$RepositoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryOrderField fromJson$Enum$RepositoryOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$RepositoryOrderField.UPDATED_AT;
    case r'PUSHED_AT':
      return Enum$RepositoryOrderField.PUSHED_AT;
    case r'NAME':
      return Enum$RepositoryOrderField.NAME;
    case r'STARGAZERS':
      return Enum$RepositoryOrderField.STARGAZERS;
    default:
      return Enum$RepositoryOrderField.$unknown;
  }
}

enum Enum$RepositoryPermission {
  ADMIN,
  MAINTAIN,
  WRITE,
  TRIAGE,
  READ,
  $unknown;

  factory Enum$RepositoryPermission.fromJson(String value) =>
      fromJson$Enum$RepositoryPermission(value);

  String toJson() => toJson$Enum$RepositoryPermission(this);
}

String toJson$Enum$RepositoryPermission(Enum$RepositoryPermission e) {
  switch (e) {
    case Enum$RepositoryPermission.ADMIN:
      return r'ADMIN';
    case Enum$RepositoryPermission.MAINTAIN:
      return r'MAINTAIN';
    case Enum$RepositoryPermission.WRITE:
      return r'WRITE';
    case Enum$RepositoryPermission.TRIAGE:
      return r'TRIAGE';
    case Enum$RepositoryPermission.READ:
      return r'READ';
    case Enum$RepositoryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryPermission fromJson$Enum$RepositoryPermission(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$RepositoryPermission.ADMIN;
    case r'MAINTAIN':
      return Enum$RepositoryPermission.MAINTAIN;
    case r'WRITE':
      return Enum$RepositoryPermission.WRITE;
    case r'TRIAGE':
      return Enum$RepositoryPermission.TRIAGE;
    case r'READ':
      return Enum$RepositoryPermission.READ;
    default:
      return Enum$RepositoryPermission.$unknown;
  }
}

enum Enum$RepositoryPrivacy {
  PUBLIC,
  PRIVATE,
  $unknown;

  factory Enum$RepositoryPrivacy.fromJson(String value) =>
      fromJson$Enum$RepositoryPrivacy(value);

  String toJson() => toJson$Enum$RepositoryPrivacy(this);
}

String toJson$Enum$RepositoryPrivacy(Enum$RepositoryPrivacy e) {
  switch (e) {
    case Enum$RepositoryPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$RepositoryPrivacy.PRIVATE:
      return r'PRIVATE';
    case Enum$RepositoryPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryPrivacy fromJson$Enum$RepositoryPrivacy(String value) {
  switch (value) {
    case r'PUBLIC':
      return Enum$RepositoryPrivacy.PUBLIC;
    case r'PRIVATE':
      return Enum$RepositoryPrivacy.PRIVATE;
    default:
      return Enum$RepositoryPrivacy.$unknown;
  }
}

enum Enum$RepositoryRuleOrderField {
  UPDATED_AT,
  CREATED_AT,
  TYPE,
  $unknown;

  factory Enum$RepositoryRuleOrderField.fromJson(String value) =>
      fromJson$Enum$RepositoryRuleOrderField(value);

  String toJson() => toJson$Enum$RepositoryRuleOrderField(this);
}

String toJson$Enum$RepositoryRuleOrderField(Enum$RepositoryRuleOrderField e) {
  switch (e) {
    case Enum$RepositoryRuleOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$RepositoryRuleOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryRuleOrderField.TYPE:
      return r'TYPE';
    case Enum$RepositoryRuleOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryRuleOrderField fromJson$Enum$RepositoryRuleOrderField(
    String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$RepositoryRuleOrderField.UPDATED_AT;
    case r'CREATED_AT':
      return Enum$RepositoryRuleOrderField.CREATED_AT;
    case r'TYPE':
      return Enum$RepositoryRuleOrderField.TYPE;
    default:
      return Enum$RepositoryRuleOrderField.$unknown;
  }
}

enum Enum$RepositoryRulesetBypassActorBypassMode {
  ALWAYS,
  PULL_REQUEST,
  EXEMPT,
  $unknown;

  factory Enum$RepositoryRulesetBypassActorBypassMode.fromJson(String value) =>
      fromJson$Enum$RepositoryRulesetBypassActorBypassMode(value);

  String toJson() => toJson$Enum$RepositoryRulesetBypassActorBypassMode(this);
}

String toJson$Enum$RepositoryRulesetBypassActorBypassMode(
    Enum$RepositoryRulesetBypassActorBypassMode e) {
  switch (e) {
    case Enum$RepositoryRulesetBypassActorBypassMode.ALWAYS:
      return r'ALWAYS';
    case Enum$RepositoryRulesetBypassActorBypassMode.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$RepositoryRulesetBypassActorBypassMode.EXEMPT:
      return r'EXEMPT';
    case Enum$RepositoryRulesetBypassActorBypassMode.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryRulesetBypassActorBypassMode
    fromJson$Enum$RepositoryRulesetBypassActorBypassMode(String value) {
  switch (value) {
    case r'ALWAYS':
      return Enum$RepositoryRulesetBypassActorBypassMode.ALWAYS;
    case r'PULL_REQUEST':
      return Enum$RepositoryRulesetBypassActorBypassMode.PULL_REQUEST;
    case r'EXEMPT':
      return Enum$RepositoryRulesetBypassActorBypassMode.EXEMPT;
    default:
      return Enum$RepositoryRulesetBypassActorBypassMode.$unknown;
  }
}

enum Enum$RepositoryRulesetTarget {
  BRANCH,
  TAG,
  PUSH,
  REPOSITORY,
  $unknown;

  factory Enum$RepositoryRulesetTarget.fromJson(String value) =>
      fromJson$Enum$RepositoryRulesetTarget(value);

  String toJson() => toJson$Enum$RepositoryRulesetTarget(this);
}

String toJson$Enum$RepositoryRulesetTarget(Enum$RepositoryRulesetTarget e) {
  switch (e) {
    case Enum$RepositoryRulesetTarget.BRANCH:
      return r'BRANCH';
    case Enum$RepositoryRulesetTarget.TAG:
      return r'TAG';
    case Enum$RepositoryRulesetTarget.PUSH:
      return r'PUSH';
    case Enum$RepositoryRulesetTarget.REPOSITORY:
      return r'REPOSITORY';
    case Enum$RepositoryRulesetTarget.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryRulesetTarget fromJson$Enum$RepositoryRulesetTarget(
    String value) {
  switch (value) {
    case r'BRANCH':
      return Enum$RepositoryRulesetTarget.BRANCH;
    case r'TAG':
      return Enum$RepositoryRulesetTarget.TAG;
    case r'PUSH':
      return Enum$RepositoryRulesetTarget.PUSH;
    case r'REPOSITORY':
      return Enum$RepositoryRulesetTarget.REPOSITORY;
    default:
      return Enum$RepositoryRulesetTarget.$unknown;
  }
}

enum Enum$RepositoryRuleType {
  CREATION,
  UPDATE,
  DELETION,
  REQUIRED_LINEAR_HISTORY,
  MERGE_QUEUE,
  REQUIRED_REVIEW_THREAD_RESOLUTION,
  REQUIRED_DEPLOYMENTS,
  REQUIRED_SIGNATURES,
  PULL_REQUEST,
  REQUIRED_STATUS_CHECKS,
  REQUIRED_WORKFLOW_STATUS_CHECKS,
  NON_FAST_FORWARD,
  AUTHORIZATION,
  TAG,
  MERGE_QUEUE_LOCKED_REF,
  LOCK_BRANCH,
  MAX_REF_UPDATES,
  COMMIT_MESSAGE_PATTERN,
  COMMIT_AUTHOR_EMAIL_PATTERN,
  COMMITTER_EMAIL_PATTERN,
  BRANCH_NAME_PATTERN,
  TAG_NAME_PATTERN,
  FILE_PATH_RESTRICTION,
  MAX_FILE_PATH_LENGTH,
  FILE_EXTENSION_RESTRICTION,
  MAX_FILE_SIZE,
  WORKFLOWS,
  SECRET_SCANNING,
  WORKFLOW_UPDATES,
  CODE_SCANNING,
  COPILOT_CODE_REVIEW,
  $unknown;

  factory Enum$RepositoryRuleType.fromJson(String value) =>
      fromJson$Enum$RepositoryRuleType(value);

  String toJson() => toJson$Enum$RepositoryRuleType(this);
}

String toJson$Enum$RepositoryRuleType(Enum$RepositoryRuleType e) {
  switch (e) {
    case Enum$RepositoryRuleType.CREATION:
      return r'CREATION';
    case Enum$RepositoryRuleType.UPDATE:
      return r'UPDATE';
    case Enum$RepositoryRuleType.DELETION:
      return r'DELETION';
    case Enum$RepositoryRuleType.REQUIRED_LINEAR_HISTORY:
      return r'REQUIRED_LINEAR_HISTORY';
    case Enum$RepositoryRuleType.MERGE_QUEUE:
      return r'MERGE_QUEUE';
    case Enum$RepositoryRuleType.REQUIRED_REVIEW_THREAD_RESOLUTION:
      return r'REQUIRED_REVIEW_THREAD_RESOLUTION';
    case Enum$RepositoryRuleType.REQUIRED_DEPLOYMENTS:
      return r'REQUIRED_DEPLOYMENTS';
    case Enum$RepositoryRuleType.REQUIRED_SIGNATURES:
      return r'REQUIRED_SIGNATURES';
    case Enum$RepositoryRuleType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$RepositoryRuleType.REQUIRED_STATUS_CHECKS:
      return r'REQUIRED_STATUS_CHECKS';
    case Enum$RepositoryRuleType.REQUIRED_WORKFLOW_STATUS_CHECKS:
      return r'REQUIRED_WORKFLOW_STATUS_CHECKS';
    case Enum$RepositoryRuleType.NON_FAST_FORWARD:
      return r'NON_FAST_FORWARD';
    case Enum$RepositoryRuleType.AUTHORIZATION:
      return r'AUTHORIZATION';
    case Enum$RepositoryRuleType.TAG:
      return r'TAG';
    case Enum$RepositoryRuleType.MERGE_QUEUE_LOCKED_REF:
      return r'MERGE_QUEUE_LOCKED_REF';
    case Enum$RepositoryRuleType.LOCK_BRANCH:
      return r'LOCK_BRANCH';
    case Enum$RepositoryRuleType.MAX_REF_UPDATES:
      return r'MAX_REF_UPDATES';
    case Enum$RepositoryRuleType.COMMIT_MESSAGE_PATTERN:
      return r'COMMIT_MESSAGE_PATTERN';
    case Enum$RepositoryRuleType.COMMIT_AUTHOR_EMAIL_PATTERN:
      return r'COMMIT_AUTHOR_EMAIL_PATTERN';
    case Enum$RepositoryRuleType.COMMITTER_EMAIL_PATTERN:
      return r'COMMITTER_EMAIL_PATTERN';
    case Enum$RepositoryRuleType.BRANCH_NAME_PATTERN:
      return r'BRANCH_NAME_PATTERN';
    case Enum$RepositoryRuleType.TAG_NAME_PATTERN:
      return r'TAG_NAME_PATTERN';
    case Enum$RepositoryRuleType.FILE_PATH_RESTRICTION:
      return r'FILE_PATH_RESTRICTION';
    case Enum$RepositoryRuleType.MAX_FILE_PATH_LENGTH:
      return r'MAX_FILE_PATH_LENGTH';
    case Enum$RepositoryRuleType.FILE_EXTENSION_RESTRICTION:
      return r'FILE_EXTENSION_RESTRICTION';
    case Enum$RepositoryRuleType.MAX_FILE_SIZE:
      return r'MAX_FILE_SIZE';
    case Enum$RepositoryRuleType.WORKFLOWS:
      return r'WORKFLOWS';
    case Enum$RepositoryRuleType.SECRET_SCANNING:
      return r'SECRET_SCANNING';
    case Enum$RepositoryRuleType.WORKFLOW_UPDATES:
      return r'WORKFLOW_UPDATES';
    case Enum$RepositoryRuleType.CODE_SCANNING:
      return r'CODE_SCANNING';
    case Enum$RepositoryRuleType.COPILOT_CODE_REVIEW:
      return r'COPILOT_CODE_REVIEW';
    case Enum$RepositoryRuleType.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryRuleType fromJson$Enum$RepositoryRuleType(String value) {
  switch (value) {
    case r'CREATION':
      return Enum$RepositoryRuleType.CREATION;
    case r'UPDATE':
      return Enum$RepositoryRuleType.UPDATE;
    case r'DELETION':
      return Enum$RepositoryRuleType.DELETION;
    case r'REQUIRED_LINEAR_HISTORY':
      return Enum$RepositoryRuleType.REQUIRED_LINEAR_HISTORY;
    case r'MERGE_QUEUE':
      return Enum$RepositoryRuleType.MERGE_QUEUE;
    case r'REQUIRED_REVIEW_THREAD_RESOLUTION':
      return Enum$RepositoryRuleType.REQUIRED_REVIEW_THREAD_RESOLUTION;
    case r'REQUIRED_DEPLOYMENTS':
      return Enum$RepositoryRuleType.REQUIRED_DEPLOYMENTS;
    case r'REQUIRED_SIGNATURES':
      return Enum$RepositoryRuleType.REQUIRED_SIGNATURES;
    case r'PULL_REQUEST':
      return Enum$RepositoryRuleType.PULL_REQUEST;
    case r'REQUIRED_STATUS_CHECKS':
      return Enum$RepositoryRuleType.REQUIRED_STATUS_CHECKS;
    case r'REQUIRED_WORKFLOW_STATUS_CHECKS':
      return Enum$RepositoryRuleType.REQUIRED_WORKFLOW_STATUS_CHECKS;
    case r'NON_FAST_FORWARD':
      return Enum$RepositoryRuleType.NON_FAST_FORWARD;
    case r'AUTHORIZATION':
      return Enum$RepositoryRuleType.AUTHORIZATION;
    case r'TAG':
      return Enum$RepositoryRuleType.TAG;
    case r'MERGE_QUEUE_LOCKED_REF':
      return Enum$RepositoryRuleType.MERGE_QUEUE_LOCKED_REF;
    case r'LOCK_BRANCH':
      return Enum$RepositoryRuleType.LOCK_BRANCH;
    case r'MAX_REF_UPDATES':
      return Enum$RepositoryRuleType.MAX_REF_UPDATES;
    case r'COMMIT_MESSAGE_PATTERN':
      return Enum$RepositoryRuleType.COMMIT_MESSAGE_PATTERN;
    case r'COMMIT_AUTHOR_EMAIL_PATTERN':
      return Enum$RepositoryRuleType.COMMIT_AUTHOR_EMAIL_PATTERN;
    case r'COMMITTER_EMAIL_PATTERN':
      return Enum$RepositoryRuleType.COMMITTER_EMAIL_PATTERN;
    case r'BRANCH_NAME_PATTERN':
      return Enum$RepositoryRuleType.BRANCH_NAME_PATTERN;
    case r'TAG_NAME_PATTERN':
      return Enum$RepositoryRuleType.TAG_NAME_PATTERN;
    case r'FILE_PATH_RESTRICTION':
      return Enum$RepositoryRuleType.FILE_PATH_RESTRICTION;
    case r'MAX_FILE_PATH_LENGTH':
      return Enum$RepositoryRuleType.MAX_FILE_PATH_LENGTH;
    case r'FILE_EXTENSION_RESTRICTION':
      return Enum$RepositoryRuleType.FILE_EXTENSION_RESTRICTION;
    case r'MAX_FILE_SIZE':
      return Enum$RepositoryRuleType.MAX_FILE_SIZE;
    case r'WORKFLOWS':
      return Enum$RepositoryRuleType.WORKFLOWS;
    case r'SECRET_SCANNING':
      return Enum$RepositoryRuleType.SECRET_SCANNING;
    case r'WORKFLOW_UPDATES':
      return Enum$RepositoryRuleType.WORKFLOW_UPDATES;
    case r'CODE_SCANNING':
      return Enum$RepositoryRuleType.CODE_SCANNING;
    case r'COPILOT_CODE_REVIEW':
      return Enum$RepositoryRuleType.COPILOT_CODE_REVIEW;
    default:
      return Enum$RepositoryRuleType.$unknown;
  }
}

enum Enum$RepositorySuggestedActorFilter {
  CAN_BE_ASSIGNED,
  CAN_BE_AUTHOR,
  $unknown;

  factory Enum$RepositorySuggestedActorFilter.fromJson(String value) =>
      fromJson$Enum$RepositorySuggestedActorFilter(value);

  String toJson() => toJson$Enum$RepositorySuggestedActorFilter(this);
}

String toJson$Enum$RepositorySuggestedActorFilter(
    Enum$RepositorySuggestedActorFilter e) {
  switch (e) {
    case Enum$RepositorySuggestedActorFilter.CAN_BE_ASSIGNED:
      return r'CAN_BE_ASSIGNED';
    case Enum$RepositorySuggestedActorFilter.CAN_BE_AUTHOR:
      return r'CAN_BE_AUTHOR';
    case Enum$RepositorySuggestedActorFilter.$unknown:
      return r'$unknown';
  }
}

Enum$RepositorySuggestedActorFilter
    fromJson$Enum$RepositorySuggestedActorFilter(String value) {
  switch (value) {
    case r'CAN_BE_ASSIGNED':
      return Enum$RepositorySuggestedActorFilter.CAN_BE_ASSIGNED;
    case r'CAN_BE_AUTHOR':
      return Enum$RepositorySuggestedActorFilter.CAN_BE_AUTHOR;
    default:
      return Enum$RepositorySuggestedActorFilter.$unknown;
  }
}

enum Enum$RepositoryVisibility {
  PRIVATE,
  PUBLIC,
  INTERNAL,
  $unknown;

  factory Enum$RepositoryVisibility.fromJson(String value) =>
      fromJson$Enum$RepositoryVisibility(value);

  String toJson() => toJson$Enum$RepositoryVisibility(this);
}

String toJson$Enum$RepositoryVisibility(Enum$RepositoryVisibility e) {
  switch (e) {
    case Enum$RepositoryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepositoryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepositoryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepositoryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVisibility fromJson$Enum$RepositoryVisibility(String value) {
  switch (value) {
    case r'PRIVATE':
      return Enum$RepositoryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepositoryVisibility.PUBLIC;
    case r'INTERNAL':
      return Enum$RepositoryVisibility.INTERNAL;
    default:
      return Enum$RepositoryVisibility.$unknown;
  }
}

enum Enum$RepositoryVulnerabilityAlertDependencyRelationship {
  UNKNOWN,
  DIRECT,
  TRANSITIVE,
  $unknown;

  factory Enum$RepositoryVulnerabilityAlertDependencyRelationship.fromJson(
          String value) =>
      fromJson$Enum$RepositoryVulnerabilityAlertDependencyRelationship(value);

  String toJson() =>
      toJson$Enum$RepositoryVulnerabilityAlertDependencyRelationship(this);
}

String toJson$Enum$RepositoryVulnerabilityAlertDependencyRelationship(
    Enum$RepositoryVulnerabilityAlertDependencyRelationship e) {
  switch (e) {
    case Enum$RepositoryVulnerabilityAlertDependencyRelationship.UNKNOWN:
      return r'UNKNOWN';
    case Enum$RepositoryVulnerabilityAlertDependencyRelationship.DIRECT:
      return r'DIRECT';
    case Enum$RepositoryVulnerabilityAlertDependencyRelationship.TRANSITIVE:
      return r'TRANSITIVE';
    case Enum$RepositoryVulnerabilityAlertDependencyRelationship.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVulnerabilityAlertDependencyRelationship
    fromJson$Enum$RepositoryVulnerabilityAlertDependencyRelationship(
        String value) {
  switch (value) {
    case r'UNKNOWN':
      return Enum$RepositoryVulnerabilityAlertDependencyRelationship.UNKNOWN;
    case r'DIRECT':
      return Enum$RepositoryVulnerabilityAlertDependencyRelationship.DIRECT;
    case r'TRANSITIVE':
      return Enum$RepositoryVulnerabilityAlertDependencyRelationship.TRANSITIVE;
    default:
      return Enum$RepositoryVulnerabilityAlertDependencyRelationship.$unknown;
  }
}

enum Enum$RepositoryVulnerabilityAlertDependencyScope {
  RUNTIME,
  DEVELOPMENT,
  $unknown;

  factory Enum$RepositoryVulnerabilityAlertDependencyScope.fromJson(
          String value) =>
      fromJson$Enum$RepositoryVulnerabilityAlertDependencyScope(value);

  String toJson() =>
      toJson$Enum$RepositoryVulnerabilityAlertDependencyScope(this);
}

String toJson$Enum$RepositoryVulnerabilityAlertDependencyScope(
    Enum$RepositoryVulnerabilityAlertDependencyScope e) {
  switch (e) {
    case Enum$RepositoryVulnerabilityAlertDependencyScope.RUNTIME:
      return r'RUNTIME';
    case Enum$RepositoryVulnerabilityAlertDependencyScope.DEVELOPMENT:
      return r'DEVELOPMENT';
    case Enum$RepositoryVulnerabilityAlertDependencyScope.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVulnerabilityAlertDependencyScope
    fromJson$Enum$RepositoryVulnerabilityAlertDependencyScope(String value) {
  switch (value) {
    case r'RUNTIME':
      return Enum$RepositoryVulnerabilityAlertDependencyScope.RUNTIME;
    case r'DEVELOPMENT':
      return Enum$RepositoryVulnerabilityAlertDependencyScope.DEVELOPMENT;
    default:
      return Enum$RepositoryVulnerabilityAlertDependencyScope.$unknown;
  }
}

enum Enum$RepositoryVulnerabilityAlertState {
  OPEN,
  FIXED,
  DISMISSED,
  AUTO_DISMISSED,
  $unknown;

  factory Enum$RepositoryVulnerabilityAlertState.fromJson(String value) =>
      fromJson$Enum$RepositoryVulnerabilityAlertState(value);

  String toJson() => toJson$Enum$RepositoryVulnerabilityAlertState(this);
}

String toJson$Enum$RepositoryVulnerabilityAlertState(
    Enum$RepositoryVulnerabilityAlertState e) {
  switch (e) {
    case Enum$RepositoryVulnerabilityAlertState.OPEN:
      return r'OPEN';
    case Enum$RepositoryVulnerabilityAlertState.FIXED:
      return r'FIXED';
    case Enum$RepositoryVulnerabilityAlertState.DISMISSED:
      return r'DISMISSED';
    case Enum$RepositoryVulnerabilityAlertState.AUTO_DISMISSED:
      return r'AUTO_DISMISSED';
    case Enum$RepositoryVulnerabilityAlertState.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVulnerabilityAlertState
    fromJson$Enum$RepositoryVulnerabilityAlertState(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$RepositoryVulnerabilityAlertState.OPEN;
    case r'FIXED':
      return Enum$RepositoryVulnerabilityAlertState.FIXED;
    case r'DISMISSED':
      return Enum$RepositoryVulnerabilityAlertState.DISMISSED;
    case r'AUTO_DISMISSED':
      return Enum$RepositoryVulnerabilityAlertState.AUTO_DISMISSED;
    default:
      return Enum$RepositoryVulnerabilityAlertState.$unknown;
  }
}

enum Enum$RequestableCheckStatusState {
  QUEUED,
  IN_PROGRESS,
  COMPLETED,
  WAITING,
  PENDING,
  $unknown;

  factory Enum$RequestableCheckStatusState.fromJson(String value) =>
      fromJson$Enum$RequestableCheckStatusState(value);

  String toJson() => toJson$Enum$RequestableCheckStatusState(this);
}

String toJson$Enum$RequestableCheckStatusState(
    Enum$RequestableCheckStatusState e) {
  switch (e) {
    case Enum$RequestableCheckStatusState.QUEUED:
      return r'QUEUED';
    case Enum$RequestableCheckStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$RequestableCheckStatusState.COMPLETED:
      return r'COMPLETED';
    case Enum$RequestableCheckStatusState.WAITING:
      return r'WAITING';
    case Enum$RequestableCheckStatusState.PENDING:
      return r'PENDING';
    case Enum$RequestableCheckStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$RequestableCheckStatusState fromJson$Enum$RequestableCheckStatusState(
    String value) {
  switch (value) {
    case r'QUEUED':
      return Enum$RequestableCheckStatusState.QUEUED;
    case r'IN_PROGRESS':
      return Enum$RequestableCheckStatusState.IN_PROGRESS;
    case r'COMPLETED':
      return Enum$RequestableCheckStatusState.COMPLETED;
    case r'WAITING':
      return Enum$RequestableCheckStatusState.WAITING;
    case r'PENDING':
      return Enum$RequestableCheckStatusState.PENDING;
    default:
      return Enum$RequestableCheckStatusState.$unknown;
  }
}

enum Enum$RoleInOrganization {
  OWNER,
  DIRECT_MEMBER,
  UNAFFILIATED,
  $unknown;

  factory Enum$RoleInOrganization.fromJson(String value) =>
      fromJson$Enum$RoleInOrganization(value);

  String toJson() => toJson$Enum$RoleInOrganization(this);
}

String toJson$Enum$RoleInOrganization(Enum$RoleInOrganization e) {
  switch (e) {
    case Enum$RoleInOrganization.OWNER:
      return r'OWNER';
    case Enum$RoleInOrganization.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$RoleInOrganization.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$RoleInOrganization.$unknown:
      return r'$unknown';
  }
}

Enum$RoleInOrganization fromJson$Enum$RoleInOrganization(String value) {
  switch (value) {
    case r'OWNER':
      return Enum$RoleInOrganization.OWNER;
    case r'DIRECT_MEMBER':
      return Enum$RoleInOrganization.DIRECT_MEMBER;
    case r'UNAFFILIATED':
      return Enum$RoleInOrganization.UNAFFILIATED;
    default:
      return Enum$RoleInOrganization.$unknown;
  }
}

enum Enum$RuleEnforcement {
  DISABLED,
  ACTIVE,
  EVALUATE,
  $unknown;

  factory Enum$RuleEnforcement.fromJson(String value) =>
      fromJson$Enum$RuleEnforcement(value);

  String toJson() => toJson$Enum$RuleEnforcement(this);
}

String toJson$Enum$RuleEnforcement(Enum$RuleEnforcement e) {
  switch (e) {
    case Enum$RuleEnforcement.DISABLED:
      return r'DISABLED';
    case Enum$RuleEnforcement.ACTIVE:
      return r'ACTIVE';
    case Enum$RuleEnforcement.EVALUATE:
      return r'EVALUATE';
    case Enum$RuleEnforcement.$unknown:
      return r'$unknown';
  }
}

Enum$RuleEnforcement fromJson$Enum$RuleEnforcement(String value) {
  switch (value) {
    case r'DISABLED':
      return Enum$RuleEnforcement.DISABLED;
    case r'ACTIVE':
      return Enum$RuleEnforcement.ACTIVE;
    case r'EVALUATE':
      return Enum$RuleEnforcement.EVALUATE;
    default:
      return Enum$RuleEnforcement.$unknown;
  }
}

enum Enum$SamlDigestAlgorithm {
  SHA1,
  SHA256,
  SHA384,
  SHA512,
  $unknown;

  factory Enum$SamlDigestAlgorithm.fromJson(String value) =>
      fromJson$Enum$SamlDigestAlgorithm(value);

  String toJson() => toJson$Enum$SamlDigestAlgorithm(this);
}

String toJson$Enum$SamlDigestAlgorithm(Enum$SamlDigestAlgorithm e) {
  switch (e) {
    case Enum$SamlDigestAlgorithm.SHA1:
      return r'SHA1';
    case Enum$SamlDigestAlgorithm.SHA256:
      return r'SHA256';
    case Enum$SamlDigestAlgorithm.SHA384:
      return r'SHA384';
    case Enum$SamlDigestAlgorithm.SHA512:
      return r'SHA512';
    case Enum$SamlDigestAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$SamlDigestAlgorithm fromJson$Enum$SamlDigestAlgorithm(String value) {
  switch (value) {
    case r'SHA1':
      return Enum$SamlDigestAlgorithm.SHA1;
    case r'SHA256':
      return Enum$SamlDigestAlgorithm.SHA256;
    case r'SHA384':
      return Enum$SamlDigestAlgorithm.SHA384;
    case r'SHA512':
      return Enum$SamlDigestAlgorithm.SHA512;
    default:
      return Enum$SamlDigestAlgorithm.$unknown;
  }
}

enum Enum$SamlSignatureAlgorithm {
  RSA_SHA1,
  RSA_SHA256,
  RSA_SHA384,
  RSA_SHA512,
  $unknown;

  factory Enum$SamlSignatureAlgorithm.fromJson(String value) =>
      fromJson$Enum$SamlSignatureAlgorithm(value);

  String toJson() => toJson$Enum$SamlSignatureAlgorithm(this);
}

String toJson$Enum$SamlSignatureAlgorithm(Enum$SamlSignatureAlgorithm e) {
  switch (e) {
    case Enum$SamlSignatureAlgorithm.RSA_SHA1:
      return r'RSA_SHA1';
    case Enum$SamlSignatureAlgorithm.RSA_SHA256:
      return r'RSA_SHA256';
    case Enum$SamlSignatureAlgorithm.RSA_SHA384:
      return r'RSA_SHA384';
    case Enum$SamlSignatureAlgorithm.RSA_SHA512:
      return r'RSA_SHA512';
    case Enum$SamlSignatureAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$SamlSignatureAlgorithm fromJson$Enum$SamlSignatureAlgorithm(String value) {
  switch (value) {
    case r'RSA_SHA1':
      return Enum$SamlSignatureAlgorithm.RSA_SHA1;
    case r'RSA_SHA256':
      return Enum$SamlSignatureAlgorithm.RSA_SHA256;
    case r'RSA_SHA384':
      return Enum$SamlSignatureAlgorithm.RSA_SHA384;
    case r'RSA_SHA512':
      return Enum$SamlSignatureAlgorithm.RSA_SHA512;
    default:
      return Enum$SamlSignatureAlgorithm.$unknown;
  }
}

enum Enum$SavedReplyOrderField {
  UPDATED_AT,
  $unknown;

  factory Enum$SavedReplyOrderField.fromJson(String value) =>
      fromJson$Enum$SavedReplyOrderField(value);

  String toJson() => toJson$Enum$SavedReplyOrderField(this);
}

String toJson$Enum$SavedReplyOrderField(Enum$SavedReplyOrderField e) {
  switch (e) {
    case Enum$SavedReplyOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SavedReplyOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SavedReplyOrderField fromJson$Enum$SavedReplyOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$SavedReplyOrderField.UPDATED_AT;
    default:
      return Enum$SavedReplyOrderField.$unknown;
  }
}

enum Enum$SearchType {
  ISSUE,
  @Deprecated(
      'Search for issues and pull requests will be overridden by advanced search on November 4, 2025. You can read more about this change on https://github.blog/changelog/2025-03-06-github-issues-projects-api-support-for-issues-advanced-search-and-more/. Removal on 2025-11-04 UTC.')
  ISSUE_ADVANCED,
  REPOSITORY,
  USER,
  DISCUSSION,
  $unknown;

  factory Enum$SearchType.fromJson(String value) =>
      fromJson$Enum$SearchType(value);

  String toJson() => toJson$Enum$SearchType(this);
}

String toJson$Enum$SearchType(Enum$SearchType e) {
  switch (e) {
    case Enum$SearchType.ISSUE:
      return r'ISSUE';
    case Enum$SearchType.ISSUE_ADVANCED:
      return r'ISSUE_ADVANCED';
    case Enum$SearchType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$SearchType.USER:
      return r'USER';
    case Enum$SearchType.DISCUSSION:
      return r'DISCUSSION';
    case Enum$SearchType.$unknown:
      return r'$unknown';
  }
}

Enum$SearchType fromJson$Enum$SearchType(String value) {
  switch (value) {
    case r'ISSUE':
      return Enum$SearchType.ISSUE;
    case r'ISSUE_ADVANCED':
      return Enum$SearchType.ISSUE_ADVANCED;
    case r'REPOSITORY':
      return Enum$SearchType.REPOSITORY;
    case r'USER':
      return Enum$SearchType.USER;
    case r'DISCUSSION':
      return Enum$SearchType.DISCUSSION;
    default:
      return Enum$SearchType.$unknown;
  }
}

enum Enum$SecurityAdvisoryClassification {
  GENERAL,
  MALWARE,
  $unknown;

  factory Enum$SecurityAdvisoryClassification.fromJson(String value) =>
      fromJson$Enum$SecurityAdvisoryClassification(value);

  String toJson() => toJson$Enum$SecurityAdvisoryClassification(this);
}

String toJson$Enum$SecurityAdvisoryClassification(
    Enum$SecurityAdvisoryClassification e) {
  switch (e) {
    case Enum$SecurityAdvisoryClassification.GENERAL:
      return r'GENERAL';
    case Enum$SecurityAdvisoryClassification.MALWARE:
      return r'MALWARE';
    case Enum$SecurityAdvisoryClassification.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryClassification
    fromJson$Enum$SecurityAdvisoryClassification(String value) {
  switch (value) {
    case r'GENERAL':
      return Enum$SecurityAdvisoryClassification.GENERAL;
    case r'MALWARE':
      return Enum$SecurityAdvisoryClassification.MALWARE;
    default:
      return Enum$SecurityAdvisoryClassification.$unknown;
  }
}

enum Enum$SecurityAdvisoryEcosystem {
  COMPOSER,
  ERLANG,
  ACTIONS,
  GO,
  MAVEN,
  NPM,
  NUGET,
  PIP,
  PUB,
  RUBYGEMS,
  RUST,
  SWIFT,
  $unknown;

  factory Enum$SecurityAdvisoryEcosystem.fromJson(String value) =>
      fromJson$Enum$SecurityAdvisoryEcosystem(value);

  String toJson() => toJson$Enum$SecurityAdvisoryEcosystem(this);
}

String toJson$Enum$SecurityAdvisoryEcosystem(Enum$SecurityAdvisoryEcosystem e) {
  switch (e) {
    case Enum$SecurityAdvisoryEcosystem.COMPOSER:
      return r'COMPOSER';
    case Enum$SecurityAdvisoryEcosystem.ERLANG:
      return r'ERLANG';
    case Enum$SecurityAdvisoryEcosystem.ACTIONS:
      return r'ACTIONS';
    case Enum$SecurityAdvisoryEcosystem.GO:
      return r'GO';
    case Enum$SecurityAdvisoryEcosystem.MAVEN:
      return r'MAVEN';
    case Enum$SecurityAdvisoryEcosystem.NPM:
      return r'NPM';
    case Enum$SecurityAdvisoryEcosystem.NUGET:
      return r'NUGET';
    case Enum$SecurityAdvisoryEcosystem.PIP:
      return r'PIP';
    case Enum$SecurityAdvisoryEcosystem.PUB:
      return r'PUB';
    case Enum$SecurityAdvisoryEcosystem.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$SecurityAdvisoryEcosystem.RUST:
      return r'RUST';
    case Enum$SecurityAdvisoryEcosystem.SWIFT:
      return r'SWIFT';
    case Enum$SecurityAdvisoryEcosystem.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryEcosystem fromJson$Enum$SecurityAdvisoryEcosystem(
    String value) {
  switch (value) {
    case r'COMPOSER':
      return Enum$SecurityAdvisoryEcosystem.COMPOSER;
    case r'ERLANG':
      return Enum$SecurityAdvisoryEcosystem.ERLANG;
    case r'ACTIONS':
      return Enum$SecurityAdvisoryEcosystem.ACTIONS;
    case r'GO':
      return Enum$SecurityAdvisoryEcosystem.GO;
    case r'MAVEN':
      return Enum$SecurityAdvisoryEcosystem.MAVEN;
    case r'NPM':
      return Enum$SecurityAdvisoryEcosystem.NPM;
    case r'NUGET':
      return Enum$SecurityAdvisoryEcosystem.NUGET;
    case r'PIP':
      return Enum$SecurityAdvisoryEcosystem.PIP;
    case r'PUB':
      return Enum$SecurityAdvisoryEcosystem.PUB;
    case r'RUBYGEMS':
      return Enum$SecurityAdvisoryEcosystem.RUBYGEMS;
    case r'RUST':
      return Enum$SecurityAdvisoryEcosystem.RUST;
    case r'SWIFT':
      return Enum$SecurityAdvisoryEcosystem.SWIFT;
    default:
      return Enum$SecurityAdvisoryEcosystem.$unknown;
  }
}

enum Enum$SecurityAdvisoryIdentifierType {
  CVE,
  GHSA,
  $unknown;

  factory Enum$SecurityAdvisoryIdentifierType.fromJson(String value) =>
      fromJson$Enum$SecurityAdvisoryIdentifierType(value);

  String toJson() => toJson$Enum$SecurityAdvisoryIdentifierType(this);
}

String toJson$Enum$SecurityAdvisoryIdentifierType(
    Enum$SecurityAdvisoryIdentifierType e) {
  switch (e) {
    case Enum$SecurityAdvisoryIdentifierType.CVE:
      return r'CVE';
    case Enum$SecurityAdvisoryIdentifierType.GHSA:
      return r'GHSA';
    case Enum$SecurityAdvisoryIdentifierType.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryIdentifierType
    fromJson$Enum$SecurityAdvisoryIdentifierType(String value) {
  switch (value) {
    case r'CVE':
      return Enum$SecurityAdvisoryIdentifierType.CVE;
    case r'GHSA':
      return Enum$SecurityAdvisoryIdentifierType.GHSA;
    default:
      return Enum$SecurityAdvisoryIdentifierType.$unknown;
  }
}

enum Enum$SecurityAdvisoryOrderField {
  PUBLISHED_AT,
  UPDATED_AT,
  EPSS_PERCENTAGE,
  EPSS_PERCENTILE,
  $unknown;

  factory Enum$SecurityAdvisoryOrderField.fromJson(String value) =>
      fromJson$Enum$SecurityAdvisoryOrderField(value);

  String toJson() => toJson$Enum$SecurityAdvisoryOrderField(this);
}

String toJson$Enum$SecurityAdvisoryOrderField(
    Enum$SecurityAdvisoryOrderField e) {
  switch (e) {
    case Enum$SecurityAdvisoryOrderField.PUBLISHED_AT:
      return r'PUBLISHED_AT';
    case Enum$SecurityAdvisoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SecurityAdvisoryOrderField.EPSS_PERCENTAGE:
      return r'EPSS_PERCENTAGE';
    case Enum$SecurityAdvisoryOrderField.EPSS_PERCENTILE:
      return r'EPSS_PERCENTILE';
    case Enum$SecurityAdvisoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryOrderField fromJson$Enum$SecurityAdvisoryOrderField(
    String value) {
  switch (value) {
    case r'PUBLISHED_AT':
      return Enum$SecurityAdvisoryOrderField.PUBLISHED_AT;
    case r'UPDATED_AT':
      return Enum$SecurityAdvisoryOrderField.UPDATED_AT;
    case r'EPSS_PERCENTAGE':
      return Enum$SecurityAdvisoryOrderField.EPSS_PERCENTAGE;
    case r'EPSS_PERCENTILE':
      return Enum$SecurityAdvisoryOrderField.EPSS_PERCENTILE;
    default:
      return Enum$SecurityAdvisoryOrderField.$unknown;
  }
}

enum Enum$SecurityAdvisorySeverity {
  LOW,
  MODERATE,
  HIGH,
  CRITICAL,
  $unknown;

  factory Enum$SecurityAdvisorySeverity.fromJson(String value) =>
      fromJson$Enum$SecurityAdvisorySeverity(value);

  String toJson() => toJson$Enum$SecurityAdvisorySeverity(this);
}

String toJson$Enum$SecurityAdvisorySeverity(Enum$SecurityAdvisorySeverity e) {
  switch (e) {
    case Enum$SecurityAdvisorySeverity.LOW:
      return r'LOW';
    case Enum$SecurityAdvisorySeverity.MODERATE:
      return r'MODERATE';
    case Enum$SecurityAdvisorySeverity.HIGH:
      return r'HIGH';
    case Enum$SecurityAdvisorySeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$SecurityAdvisorySeverity.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisorySeverity fromJson$Enum$SecurityAdvisorySeverity(
    String value) {
  switch (value) {
    case r'LOW':
      return Enum$SecurityAdvisorySeverity.LOW;
    case r'MODERATE':
      return Enum$SecurityAdvisorySeverity.MODERATE;
    case r'HIGH':
      return Enum$SecurityAdvisorySeverity.HIGH;
    case r'CRITICAL':
      return Enum$SecurityAdvisorySeverity.CRITICAL;
    default:
      return Enum$SecurityAdvisorySeverity.$unknown;
  }
}

enum Enum$SecurityVulnerabilityOrderField {
  UPDATED_AT,
  $unknown;

  factory Enum$SecurityVulnerabilityOrderField.fromJson(String value) =>
      fromJson$Enum$SecurityVulnerabilityOrderField(value);

  String toJson() => toJson$Enum$SecurityVulnerabilityOrderField(this);
}

String toJson$Enum$SecurityVulnerabilityOrderField(
    Enum$SecurityVulnerabilityOrderField e) {
  switch (e) {
    case Enum$SecurityVulnerabilityOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SecurityVulnerabilityOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityVulnerabilityOrderField
    fromJson$Enum$SecurityVulnerabilityOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$SecurityVulnerabilityOrderField.UPDATED_AT;
    default:
      return Enum$SecurityVulnerabilityOrderField.$unknown;
  }
}

enum Enum$SocialAccountProvider {
  GENERIC,
  FACEBOOK,
  HOMETOWN,
  INSTAGRAM,
  LINKEDIN,
  MASTODON,
  REDDIT,
  TWITCH,
  TWITTER,
  YOUTUBE,
  BLUESKY,
  NPM,
  $unknown;

  factory Enum$SocialAccountProvider.fromJson(String value) =>
      fromJson$Enum$SocialAccountProvider(value);

  String toJson() => toJson$Enum$SocialAccountProvider(this);
}

String toJson$Enum$SocialAccountProvider(Enum$SocialAccountProvider e) {
  switch (e) {
    case Enum$SocialAccountProvider.GENERIC:
      return r'GENERIC';
    case Enum$SocialAccountProvider.FACEBOOK:
      return r'FACEBOOK';
    case Enum$SocialAccountProvider.HOMETOWN:
      return r'HOMETOWN';
    case Enum$SocialAccountProvider.INSTAGRAM:
      return r'INSTAGRAM';
    case Enum$SocialAccountProvider.LINKEDIN:
      return r'LINKEDIN';
    case Enum$SocialAccountProvider.MASTODON:
      return r'MASTODON';
    case Enum$SocialAccountProvider.REDDIT:
      return r'REDDIT';
    case Enum$SocialAccountProvider.TWITCH:
      return r'TWITCH';
    case Enum$SocialAccountProvider.TWITTER:
      return r'TWITTER';
    case Enum$SocialAccountProvider.YOUTUBE:
      return r'YOUTUBE';
    case Enum$SocialAccountProvider.BLUESKY:
      return r'BLUESKY';
    case Enum$SocialAccountProvider.NPM:
      return r'NPM';
    case Enum$SocialAccountProvider.$unknown:
      return r'$unknown';
  }
}

Enum$SocialAccountProvider fromJson$Enum$SocialAccountProvider(String value) {
  switch (value) {
    case r'GENERIC':
      return Enum$SocialAccountProvider.GENERIC;
    case r'FACEBOOK':
      return Enum$SocialAccountProvider.FACEBOOK;
    case r'HOMETOWN':
      return Enum$SocialAccountProvider.HOMETOWN;
    case r'INSTAGRAM':
      return Enum$SocialAccountProvider.INSTAGRAM;
    case r'LINKEDIN':
      return Enum$SocialAccountProvider.LINKEDIN;
    case r'MASTODON':
      return Enum$SocialAccountProvider.MASTODON;
    case r'REDDIT':
      return Enum$SocialAccountProvider.REDDIT;
    case r'TWITCH':
      return Enum$SocialAccountProvider.TWITCH;
    case r'TWITTER':
      return Enum$SocialAccountProvider.TWITTER;
    case r'YOUTUBE':
      return Enum$SocialAccountProvider.YOUTUBE;
    case r'BLUESKY':
      return Enum$SocialAccountProvider.BLUESKY;
    case r'NPM':
      return Enum$SocialAccountProvider.NPM;
    default:
      return Enum$SocialAccountProvider.$unknown;
  }
}

enum Enum$SponsorableOrderField {
  LOGIN,
  $unknown;

  factory Enum$SponsorableOrderField.fromJson(String value) =>
      fromJson$Enum$SponsorableOrderField(value);

  String toJson() => toJson$Enum$SponsorableOrderField(this);
}

String toJson$Enum$SponsorableOrderField(Enum$SponsorableOrderField e) {
  switch (e) {
    case Enum$SponsorableOrderField.LOGIN:
      return r'LOGIN';
    case Enum$SponsorableOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorableOrderField fromJson$Enum$SponsorableOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$SponsorableOrderField.LOGIN;
    default:
      return Enum$SponsorableOrderField.$unknown;
  }
}

enum Enum$SponsorAndLifetimeValueOrderField {
  SPONSOR_LOGIN,
  SPONSOR_RELEVANCE,
  LIFETIME_VALUE,
  $unknown;

  factory Enum$SponsorAndLifetimeValueOrderField.fromJson(String value) =>
      fromJson$Enum$SponsorAndLifetimeValueOrderField(value);

  String toJson() => toJson$Enum$SponsorAndLifetimeValueOrderField(this);
}

String toJson$Enum$SponsorAndLifetimeValueOrderField(
    Enum$SponsorAndLifetimeValueOrderField e) {
  switch (e) {
    case Enum$SponsorAndLifetimeValueOrderField.SPONSOR_LOGIN:
      return r'SPONSOR_LOGIN';
    case Enum$SponsorAndLifetimeValueOrderField.SPONSOR_RELEVANCE:
      return r'SPONSOR_RELEVANCE';
    case Enum$SponsorAndLifetimeValueOrderField.LIFETIME_VALUE:
      return r'LIFETIME_VALUE';
    case Enum$SponsorAndLifetimeValueOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorAndLifetimeValueOrderField
    fromJson$Enum$SponsorAndLifetimeValueOrderField(String value) {
  switch (value) {
    case r'SPONSOR_LOGIN':
      return Enum$SponsorAndLifetimeValueOrderField.SPONSOR_LOGIN;
    case r'SPONSOR_RELEVANCE':
      return Enum$SponsorAndLifetimeValueOrderField.SPONSOR_RELEVANCE;
    case r'LIFETIME_VALUE':
      return Enum$SponsorAndLifetimeValueOrderField.LIFETIME_VALUE;
    default:
      return Enum$SponsorAndLifetimeValueOrderField.$unknown;
  }
}

enum Enum$SponsorOrderField {
  LOGIN,
  RELEVANCE,
  $unknown;

  factory Enum$SponsorOrderField.fromJson(String value) =>
      fromJson$Enum$SponsorOrderField(value);

  String toJson() => toJson$Enum$SponsorOrderField(this);
}

String toJson$Enum$SponsorOrderField(Enum$SponsorOrderField e) {
  switch (e) {
    case Enum$SponsorOrderField.LOGIN:
      return r'LOGIN';
    case Enum$SponsorOrderField.RELEVANCE:
      return r'RELEVANCE';
    case Enum$SponsorOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorOrderField fromJson$Enum$SponsorOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$SponsorOrderField.LOGIN;
    case r'RELEVANCE':
      return Enum$SponsorOrderField.RELEVANCE;
    default:
      return Enum$SponsorOrderField.$unknown;
  }
}

enum Enum$SponsorsActivityAction {
  NEW_SPONSORSHIP,
  CANCELLED_SPONSORSHIP,
  TIER_CHANGE,
  REFUND,
  PENDING_CHANGE,
  SPONSOR_MATCH_DISABLED,
  $unknown;

  factory Enum$SponsorsActivityAction.fromJson(String value) =>
      fromJson$Enum$SponsorsActivityAction(value);

  String toJson() => toJson$Enum$SponsorsActivityAction(this);
}

String toJson$Enum$SponsorsActivityAction(Enum$SponsorsActivityAction e) {
  switch (e) {
    case Enum$SponsorsActivityAction.NEW_SPONSORSHIP:
      return r'NEW_SPONSORSHIP';
    case Enum$SponsorsActivityAction.CANCELLED_SPONSORSHIP:
      return r'CANCELLED_SPONSORSHIP';
    case Enum$SponsorsActivityAction.TIER_CHANGE:
      return r'TIER_CHANGE';
    case Enum$SponsorsActivityAction.REFUND:
      return r'REFUND';
    case Enum$SponsorsActivityAction.PENDING_CHANGE:
      return r'PENDING_CHANGE';
    case Enum$SponsorsActivityAction.SPONSOR_MATCH_DISABLED:
      return r'SPONSOR_MATCH_DISABLED';
    case Enum$SponsorsActivityAction.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityAction fromJson$Enum$SponsorsActivityAction(String value) {
  switch (value) {
    case r'NEW_SPONSORSHIP':
      return Enum$SponsorsActivityAction.NEW_SPONSORSHIP;
    case r'CANCELLED_SPONSORSHIP':
      return Enum$SponsorsActivityAction.CANCELLED_SPONSORSHIP;
    case r'TIER_CHANGE':
      return Enum$SponsorsActivityAction.TIER_CHANGE;
    case r'REFUND':
      return Enum$SponsorsActivityAction.REFUND;
    case r'PENDING_CHANGE':
      return Enum$SponsorsActivityAction.PENDING_CHANGE;
    case r'SPONSOR_MATCH_DISABLED':
      return Enum$SponsorsActivityAction.SPONSOR_MATCH_DISABLED;
    default:
      return Enum$SponsorsActivityAction.$unknown;
  }
}

enum Enum$SponsorsActivityOrderField {
  TIMESTAMP,
  $unknown;

  factory Enum$SponsorsActivityOrderField.fromJson(String value) =>
      fromJson$Enum$SponsorsActivityOrderField(value);

  String toJson() => toJson$Enum$SponsorsActivityOrderField(this);
}

String toJson$Enum$SponsorsActivityOrderField(
    Enum$SponsorsActivityOrderField e) {
  switch (e) {
    case Enum$SponsorsActivityOrderField.TIMESTAMP:
      return r'TIMESTAMP';
    case Enum$SponsorsActivityOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityOrderField fromJson$Enum$SponsorsActivityOrderField(
    String value) {
  switch (value) {
    case r'TIMESTAMP':
      return Enum$SponsorsActivityOrderField.TIMESTAMP;
    default:
      return Enum$SponsorsActivityOrderField.$unknown;
  }
}

enum Enum$SponsorsActivityPeriod {
  DAY,
  WEEK,
  MONTH,
  ALL,
  $unknown;

  factory Enum$SponsorsActivityPeriod.fromJson(String value) =>
      fromJson$Enum$SponsorsActivityPeriod(value);

  String toJson() => toJson$Enum$SponsorsActivityPeriod(this);
}

String toJson$Enum$SponsorsActivityPeriod(Enum$SponsorsActivityPeriod e) {
  switch (e) {
    case Enum$SponsorsActivityPeriod.DAY:
      return r'DAY';
    case Enum$SponsorsActivityPeriod.WEEK:
      return r'WEEK';
    case Enum$SponsorsActivityPeriod.MONTH:
      return r'MONTH';
    case Enum$SponsorsActivityPeriod.ALL:
      return r'ALL';
    case Enum$SponsorsActivityPeriod.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityPeriod fromJson$Enum$SponsorsActivityPeriod(String value) {
  switch (value) {
    case r'DAY':
      return Enum$SponsorsActivityPeriod.DAY;
    case r'WEEK':
      return Enum$SponsorsActivityPeriod.WEEK;
    case r'MONTH':
      return Enum$SponsorsActivityPeriod.MONTH;
    case r'ALL':
      return Enum$SponsorsActivityPeriod.ALL;
    default:
      return Enum$SponsorsActivityPeriod.$unknown;
  }
}

enum Enum$SponsorsCountryOrRegionCode {
  AF,
  AX,
  AL,
  DZ,
  AS,
  AD,
  AO,
  AI,
  AQ,
  AG,
  AR,
  AM,
  AW,
  AU,
  AT,
  AZ,
  BS,
  BH,
  BD,
  BB,
  BY,
  BE,
  BZ,
  BJ,
  BM,
  BT,
  BO,
  BQ,
  BA,
  BW,
  BV,
  BR,
  IO,
  BN,
  BG,
  BF,
  BI,
  KH,
  CM,
  CA,
  CV,
  KY,
  CF,
  TD,
  CL,
  CN,
  CX,
  CC,
  CO,
  KM,
  CG,
  CD,
  CK,
  CR,
  CI,
  HR,
  CW,
  CY,
  CZ,
  DK,
  DJ,
  DM,
  DO,
  EC,
  EG,
  SV,
  GQ,
  ER,
  EE,
  ET,
  FK,
  FO,
  FJ,
  FI,
  FR,
  GF,
  PF,
  TF,
  GA,
  GM,
  GE,
  DE,
  GH,
  GI,
  GR,
  GL,
  GD,
  GP,
  GU,
  GT,
  GG,
  GN,
  GW,
  GY,
  HT,
  HM,
  HN,
  HK,
  HU,
  IS,
  IN,
  ID,
  IR,
  IQ,
  IE,
  IM,
  IL,
  IT,
  JM,
  JP,
  JE,
  JO,
  KZ,
  KE,
  KI,
  KR,
  KW,
  KG,
  LA,
  LV,
  LB,
  LS,
  LR,
  LY,
  LI,
  LT,
  LU,
  MO,
  MK,
  MG,
  MW,
  MY,
  MV,
  ML,
  MT,
  MH,
  MQ,
  MR,
  MU,
  YT,
  MX,
  FM,
  MD,
  MC,
  MN,
  ME,
  MS,
  MA,
  MZ,
  MM,
  NA,
  NR,
  NP,
  NL,
  NC,
  NZ,
  NI,
  NE,
  NG,
  NU,
  NF,
  MP,
  NO,
  OM,
  PK,
  PW,
  PS,
  PA,
  PG,
  PY,
  PE,
  PH,
  PN,
  PL,
  PT,
  PR,
  QA,
  RE,
  RO,
  RU,
  RW,
  BL,
  SH,
  KN,
  LC,
  MF,
  PM,
  VC,
  WS,
  SM,
  ST,
  SA,
  SN,
  RS,
  SC,
  SL,
  SG,
  SX,
  SK,
  SI,
  SB,
  SO,
  ZA,
  GS,
  SS,
  ES,
  LK,
  SD,
  SR,
  SJ,
  SZ,
  SE,
  CH,
  SY,
  TW,
  TJ,
  TZ,
  TH,
  TL,
  TG,
  TK,
  TO,
  TT,
  TN,
  TR,
  TM,
  TC,
  TV,
  UG,
  UA,
  AE,
  GB,
  UM,
  US,
  UY,
  UZ,
  VU,
  VA,
  VE,
  VN,
  VG,
  VI,
  WF,
  EH,
  YE,
  ZM,
  ZW,
  $unknown;

  factory Enum$SponsorsCountryOrRegionCode.fromJson(String value) =>
      fromJson$Enum$SponsorsCountryOrRegionCode(value);

  String toJson() => toJson$Enum$SponsorsCountryOrRegionCode(this);
}

String toJson$Enum$SponsorsCountryOrRegionCode(
    Enum$SponsorsCountryOrRegionCode e) {
  switch (e) {
    case Enum$SponsorsCountryOrRegionCode.AF:
      return r'AF';
    case Enum$SponsorsCountryOrRegionCode.AX:
      return r'AX';
    case Enum$SponsorsCountryOrRegionCode.AL:
      return r'AL';
    case Enum$SponsorsCountryOrRegionCode.DZ:
      return r'DZ';
    case Enum$SponsorsCountryOrRegionCode.AS:
      return r'AS';
    case Enum$SponsorsCountryOrRegionCode.AD:
      return r'AD';
    case Enum$SponsorsCountryOrRegionCode.AO:
      return r'AO';
    case Enum$SponsorsCountryOrRegionCode.AI:
      return r'AI';
    case Enum$SponsorsCountryOrRegionCode.AQ:
      return r'AQ';
    case Enum$SponsorsCountryOrRegionCode.AG:
      return r'AG';
    case Enum$SponsorsCountryOrRegionCode.AR:
      return r'AR';
    case Enum$SponsorsCountryOrRegionCode.AM:
      return r'AM';
    case Enum$SponsorsCountryOrRegionCode.AW:
      return r'AW';
    case Enum$SponsorsCountryOrRegionCode.AU:
      return r'AU';
    case Enum$SponsorsCountryOrRegionCode.AT:
      return r'AT';
    case Enum$SponsorsCountryOrRegionCode.AZ:
      return r'AZ';
    case Enum$SponsorsCountryOrRegionCode.BS:
      return r'BS';
    case Enum$SponsorsCountryOrRegionCode.BH:
      return r'BH';
    case Enum$SponsorsCountryOrRegionCode.BD:
      return r'BD';
    case Enum$SponsorsCountryOrRegionCode.BB:
      return r'BB';
    case Enum$SponsorsCountryOrRegionCode.BY:
      return r'BY';
    case Enum$SponsorsCountryOrRegionCode.BE:
      return r'BE';
    case Enum$SponsorsCountryOrRegionCode.BZ:
      return r'BZ';
    case Enum$SponsorsCountryOrRegionCode.BJ:
      return r'BJ';
    case Enum$SponsorsCountryOrRegionCode.BM:
      return r'BM';
    case Enum$SponsorsCountryOrRegionCode.BT:
      return r'BT';
    case Enum$SponsorsCountryOrRegionCode.BO:
      return r'BO';
    case Enum$SponsorsCountryOrRegionCode.BQ:
      return r'BQ';
    case Enum$SponsorsCountryOrRegionCode.BA:
      return r'BA';
    case Enum$SponsorsCountryOrRegionCode.BW:
      return r'BW';
    case Enum$SponsorsCountryOrRegionCode.BV:
      return r'BV';
    case Enum$SponsorsCountryOrRegionCode.BR:
      return r'BR';
    case Enum$SponsorsCountryOrRegionCode.IO:
      return r'IO';
    case Enum$SponsorsCountryOrRegionCode.BN:
      return r'BN';
    case Enum$SponsorsCountryOrRegionCode.BG:
      return r'BG';
    case Enum$SponsorsCountryOrRegionCode.BF:
      return r'BF';
    case Enum$SponsorsCountryOrRegionCode.BI:
      return r'BI';
    case Enum$SponsorsCountryOrRegionCode.KH:
      return r'KH';
    case Enum$SponsorsCountryOrRegionCode.CM:
      return r'CM';
    case Enum$SponsorsCountryOrRegionCode.CA:
      return r'CA';
    case Enum$SponsorsCountryOrRegionCode.CV:
      return r'CV';
    case Enum$SponsorsCountryOrRegionCode.KY:
      return r'KY';
    case Enum$SponsorsCountryOrRegionCode.CF:
      return r'CF';
    case Enum$SponsorsCountryOrRegionCode.TD:
      return r'TD';
    case Enum$SponsorsCountryOrRegionCode.CL:
      return r'CL';
    case Enum$SponsorsCountryOrRegionCode.CN:
      return r'CN';
    case Enum$SponsorsCountryOrRegionCode.CX:
      return r'CX';
    case Enum$SponsorsCountryOrRegionCode.CC:
      return r'CC';
    case Enum$SponsorsCountryOrRegionCode.CO:
      return r'CO';
    case Enum$SponsorsCountryOrRegionCode.KM:
      return r'KM';
    case Enum$SponsorsCountryOrRegionCode.CG:
      return r'CG';
    case Enum$SponsorsCountryOrRegionCode.CD:
      return r'CD';
    case Enum$SponsorsCountryOrRegionCode.CK:
      return r'CK';
    case Enum$SponsorsCountryOrRegionCode.CR:
      return r'CR';
    case Enum$SponsorsCountryOrRegionCode.CI:
      return r'CI';
    case Enum$SponsorsCountryOrRegionCode.HR:
      return r'HR';
    case Enum$SponsorsCountryOrRegionCode.CW:
      return r'CW';
    case Enum$SponsorsCountryOrRegionCode.CY:
      return r'CY';
    case Enum$SponsorsCountryOrRegionCode.CZ:
      return r'CZ';
    case Enum$SponsorsCountryOrRegionCode.DK:
      return r'DK';
    case Enum$SponsorsCountryOrRegionCode.DJ:
      return r'DJ';
    case Enum$SponsorsCountryOrRegionCode.DM:
      return r'DM';
    case Enum$SponsorsCountryOrRegionCode.DO:
      return r'DO';
    case Enum$SponsorsCountryOrRegionCode.EC:
      return r'EC';
    case Enum$SponsorsCountryOrRegionCode.EG:
      return r'EG';
    case Enum$SponsorsCountryOrRegionCode.SV:
      return r'SV';
    case Enum$SponsorsCountryOrRegionCode.GQ:
      return r'GQ';
    case Enum$SponsorsCountryOrRegionCode.ER:
      return r'ER';
    case Enum$SponsorsCountryOrRegionCode.EE:
      return r'EE';
    case Enum$SponsorsCountryOrRegionCode.ET:
      return r'ET';
    case Enum$SponsorsCountryOrRegionCode.FK:
      return r'FK';
    case Enum$SponsorsCountryOrRegionCode.FO:
      return r'FO';
    case Enum$SponsorsCountryOrRegionCode.FJ:
      return r'FJ';
    case Enum$SponsorsCountryOrRegionCode.FI:
      return r'FI';
    case Enum$SponsorsCountryOrRegionCode.FR:
      return r'FR';
    case Enum$SponsorsCountryOrRegionCode.GF:
      return r'GF';
    case Enum$SponsorsCountryOrRegionCode.PF:
      return r'PF';
    case Enum$SponsorsCountryOrRegionCode.TF:
      return r'TF';
    case Enum$SponsorsCountryOrRegionCode.GA:
      return r'GA';
    case Enum$SponsorsCountryOrRegionCode.GM:
      return r'GM';
    case Enum$SponsorsCountryOrRegionCode.GE:
      return r'GE';
    case Enum$SponsorsCountryOrRegionCode.DE:
      return r'DE';
    case Enum$SponsorsCountryOrRegionCode.GH:
      return r'GH';
    case Enum$SponsorsCountryOrRegionCode.GI:
      return r'GI';
    case Enum$SponsorsCountryOrRegionCode.GR:
      return r'GR';
    case Enum$SponsorsCountryOrRegionCode.GL:
      return r'GL';
    case Enum$SponsorsCountryOrRegionCode.GD:
      return r'GD';
    case Enum$SponsorsCountryOrRegionCode.GP:
      return r'GP';
    case Enum$SponsorsCountryOrRegionCode.GU:
      return r'GU';
    case Enum$SponsorsCountryOrRegionCode.GT:
      return r'GT';
    case Enum$SponsorsCountryOrRegionCode.GG:
      return r'GG';
    case Enum$SponsorsCountryOrRegionCode.GN:
      return r'GN';
    case Enum$SponsorsCountryOrRegionCode.GW:
      return r'GW';
    case Enum$SponsorsCountryOrRegionCode.GY:
      return r'GY';
    case Enum$SponsorsCountryOrRegionCode.HT:
      return r'HT';
    case Enum$SponsorsCountryOrRegionCode.HM:
      return r'HM';
    case Enum$SponsorsCountryOrRegionCode.HN:
      return r'HN';
    case Enum$SponsorsCountryOrRegionCode.HK:
      return r'HK';
    case Enum$SponsorsCountryOrRegionCode.HU:
      return r'HU';
    case Enum$SponsorsCountryOrRegionCode.IS:
      return r'IS';
    case Enum$SponsorsCountryOrRegionCode.IN:
      return r'IN';
    case Enum$SponsorsCountryOrRegionCode.ID:
      return r'ID';
    case Enum$SponsorsCountryOrRegionCode.IR:
      return r'IR';
    case Enum$SponsorsCountryOrRegionCode.IQ:
      return r'IQ';
    case Enum$SponsorsCountryOrRegionCode.IE:
      return r'IE';
    case Enum$SponsorsCountryOrRegionCode.IM:
      return r'IM';
    case Enum$SponsorsCountryOrRegionCode.IL:
      return r'IL';
    case Enum$SponsorsCountryOrRegionCode.IT:
      return r'IT';
    case Enum$SponsorsCountryOrRegionCode.JM:
      return r'JM';
    case Enum$SponsorsCountryOrRegionCode.JP:
      return r'JP';
    case Enum$SponsorsCountryOrRegionCode.JE:
      return r'JE';
    case Enum$SponsorsCountryOrRegionCode.JO:
      return r'JO';
    case Enum$SponsorsCountryOrRegionCode.KZ:
      return r'KZ';
    case Enum$SponsorsCountryOrRegionCode.KE:
      return r'KE';
    case Enum$SponsorsCountryOrRegionCode.KI:
      return r'KI';
    case Enum$SponsorsCountryOrRegionCode.KR:
      return r'KR';
    case Enum$SponsorsCountryOrRegionCode.KW:
      return r'KW';
    case Enum$SponsorsCountryOrRegionCode.KG:
      return r'KG';
    case Enum$SponsorsCountryOrRegionCode.LA:
      return r'LA';
    case Enum$SponsorsCountryOrRegionCode.LV:
      return r'LV';
    case Enum$SponsorsCountryOrRegionCode.LB:
      return r'LB';
    case Enum$SponsorsCountryOrRegionCode.LS:
      return r'LS';
    case Enum$SponsorsCountryOrRegionCode.LR:
      return r'LR';
    case Enum$SponsorsCountryOrRegionCode.LY:
      return r'LY';
    case Enum$SponsorsCountryOrRegionCode.LI:
      return r'LI';
    case Enum$SponsorsCountryOrRegionCode.LT:
      return r'LT';
    case Enum$SponsorsCountryOrRegionCode.LU:
      return r'LU';
    case Enum$SponsorsCountryOrRegionCode.MO:
      return r'MO';
    case Enum$SponsorsCountryOrRegionCode.MK:
      return r'MK';
    case Enum$SponsorsCountryOrRegionCode.MG:
      return r'MG';
    case Enum$SponsorsCountryOrRegionCode.MW:
      return r'MW';
    case Enum$SponsorsCountryOrRegionCode.MY:
      return r'MY';
    case Enum$SponsorsCountryOrRegionCode.MV:
      return r'MV';
    case Enum$SponsorsCountryOrRegionCode.ML:
      return r'ML';
    case Enum$SponsorsCountryOrRegionCode.MT:
      return r'MT';
    case Enum$SponsorsCountryOrRegionCode.MH:
      return r'MH';
    case Enum$SponsorsCountryOrRegionCode.MQ:
      return r'MQ';
    case Enum$SponsorsCountryOrRegionCode.MR:
      return r'MR';
    case Enum$SponsorsCountryOrRegionCode.MU:
      return r'MU';
    case Enum$SponsorsCountryOrRegionCode.YT:
      return r'YT';
    case Enum$SponsorsCountryOrRegionCode.MX:
      return r'MX';
    case Enum$SponsorsCountryOrRegionCode.FM:
      return r'FM';
    case Enum$SponsorsCountryOrRegionCode.MD:
      return r'MD';
    case Enum$SponsorsCountryOrRegionCode.MC:
      return r'MC';
    case Enum$SponsorsCountryOrRegionCode.MN:
      return r'MN';
    case Enum$SponsorsCountryOrRegionCode.ME:
      return r'ME';
    case Enum$SponsorsCountryOrRegionCode.MS:
      return r'MS';
    case Enum$SponsorsCountryOrRegionCode.MA:
      return r'MA';
    case Enum$SponsorsCountryOrRegionCode.MZ:
      return r'MZ';
    case Enum$SponsorsCountryOrRegionCode.MM:
      return r'MM';
    case Enum$SponsorsCountryOrRegionCode.NA:
      return r'NA';
    case Enum$SponsorsCountryOrRegionCode.NR:
      return r'NR';
    case Enum$SponsorsCountryOrRegionCode.NP:
      return r'NP';
    case Enum$SponsorsCountryOrRegionCode.NL:
      return r'NL';
    case Enum$SponsorsCountryOrRegionCode.NC:
      return r'NC';
    case Enum$SponsorsCountryOrRegionCode.NZ:
      return r'NZ';
    case Enum$SponsorsCountryOrRegionCode.NI:
      return r'NI';
    case Enum$SponsorsCountryOrRegionCode.NE:
      return r'NE';
    case Enum$SponsorsCountryOrRegionCode.NG:
      return r'NG';
    case Enum$SponsorsCountryOrRegionCode.NU:
      return r'NU';
    case Enum$SponsorsCountryOrRegionCode.NF:
      return r'NF';
    case Enum$SponsorsCountryOrRegionCode.MP:
      return r'MP';
    case Enum$SponsorsCountryOrRegionCode.NO:
      return r'NO';
    case Enum$SponsorsCountryOrRegionCode.OM:
      return r'OM';
    case Enum$SponsorsCountryOrRegionCode.PK:
      return r'PK';
    case Enum$SponsorsCountryOrRegionCode.PW:
      return r'PW';
    case Enum$SponsorsCountryOrRegionCode.PS:
      return r'PS';
    case Enum$SponsorsCountryOrRegionCode.PA:
      return r'PA';
    case Enum$SponsorsCountryOrRegionCode.PG:
      return r'PG';
    case Enum$SponsorsCountryOrRegionCode.PY:
      return r'PY';
    case Enum$SponsorsCountryOrRegionCode.PE:
      return r'PE';
    case Enum$SponsorsCountryOrRegionCode.PH:
      return r'PH';
    case Enum$SponsorsCountryOrRegionCode.PN:
      return r'PN';
    case Enum$SponsorsCountryOrRegionCode.PL:
      return r'PL';
    case Enum$SponsorsCountryOrRegionCode.PT:
      return r'PT';
    case Enum$SponsorsCountryOrRegionCode.PR:
      return r'PR';
    case Enum$SponsorsCountryOrRegionCode.QA:
      return r'QA';
    case Enum$SponsorsCountryOrRegionCode.RE:
      return r'RE';
    case Enum$SponsorsCountryOrRegionCode.RO:
      return r'RO';
    case Enum$SponsorsCountryOrRegionCode.RU:
      return r'RU';
    case Enum$SponsorsCountryOrRegionCode.RW:
      return r'RW';
    case Enum$SponsorsCountryOrRegionCode.BL:
      return r'BL';
    case Enum$SponsorsCountryOrRegionCode.SH:
      return r'SH';
    case Enum$SponsorsCountryOrRegionCode.KN:
      return r'KN';
    case Enum$SponsorsCountryOrRegionCode.LC:
      return r'LC';
    case Enum$SponsorsCountryOrRegionCode.MF:
      return r'MF';
    case Enum$SponsorsCountryOrRegionCode.PM:
      return r'PM';
    case Enum$SponsorsCountryOrRegionCode.VC:
      return r'VC';
    case Enum$SponsorsCountryOrRegionCode.WS:
      return r'WS';
    case Enum$SponsorsCountryOrRegionCode.SM:
      return r'SM';
    case Enum$SponsorsCountryOrRegionCode.ST:
      return r'ST';
    case Enum$SponsorsCountryOrRegionCode.SA:
      return r'SA';
    case Enum$SponsorsCountryOrRegionCode.SN:
      return r'SN';
    case Enum$SponsorsCountryOrRegionCode.RS:
      return r'RS';
    case Enum$SponsorsCountryOrRegionCode.SC:
      return r'SC';
    case Enum$SponsorsCountryOrRegionCode.SL:
      return r'SL';
    case Enum$SponsorsCountryOrRegionCode.SG:
      return r'SG';
    case Enum$SponsorsCountryOrRegionCode.SX:
      return r'SX';
    case Enum$SponsorsCountryOrRegionCode.SK:
      return r'SK';
    case Enum$SponsorsCountryOrRegionCode.SI:
      return r'SI';
    case Enum$SponsorsCountryOrRegionCode.SB:
      return r'SB';
    case Enum$SponsorsCountryOrRegionCode.SO:
      return r'SO';
    case Enum$SponsorsCountryOrRegionCode.ZA:
      return r'ZA';
    case Enum$SponsorsCountryOrRegionCode.GS:
      return r'GS';
    case Enum$SponsorsCountryOrRegionCode.SS:
      return r'SS';
    case Enum$SponsorsCountryOrRegionCode.ES:
      return r'ES';
    case Enum$SponsorsCountryOrRegionCode.LK:
      return r'LK';
    case Enum$SponsorsCountryOrRegionCode.SD:
      return r'SD';
    case Enum$SponsorsCountryOrRegionCode.SR:
      return r'SR';
    case Enum$SponsorsCountryOrRegionCode.SJ:
      return r'SJ';
    case Enum$SponsorsCountryOrRegionCode.SZ:
      return r'SZ';
    case Enum$SponsorsCountryOrRegionCode.SE:
      return r'SE';
    case Enum$SponsorsCountryOrRegionCode.CH:
      return r'CH';
    case Enum$SponsorsCountryOrRegionCode.SY:
      return r'SY';
    case Enum$SponsorsCountryOrRegionCode.TW:
      return r'TW';
    case Enum$SponsorsCountryOrRegionCode.TJ:
      return r'TJ';
    case Enum$SponsorsCountryOrRegionCode.TZ:
      return r'TZ';
    case Enum$SponsorsCountryOrRegionCode.TH:
      return r'TH';
    case Enum$SponsorsCountryOrRegionCode.TL:
      return r'TL';
    case Enum$SponsorsCountryOrRegionCode.TG:
      return r'TG';
    case Enum$SponsorsCountryOrRegionCode.TK:
      return r'TK';
    case Enum$SponsorsCountryOrRegionCode.TO:
      return r'TO';
    case Enum$SponsorsCountryOrRegionCode.TT:
      return r'TT';
    case Enum$SponsorsCountryOrRegionCode.TN:
      return r'TN';
    case Enum$SponsorsCountryOrRegionCode.TR:
      return r'TR';
    case Enum$SponsorsCountryOrRegionCode.TM:
      return r'TM';
    case Enum$SponsorsCountryOrRegionCode.TC:
      return r'TC';
    case Enum$SponsorsCountryOrRegionCode.TV:
      return r'TV';
    case Enum$SponsorsCountryOrRegionCode.UG:
      return r'UG';
    case Enum$SponsorsCountryOrRegionCode.UA:
      return r'UA';
    case Enum$SponsorsCountryOrRegionCode.AE:
      return r'AE';
    case Enum$SponsorsCountryOrRegionCode.GB:
      return r'GB';
    case Enum$SponsorsCountryOrRegionCode.UM:
      return r'UM';
    case Enum$SponsorsCountryOrRegionCode.US:
      return r'US';
    case Enum$SponsorsCountryOrRegionCode.UY:
      return r'UY';
    case Enum$SponsorsCountryOrRegionCode.UZ:
      return r'UZ';
    case Enum$SponsorsCountryOrRegionCode.VU:
      return r'VU';
    case Enum$SponsorsCountryOrRegionCode.VA:
      return r'VA';
    case Enum$SponsorsCountryOrRegionCode.VE:
      return r'VE';
    case Enum$SponsorsCountryOrRegionCode.VN:
      return r'VN';
    case Enum$SponsorsCountryOrRegionCode.VG:
      return r'VG';
    case Enum$SponsorsCountryOrRegionCode.VI:
      return r'VI';
    case Enum$SponsorsCountryOrRegionCode.WF:
      return r'WF';
    case Enum$SponsorsCountryOrRegionCode.EH:
      return r'EH';
    case Enum$SponsorsCountryOrRegionCode.YE:
      return r'YE';
    case Enum$SponsorsCountryOrRegionCode.ZM:
      return r'ZM';
    case Enum$SponsorsCountryOrRegionCode.ZW:
      return r'ZW';
    case Enum$SponsorsCountryOrRegionCode.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsCountryOrRegionCode fromJson$Enum$SponsorsCountryOrRegionCode(
    String value) {
  switch (value) {
    case r'AF':
      return Enum$SponsorsCountryOrRegionCode.AF;
    case r'AX':
      return Enum$SponsorsCountryOrRegionCode.AX;
    case r'AL':
      return Enum$SponsorsCountryOrRegionCode.AL;
    case r'DZ':
      return Enum$SponsorsCountryOrRegionCode.DZ;
    case r'AS':
      return Enum$SponsorsCountryOrRegionCode.AS;
    case r'AD':
      return Enum$SponsorsCountryOrRegionCode.AD;
    case r'AO':
      return Enum$SponsorsCountryOrRegionCode.AO;
    case r'AI':
      return Enum$SponsorsCountryOrRegionCode.AI;
    case r'AQ':
      return Enum$SponsorsCountryOrRegionCode.AQ;
    case r'AG':
      return Enum$SponsorsCountryOrRegionCode.AG;
    case r'AR':
      return Enum$SponsorsCountryOrRegionCode.AR;
    case r'AM':
      return Enum$SponsorsCountryOrRegionCode.AM;
    case r'AW':
      return Enum$SponsorsCountryOrRegionCode.AW;
    case r'AU':
      return Enum$SponsorsCountryOrRegionCode.AU;
    case r'AT':
      return Enum$SponsorsCountryOrRegionCode.AT;
    case r'AZ':
      return Enum$SponsorsCountryOrRegionCode.AZ;
    case r'BS':
      return Enum$SponsorsCountryOrRegionCode.BS;
    case r'BH':
      return Enum$SponsorsCountryOrRegionCode.BH;
    case r'BD':
      return Enum$SponsorsCountryOrRegionCode.BD;
    case r'BB':
      return Enum$SponsorsCountryOrRegionCode.BB;
    case r'BY':
      return Enum$SponsorsCountryOrRegionCode.BY;
    case r'BE':
      return Enum$SponsorsCountryOrRegionCode.BE;
    case r'BZ':
      return Enum$SponsorsCountryOrRegionCode.BZ;
    case r'BJ':
      return Enum$SponsorsCountryOrRegionCode.BJ;
    case r'BM':
      return Enum$SponsorsCountryOrRegionCode.BM;
    case r'BT':
      return Enum$SponsorsCountryOrRegionCode.BT;
    case r'BO':
      return Enum$SponsorsCountryOrRegionCode.BO;
    case r'BQ':
      return Enum$SponsorsCountryOrRegionCode.BQ;
    case r'BA':
      return Enum$SponsorsCountryOrRegionCode.BA;
    case r'BW':
      return Enum$SponsorsCountryOrRegionCode.BW;
    case r'BV':
      return Enum$SponsorsCountryOrRegionCode.BV;
    case r'BR':
      return Enum$SponsorsCountryOrRegionCode.BR;
    case r'IO':
      return Enum$SponsorsCountryOrRegionCode.IO;
    case r'BN':
      return Enum$SponsorsCountryOrRegionCode.BN;
    case r'BG':
      return Enum$SponsorsCountryOrRegionCode.BG;
    case r'BF':
      return Enum$SponsorsCountryOrRegionCode.BF;
    case r'BI':
      return Enum$SponsorsCountryOrRegionCode.BI;
    case r'KH':
      return Enum$SponsorsCountryOrRegionCode.KH;
    case r'CM':
      return Enum$SponsorsCountryOrRegionCode.CM;
    case r'CA':
      return Enum$SponsorsCountryOrRegionCode.CA;
    case r'CV':
      return Enum$SponsorsCountryOrRegionCode.CV;
    case r'KY':
      return Enum$SponsorsCountryOrRegionCode.KY;
    case r'CF':
      return Enum$SponsorsCountryOrRegionCode.CF;
    case r'TD':
      return Enum$SponsorsCountryOrRegionCode.TD;
    case r'CL':
      return Enum$SponsorsCountryOrRegionCode.CL;
    case r'CN':
      return Enum$SponsorsCountryOrRegionCode.CN;
    case r'CX':
      return Enum$SponsorsCountryOrRegionCode.CX;
    case r'CC':
      return Enum$SponsorsCountryOrRegionCode.CC;
    case r'CO':
      return Enum$SponsorsCountryOrRegionCode.CO;
    case r'KM':
      return Enum$SponsorsCountryOrRegionCode.KM;
    case r'CG':
      return Enum$SponsorsCountryOrRegionCode.CG;
    case r'CD':
      return Enum$SponsorsCountryOrRegionCode.CD;
    case r'CK':
      return Enum$SponsorsCountryOrRegionCode.CK;
    case r'CR':
      return Enum$SponsorsCountryOrRegionCode.CR;
    case r'CI':
      return Enum$SponsorsCountryOrRegionCode.CI;
    case r'HR':
      return Enum$SponsorsCountryOrRegionCode.HR;
    case r'CW':
      return Enum$SponsorsCountryOrRegionCode.CW;
    case r'CY':
      return Enum$SponsorsCountryOrRegionCode.CY;
    case r'CZ':
      return Enum$SponsorsCountryOrRegionCode.CZ;
    case r'DK':
      return Enum$SponsorsCountryOrRegionCode.DK;
    case r'DJ':
      return Enum$SponsorsCountryOrRegionCode.DJ;
    case r'DM':
      return Enum$SponsorsCountryOrRegionCode.DM;
    case r'DO':
      return Enum$SponsorsCountryOrRegionCode.DO;
    case r'EC':
      return Enum$SponsorsCountryOrRegionCode.EC;
    case r'EG':
      return Enum$SponsorsCountryOrRegionCode.EG;
    case r'SV':
      return Enum$SponsorsCountryOrRegionCode.SV;
    case r'GQ':
      return Enum$SponsorsCountryOrRegionCode.GQ;
    case r'ER':
      return Enum$SponsorsCountryOrRegionCode.ER;
    case r'EE':
      return Enum$SponsorsCountryOrRegionCode.EE;
    case r'ET':
      return Enum$SponsorsCountryOrRegionCode.ET;
    case r'FK':
      return Enum$SponsorsCountryOrRegionCode.FK;
    case r'FO':
      return Enum$SponsorsCountryOrRegionCode.FO;
    case r'FJ':
      return Enum$SponsorsCountryOrRegionCode.FJ;
    case r'FI':
      return Enum$SponsorsCountryOrRegionCode.FI;
    case r'FR':
      return Enum$SponsorsCountryOrRegionCode.FR;
    case r'GF':
      return Enum$SponsorsCountryOrRegionCode.GF;
    case r'PF':
      return Enum$SponsorsCountryOrRegionCode.PF;
    case r'TF':
      return Enum$SponsorsCountryOrRegionCode.TF;
    case r'GA':
      return Enum$SponsorsCountryOrRegionCode.GA;
    case r'GM':
      return Enum$SponsorsCountryOrRegionCode.GM;
    case r'GE':
      return Enum$SponsorsCountryOrRegionCode.GE;
    case r'DE':
      return Enum$SponsorsCountryOrRegionCode.DE;
    case r'GH':
      return Enum$SponsorsCountryOrRegionCode.GH;
    case r'GI':
      return Enum$SponsorsCountryOrRegionCode.GI;
    case r'GR':
      return Enum$SponsorsCountryOrRegionCode.GR;
    case r'GL':
      return Enum$SponsorsCountryOrRegionCode.GL;
    case r'GD':
      return Enum$SponsorsCountryOrRegionCode.GD;
    case r'GP':
      return Enum$SponsorsCountryOrRegionCode.GP;
    case r'GU':
      return Enum$SponsorsCountryOrRegionCode.GU;
    case r'GT':
      return Enum$SponsorsCountryOrRegionCode.GT;
    case r'GG':
      return Enum$SponsorsCountryOrRegionCode.GG;
    case r'GN':
      return Enum$SponsorsCountryOrRegionCode.GN;
    case r'GW':
      return Enum$SponsorsCountryOrRegionCode.GW;
    case r'GY':
      return Enum$SponsorsCountryOrRegionCode.GY;
    case r'HT':
      return Enum$SponsorsCountryOrRegionCode.HT;
    case r'HM':
      return Enum$SponsorsCountryOrRegionCode.HM;
    case r'HN':
      return Enum$SponsorsCountryOrRegionCode.HN;
    case r'HK':
      return Enum$SponsorsCountryOrRegionCode.HK;
    case r'HU':
      return Enum$SponsorsCountryOrRegionCode.HU;
    case r'IS':
      return Enum$SponsorsCountryOrRegionCode.IS;
    case r'IN':
      return Enum$SponsorsCountryOrRegionCode.IN;
    case r'ID':
      return Enum$SponsorsCountryOrRegionCode.ID;
    case r'IR':
      return Enum$SponsorsCountryOrRegionCode.IR;
    case r'IQ':
      return Enum$SponsorsCountryOrRegionCode.IQ;
    case r'IE':
      return Enum$SponsorsCountryOrRegionCode.IE;
    case r'IM':
      return Enum$SponsorsCountryOrRegionCode.IM;
    case r'IL':
      return Enum$SponsorsCountryOrRegionCode.IL;
    case r'IT':
      return Enum$SponsorsCountryOrRegionCode.IT;
    case r'JM':
      return Enum$SponsorsCountryOrRegionCode.JM;
    case r'JP':
      return Enum$SponsorsCountryOrRegionCode.JP;
    case r'JE':
      return Enum$SponsorsCountryOrRegionCode.JE;
    case r'JO':
      return Enum$SponsorsCountryOrRegionCode.JO;
    case r'KZ':
      return Enum$SponsorsCountryOrRegionCode.KZ;
    case r'KE':
      return Enum$SponsorsCountryOrRegionCode.KE;
    case r'KI':
      return Enum$SponsorsCountryOrRegionCode.KI;
    case r'KR':
      return Enum$SponsorsCountryOrRegionCode.KR;
    case r'KW':
      return Enum$SponsorsCountryOrRegionCode.KW;
    case r'KG':
      return Enum$SponsorsCountryOrRegionCode.KG;
    case r'LA':
      return Enum$SponsorsCountryOrRegionCode.LA;
    case r'LV':
      return Enum$SponsorsCountryOrRegionCode.LV;
    case r'LB':
      return Enum$SponsorsCountryOrRegionCode.LB;
    case r'LS':
      return Enum$SponsorsCountryOrRegionCode.LS;
    case r'LR':
      return Enum$SponsorsCountryOrRegionCode.LR;
    case r'LY':
      return Enum$SponsorsCountryOrRegionCode.LY;
    case r'LI':
      return Enum$SponsorsCountryOrRegionCode.LI;
    case r'LT':
      return Enum$SponsorsCountryOrRegionCode.LT;
    case r'LU':
      return Enum$SponsorsCountryOrRegionCode.LU;
    case r'MO':
      return Enum$SponsorsCountryOrRegionCode.MO;
    case r'MK':
      return Enum$SponsorsCountryOrRegionCode.MK;
    case r'MG':
      return Enum$SponsorsCountryOrRegionCode.MG;
    case r'MW':
      return Enum$SponsorsCountryOrRegionCode.MW;
    case r'MY':
      return Enum$SponsorsCountryOrRegionCode.MY;
    case r'MV':
      return Enum$SponsorsCountryOrRegionCode.MV;
    case r'ML':
      return Enum$SponsorsCountryOrRegionCode.ML;
    case r'MT':
      return Enum$SponsorsCountryOrRegionCode.MT;
    case r'MH':
      return Enum$SponsorsCountryOrRegionCode.MH;
    case r'MQ':
      return Enum$SponsorsCountryOrRegionCode.MQ;
    case r'MR':
      return Enum$SponsorsCountryOrRegionCode.MR;
    case r'MU':
      return Enum$SponsorsCountryOrRegionCode.MU;
    case r'YT':
      return Enum$SponsorsCountryOrRegionCode.YT;
    case r'MX':
      return Enum$SponsorsCountryOrRegionCode.MX;
    case r'FM':
      return Enum$SponsorsCountryOrRegionCode.FM;
    case r'MD':
      return Enum$SponsorsCountryOrRegionCode.MD;
    case r'MC':
      return Enum$SponsorsCountryOrRegionCode.MC;
    case r'MN':
      return Enum$SponsorsCountryOrRegionCode.MN;
    case r'ME':
      return Enum$SponsorsCountryOrRegionCode.ME;
    case r'MS':
      return Enum$SponsorsCountryOrRegionCode.MS;
    case r'MA':
      return Enum$SponsorsCountryOrRegionCode.MA;
    case r'MZ':
      return Enum$SponsorsCountryOrRegionCode.MZ;
    case r'MM':
      return Enum$SponsorsCountryOrRegionCode.MM;
    case r'NA':
      return Enum$SponsorsCountryOrRegionCode.NA;
    case r'NR':
      return Enum$SponsorsCountryOrRegionCode.NR;
    case r'NP':
      return Enum$SponsorsCountryOrRegionCode.NP;
    case r'NL':
      return Enum$SponsorsCountryOrRegionCode.NL;
    case r'NC':
      return Enum$SponsorsCountryOrRegionCode.NC;
    case r'NZ':
      return Enum$SponsorsCountryOrRegionCode.NZ;
    case r'NI':
      return Enum$SponsorsCountryOrRegionCode.NI;
    case r'NE':
      return Enum$SponsorsCountryOrRegionCode.NE;
    case r'NG':
      return Enum$SponsorsCountryOrRegionCode.NG;
    case r'NU':
      return Enum$SponsorsCountryOrRegionCode.NU;
    case r'NF':
      return Enum$SponsorsCountryOrRegionCode.NF;
    case r'MP':
      return Enum$SponsorsCountryOrRegionCode.MP;
    case r'NO':
      return Enum$SponsorsCountryOrRegionCode.NO;
    case r'OM':
      return Enum$SponsorsCountryOrRegionCode.OM;
    case r'PK':
      return Enum$SponsorsCountryOrRegionCode.PK;
    case r'PW':
      return Enum$SponsorsCountryOrRegionCode.PW;
    case r'PS':
      return Enum$SponsorsCountryOrRegionCode.PS;
    case r'PA':
      return Enum$SponsorsCountryOrRegionCode.PA;
    case r'PG':
      return Enum$SponsorsCountryOrRegionCode.PG;
    case r'PY':
      return Enum$SponsorsCountryOrRegionCode.PY;
    case r'PE':
      return Enum$SponsorsCountryOrRegionCode.PE;
    case r'PH':
      return Enum$SponsorsCountryOrRegionCode.PH;
    case r'PN':
      return Enum$SponsorsCountryOrRegionCode.PN;
    case r'PL':
      return Enum$SponsorsCountryOrRegionCode.PL;
    case r'PT':
      return Enum$SponsorsCountryOrRegionCode.PT;
    case r'PR':
      return Enum$SponsorsCountryOrRegionCode.PR;
    case r'QA':
      return Enum$SponsorsCountryOrRegionCode.QA;
    case r'RE':
      return Enum$SponsorsCountryOrRegionCode.RE;
    case r'RO':
      return Enum$SponsorsCountryOrRegionCode.RO;
    case r'RU':
      return Enum$SponsorsCountryOrRegionCode.RU;
    case r'RW':
      return Enum$SponsorsCountryOrRegionCode.RW;
    case r'BL':
      return Enum$SponsorsCountryOrRegionCode.BL;
    case r'SH':
      return Enum$SponsorsCountryOrRegionCode.SH;
    case r'KN':
      return Enum$SponsorsCountryOrRegionCode.KN;
    case r'LC':
      return Enum$SponsorsCountryOrRegionCode.LC;
    case r'MF':
      return Enum$SponsorsCountryOrRegionCode.MF;
    case r'PM':
      return Enum$SponsorsCountryOrRegionCode.PM;
    case r'VC':
      return Enum$SponsorsCountryOrRegionCode.VC;
    case r'WS':
      return Enum$SponsorsCountryOrRegionCode.WS;
    case r'SM':
      return Enum$SponsorsCountryOrRegionCode.SM;
    case r'ST':
      return Enum$SponsorsCountryOrRegionCode.ST;
    case r'SA':
      return Enum$SponsorsCountryOrRegionCode.SA;
    case r'SN':
      return Enum$SponsorsCountryOrRegionCode.SN;
    case r'RS':
      return Enum$SponsorsCountryOrRegionCode.RS;
    case r'SC':
      return Enum$SponsorsCountryOrRegionCode.SC;
    case r'SL':
      return Enum$SponsorsCountryOrRegionCode.SL;
    case r'SG':
      return Enum$SponsorsCountryOrRegionCode.SG;
    case r'SX':
      return Enum$SponsorsCountryOrRegionCode.SX;
    case r'SK':
      return Enum$SponsorsCountryOrRegionCode.SK;
    case r'SI':
      return Enum$SponsorsCountryOrRegionCode.SI;
    case r'SB':
      return Enum$SponsorsCountryOrRegionCode.SB;
    case r'SO':
      return Enum$SponsorsCountryOrRegionCode.SO;
    case r'ZA':
      return Enum$SponsorsCountryOrRegionCode.ZA;
    case r'GS':
      return Enum$SponsorsCountryOrRegionCode.GS;
    case r'SS':
      return Enum$SponsorsCountryOrRegionCode.SS;
    case r'ES':
      return Enum$SponsorsCountryOrRegionCode.ES;
    case r'LK':
      return Enum$SponsorsCountryOrRegionCode.LK;
    case r'SD':
      return Enum$SponsorsCountryOrRegionCode.SD;
    case r'SR':
      return Enum$SponsorsCountryOrRegionCode.SR;
    case r'SJ':
      return Enum$SponsorsCountryOrRegionCode.SJ;
    case r'SZ':
      return Enum$SponsorsCountryOrRegionCode.SZ;
    case r'SE':
      return Enum$SponsorsCountryOrRegionCode.SE;
    case r'CH':
      return Enum$SponsorsCountryOrRegionCode.CH;
    case r'SY':
      return Enum$SponsorsCountryOrRegionCode.SY;
    case r'TW':
      return Enum$SponsorsCountryOrRegionCode.TW;
    case r'TJ':
      return Enum$SponsorsCountryOrRegionCode.TJ;
    case r'TZ':
      return Enum$SponsorsCountryOrRegionCode.TZ;
    case r'TH':
      return Enum$SponsorsCountryOrRegionCode.TH;
    case r'TL':
      return Enum$SponsorsCountryOrRegionCode.TL;
    case r'TG':
      return Enum$SponsorsCountryOrRegionCode.TG;
    case r'TK':
      return Enum$SponsorsCountryOrRegionCode.TK;
    case r'TO':
      return Enum$SponsorsCountryOrRegionCode.TO;
    case r'TT':
      return Enum$SponsorsCountryOrRegionCode.TT;
    case r'TN':
      return Enum$SponsorsCountryOrRegionCode.TN;
    case r'TR':
      return Enum$SponsorsCountryOrRegionCode.TR;
    case r'TM':
      return Enum$SponsorsCountryOrRegionCode.TM;
    case r'TC':
      return Enum$SponsorsCountryOrRegionCode.TC;
    case r'TV':
      return Enum$SponsorsCountryOrRegionCode.TV;
    case r'UG':
      return Enum$SponsorsCountryOrRegionCode.UG;
    case r'UA':
      return Enum$SponsorsCountryOrRegionCode.UA;
    case r'AE':
      return Enum$SponsorsCountryOrRegionCode.AE;
    case r'GB':
      return Enum$SponsorsCountryOrRegionCode.GB;
    case r'UM':
      return Enum$SponsorsCountryOrRegionCode.UM;
    case r'US':
      return Enum$SponsorsCountryOrRegionCode.US;
    case r'UY':
      return Enum$SponsorsCountryOrRegionCode.UY;
    case r'UZ':
      return Enum$SponsorsCountryOrRegionCode.UZ;
    case r'VU':
      return Enum$SponsorsCountryOrRegionCode.VU;
    case r'VA':
      return Enum$SponsorsCountryOrRegionCode.VA;
    case r'VE':
      return Enum$SponsorsCountryOrRegionCode.VE;
    case r'VN':
      return Enum$SponsorsCountryOrRegionCode.VN;
    case r'VG':
      return Enum$SponsorsCountryOrRegionCode.VG;
    case r'VI':
      return Enum$SponsorsCountryOrRegionCode.VI;
    case r'WF':
      return Enum$SponsorsCountryOrRegionCode.WF;
    case r'EH':
      return Enum$SponsorsCountryOrRegionCode.EH;
    case r'YE':
      return Enum$SponsorsCountryOrRegionCode.YE;
    case r'ZM':
      return Enum$SponsorsCountryOrRegionCode.ZM;
    case r'ZW':
      return Enum$SponsorsCountryOrRegionCode.ZW;
    default:
      return Enum$SponsorsCountryOrRegionCode.$unknown;
  }
}

enum Enum$SponsorsGoalKind {
  TOTAL_SPONSORS_COUNT,
  MONTHLY_SPONSORSHIP_AMOUNT,
  $unknown;

  factory Enum$SponsorsGoalKind.fromJson(String value) =>
      fromJson$Enum$SponsorsGoalKind(value);

  String toJson() => toJson$Enum$SponsorsGoalKind(this);
}

String toJson$Enum$SponsorsGoalKind(Enum$SponsorsGoalKind e) {
  switch (e) {
    case Enum$SponsorsGoalKind.TOTAL_SPONSORS_COUNT:
      return r'TOTAL_SPONSORS_COUNT';
    case Enum$SponsorsGoalKind.MONTHLY_SPONSORSHIP_AMOUNT:
      return r'MONTHLY_SPONSORSHIP_AMOUNT';
    case Enum$SponsorsGoalKind.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsGoalKind fromJson$Enum$SponsorsGoalKind(String value) {
  switch (value) {
    case r'TOTAL_SPONSORS_COUNT':
      return Enum$SponsorsGoalKind.TOTAL_SPONSORS_COUNT;
    case r'MONTHLY_SPONSORSHIP_AMOUNT':
      return Enum$SponsorsGoalKind.MONTHLY_SPONSORSHIP_AMOUNT;
    default:
      return Enum$SponsorsGoalKind.$unknown;
  }
}

enum Enum$SponsorshipNewsletterOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$SponsorshipNewsletterOrderField.fromJson(String value) =>
      fromJson$Enum$SponsorshipNewsletterOrderField(value);

  String toJson() => toJson$Enum$SponsorshipNewsletterOrderField(this);
}

String toJson$Enum$SponsorshipNewsletterOrderField(
    Enum$SponsorshipNewsletterOrderField e) {
  switch (e) {
    case Enum$SponsorshipNewsletterOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorshipNewsletterOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipNewsletterOrderField
    fromJson$Enum$SponsorshipNewsletterOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorshipNewsletterOrderField.CREATED_AT;
    default:
      return Enum$SponsorshipNewsletterOrderField.$unknown;
  }
}

enum Enum$SponsorshipOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$SponsorshipOrderField.fromJson(String value) =>
      fromJson$Enum$SponsorshipOrderField(value);

  String toJson() => toJson$Enum$SponsorshipOrderField(this);
}

String toJson$Enum$SponsorshipOrderField(Enum$SponsorshipOrderField e) {
  switch (e) {
    case Enum$SponsorshipOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorshipOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipOrderField fromJson$Enum$SponsorshipOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorshipOrderField.CREATED_AT;
    default:
      return Enum$SponsorshipOrderField.$unknown;
  }
}

enum Enum$SponsorshipPaymentSource {
  GITHUB,
  PATREON,
  $unknown;

  factory Enum$SponsorshipPaymentSource.fromJson(String value) =>
      fromJson$Enum$SponsorshipPaymentSource(value);

  String toJson() => toJson$Enum$SponsorshipPaymentSource(this);
}

String toJson$Enum$SponsorshipPaymentSource(Enum$SponsorshipPaymentSource e) {
  switch (e) {
    case Enum$SponsorshipPaymentSource.GITHUB:
      return r'GITHUB';
    case Enum$SponsorshipPaymentSource.PATREON:
      return r'PATREON';
    case Enum$SponsorshipPaymentSource.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipPaymentSource fromJson$Enum$SponsorshipPaymentSource(
    String value) {
  switch (value) {
    case r'GITHUB':
      return Enum$SponsorshipPaymentSource.GITHUB;
    case r'PATREON':
      return Enum$SponsorshipPaymentSource.PATREON;
    default:
      return Enum$SponsorshipPaymentSource.$unknown;
  }
}

enum Enum$SponsorshipPrivacy {
  PUBLIC,
  PRIVATE,
  $unknown;

  factory Enum$SponsorshipPrivacy.fromJson(String value) =>
      fromJson$Enum$SponsorshipPrivacy(value);

  String toJson() => toJson$Enum$SponsorshipPrivacy(this);
}

String toJson$Enum$SponsorshipPrivacy(Enum$SponsorshipPrivacy e) {
  switch (e) {
    case Enum$SponsorshipPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$SponsorshipPrivacy.PRIVATE:
      return r'PRIVATE';
    case Enum$SponsorshipPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipPrivacy fromJson$Enum$SponsorshipPrivacy(String value) {
  switch (value) {
    case r'PUBLIC':
      return Enum$SponsorshipPrivacy.PUBLIC;
    case r'PRIVATE':
      return Enum$SponsorshipPrivacy.PRIVATE;
    default:
      return Enum$SponsorshipPrivacy.$unknown;
  }
}

enum Enum$SponsorsListingFeaturedItemFeatureableType {
  REPOSITORY,
  USER,
  $unknown;

  factory Enum$SponsorsListingFeaturedItemFeatureableType.fromJson(
          String value) =>
      fromJson$Enum$SponsorsListingFeaturedItemFeatureableType(value);

  String toJson() =>
      toJson$Enum$SponsorsListingFeaturedItemFeatureableType(this);
}

String toJson$Enum$SponsorsListingFeaturedItemFeatureableType(
    Enum$SponsorsListingFeaturedItemFeatureableType e) {
  switch (e) {
    case Enum$SponsorsListingFeaturedItemFeatureableType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$SponsorsListingFeaturedItemFeatureableType.USER:
      return r'USER';
    case Enum$SponsorsListingFeaturedItemFeatureableType.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsListingFeaturedItemFeatureableType
    fromJson$Enum$SponsorsListingFeaturedItemFeatureableType(String value) {
  switch (value) {
    case r'REPOSITORY':
      return Enum$SponsorsListingFeaturedItemFeatureableType.REPOSITORY;
    case r'USER':
      return Enum$SponsorsListingFeaturedItemFeatureableType.USER;
    default:
      return Enum$SponsorsListingFeaturedItemFeatureableType.$unknown;
  }
}

enum Enum$SponsorsTierOrderField {
  CREATED_AT,
  MONTHLY_PRICE_IN_CENTS,
  $unknown;

  factory Enum$SponsorsTierOrderField.fromJson(String value) =>
      fromJson$Enum$SponsorsTierOrderField(value);

  String toJson() => toJson$Enum$SponsorsTierOrderField(this);
}

String toJson$Enum$SponsorsTierOrderField(Enum$SponsorsTierOrderField e) {
  switch (e) {
    case Enum$SponsorsTierOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorsTierOrderField.MONTHLY_PRICE_IN_CENTS:
      return r'MONTHLY_PRICE_IN_CENTS';
    case Enum$SponsorsTierOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsTierOrderField fromJson$Enum$SponsorsTierOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorsTierOrderField.CREATED_AT;
    case r'MONTHLY_PRICE_IN_CENTS':
      return Enum$SponsorsTierOrderField.MONTHLY_PRICE_IN_CENTS;
    default:
      return Enum$SponsorsTierOrderField.$unknown;
  }
}

enum Enum$SquashMergeCommitMessage {
  PR_BODY,
  COMMIT_MESSAGES,
  BLANK,
  $unknown;

  factory Enum$SquashMergeCommitMessage.fromJson(String value) =>
      fromJson$Enum$SquashMergeCommitMessage(value);

  String toJson() => toJson$Enum$SquashMergeCommitMessage(this);
}

String toJson$Enum$SquashMergeCommitMessage(Enum$SquashMergeCommitMessage e) {
  switch (e) {
    case Enum$SquashMergeCommitMessage.PR_BODY:
      return r'PR_BODY';
    case Enum$SquashMergeCommitMessage.COMMIT_MESSAGES:
      return r'COMMIT_MESSAGES';
    case Enum$SquashMergeCommitMessage.BLANK:
      return r'BLANK';
    case Enum$SquashMergeCommitMessage.$unknown:
      return r'$unknown';
  }
}

Enum$SquashMergeCommitMessage fromJson$Enum$SquashMergeCommitMessage(
    String value) {
  switch (value) {
    case r'PR_BODY':
      return Enum$SquashMergeCommitMessage.PR_BODY;
    case r'COMMIT_MESSAGES':
      return Enum$SquashMergeCommitMessage.COMMIT_MESSAGES;
    case r'BLANK':
      return Enum$SquashMergeCommitMessage.BLANK;
    default:
      return Enum$SquashMergeCommitMessage.$unknown;
  }
}

enum Enum$SquashMergeCommitTitle {
  PR_TITLE,
  COMMIT_OR_PR_TITLE,
  $unknown;

  factory Enum$SquashMergeCommitTitle.fromJson(String value) =>
      fromJson$Enum$SquashMergeCommitTitle(value);

  String toJson() => toJson$Enum$SquashMergeCommitTitle(this);
}

String toJson$Enum$SquashMergeCommitTitle(Enum$SquashMergeCommitTitle e) {
  switch (e) {
    case Enum$SquashMergeCommitTitle.PR_TITLE:
      return r'PR_TITLE';
    case Enum$SquashMergeCommitTitle.COMMIT_OR_PR_TITLE:
      return r'COMMIT_OR_PR_TITLE';
    case Enum$SquashMergeCommitTitle.$unknown:
      return r'$unknown';
  }
}

Enum$SquashMergeCommitTitle fromJson$Enum$SquashMergeCommitTitle(String value) {
  switch (value) {
    case r'PR_TITLE':
      return Enum$SquashMergeCommitTitle.PR_TITLE;
    case r'COMMIT_OR_PR_TITLE':
      return Enum$SquashMergeCommitTitle.COMMIT_OR_PR_TITLE;
    default:
      return Enum$SquashMergeCommitTitle.$unknown;
  }
}

enum Enum$StarOrderField {
  STARRED_AT,
  $unknown;

  factory Enum$StarOrderField.fromJson(String value) =>
      fromJson$Enum$StarOrderField(value);

  String toJson() => toJson$Enum$StarOrderField(this);
}

String toJson$Enum$StarOrderField(Enum$StarOrderField e) {
  switch (e) {
    case Enum$StarOrderField.STARRED_AT:
      return r'STARRED_AT';
    case Enum$StarOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$StarOrderField fromJson$Enum$StarOrderField(String value) {
  switch (value) {
    case r'STARRED_AT':
      return Enum$StarOrderField.STARRED_AT;
    default:
      return Enum$StarOrderField.$unknown;
  }
}

enum Enum$StatusState {
  EXPECTED,
  ERROR,
  FAILURE,
  PENDING,
  SUCCESS,
  $unknown;

  factory Enum$StatusState.fromJson(String value) =>
      fromJson$Enum$StatusState(value);

  String toJson() => toJson$Enum$StatusState(this);
}

String toJson$Enum$StatusState(Enum$StatusState e) {
  switch (e) {
    case Enum$StatusState.EXPECTED:
      return r'EXPECTED';
    case Enum$StatusState.ERROR:
      return r'ERROR';
    case Enum$StatusState.FAILURE:
      return r'FAILURE';
    case Enum$StatusState.PENDING:
      return r'PENDING';
    case Enum$StatusState.SUCCESS:
      return r'SUCCESS';
    case Enum$StatusState.$unknown:
      return r'$unknown';
  }
}

Enum$StatusState fromJson$Enum$StatusState(String value) {
  switch (value) {
    case r'EXPECTED':
      return Enum$StatusState.EXPECTED;
    case r'ERROR':
      return Enum$StatusState.ERROR;
    case r'FAILURE':
      return Enum$StatusState.FAILURE;
    case r'PENDING':
      return Enum$StatusState.PENDING;
    case r'SUCCESS':
      return Enum$StatusState.SUCCESS;
    default:
      return Enum$StatusState.$unknown;
  }
}

enum Enum$SubscriptionState {
  UNSUBSCRIBED,
  SUBSCRIBED,
  IGNORED,
  $unknown;

  factory Enum$SubscriptionState.fromJson(String value) =>
      fromJson$Enum$SubscriptionState(value);

  String toJson() => toJson$Enum$SubscriptionState(this);
}

String toJson$Enum$SubscriptionState(Enum$SubscriptionState e) {
  switch (e) {
    case Enum$SubscriptionState.UNSUBSCRIBED:
      return r'UNSUBSCRIBED';
    case Enum$SubscriptionState.SUBSCRIBED:
      return r'SUBSCRIBED';
    case Enum$SubscriptionState.IGNORED:
      return r'IGNORED';
    case Enum$SubscriptionState.$unknown:
      return r'$unknown';
  }
}

Enum$SubscriptionState fromJson$Enum$SubscriptionState(String value) {
  switch (value) {
    case r'UNSUBSCRIBED':
      return Enum$SubscriptionState.UNSUBSCRIBED;
    case r'SUBSCRIBED':
      return Enum$SubscriptionState.SUBSCRIBED;
    case r'IGNORED':
      return Enum$SubscriptionState.IGNORED;
    default:
      return Enum$SubscriptionState.$unknown;
  }
}

enum Enum$TeamDiscussionCommentOrderField {
  NUMBER,
  $unknown;

  factory Enum$TeamDiscussionCommentOrderField.fromJson(String value) =>
      fromJson$Enum$TeamDiscussionCommentOrderField(value);

  String toJson() => toJson$Enum$TeamDiscussionCommentOrderField(this);
}

String toJson$Enum$TeamDiscussionCommentOrderField(
    Enum$TeamDiscussionCommentOrderField e) {
  switch (e) {
    case Enum$TeamDiscussionCommentOrderField.NUMBER:
      return r'NUMBER';
    case Enum$TeamDiscussionCommentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamDiscussionCommentOrderField
    fromJson$Enum$TeamDiscussionCommentOrderField(String value) {
  switch (value) {
    case r'NUMBER':
      return Enum$TeamDiscussionCommentOrderField.NUMBER;
    default:
      return Enum$TeamDiscussionCommentOrderField.$unknown;
  }
}

enum Enum$TeamDiscussionOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$TeamDiscussionOrderField.fromJson(String value) =>
      fromJson$Enum$TeamDiscussionOrderField(value);

  String toJson() => toJson$Enum$TeamDiscussionOrderField(this);
}

String toJson$Enum$TeamDiscussionOrderField(Enum$TeamDiscussionOrderField e) {
  switch (e) {
    case Enum$TeamDiscussionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamDiscussionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamDiscussionOrderField fromJson$Enum$TeamDiscussionOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$TeamDiscussionOrderField.CREATED_AT;
    default:
      return Enum$TeamDiscussionOrderField.$unknown;
  }
}

enum Enum$TeamMemberOrderField {
  LOGIN,
  CREATED_AT,
  $unknown;

  factory Enum$TeamMemberOrderField.fromJson(String value) =>
      fromJson$Enum$TeamMemberOrderField(value);

  String toJson() => toJson$Enum$TeamMemberOrderField(this);
}

String toJson$Enum$TeamMemberOrderField(Enum$TeamMemberOrderField e) {
  switch (e) {
    case Enum$TeamMemberOrderField.LOGIN:
      return r'LOGIN';
    case Enum$TeamMemberOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamMemberOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMemberOrderField fromJson$Enum$TeamMemberOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$TeamMemberOrderField.LOGIN;
    case r'CREATED_AT':
      return Enum$TeamMemberOrderField.CREATED_AT;
    default:
      return Enum$TeamMemberOrderField.$unknown;
  }
}

enum Enum$TeamMemberRole {
  MAINTAINER,
  MEMBER,
  $unknown;

  factory Enum$TeamMemberRole.fromJson(String value) =>
      fromJson$Enum$TeamMemberRole(value);

  String toJson() => toJson$Enum$TeamMemberRole(this);
}

String toJson$Enum$TeamMemberRole(Enum$TeamMemberRole e) {
  switch (e) {
    case Enum$TeamMemberRole.MAINTAINER:
      return r'MAINTAINER';
    case Enum$TeamMemberRole.MEMBER:
      return r'MEMBER';
    case Enum$TeamMemberRole.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMemberRole fromJson$Enum$TeamMemberRole(String value) {
  switch (value) {
    case r'MAINTAINER':
      return Enum$TeamMemberRole.MAINTAINER;
    case r'MEMBER':
      return Enum$TeamMemberRole.MEMBER;
    default:
      return Enum$TeamMemberRole.$unknown;
  }
}

enum Enum$TeamMembershipType {
  IMMEDIATE,
  CHILD_TEAM,
  ALL,
  $unknown;

  factory Enum$TeamMembershipType.fromJson(String value) =>
      fromJson$Enum$TeamMembershipType(value);

  String toJson() => toJson$Enum$TeamMembershipType(this);
}

String toJson$Enum$TeamMembershipType(Enum$TeamMembershipType e) {
  switch (e) {
    case Enum$TeamMembershipType.IMMEDIATE:
      return r'IMMEDIATE';
    case Enum$TeamMembershipType.CHILD_TEAM:
      return r'CHILD_TEAM';
    case Enum$TeamMembershipType.ALL:
      return r'ALL';
    case Enum$TeamMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMembershipType fromJson$Enum$TeamMembershipType(String value) {
  switch (value) {
    case r'IMMEDIATE':
      return Enum$TeamMembershipType.IMMEDIATE;
    case r'CHILD_TEAM':
      return Enum$TeamMembershipType.CHILD_TEAM;
    case r'ALL':
      return Enum$TeamMembershipType.ALL;
    default:
      return Enum$TeamMembershipType.$unknown;
  }
}

enum Enum$TeamNotificationSetting {
  NOTIFICATIONS_ENABLED,
  NOTIFICATIONS_DISABLED,
  $unknown;

  factory Enum$TeamNotificationSetting.fromJson(String value) =>
      fromJson$Enum$TeamNotificationSetting(value);

  String toJson() => toJson$Enum$TeamNotificationSetting(this);
}

String toJson$Enum$TeamNotificationSetting(Enum$TeamNotificationSetting e) {
  switch (e) {
    case Enum$TeamNotificationSetting.NOTIFICATIONS_ENABLED:
      return r'NOTIFICATIONS_ENABLED';
    case Enum$TeamNotificationSetting.NOTIFICATIONS_DISABLED:
      return r'NOTIFICATIONS_DISABLED';
    case Enum$TeamNotificationSetting.$unknown:
      return r'$unknown';
  }
}

Enum$TeamNotificationSetting fromJson$Enum$TeamNotificationSetting(
    String value) {
  switch (value) {
    case r'NOTIFICATIONS_ENABLED':
      return Enum$TeamNotificationSetting.NOTIFICATIONS_ENABLED;
    case r'NOTIFICATIONS_DISABLED':
      return Enum$TeamNotificationSetting.NOTIFICATIONS_DISABLED;
    default:
      return Enum$TeamNotificationSetting.$unknown;
  }
}

enum Enum$TeamOrderField {
  NAME,
  $unknown;

  factory Enum$TeamOrderField.fromJson(String value) =>
      fromJson$Enum$TeamOrderField(value);

  String toJson() => toJson$Enum$TeamOrderField(this);
}

String toJson$Enum$TeamOrderField(Enum$TeamOrderField e) {
  switch (e) {
    case Enum$TeamOrderField.NAME:
      return r'NAME';
    case Enum$TeamOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamOrderField fromJson$Enum$TeamOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$TeamOrderField.NAME;
    default:
      return Enum$TeamOrderField.$unknown;
  }
}

enum Enum$TeamPrivacy {
  SECRET,
  VISIBLE,
  $unknown;

  factory Enum$TeamPrivacy.fromJson(String value) =>
      fromJson$Enum$TeamPrivacy(value);

  String toJson() => toJson$Enum$TeamPrivacy(this);
}

String toJson$Enum$TeamPrivacy(Enum$TeamPrivacy e) {
  switch (e) {
    case Enum$TeamPrivacy.SECRET:
      return r'SECRET';
    case Enum$TeamPrivacy.VISIBLE:
      return r'VISIBLE';
    case Enum$TeamPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$TeamPrivacy fromJson$Enum$TeamPrivacy(String value) {
  switch (value) {
    case r'SECRET':
      return Enum$TeamPrivacy.SECRET;
    case r'VISIBLE':
      return Enum$TeamPrivacy.VISIBLE;
    default:
      return Enum$TeamPrivacy.$unknown;
  }
}

enum Enum$TeamRepositoryOrderField {
  CREATED_AT,
  UPDATED_AT,
  PUSHED_AT,
  NAME,
  PERMISSION,
  STARGAZERS,
  $unknown;

  factory Enum$TeamRepositoryOrderField.fromJson(String value) =>
      fromJson$Enum$TeamRepositoryOrderField(value);

  String toJson() => toJson$Enum$TeamRepositoryOrderField(this);
}

String toJson$Enum$TeamRepositoryOrderField(Enum$TeamRepositoryOrderField e) {
  switch (e) {
    case Enum$TeamRepositoryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamRepositoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$TeamRepositoryOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$TeamRepositoryOrderField.NAME:
      return r'NAME';
    case Enum$TeamRepositoryOrderField.PERMISSION:
      return r'PERMISSION';
    case Enum$TeamRepositoryOrderField.STARGAZERS:
      return r'STARGAZERS';
    case Enum$TeamRepositoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamRepositoryOrderField fromJson$Enum$TeamRepositoryOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$TeamRepositoryOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$TeamRepositoryOrderField.UPDATED_AT;
    case r'PUSHED_AT':
      return Enum$TeamRepositoryOrderField.PUSHED_AT;
    case r'NAME':
      return Enum$TeamRepositoryOrderField.NAME;
    case r'PERMISSION':
      return Enum$TeamRepositoryOrderField.PERMISSION;
    case r'STARGAZERS':
      return Enum$TeamRepositoryOrderField.STARGAZERS;
    default:
      return Enum$TeamRepositoryOrderField.$unknown;
  }
}

enum Enum$TeamReviewAssignmentAlgorithm {
  ROUND_ROBIN,
  LOAD_BALANCE,
  $unknown;

  factory Enum$TeamReviewAssignmentAlgorithm.fromJson(String value) =>
      fromJson$Enum$TeamReviewAssignmentAlgorithm(value);

  String toJson() => toJson$Enum$TeamReviewAssignmentAlgorithm(this);
}

String toJson$Enum$TeamReviewAssignmentAlgorithm(
    Enum$TeamReviewAssignmentAlgorithm e) {
  switch (e) {
    case Enum$TeamReviewAssignmentAlgorithm.ROUND_ROBIN:
      return r'ROUND_ROBIN';
    case Enum$TeamReviewAssignmentAlgorithm.LOAD_BALANCE:
      return r'LOAD_BALANCE';
    case Enum$TeamReviewAssignmentAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$TeamReviewAssignmentAlgorithm fromJson$Enum$TeamReviewAssignmentAlgorithm(
    String value) {
  switch (value) {
    case r'ROUND_ROBIN':
      return Enum$TeamReviewAssignmentAlgorithm.ROUND_ROBIN;
    case r'LOAD_BALANCE':
      return Enum$TeamReviewAssignmentAlgorithm.LOAD_BALANCE;
    default:
      return Enum$TeamReviewAssignmentAlgorithm.$unknown;
  }
}

enum Enum$TeamRole {
  ADMIN,
  MEMBER,
  $unknown;

  factory Enum$TeamRole.fromJson(String value) => fromJson$Enum$TeamRole(value);

  String toJson() => toJson$Enum$TeamRole(this);
}

String toJson$Enum$TeamRole(Enum$TeamRole e) {
  switch (e) {
    case Enum$TeamRole.ADMIN:
      return r'ADMIN';
    case Enum$TeamRole.MEMBER:
      return r'MEMBER';
    case Enum$TeamRole.$unknown:
      return r'$unknown';
  }
}

Enum$TeamRole fromJson$Enum$TeamRole(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$TeamRole.ADMIN;
    case r'MEMBER':
      return Enum$TeamRole.MEMBER;
    default:
      return Enum$TeamRole.$unknown;
  }
}

enum Enum$ThreadSubscriptionFormAction {
  NONE,
  SUBSCRIBE,
  UNSUBSCRIBE,
  $unknown;

  factory Enum$ThreadSubscriptionFormAction.fromJson(String value) =>
      fromJson$Enum$ThreadSubscriptionFormAction(value);

  String toJson() => toJson$Enum$ThreadSubscriptionFormAction(this);
}

String toJson$Enum$ThreadSubscriptionFormAction(
    Enum$ThreadSubscriptionFormAction e) {
  switch (e) {
    case Enum$ThreadSubscriptionFormAction.NONE:
      return r'NONE';
    case Enum$ThreadSubscriptionFormAction.SUBSCRIBE:
      return r'SUBSCRIBE';
    case Enum$ThreadSubscriptionFormAction.UNSUBSCRIBE:
      return r'UNSUBSCRIBE';
    case Enum$ThreadSubscriptionFormAction.$unknown:
      return r'$unknown';
  }
}

Enum$ThreadSubscriptionFormAction fromJson$Enum$ThreadSubscriptionFormAction(
    String value) {
  switch (value) {
    case r'NONE':
      return Enum$ThreadSubscriptionFormAction.NONE;
    case r'SUBSCRIBE':
      return Enum$ThreadSubscriptionFormAction.SUBSCRIBE;
    case r'UNSUBSCRIBE':
      return Enum$ThreadSubscriptionFormAction.UNSUBSCRIBE;
    default:
      return Enum$ThreadSubscriptionFormAction.$unknown;
  }
}

enum Enum$ThreadSubscriptionState {
  UNAVAILABLE,
  DISABLED,
  IGNORING_LIST,
  SUBSCRIBED_TO_THREAD_EVENTS,
  IGNORING_THREAD,
  SUBSCRIBED_TO_LIST,
  SUBSCRIBED_TO_THREAD_TYPE,
  SUBSCRIBED_TO_THREAD,
  NONE,
  $unknown;

  factory Enum$ThreadSubscriptionState.fromJson(String value) =>
      fromJson$Enum$ThreadSubscriptionState(value);

  String toJson() => toJson$Enum$ThreadSubscriptionState(this);
}

String toJson$Enum$ThreadSubscriptionState(Enum$ThreadSubscriptionState e) {
  switch (e) {
    case Enum$ThreadSubscriptionState.UNAVAILABLE:
      return r'UNAVAILABLE';
    case Enum$ThreadSubscriptionState.DISABLED:
      return r'DISABLED';
    case Enum$ThreadSubscriptionState.IGNORING_LIST:
      return r'IGNORING_LIST';
    case Enum$ThreadSubscriptionState.SUBSCRIBED_TO_THREAD_EVENTS:
      return r'SUBSCRIBED_TO_THREAD_EVENTS';
    case Enum$ThreadSubscriptionState.IGNORING_THREAD:
      return r'IGNORING_THREAD';
    case Enum$ThreadSubscriptionState.SUBSCRIBED_TO_LIST:
      return r'SUBSCRIBED_TO_LIST';
    case Enum$ThreadSubscriptionState.SUBSCRIBED_TO_THREAD_TYPE:
      return r'SUBSCRIBED_TO_THREAD_TYPE';
    case Enum$ThreadSubscriptionState.SUBSCRIBED_TO_THREAD:
      return r'SUBSCRIBED_TO_THREAD';
    case Enum$ThreadSubscriptionState.NONE:
      return r'NONE';
    case Enum$ThreadSubscriptionState.$unknown:
      return r'$unknown';
  }
}

Enum$ThreadSubscriptionState fromJson$Enum$ThreadSubscriptionState(
    String value) {
  switch (value) {
    case r'UNAVAILABLE':
      return Enum$ThreadSubscriptionState.UNAVAILABLE;
    case r'DISABLED':
      return Enum$ThreadSubscriptionState.DISABLED;
    case r'IGNORING_LIST':
      return Enum$ThreadSubscriptionState.IGNORING_LIST;
    case r'SUBSCRIBED_TO_THREAD_EVENTS':
      return Enum$ThreadSubscriptionState.SUBSCRIBED_TO_THREAD_EVENTS;
    case r'IGNORING_THREAD':
      return Enum$ThreadSubscriptionState.IGNORING_THREAD;
    case r'SUBSCRIBED_TO_LIST':
      return Enum$ThreadSubscriptionState.SUBSCRIBED_TO_LIST;
    case r'SUBSCRIBED_TO_THREAD_TYPE':
      return Enum$ThreadSubscriptionState.SUBSCRIBED_TO_THREAD_TYPE;
    case r'SUBSCRIBED_TO_THREAD':
      return Enum$ThreadSubscriptionState.SUBSCRIBED_TO_THREAD;
    case r'NONE':
      return Enum$ThreadSubscriptionState.NONE;
    default:
      return Enum$ThreadSubscriptionState.$unknown;
  }
}

enum Enum$TopicSuggestionDeclineReason {
  @Deprecated(
      'Suggested topics are no longer supported Removal on 2024-04-01 UTC.')
  NOT_RELEVANT,
  @Deprecated(
      'Suggested topics are no longer supported Removal on 2024-04-01 UTC.')
  TOO_SPECIFIC,
  @Deprecated(
      'Suggested topics are no longer supported Removal on 2024-04-01 UTC.')
  PERSONAL_PREFERENCE,
  @Deprecated(
      'Suggested topics are no longer supported Removal on 2024-04-01 UTC.')
  TOO_GENERAL,
  $unknown;

  factory Enum$TopicSuggestionDeclineReason.fromJson(String value) =>
      fromJson$Enum$TopicSuggestionDeclineReason(value);

  String toJson() => toJson$Enum$TopicSuggestionDeclineReason(this);
}

String toJson$Enum$TopicSuggestionDeclineReason(
    Enum$TopicSuggestionDeclineReason e) {
  switch (e) {
    case Enum$TopicSuggestionDeclineReason.NOT_RELEVANT:
      return r'NOT_RELEVANT';
    case Enum$TopicSuggestionDeclineReason.TOO_SPECIFIC:
      return r'TOO_SPECIFIC';
    case Enum$TopicSuggestionDeclineReason.PERSONAL_PREFERENCE:
      return r'PERSONAL_PREFERENCE';
    case Enum$TopicSuggestionDeclineReason.TOO_GENERAL:
      return r'TOO_GENERAL';
    case Enum$TopicSuggestionDeclineReason.$unknown:
      return r'$unknown';
  }
}

Enum$TopicSuggestionDeclineReason fromJson$Enum$TopicSuggestionDeclineReason(
    String value) {
  switch (value) {
    case r'NOT_RELEVANT':
      return Enum$TopicSuggestionDeclineReason.NOT_RELEVANT;
    case r'TOO_SPECIFIC':
      return Enum$TopicSuggestionDeclineReason.TOO_SPECIFIC;
    case r'PERSONAL_PREFERENCE':
      return Enum$TopicSuggestionDeclineReason.PERSONAL_PREFERENCE;
    case r'TOO_GENERAL':
      return Enum$TopicSuggestionDeclineReason.TOO_GENERAL;
    default:
      return Enum$TopicSuggestionDeclineReason.$unknown;
  }
}

enum Enum$TrackedIssueStates {
  OPEN,
  CLOSED,
  $unknown;

  factory Enum$TrackedIssueStates.fromJson(String value) =>
      fromJson$Enum$TrackedIssueStates(value);

  String toJson() => toJson$Enum$TrackedIssueStates(this);
}

String toJson$Enum$TrackedIssueStates(Enum$TrackedIssueStates e) {
  switch (e) {
    case Enum$TrackedIssueStates.OPEN:
      return r'OPEN';
    case Enum$TrackedIssueStates.CLOSED:
      return r'CLOSED';
    case Enum$TrackedIssueStates.$unknown:
      return r'$unknown';
  }
}

Enum$TrackedIssueStates fromJson$Enum$TrackedIssueStates(String value) {
  switch (value) {
    case r'OPEN':
      return Enum$TrackedIssueStates.OPEN;
    case r'CLOSED':
      return Enum$TrackedIssueStates.CLOSED;
    default:
      return Enum$TrackedIssueStates.$unknown;
  }
}

enum Enum$TwoFactorCredentialSecurityType {
  SECURE,
  INSECURE,
  DISABLED,
  $unknown;

  factory Enum$TwoFactorCredentialSecurityType.fromJson(String value) =>
      fromJson$Enum$TwoFactorCredentialSecurityType(value);

  String toJson() => toJson$Enum$TwoFactorCredentialSecurityType(this);
}

String toJson$Enum$TwoFactorCredentialSecurityType(
    Enum$TwoFactorCredentialSecurityType e) {
  switch (e) {
    case Enum$TwoFactorCredentialSecurityType.SECURE:
      return r'SECURE';
    case Enum$TwoFactorCredentialSecurityType.INSECURE:
      return r'INSECURE';
    case Enum$TwoFactorCredentialSecurityType.DISABLED:
      return r'DISABLED';
    case Enum$TwoFactorCredentialSecurityType.$unknown:
      return r'$unknown';
  }
}

Enum$TwoFactorCredentialSecurityType
    fromJson$Enum$TwoFactorCredentialSecurityType(String value) {
  switch (value) {
    case r'SECURE':
      return Enum$TwoFactorCredentialSecurityType.SECURE;
    case r'INSECURE':
      return Enum$TwoFactorCredentialSecurityType.INSECURE;
    case r'DISABLED':
      return Enum$TwoFactorCredentialSecurityType.DISABLED;
    default:
      return Enum$TwoFactorCredentialSecurityType.$unknown;
  }
}

enum Enum$UserBlockDuration {
  ONE_DAY,
  THREE_DAYS,
  ONE_WEEK,
  ONE_MONTH,
  PERMANENT,
  $unknown;

  factory Enum$UserBlockDuration.fromJson(String value) =>
      fromJson$Enum$UserBlockDuration(value);

  String toJson() => toJson$Enum$UserBlockDuration(this);
}

String toJson$Enum$UserBlockDuration(Enum$UserBlockDuration e) {
  switch (e) {
    case Enum$UserBlockDuration.ONE_DAY:
      return r'ONE_DAY';
    case Enum$UserBlockDuration.THREE_DAYS:
      return r'THREE_DAYS';
    case Enum$UserBlockDuration.ONE_WEEK:
      return r'ONE_WEEK';
    case Enum$UserBlockDuration.ONE_MONTH:
      return r'ONE_MONTH';
    case Enum$UserBlockDuration.PERMANENT:
      return r'PERMANENT';
    case Enum$UserBlockDuration.$unknown:
      return r'$unknown';
  }
}

Enum$UserBlockDuration fromJson$Enum$UserBlockDuration(String value) {
  switch (value) {
    case r'ONE_DAY':
      return Enum$UserBlockDuration.ONE_DAY;
    case r'THREE_DAYS':
      return Enum$UserBlockDuration.THREE_DAYS;
    case r'ONE_WEEK':
      return Enum$UserBlockDuration.ONE_WEEK;
    case r'ONE_MONTH':
      return Enum$UserBlockDuration.ONE_MONTH;
    case r'PERMANENT':
      return Enum$UserBlockDuration.PERMANENT;
    default:
      return Enum$UserBlockDuration.$unknown;
  }
}

enum Enum$UserStatusOrderField {
  UPDATED_AT,
  $unknown;

  factory Enum$UserStatusOrderField.fromJson(String value) =>
      fromJson$Enum$UserStatusOrderField(value);

  String toJson() => toJson$Enum$UserStatusOrderField(this);
}

String toJson$Enum$UserStatusOrderField(Enum$UserStatusOrderField e) {
  switch (e) {
    case Enum$UserStatusOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$UserStatusOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$UserStatusOrderField fromJson$Enum$UserStatusOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$UserStatusOrderField.UPDATED_AT;
    default:
      return Enum$UserStatusOrderField.$unknown;
  }
}

enum Enum$UserViewType {
  PUBLIC,
  PRIVATE,
  $unknown;

  factory Enum$UserViewType.fromJson(String value) =>
      fromJson$Enum$UserViewType(value);

  String toJson() => toJson$Enum$UserViewType(this);
}

String toJson$Enum$UserViewType(Enum$UserViewType e) {
  switch (e) {
    case Enum$UserViewType.PUBLIC:
      return r'PUBLIC';
    case Enum$UserViewType.PRIVATE:
      return r'PRIVATE';
    case Enum$UserViewType.$unknown:
      return r'$unknown';
  }
}

Enum$UserViewType fromJson$Enum$UserViewType(String value) {
  switch (value) {
    case r'PUBLIC':
      return Enum$UserViewType.PUBLIC;
    case r'PRIVATE':
      return Enum$UserViewType.PRIVATE;
    default:
      return Enum$UserViewType.$unknown;
  }
}

enum Enum$VerifiableDomainOrderField {
  DOMAIN,
  CREATED_AT,
  $unknown;

  factory Enum$VerifiableDomainOrderField.fromJson(String value) =>
      fromJson$Enum$VerifiableDomainOrderField(value);

  String toJson() => toJson$Enum$VerifiableDomainOrderField(this);
}

String toJson$Enum$VerifiableDomainOrderField(
    Enum$VerifiableDomainOrderField e) {
  switch (e) {
    case Enum$VerifiableDomainOrderField.DOMAIN:
      return r'DOMAIN';
    case Enum$VerifiableDomainOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$VerifiableDomainOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$VerifiableDomainOrderField fromJson$Enum$VerifiableDomainOrderField(
    String value) {
  switch (value) {
    case r'DOMAIN':
      return Enum$VerifiableDomainOrderField.DOMAIN;
    case r'CREATED_AT':
      return Enum$VerifiableDomainOrderField.CREATED_AT;
    default:
      return Enum$VerifiableDomainOrderField.$unknown;
  }
}

enum Enum$WorkflowRunOrderField {
  CREATED_AT,
  $unknown;

  factory Enum$WorkflowRunOrderField.fromJson(String value) =>
      fromJson$Enum$WorkflowRunOrderField(value);

  String toJson() => toJson$Enum$WorkflowRunOrderField(this);
}

String toJson$Enum$WorkflowRunOrderField(Enum$WorkflowRunOrderField e) {
  switch (e) {
    case Enum$WorkflowRunOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$WorkflowRunOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$WorkflowRunOrderField fromJson$Enum$WorkflowRunOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$WorkflowRunOrderField.CREATED_AT;
    default:
      return Enum$WorkflowRunOrderField.$unknown;
  }
}

enum Enum$WorkflowState {
  ACTIVE,
  DELETED,
  DISABLED_FORK,
  DISABLED_INACTIVITY,
  DISABLED_MANUALLY,
  $unknown;

  factory Enum$WorkflowState.fromJson(String value) =>
      fromJson$Enum$WorkflowState(value);

  String toJson() => toJson$Enum$WorkflowState(this);
}

String toJson$Enum$WorkflowState(Enum$WorkflowState e) {
  switch (e) {
    case Enum$WorkflowState.ACTIVE:
      return r'ACTIVE';
    case Enum$WorkflowState.DELETED:
      return r'DELETED';
    case Enum$WorkflowState.DISABLED_FORK:
      return r'DISABLED_FORK';
    case Enum$WorkflowState.DISABLED_INACTIVITY:
      return r'DISABLED_INACTIVITY';
    case Enum$WorkflowState.DISABLED_MANUALLY:
      return r'DISABLED_MANUALLY';
    case Enum$WorkflowState.$unknown:
      return r'$unknown';
  }
}

Enum$WorkflowState fromJson$Enum$WorkflowState(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$WorkflowState.ACTIVE;
    case r'DELETED':
      return Enum$WorkflowState.DELETED;
    case r'DISABLED_FORK':
      return Enum$WorkflowState.DISABLED_FORK;
    case r'DISABLED_INACTIVITY':
      return Enum$WorkflowState.DISABLED_INACTIVITY;
    case r'DISABLED_MANUALLY':
      return Enum$WorkflowState.DISABLED_MANUALLY;
    default:
      return Enum$WorkflowState.$unknown;
  }
}
